!function(n,t,e){function c(n){return n&&"object"==typeof n&&!Array.isArray(n)}
function i(n,t){null==n&&(n={});for(var e=Object(n),r=1;r<arguments.length;r++){
var o=arguments[r];if(null!=o)for(var c in o
)Object.prototype.hasOwnProperty.call(o,c)&&(e[c]=o[c])}return e}function a(e,r
){var o=i({},e);return c(e)&&c(r)&&Object.keys(r).forEach(function(n){var t;c(r[
n])?n in e?o[n]=a(e[n],r[n]):((t={})[n]=r[n],i(o,t)):((t={})[n]=r[n],i(o,t))}),o
}var r=n.document,o=n.synchroniteConfig=n.synchroniteConfig||{};t&&(o=a(t,o)),(
o=e?a(o,e):o).locale||(t="lang",e=r.documentElement,
r=r.body||r.getElementsByTagName("body")[0],o.locale=e&&e.getAttribute(t
)||r&&r.getAttribute(t)),n.synchroniteConfig=o}(window,{"liveEngageTheme":"dark","mouseMoveUseParent":[],"strictPageVerification":false,"urlBlacklist":[],"annotations":false,"enableOnBlurFallback":false,"tenantHost":"90412079.va.cobrowse.liveperson.net","rejectRequestCookies":["JSESSIONID","PHPSESSID","ASPSESSIONID"],"detectRandomIds":false,"nativeLocationGetter":true,"enableCsat":false,"addViaHeaders":true,"disableMouseMove":false,"addUniqueIDs":["p","div","span","a","h1","h2","h3","center","table","tr","td","th","img","pre","b","i","li","ul","label"],"synchronizeFocus":false,"synchroniteCookieSecure":false,"forceCachedResponse":[],"showPausePage":true,"enableMobileOverlay":true,"useClasses":[],"executeAfterPageLoad":"\u002F\u002F write code here that gets executed when synchronite loads the target page.","hoverEmulation":"on","mousedownChangesFocus":true,"protectAreasByClassName":[],"startPaused":false,"homeURI":"\u002Fagents","proxyHost":"va.cobrowse.liveperson.net","isDragEnabled":false,"parseExternalScriptsOnClient":false,"rewriteTargets":false,"integration":{"features":{"showJobOffer":false,"noconflict":false,"realtimeTracking":false,"startDelay":25,"hasCustomUI":true,"trustedEmails":[]},"termsOfServiceURL":"${serverUrl}\u002Fterms","mail":false,"enableLiveButton":false,"termsOfService":"hide","serviceKey":"-","scripts":{"onStateSet":"","extractFullname":"","onSynchroniteLoad":"","onStateGet":""}},"filterPseudoClass":"","authCache":[],"secureCookieRemoval":false,"sessionTimeout":240,"protectAreasById":[],"uiSession":{"highlightSymbol":"solidCircle","highlightColor":"#FFEB53","clickBlurRadius":10,"companyLogo":"","favIcon":"","docTitle":"Co-Browsing: ${title}","customizedTexts":{}},"resizeAgentsScreen":true,"agentExitOperation":"useEndUrl","uiPointers":{"telepointer":[{"cursor":"yellow","color":"#FFEB53"},{"cursor":"white","color":"#CCC"},{"cursor":"pink","color":"#F9B5FF"},{"cursor":"turquoise","color":"#41FFFA"},{"cursor":"green","color":"#58FF43"}],"useCustom":false},"supportCoBrowsingInIFrame":true,"showTelepointerHint":true,"restoreDocumentCookies":false,"noGlobals":true,"disableWebsockets":false,"preventDuplicateSessions":true,"cobrowseEngine":"proxyless","proxifyImages":true,"trackErrors":false,"renewCobrowseSessionId":true,"restrictToDomains":[],"stickyMenubar":true,"isAgentVideoEnabledAtStart":true,"documentDomain":"liveperson.net","proxifyForms":true,"protectedFields":[],"continuationTimeout":30,"isVisitorVideoEnabledAtStart":true,"userAgent":"static","enableEscapingInCssUrlsOnAgentBrowser":true,"cacheBust":"311003106183","ignoreIds":[],"cometUrl":"90412079-sync.va.cobrowse.liveperson.net","livepersonHandover":true,"defaultSupportProfile":"p-interactive","overrideDate":false,"tenantId":"90412079","urlWhitelist":[],"parseInlineScriptsOnClient":true},
{"isDebug":false,"baseUrl":"https:\u002F\u002F90412079.va.cobrowse.liveperson.net\u002Fjs\u002F","paths":{"dojo":"dojo","dijit":"dijit","bootstrap":"bootstrap","uglify-js":"uglify-js","synchronite":"synchronite","org":"org","dojox":"dojox"},"dojoBlankHtmlUrl":"\u002Fblank","cacheBust":"311003106183","selectorEngine":"acme"});;(function() {
var i18next_options, libs_i18next, libs_i18next_xhr_backend, libs_i18next_browser_languageDetector, i18next_loader, i18next_inlineLocales, dojo_domReady, synchronite_constants_strings, synchronite_constants_constants, dojo_has, dojo__base_config, dojo__base_kernel, dojo_sniff, dojo__base_lang, dojo_string, dojo__base_array, dojo__base_url, synchronite_libs_sizzle, synchronite__base_query, synchronite__base_url, dojo__base_window, dojo_dom, dojo_on, dojo_selector__loader, dojo_query, dojo_dom_class, dojo_aspect, dojo_Evented, dojo__base_Color, dojo_dom_style, dojo__base_fx, dojo_dom_geometry, dojo__base_event, synchronite__base_event, synchronite__base_goog, synchronite_micro_dom, dojo_regexp, synchronite__base_cookie, synchronite__base_window, dojo_errors_create, dojo_errors_CancelError, dojo_promise_Promise, dojo_Deferred, dojox_encoding_base64, synchronite__base_base64, dojo_cookie, synchronite_proxyless_lib_lpSecureStorageAMD, synchronite_proxyless_storage, synchronite__base_state, synchronite_events_scroll, synchronite_proxyless_dom_shadowHosts, synchronite_proxyless_utils, synchronite_proxyless_memberStateEvents_events, synchronite_proxyless_memberStateEvents_common, synchronite_proxyless_participantNotification, synchronite_proxyless_connectionEvents_events, synchronite_proxyless_connectionEvents_common, synchronite_proxyless_reconnectNotification, synchronite_libs_lz_string, synchronite_cometd_LargeMessageExtension, org_cometd, dojo_json, dojox_main, dojox, dojo__base_sniff, dojo_io_query, dojo_dom_form, dojo_when, dojo__base_Deferred, dojo__base_json, dojo_errors_RequestError, dojo_request_util = {}, dojo_errors_RequestTimeoutError, dojo_request_watch, dojo_request_handlers, dojo_request_xhr, dojo__base_xhr, dojo_request_script, dojox_cometd, org_cometd_ReloadExtensionLP, dojox_cometd_reloadLP, dojo_request, synchronite_proxyless_datachannel, synchronite_proxyless_accessibility, dojo_text, dojo_text_synchronite_proxyless_templates_errorhtml, dojo_text_synchronite_proxyless_templates_statushtml, dojo_text_synchronite_proxyless_templates_notificationhtml, synchronite_proxyless_ui, synchronite_proxyless_lib_tree_mirror, synchronite_proxyless_lib_mutation_summary, synchronite_proxyless_dom_TreeListener, synchronite_proxyless_dom_common, synchronite_proxyless_dom_listener, synchronite_proxyless_unifiedWindowState_common, synchronite_proxyless_unifiedWindowState_listener, synchronite__base_trackingEvents, synchronite_integration_tracking_ga, synchronite_integration_tracking_piwik, synchronite_integration_tracking_wt, synchronite_integration_tracking_lpEvents, synchronite_integration_tracking_tealium, synchronite_integration_tracking_loader, dojo_mouse, dojo_touch, dojo__base_declare, dojo_fx_easing, libs_rangy_core, libs_rangy_serializer, libs_rangy, synchronite_ui_effects, synchronite__base_frames, synchronite_page, synchronite_events_mouse, dojo_debounce, synchronite_events_resize, synchronite_events_focus, synchronite_ui_typing, transpiled_node_modules_ua_parser, transpiled_node_modules_launch_darkly, synchronite_proxyless_env, synchronite_proxyless_getCsdsSettings, synchronite_call_launchDarkly, synchronite_events_keyboard, dojo_text_synchronite_config_participantProfilesjson, synchronite_config_profiles, synchronite_proxyless_requestDomRetry, synchronite_proxyless_dom_replicator, synchronite_proxyless_unifiedWindowState_replicator, synchronite_simulate_synthetic, synchronite_simulate_mouse, synchronite_simulate_browsers, synchronite_simulate_key, dojo_NodeList_traverse, synchronite_simulate_drag_drag, synchronite_simulate, synchronite_proxyless_eventreplicator, dojo_topic, dojo_keys, dojo__base_connect, dojo_dom_prop = {}, dojo_dom_attr = {}, dojo_dom_construct = {}, dojo_text_synchronite_proxyless_templates_csathtml, synchronite_proxyless_csat, synchronite_proxyless_app, synchronite_proxyless_run, synchronite_proxyless_run_build;
(function () {
  i18next_options = function () {
    function appenPath(url, path) {
      if (!/\/$/.test(url)) {
        url += '/';
      }
      return url + path;
    }
    var jsPath = 'js', nlsPath = 'synchronite/i18n', baseUrl;
    if (typeof synchroniteConfig != 'undefined') {
      baseUrl = synchroniteConfig.serverUrl || 'https://' + synchroniteConfig.tenantHost;
      baseUrl = appenPath(baseUrl, jsPath + '/' + nlsPath);
    } else if (typeof require != 'undefined') {
      baseUrl = appenPath(require.toUrl(''), nlsPath);
    } else {
      baseUrl = '/' + jsPath + '/' + nlsPath;
    }
    var options = {
      'ns': [],
      'defaultNS': [
        'session',
        'integration',
        'common'
      ],
      // default namespace used if not passed to translation function
      'load': 'all',
      'fallbackLng': ['en-US'],
      'whitelist': [
        'Cy-sr-SP',
        'ar-AE',
        'bg-BG',
        'cs-CZ',
        'da-DK',
        'de-DE',
        'el-GR',
        'en-US',
        'es-419',
        'es-ES',
        'et-EE',
        'fi-FI',
        'fr-CA',
        'fr-FR',
        'he-IL',
        'hi-IN',
        'hr-HR',
        'hu-HU',
        'id-ID',
        'it-IT',
        'ja-JP',
        'ko-KR',
        'lt-LT',
        'lv-LV',
        'mk-MK',
        'ms-MY',
        'nb-NO',
        'nl-NL',
        'pl-PL',
        'pt-BR',
        'pt-PT',
        'ro-RO',
        'ru-RU',
        'sk-SK',
        'sl-SI',
        'sv-SE',
        'th-TH',
        'tr-TR',
        'uk-UA',
        'vi-VN',
        'zh-CN',
        'zh-HK',
        'zh-TW'
      ],
      'nonExplicitWhitelist': true,
      'preload': false,
      //	array of languages to preload
      'debug': false,
      //(typeof synchroniteConfig !== "undefined") && synchroniteConfig.isDebug,
      'interpolation': {
        'prefix': '${',
        'suffix': '}'
      },
      'keySeparator': '....',
      'backend': {
        'crossDomain': true,
        'allowMultiLoading': false,
        'loadPath': baseUrl + '/${lng}.json'
      },
      'detection': {
        //  Language Detector
        'lookupQuerystring': 'locale',
        'order': [
          'localStorage',
          'querystring',
          'navigator'
        ]
      }
    };
    if (typeof XDomainRequest !== 'undefined') {
      // IE 8-9 cross-origin ajax
      options.backend.ajax = function (url, options, callback, data) {
        var xdr = new XDomainRequest();
        if (url.indexOf('://') !== -1) {
          url = window.location.protocol + url.substring(url.indexOf('//'));
        }
        xdr.open(data ? 'POST' : 'GET', url, 1);
        // Unfortunately the XDomainRequest object does not provide status codes
        // http://stackoverflow.com/a/23554313
        xdr.onload = function () {
          callback(xdr.responseText, { status: 200 });
        };
        xdr.ontimeout = xdr.onerror = function () {
          callback(xdr.responseText, { status: 400 });
        };
        // Empty event handlers needs to be there, because IE9 is flawed
        // http://rudovsky.blogspot.dk/2012/09/microsoft-shit-xdomainrequest.html
        xdr.onprogress = function () {
        };
        xdr.send();
      };
    }
    return options;
  }();
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18next = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i['return'])
                    _i['return']();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError('Invalid attempt to destructure non-iterable instance');
              }
            };
          }();
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x2, _x3, _x4) {
            var _again = true;
            while (_again) {
              var object = _x2, property = _x3, receiver = _x4;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x2 = parent;
                  _x3 = property;
                  _x4 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          function remove(arr, what) {
            var found = arr.indexOf(what);
            while (found !== -1) {
              arr.splice(found, 1);
              found = arr.indexOf(what);
            }
          }
          var Connector = function (_EventEmitter) {
            _inherits(Connector, _EventEmitter);
            function Connector(backend, store, services) {
              var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
              _classCallCheck(this, Connector);
              _get(Object.getPrototypeOf(Connector.prototype), 'constructor', this).call(this);
              this.backend = backend;
              this.store = store;
              this.services = services;
              this.options = options;
              this.logger = _logger2['default'].create('backendConnector');
              this.state = {};
              this.queue = [];
              this.backend && this.backend.init(services, options.backend, options);
            }
            _createClass(Connector, [
              {
                key: 'queueLoad',
                value: function queueLoad(languages, namespaces, callback) {
                  var _this = this;
                  // find what needs to be loaded
                  var toLoad = [], pending = [], toLoadLanguages = [], toLoadNamespaces = [];
                  languages.forEach(function (lng) {
                    var hasAllNamespaces = true;
                    namespaces.forEach(function (ns) {
                      var name = lng + '|' + ns;
                      if (_this.store.hasResourceBundle(lng, ns)) {
                        _this.state[name] = 2;  // loaded
                      } else if (_this.state[name] === 1) {
                        if (pending.indexOf(name) < 0)
                          pending.push(name);
                      } else {
                        _this.state[name] = 1;
                        // pending
                        hasAllNamespaces = false;
                        if (pending.indexOf(name) < 0)
                          pending.push(name);
                        if (toLoad.indexOf(name) < 0)
                          toLoad.push(name);
                        if (toLoadNamespaces.indexOf(ns) < 0)
                          toLoadNamespaces.push(ns);
                      }
                    });
                    if (!hasAllNamespaces)
                      toLoadLanguages.push(lng);
                  });
                  if (toLoad.length || pending.length) {
                    this.queue.push({
                      pending: pending,
                      loaded: {},
                      errors: [],
                      callback: callback
                    });
                  }
                  return {
                    toLoad: toLoad,
                    pending: pending,
                    toLoadLanguages: toLoadLanguages,
                    toLoadNamespaces: toLoadNamespaces
                  };
                }
              },
              {
                key: 'loaded',
                value: function loaded(name, err, data) {
                  var _this2 = this;
                  var _name$split = name.split('|');
                  var _name$split2 = _slicedToArray(_name$split, 2);
                  var lng = _name$split2[0];
                  var ns = _name$split2[1];
                  if (data) {
                    this.store.addResourceBundle(lng, ns, data);
                  }
                  // set loaded
                  this.state[name] = err ? -1 : 2;
                  // callback if ready
                  this.queue.forEach(function (q) {
                    utils.pushPath(q.loaded, [lng], ns);
                    remove(q.pending, name);
                    if (err)
                      q.errors.push(err);
                    if (q.pending.length === 0 && !q.done) {
                      q.errors.length ? q.callback(q.errors) : q.callback();
                      _this2.emit('loaded', q.loaded);
                      q.done = true;
                    }
                  });
                }
              },
              {
                key: 'read',
                value: function read(lng, ns, fcName, tried, wait, callback) {
                  var _this3 = this;
                  if (!tried)
                    tried = 0;
                  if (!wait)
                    wait = 250;
                  if (!lng.length)
                    return callback(null, {});
                  // noting to load
                  this.backend[fcName](lng, ns, function (err, data) {
                    if (err && data  /* = retryFlag */ && tried < 5) {
                      setTimeout(function () {
                        _this3.read.call(_this3, lng, ns, fcName, ++tried, wait * 2, callback);
                      }, wait);
                      return;
                    }
                    callback(err, data);
                  });
                }
              },
              {
                key: 'load',
                value: function load(languages, namespaces, callback) {
                  var _this4 = this;
                  if (!this.backend)
                    return callback && callback('no backend was defined.');
                  var options = _extends({}, this.backend.options, this.options.backend);
                  if (typeof languages === 'string')
                    languages = this.services.languageUtils.toResolveHierarchy(languages);
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  var toLoad = this.queueLoad(languages, namespaces, callback);
                  if (!toLoad.toLoad.length) {
                    if (!toLoad.pending.length)
                      callback();
                    // nothing to load and no pendings...callback now
                    return;  // pendings will trigger callback
                  }
                  // load with multi-load
                  if (options.allowMultiLoading && this.backend.readMulti) {
                    this.read(toLoad.toLoadLanguages, toLoad.toLoadNamespaces, 'readMulti', null, null, function (err, data) {
                      if (err)
                        _this4.logger.warn('loading namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading failed', err);
                      if (!err && data)
                        _this4.logger.log('loaded namespaces ' + toLoad.toLoadNamespaces.join(', ') + ' for languages ' + toLoad.toLoadLanguages.join(', ') + ' via multiloading', data);
                      toLoad.toLoad.forEach(function (name) {
                        var _name$split3 = name.split('|');
                        var _name$split32 = _slicedToArray(_name$split3, 2);
                        var l = _name$split32[0];
                        var n = _name$split32[1];
                        var bundle = utils.getPath(data, [
                          l,
                          n
                        ]);
                        if (bundle) {
                          _this4.loaded(name, err, bundle);
                        } else {
                          var _err = 'loading namespace ' + n + ' for language ' + l + ' via multiloading failed';
                          _this4.loaded(name, _err);
                          _this4.logger.error(_err);
                        }
                      });
                    });
                  }  // load one by one
                  else {
                    (function () {
                      var read = function read(name) {
                        var _this5 = this;
                        var _name$split4 = name.split('|');
                        var _name$split42 = _slicedToArray(_name$split4, 2);
                        var lng = _name$split42[0];
                        var ns = _name$split42[1];
                        this.read(lng, ns, 'read', null, null, function (err, data) {
                          if (err)
                            _this5.logger.warn('loading namespace ' + ns + ' for language ' + lng + ' failed', err);
                          if (!err && data)
                            _this5.logger.log('loaded namespace ' + ns + ' for language ' + lng, data);
                          _this5.loaded(name, err, data);
                        });
                      };
                      toLoad.toLoad.forEach(function (name) {
                        read.call(_this4, name);
                      });
                    }());
                  }
                }
              },
              {
                key: 'saveMissing',
                value: function saveMissing(languages, namespace, key, fallbackValue) {
                  if (this.backend && this.backend.create)
                    this.backend.create(languages, namespace, key, fallbackValue);
                  // write to store to avoid resending
                  this.store.addResource(languages[0], namespace, key, fallbackValue);
                }
              }
            ]);
            return Connector;
          }(_EventEmitter3['default']);
          exports['default'] = Connector;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './logger': 12,
          './utils': 14
        }
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x2, _x3, _x4) {
            var _again = true;
            while (_again) {
              var object = _x2, property = _x3, receiver = _x4;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x2 = parent;
                  _x3 = property;
                  _x4 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var Connector = function (_EventEmitter) {
            _inherits(Connector, _EventEmitter);
            function Connector(cache, store, services) {
              var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
              _classCallCheck(this, Connector);
              _get(Object.getPrototypeOf(Connector.prototype), 'constructor', this).call(this);
              this.cache = cache;
              this.store = store;
              this.services = services;
              this.options = options;
              this.logger = _logger2['default'].create('cacheConnector');
              this.cache && this.cache.init(services, options.cache, options);
            }
            _createClass(Connector, [
              {
                key: 'load',
                value: function load(languages, namespaces, callback) {
                  var _this = this;
                  if (!this.cache)
                    return callback && callback();
                  var options = _extends({}, this.cache.options, this.options.cache);
                  if (typeof languages === 'string')
                    languages = this.services.languageUtils.toResolveHierarchy(languages);
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  if (options.enabled) {
                    this.cache.load(languages, function (err, data) {
                      if (err)
                        _this.logger.error('loading languages ' + languages.join(', ') + ' from cache failed', err);
                      if (data) {
                        for (var l in data) {
                          for (var n in data[l]) {
                            if (n === 'i18nStamp')
                              continue;
                            var bundle = data[l][n];
                            if (bundle)
                              _this.store.addResourceBundle(l, n, bundle);
                          }
                        }
                      }
                      if (callback)
                        callback();
                    });
                  } else {
                    if (callback)
                      callback();
                  }
                }
              },
              {
                key: 'save',
                value: function save() {
                  if (this.cache && this.options.cache && this.options.cache.enabled)
                    this.cache.save(this.store.data);
                }
              }
            ]);
            return Connector;
          }(_EventEmitter3['default']);
          exports['default'] = Connector;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './logger': 12,
          './utils': 14
        }
      ],
      3: [
        function (require, module, exports) {
          'use strict';
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var EventEmitter = function () {
            function EventEmitter() {
              _classCallCheck(this, EventEmitter);
              this.observers = {};
            }
            _createClass(EventEmitter, [
              {
                key: 'on',
                value: function on(events, listener) {
                  var _this = this;
                  events.split(' ').forEach(function (event) {
                    _this.observers[event] = _this.observers[event] || [];
                    _this.observers[event].push(listener);
                  });
                }
              },
              {
                key: 'off',
                value: function off(event, listener) {
                  var _this2 = this;
                  if (!this.observers[event]) {
                    return;
                  }
                  this.observers[event].forEach(function () {
                    if (!listener) {
                      delete _this2.observers[event];
                    } else {
                      var index = _this2.observers[event].indexOf(listener);
                      if (index > -1) {
                        _this2.observers[event].splice(index, 1);
                      }
                    }
                  });
                }
              },
              {
                key: 'emit',
                value: function emit(event) {
                  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  if (this.observers[event]) {
                    this.observers[event].forEach(function (observer) {
                      observer.apply(undefined, args);
                    });
                  }
                  if (this.observers['*']) {
                    this.observers['*'].forEach(function (observer) {
                      var _ref;
                      observer.apply(observer, (_ref = [event]).concat.apply(_ref, args));
                    });
                  }
                }
              }
            ]);
            return EventEmitter;
          }();
          module.exports = EventEmitter;
          return exports;
        },
        {}
      ],
      4: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var Interpolator = function () {
            function Interpolator() {
              var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
              _classCallCheck(this, Interpolator);
              this.logger = _logger2['default'].create('interpolator');
              this.init(options, true);
            }
            _createClass(Interpolator, [
              {
                key: 'init',
                value: function init(options, reset) {
                  if (options === undefined)
                    options = {};
                  if (reset)
                    this.options = options;
                  if (!options.interpolation)
                    options.interpolation = { escapeValue: true };
                  var iOpts = options.interpolation;
                  this.escapeValue = iOpts.escapeValue;
                  this.prefix = iOpts.prefix ? utils.regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
                  this.suffix = iOpts.suffix ? utils.regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
                  this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
                  this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
                  this.nestingPrefix = iOpts.nestingPrefix ? utils.regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || utils.regexEscape('$t(');
                  this.nestingSuffix = iOpts.nestingSuffix ? utils.regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || utils.regexEscape(')');
                  // the regexp
                  var regexpStr = this.prefix + '(.+?)' + this.suffix;
                  this.regexp = new RegExp(regexpStr, 'g');
                  var regexpUnescapeStr = this.prefix + this.unescapePrefix + '(.+?)' + this.unescapeSuffix + this.suffix;
                  this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
                  var nestingRegexpStr = this.nestingPrefix + '(.+?)' + this.nestingSuffix;
                  this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
                }
              },
              {
                key: 'reset',
                value: function reset() {
                  if (this.options)
                    this.init(this.options);
                }
              },
              {
                key: 'interpolate',
                value: function interpolate(str, data) {
                  var match = undefined, value = undefined;
                  function regexSafe(val) {
                    return val.replace(/\$/g, '$$$$');
                  }
                  // unescape if has unescapePrefix/Suffix
                  while (match = this.regexpUnescape.exec(str)) {
                    var _value = utils.getPath(data, match[1].trim());
                    str = str.replace(match[0], _value);
                  }
                  // regular escape on demand
                  while (match = this.regexp.exec(str)) {
                    value = utils.getPath(data, match[1].trim());
                    if (typeof value !== 'string')
                      value = utils.makeString(value);
                    if (!value) {
                      this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
                      value = '';
                    }
                    value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
                    str = str.replace(match[0], value);
                    this.regexp.lastIndex = 0;
                  }
                  return str;
                }
              },
              {
                key: 'nest',
                value: function nest(str, fc) {
                  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                  var match = undefined, value = undefined;
                  var clonedOptions = JSON.parse(JSON.stringify(options));
                  clonedOptions.applyPostProcessor = false;
                  // avoid post processing on nested lookup
                  function regexSafe(val) {
                    return val.replace(/\$/g, '$$$$');
                  }
                  // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"
                  function handleHasOptions(key) {
                    if (key.indexOf(',') < 0)
                      return key;
                    var p = key.split(',');
                    key = p.shift();
                    var optionsString = p.join(',');
                    optionsString = this.interpolate(optionsString, clonedOptions);
                    try {
                      clonedOptions = JSON.parse(optionsString);
                    } catch (e) {
                      this.logger.error('failed parsing options string in nesting for key ' + key, e);
                    }
                    return key;
                  }
                  // regular escape on demand
                  while (match = this.nestingRegexp.exec(str)) {
                    value = fc(handleHasOptions.call(this, match[1].trim()), clonedOptions);
                    if (typeof value !== 'string')
                      value = utils.makeString(value);
                    if (!value) {
                      this.logger.warn('missed to pass in variable ' + match[1] + ' for interpolating ' + str);
                      value = '';
                    }
                    value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);
                    str = str.replace(match[0], value);
                    this.regexp.lastIndex = 0;
                  }
                  return str;
                }
              }
            ]);
            return Interpolator;
          }();
          exports['default'] = Interpolator;
          module.exports = exports['default'];
          return exports;
        },
        {
          './logger': 12,
          './utils': 14
        }
      ],
      5: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _slicedToArray = function () {
            function sliceIterator(arr, i) {
              var _arr = [];
              var _n = true;
              var _d = false;
              var _e = undefined;
              try {
                for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i['return'])
                    _i['return']();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              } else {
                throw new TypeError('Invalid attempt to destructure non-iterable instance');
              }
            };
          }();
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var LanguageUtil = function () {
            function LanguageUtil(options) {
              _classCallCheck(this, LanguageUtil);
              this.options = options;
              this.whitelist = this.options.whitelist || false;
              this.logger = _logger2['default'].create('languageUtils');
            }
            _createClass(LanguageUtil, [
              {
                key: 'getLanguagePartFromCode',
                value: function getLanguagePartFromCode(code) {
                  if (code.indexOf('-') < 0)
                    return code;
                  var specialCases = [
                    'nb-NO',
                    'nn-NO',
                    'nb-no',
                    'nn-no'
                  ];
                  var p = code.split('-');
                  return this.formatLanguageCode(specialCases.indexOf(code) > -1 ? p[1].toLowerCase() : p[0]);
                }
              },
              {
                key: 'formatLanguageCode',
                value: function formatLanguageCode(code) {
                  if (typeof code === 'string' && code.indexOf('-') > -1) {
                    var _code$split = code.split('-');
                    var _code$split2 = _slicedToArray(_code$split, 2);
                    var head = _code$split2[0];
                    var tail = _code$split2[1];
                    return this.options.lowerCaseLng ? head.toLowerCase() + '-' + tail.toLowerCase() : head.toLowerCase() + '-' + tail.toUpperCase();
                  } else {
                    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
                  }
                }
              },
              {
                key: 'isWhitelisted',
                value: function isWhitelisted(code, exactMatch) {
                  if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist && !exactMatch) {
                    code = this.getLanguagePartFromCode(code);
                  }
                  return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1 ? true : false;
                }
              },
              {
                key: 'toResolveHierarchy',
                value: function toResolveHierarchy(code, fallbackCode) {
                  var _this = this;
                  fallbackCode = fallbackCode || this.options.fallbackLng || [];
                  if (typeof fallbackCode === 'string')
                    fallbackCode = [fallbackCode];
                  var codes = [];
                  var addCode = function addCode(code, exactMatch) {
                    if (_this.isWhitelisted(code, exactMatch)) {
                      codes.push(code);
                    } else {
                      _this.logger.warn('rejecting non-whitelisted language code: ' + code);
                    }
                  };
                  if (typeof code === 'string' && code.indexOf('-') > -1) {
                    if (this.options.load !== 'languageOnly')
                      addCode(this.formatLanguageCode(code), true);
                    if (this.options.load !== 'currentOnly')
                      addCode(this.getLanguagePartFromCode(code));
                  } else if (typeof code === 'string') {
                    addCode(this.formatLanguageCode(code));
                  }
                  fallbackCode.forEach(function (fc) {
                    if (codes.indexOf(fc) < 0)
                      addCode(_this.formatLanguageCode(fc));
                  });
                  return codes;
                }
              }
            ]);
            return LanguageUtil;
          }();
          exports['default'] = LanguageUtil;
          module.exports = exports['default'];
          return exports;
        },
        { './logger': 12 }
      ],
      6: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
          /* eslint-disable */
          var sets = [
            {
              lngs: [
                'ach',
                'ak',
                'am',
                'arn',
                'br',
                'fil',
                'gun',
                'ln',
                'mfe',
                'mg',
                'mi',
                'oc',
                'tg',
                'ti',
                'tr',
                'uz',
                'wa'
              ],
              nr: [
                1,
                2
              ],
              fc: 1
            },
            {
              lngs: [
                'af',
                'an',
                'ast',
                'az',
                'bg',
                'bn',
                'ca',
                'da',
                'de',
                'dev',
                'el',
                'en',
                'eo',
                'es',
                'es_ar',
                'et',
                'eu',
                'fi',
                'fo',
                'fur',
                'fy',
                'gl',
                'gu',
                'ha',
                'he',
                'hi',
                'hu',
                'hy',
                'ia',
                'it',
                'kn',
                'ku',
                'lb',
                'mai',
                'ml',
                'mn',
                'mr',
                'nah',
                'nap',
                'nb',
                'ne',
                'nl',
                'nn',
                'no',
                'nso',
                'pa',
                'pap',
                'pms',
                'ps',
                'pt',
                'pt_br',
                'rm',
                'sco',
                'se',
                'si',
                'so',
                'son',
                'sq',
                'sv',
                'sw',
                'ta',
                'te',
                'tk',
                'ur',
                'yo'
              ],
              nr: [
                1,
                2
              ],
              fc: 2
            },
            {
              lngs: [
                'ay',
                'bo',
                'cgg',
                'fa',
                'id',
                'ja',
                'jbo',
                'ka',
                'kk',
                'km',
                'ko',
                'ky',
                'lo',
                'ms',
                'sah',
                'su',
                'th',
                'tt',
                'ug',
                'vi',
                'wo',
                'zh'
              ],
              nr: [1],
              fc: 3
            },
            {
              lngs: [
                'be',
                'bs',
                'dz',
                'hr',
                'ru',
                'sr',
                'uk'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 4
            },
            {
              lngs: ['ar'],
              nr: [
                0,
                1,
                2,
                3,
                11,
                100
              ],
              fc: 5
            },
            {
              lngs: [
                'cs',
                'sk'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 6
            },
            {
              lngs: [
                'csb',
                'pl'
              ],
              nr: [
                1,
                2,
                5
              ],
              fc: 7
            },
            {
              lngs: ['cy'],
              nr: [
                1,
                2,
                3,
                8
              ],
              fc: 8
            },
            {
              lngs: ['fr'],
              nr: [
                1,
                2
              ],
              fc: 9
            },
            {
              lngs: ['ga'],
              nr: [
                1,
                2,
                3,
                7,
                11
              ],
              fc: 10
            },
            {
              lngs: ['gd'],
              nr: [
                1,
                2,
                3,
                20
              ],
              fc: 11
            },
            {
              lngs: ['is'],
              nr: [
                1,
                2
              ],
              fc: 12
            },
            {
              lngs: ['jv'],
              nr: [
                0,
                1
              ],
              fc: 13
            },
            {
              lngs: ['kw'],
              nr: [
                1,
                2,
                3,
                4
              ],
              fc: 14
            },
            {
              lngs: ['lt'],
              nr: [
                1,
                2,
                10
              ],
              fc: 15
            },
            {
              lngs: ['lv'],
              nr: [
                1,
                2,
                0
              ],
              fc: 16
            },
            {
              lngs: ['mk'],
              nr: [
                1,
                2
              ],
              fc: 17
            },
            {
              lngs: ['mnk'],
              nr: [
                0,
                1,
                2
              ],
              fc: 18
            },
            {
              lngs: ['mt'],
              nr: [
                1,
                2,
                11,
                20
              ],
              fc: 19
            },
            {
              lngs: ['or'],
              nr: [
                2,
                1
              ],
              fc: 2
            },
            {
              lngs: ['ro'],
              nr: [
                1,
                2,
                20
              ],
              fc: 20
            },
            {
              lngs: ['sl'],
              nr: [
                5,
                1,
                2,
                3
              ],
              fc: 21
            }
          ];
          var _rulesPluralsTypes = {
            1: function _(n) {
              return Number(n > 1);
            },
            2: function _(n) {
              return Number(n != 1);
            },
            3: function _(n) {
              return 0;
            },
            4: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            5: function _(n) {
              return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
            },
            6: function _(n) {
              return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
            },
            7: function _(n) {
              return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            8: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
            },
            9: function _(n) {
              return Number(n >= 2);
            },
            10: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
            },
            11: function _(n) {
              return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
            },
            12: function _(n) {
              return Number(n % 10 != 1 || n % 100 == 11);
            },
            13: function _(n) {
              return Number(n !== 0);
            },
            14: function _(n) {
              return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
            },
            15: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
            },
            16: function _(n) {
              return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
            },
            17: function _(n) {
              return Number(n == 1 || n % 10 == 1 ? 0 : 1);
            },
            18: function _(n) {
              return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
            },
            19: function _(n) {
              return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
            },
            20: function _(n) {
              return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
            },
            21: function _(n) {
              return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
            }
          };
          /* eslint-enable */
          var PluralResolver = function () {
            function PluralResolver(languageUtils) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, PluralResolver);
              this.rules = function () {
                var l, rules = {};
                sets.forEach(function (set) {
                  set.lngs.forEach(function (l) {
                    return rules[l] = {
                      numbers: set.nr,
                      plurals: _rulesPluralsTypes[set.fc]
                    };
                  });
                });
                return rules;
              }();
              this.languageUtils = languageUtils;
              this.options = options;
              this.logger = _logger2['default'].create('pluralResolver');
            }
            _createClass(PluralResolver, [
              {
                key: 'addRule',
                value: function addRule(lng, obj) {
                  this.rules[lng] = obj;
                }
              },
              {
                key: 'getRule',
                value: function getRule(code) {
                  return this.rules[this.languageUtils.getLanguagePartFromCode(code)];
                }
              },
              {
                key: 'needsPlural',
                value: function needsPlural(code) {
                  var rule = this.getRule(code);
                  return rule && rule.numbers.length <= 1 ? false : true;
                }
              },
              {
                key: 'getSuffix',
                value: function getSuffix(code, count) {
                  var rule = this.getRule(code);
                  if (rule) {
                    if (rule.numbers.length === 1)
                      return '';
                    // only singular
                    var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
                    var suffix = rule.numbers[idx];
                    // special treatment for lngs only having singular and plural
                    if (rule.numbers.length === 2 && rule.numbers[0] === 1) {
                      if (suffix === 2) {
                        suffix = 'plural';
                      } else if (suffix === 1) {
                        suffix = '';
                      }
                    }
                    // COMPATIBILITY JSON
                    if (this.options.compatibilityJSON === 'v1') {
                      if (suffix === 1)
                        return '';
                      if (typeof suffix === 'number')
                        return '_plural_' + suffix.toString();
                    }
                    return this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
                  } else {
                    this.logger.warn('no plural rule found for: ' + code);
                    return '';
                  }
                }
              }
            ]);
            return PluralResolver;
          }();
          exports['default'] = PluralResolver;
          module.exports = exports['default'];
          return exports;
        },
        { './logger': 12 }
      ],
      7: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x5, _x6, _x7) {
            var _again = true;
            while (_again) {
              var object = _x5, property = _x6, receiver = _x7;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x5 = parent;
                  _x6 = property;
                  _x7 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var ResourceStore = function (_EventEmitter) {
            _inherits(ResourceStore, _EventEmitter);
            function ResourceStore() {
              var data = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
              var options = arguments.length <= 1 || arguments[1] === undefined ? {
                ns: ['translation'],
                defaultNS: 'translation'
              } : arguments[1];
              _classCallCheck(this, ResourceStore);
              _get(Object.getPrototypeOf(ResourceStore.prototype), 'constructor', this).call(this);
              this.data = data;
              this.options = options;
            }
            _createClass(ResourceStore, [
              {
                key: 'addNamespaces',
                value: function addNamespaces(ns) {
                  if (this.options.ns.indexOf(ns) < 0) {
                    this.options.ns.push(ns);
                  }
                }
              },
              {
                key: 'removeNamespaces',
                value: function removeNamespaces(ns) {
                  var index = this.options.ns.indexOf(ns);
                  if (index > -1) {
                    this.options.ns.splice(index, 1);
                  }
                }
              },
              {
                key: 'getResource',
                value: function getResource(lng, ns, key) {
                  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
                  var keySeparator = options.keySeparator || this.options.keySeparator || '.';
                  var path = [
                    lng,
                    ns
                  ];
                  if (key && typeof key !== 'string')
                    path = path.concat(key);
                  if (key && typeof key === 'string')
                    path = path.concat(key.split(keySeparator));
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                  }
                  return utils.getPath(this.data, path);
                }
              },
              {
                key: 'addResource',
                value: function addResource(lng, ns, key, value) {
                  var options = arguments.length <= 4 || arguments[4] === undefined ? { silent: false } : arguments[4];
                  var path = [
                    lng,
                    ns
                  ];
                  if (key)
                    path = path.concat(key.split(this.options.keySeparator || '.'));
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                    value = ns;
                    ns = path[1];
                  }
                  this.addNamespaces(ns);
                  utils.setPath(this.data, path, value);
                  if (!options.silent)
                    this.emit('added', lng, ns);
                }
              },
              {
                key: 'addResources',
                value: function addResources(lng, ns, resources) {
                  for (var m in resources) {
                    if (typeof resources[m] === 'string')
                      this.addResource(lng, ns, m, resources[m], { silent: true });
                  }
                  this.emit('added', lng, ns);
                }
              },
              {
                key: 'addResourceBundle',
                value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
                  var path = [
                    lng,
                    ns
                  ];
                  if (lng.indexOf('.') > -1) {
                    path = lng.split('.');
                    deep = resources;
                    resources = ns;
                    ns = path[1];
                  }
                  this.addNamespaces(ns);
                  var pack = utils.getPath(this.data, path) || {};
                  if (deep) {
                    utils.deepExtend(pack, resources, overwrite);
                  } else {
                    pack = _extends({}, pack, resources);
                  }
                  utils.setPath(this.data, path, pack);
                  this.emit('added', lng, ns);
                }
              },
              {
                key: 'removeResourceBundle',
                value: function removeResourceBundle(lng, ns) {
                  if (this.hasResourceBundle(lng, ns)) {
                    delete this.data[lng][ns];
                  }
                  this.removeNamespaces(ns);
                  this.emit('removed', lng, ns);
                }
              },
              {
                key: 'hasResourceBundle',
                value: function hasResourceBundle(lng, ns) {
                  return this.getResource(lng, ns) !== undefined;
                }
              },
              {
                key: 'getResourceBundle',
                value: function getResourceBundle(lng, ns) {
                  if (!ns)
                    ns = this.options.defaultNS;
                  // TODO: COMPATIBILITY remove extend in v2.1.0
                  if (this.options.compatibilityAPI === 'v1')
                    return _extends({}, this.getResource(lng, ns));
                  return this.getResource(lng, ns);
                }
              },
              {
                key: 'toJSON',
                value: function toJSON() {
                  return this.data;
                }
              }
            ]);
            return ResourceStore;
          }(_EventEmitter3['default']);
          exports['default'] = ResourceStore;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './utils': 14
        }
      ],
      8: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x6, _x7, _x8) {
            var _again = true;
            while (_again) {
              var object = _x6, property = _x7, receiver = _x8;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x6 = parent;
                  _x7 = property;
                  _x8 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _postProcessor = require('./postProcessor');
          var _postProcessor2 = _interopRequireDefault(_postProcessor);
          var _compatibilityV1 = require('./compatibility/v1');
          var compat = _interopRequireWildcard(_compatibilityV1);
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var Translator = function (_EventEmitter) {
            _inherits(Translator, _EventEmitter);
            function Translator(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Translator);
              _get(Object.getPrototypeOf(Translator.prototype), 'constructor', this).call(this);
              utils.copy([
                'resourceStore',
                'languageUtils',
                'pluralResolver',
                'interpolator',
                'backendConnector'
              ], services, this);
              this.options = options;
              this.logger = _logger2['default'].create('translator');
            }
            _createClass(Translator, [
              {
                key: 'changeLanguage',
                value: function changeLanguage(lng) {
                  if (lng)
                    this.language = lng;
                }
              },
              {
                key: 'exists',
                value: function exists(key) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? { interpolation: {} } : arguments[1];
                  if (this.options.compatibilityAPI === 'v1') {
                    options = compat.convertTOptions(options);
                  }
                  return this.resolve(key, options) !== undefined;
                }
              },
              {
                key: 'extractFromKey',
                value: function extractFromKey(key, options) {
                  var nsSeparator = options.nsSeparator || this.options.nsSeparator || ':';
                  var namespaces = options.ns || this.options.defaultNS;
                  if (key.indexOf(nsSeparator) > -1) {
                    var parts = key.split(nsSeparator);
                    namespaces = parts[0];
                    key = parts[1];
                  }
                  if (typeof namespaces === 'string')
                    namespaces = [namespaces];
                  return {
                    key: key,
                    namespaces: namespaces
                  };
                }
              },
              {
                key: 'translate',
                value: function translate(keys) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  if (typeof options !== 'object') {
                    options = this.options.overloadTranslationOptionHandler(arguments);
                  } else if (this.options.compatibilityAPI === 'v1') {
                    options = compat.convertTOptions(options);
                  }
                  // non valid keys handling
                  if (keys === undefined || keys === null || keys === '')
                    return '';
                  if (typeof keys === 'number')
                    keys = String(keys);
                  if (typeof keys === 'string')
                    keys = [keys];
                  // return key on CIMode
                  var lng = options.lng || this.language;
                  if (lng && lng.toLowerCase() === 'cimode')
                    return keys[keys.length - 1];
                  // separators
                  var keySeparator = options.keySeparator || this.options.keySeparator || '.';
                  // get namespace(s)
                  var _extractFromKey = this.extractFromKey(keys[keys.length - 1], options);
                  var key = _extractFromKey.key;
                  var namespaces = _extractFromKey.namespaces;
                  var namespace = namespaces[namespaces.length - 1];
                  // resolve from store
                  var res = this.resolve(keys, options);
                  var resType = Object.prototype.toString.apply(res);
                  var noObject = [
                    '[object Number]',
                    '[object Function]',
                    '[object RegExp]'
                  ];
                  var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
                  // object
                  if (res && typeof res !== 'string' && noObject.indexOf(resType) < 0 && !(joinArrays && resType === '[object Array]')) {
                    if (!options.returnObjects && !this.options.returnObjects) {
                      this.logger.warn('accessing an object - but returnObjects options is not enabled!');
                      return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(key, res, options) : 'key \'' + key + ' (' + this.language + ')\' returned an object instead of string.';
                    }
                    var copy = resType === '[object Array]' ? [] : {};
                    // apply child translation on a copy
                    for (var m in res) {
                      copy[m] = this.translate('' + key + keySeparator + m, _extends({ joinArrays: false }, options));
                    }
                    res = copy;
                  }  // array special treatment
                  else if (joinArrays && resType === '[object Array]') {
                    res = res.join(joinArrays);
                    if (res)
                      res = this.extendTranslation(res, key, options);
                  }  // string, empty or null
                  else {
                    var usedDefault = false, usedKey = false;
                    // fallback value
                    if (!this.isValidLookup(res) && options.defaultValue) {
                      usedDefault = true;
                      res = options.defaultValue;
                    }
                    if (!this.isValidLookup(res)) {
                      usedKey = true;
                      res = key;
                    }
                    // save missing
                    if (usedKey || usedDefault) {
                      this.logger.log('missingKey', lng, namespace, key, res);
                      if (this.options.saveMissing) {
                        var lngs = [];
                        if (this.options.saveMissingTo === 'fallback' && this.options.fallbackLng[0]) {
                          for (var i = 0; i < this.options.fallbackLng.length; i++) {
                            lngs.push(this.options.fallbackLng[i]);
                          }
                        } else if (this.options.saveMissingTo === 'all') {
                          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
                        } else {
                          //(this.options.saveMissingTo === 'current' || (this.options.saveMissingTo === 'fallback' && this.options.fallbackLng[0] === false) ) {
                          lngs.push(options.lng || this.language);
                        }
                        if (this.options.missingKeyHandler) {
                          this.options.missingKeyHandler(lngs, namespace, key, res);
                        } else if (this.backendConnector && this.backendConnector.saveMissing) {
                          this.backendConnector.saveMissing(lngs, namespace, key, res);
                        }
                        this.emit('missingKey', lngs, namespace, key, res);
                      }
                    }
                    // extend
                    res = this.extendTranslation(res, key, options);
                    // append namespace if still key
                    if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
                      res = namespace + ':' + key;
                    // parseMissingKeyHandler
                    if (usedKey && this.options.parseMissingKeyHandler)
                      res = this.options.parseMissingKeyHandler(res);
                  }
                  // return
                  return res;
                }
              },
              {
                key: 'extendTranslation',
                value: function extendTranslation(res, key, options) {
                  var _this = this;
                  if (options.interpolation)
                    this.interpolator.init(options);
                  // interpolate
                  var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
                  if (this.options.interpolation.defaultVariables)
                    data = _extends({}, this.options.interpolation.defaultVariables, data);
                  res = this.interpolator.interpolate(res, data);
                  // nesting
                  res = this.interpolator.nest(res, function () {
                    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    return _this.translate.apply(_this, args);
                  }, options);
                  if (options.interpolation)
                    this.interpolator.reset();
                  // post process
                  var postProcess = options.postProcess || this.options.postProcess;
                  var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;
                  if (res !== undefined && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false)
                    res = _postProcessor2['default'].handle(postProcessorNames, res, key, options, this);
                  return res;
                }
              },
              {
                key: 'resolve',
                value: function resolve(keys) {
                  var _this2 = this;
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  var found = undefined;
                  if (typeof keys === 'string')
                    keys = [keys];
                  // forEach possible key
                  keys.forEach(function (k) {
                    if (_this2.isValidLookup(found))
                      return;
                    var _extractFromKey2 = _this2.extractFromKey(k, options);
                    var key = _extractFromKey2.key;
                    var namespaces = _extractFromKey2.namespaces;
                    if (_this2.options.fallbackNS)
                      namespaces = namespaces.concat(_this2.options.fallbackNS);
                    var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
                    var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
                    var codes = options.lngs ? options.lngs : _this2.languageUtils.toResolveHierarchy(options.lng || _this2.language);
                    namespaces.forEach(function (ns) {
                      if (_this2.isValidLookup(found))
                        return;
                      codes.forEach(function (code) {
                        if (_this2.isValidLookup(found))
                          return;
                        var finalKey = key;
                        var finalKeys = [finalKey];
                        // get key for context if needed
                        if (needsContextHandling)
                          finalKeys.push(finalKey += '_' + options.context);
                        // get key for plural if needed
                        if (needsPluralHandling)
                          finalKeys.push(finalKey += _this2.pluralResolver.getSuffix(code, options.count));
                        // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only
                        var possibleKey = undefined;
                        while (possibleKey = finalKeys.pop()) {
                          if (_this2.isValidLookup(found))
                            continue;
                          found = _this2.getResource(code, ns, possibleKey, options);
                        }
                      });
                    });
                  });
                  return found;
                }
              },
              {
                key: 'isValidLookup',
                value: function isValidLookup(res) {
                  return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
                }
              },
              {
                key: 'getResource',
                value: function getResource(code, ns, key) {
                  var options = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];
                  return this.resourceStore.getResource(code, ns, key, options);
                }
              }
            ]);
            return Translator;
          }(_EventEmitter3['default']);
          exports['default'] = Translator;
          module.exports = exports['default'];
          return exports;
        },
        {
          './EventEmitter': 3,
          './compatibility/v1': 9,
          './logger': 12,
          './postProcessor': 13,
          './utils': 14
        }
      ],
      9: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.convertAPIOptions = convertAPIOptions;
          exports.convertJSONOptions = convertJSONOptions;
          exports.convertTOptions = convertTOptions;
          exports.appendBackwardsAPI = appendBackwardsAPI;
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          var _logger = require('../logger');
          var _logger2 = _interopRequireDefault(_logger);
          function convertInterpolation(options) {
            options.interpolation = { unescapeSuffix: 'HTML' };
            options.interpolation.prefix = options.interpolationPrefix || '__';
            options.interpolation.suffix = options.interpolationSuffix || '__';
            options.interpolation.escapeValue = options.escapeInterpolation || false;
            options.interpolation.nestingPrefix = options.reusePrefix || '$t(';
            options.interpolation.nestingSuffix = options.reuseSuffix || ')';
            return options;
          }
          function convertAPIOptions(options) {
            if (options.resStore)
              options.resources = options.resStore;
            if (options.ns && options.ns.defaultNs) {
              options.defaultNS = options.ns.defaultNs;
              options.ns = options.ns.namespaces;
            } else {
              options.defaultNS = options.ns || 'translation';
            }
            if (options.fallbackToDefaultNS && options.defaultNS)
              options.fallbackNS = options.defaultNS;
            options.saveMissing = options.sendMissing;
            options.saveMissingTo = options.sendMissingTo || 'current';
            options.returnNull = options.fallbackOnNull ? false : true;
            options.returnEmptyString = options.fallbackOnEmpty ? false : true;
            options.returnObjects = options.returnObjectTrees;
            options.joinArrays = '\n';
            options.returnedObjectHandler = options.objectTreeKeyHandler;
            options.parseMissingKeyHandler = options.parseMissingKey;
            options.appendNamespaceToMissingKey = true;
            options.nsSeparator = options.nsseparator;
            options.keySeparator = options.keyseparator;
            if (options.shortcutFunction === 'sprintf') {
              options.overloadTranslationOptionHandler = function (args) {
                var values = [];
                for (var i = 1; i < args.length; i++) {
                  values.push(args[i]);
                }
                return {
                  postProcess: 'sprintf',
                  sprintf: values
                };
              };
            }
            options.whitelist = options.lngWhitelist;
            options.preload = options.preload;
            if (options.load === 'current')
              options.load = 'currentOnly';
            if (options.load === 'unspecific')
              options.load = 'languageOnly';
            // backend
            options.backend = options.backend || {};
            options.backend.loadPath = options.resGetPath || 'locales/__lng__/__ns__.json';
            options.backend.addPath = options.resPostPath || 'locales/add/__lng__/__ns__';
            options.backend.allowMultiLoading = options.dynamicLoad;
            // cache
            options.cache = options.cache || {};
            options.cache.prefix = 'res_';
            options.cache.expirationTime = 7 * 24 * 60 * 60 * 1000;
            options.cache.enabled = options.useLocalStorage ? true : false;
            options = convertInterpolation(options);
            if (options.defaultVariables)
              options.interpolation.defaultVariables = options.defaultVariables;
            // TODO: deprecation
            // if (options.getAsync === false) throw deprecation error
            return options;
          }
          function convertJSONOptions(options) {
            options = convertInterpolation(options);
            options.joinArrays = '\n';
            return options;
          }
          function convertTOptions(options) {
            if (options.interpolationPrefix || options.interpolationSuffix || options.escapeInterpolation) {
              options = convertInterpolation(options);
            }
            options.nsSeparator = options.nsseparator;
            options.keySeparator = options.keyseparator;
            options.returnObjects = options.returnObjectTrees;
            return options;
          }
          function appendBackwardsAPI(i18n) {
            i18n.lng = function () {
              _logger2['default'].deprecate('i18next.lng() can be replaced by i18next.language for detected language or i18next.languages for languages ordered by translation lookup.');
              return i18n.services.languageUtils.toResolveHierarchy(i18n.language)[0];
            };
            i18n.preload = function (lngs, cb) {
              _logger2['default'].deprecate('i18next.preload() can be replaced with i18next.loadLanguages()');
              i18n.loadLanguages(lngs, cb);
            };
            i18n.setLng = function (lng, options, callback) {
              _logger2['default'].deprecate('i18next.setLng() can be replaced with i18next.changeLanguage() or i18next.getFixedT() to get a translation function with fixed language or namespace.');
              if (typeof options === 'function') {
                callback = options;
                options = {};
              }
              if (!options)
                options = {};
              if (options.fixLng === true) {
                if (callback)
                  return callback(null, i18n.getFixedT(lng));
              }
              i18n.changeLanguage(lng, callback);
            };
            i18n.addPostProcessor = function (name, fc) {
              _logger2['default'].deprecate('i18next.addPostProcessor() can be replaced by i18next.use({ type: \'postProcessor\', name: \'name\', process: fc })');
              i18n.use({
                type: 'postProcessor',
                name: name,
                process: fc
              });
            };
          }
          return exports;
        },
        { '../logger': 12 }
      ],
      10: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.get = get;
          exports.transformOptions = transformOptions;
          function get() {
            return {
              debug: false,
              ns: ['translation'],
              defaultNS: ['translation'],
              fallbackLng: ['dev'],
              fallbackNS: false,
              // string or array of namespaces
              whitelist: false,
              // array with whitelisted languages
              nonExplicitWhitelist: false,
              load: 'all',
              // | currentOnly | languageOnly
              preload: false,
              // array with preload languages
              keySeparator: '.',
              nsSeparator: ':',
              saveMissing: false,
              // enable to send missing values
              saveMissingTo: 'fallback',
              // 'current' || 'all'
              missingKeyHandler: false,
              // function(lng, ns, key, fallbackValue) -> override if prefer on handling
              postProcess: false,
              // string or array of postProcessor names
              returnNull: true,
              // allows null value as valid translation
              returnEmptyString: true,
              // allows empty string value as valid translation
              returnObjects: false,
              joinArrays: false,
              // or string to join array
              returnedObjectHandler: function returnedObjectHandler() {
              },
              // function(key, value, options) triggered if key returns object but returnObjects is set to false
              parseMissingKeyHandler: false,
              // function(key) parsed a key that was not found in t() before returning
              appendNamespaceToMissingKey: false,
              overloadTranslationOptionHandler: function overloadTranslationOptionHandler(args) {
                return { defaultValue: args[1] };
              },
              interpolation: {
                escapeValue: true,
                prefix: '{{',
                suffix: '}}',
                // prefixEscaped: '{{',
                // suffixEscaped: '}}',
                // unescapeSuffix: '',
                unescapePrefix: '-',
                nestingPrefix: '$t(',
                nestingSuffix: ')',
                // nestingPrefixEscaped: '$t(',
                // nestingSuffixEscaped: ')',
                defaultVariables: undefined  // object that can have values to interpolate on - extends passed in interpolation data
              }
            };
          }
          function transformOptions(options) {
            // create namespace object if namespace is passed in as string
            if (typeof options.ns === 'string')
              options.ns = [options.ns];
            if (typeof options.fallbackLng === 'string')
              options.fallbackLng = [options.fallbackLng];
            if (typeof options.fallbackNS === 'string')
              options.fallbackNS = [options.fallbackNS];
            return options;
          }
          return exports;
        },
        {}
      ],
      11: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          var _get = function get(_x, _x2, _x3) {
            var _again = true;
            while (_again) {
              var object = _x, property = _x2, receiver = _x3;
              _again = false;
              if (object === null)
                object = Function.prototype;
              var desc = Object.getOwnPropertyDescriptor(object, property);
              if (desc === undefined) {
                var parent = Object.getPrototypeOf(object);
                if (parent === null) {
                  return undefined;
                } else {
                  _x = parent;
                  _x2 = property;
                  _x3 = receiver;
                  _again = true;
                  desc = parent = undefined;
                }
              } else if ('value' in desc) {
                return desc.value;
              } else {
                var getter = desc.get;
                if (getter === undefined) {
                  return undefined;
                }
                return getter.call(receiver);
              }
            }
          };
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
            if (superClass)
              Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
          }
          var _logger = require('./logger');
          var _logger2 = _interopRequireDefault(_logger);
          var _EventEmitter2 = require('./EventEmitter');
          var _EventEmitter3 = _interopRequireDefault(_EventEmitter2);
          var _ResourceStore = require('./ResourceStore');
          var _ResourceStore2 = _interopRequireDefault(_ResourceStore);
          var _Translator = require('./Translator');
          var _Translator2 = _interopRequireDefault(_Translator);
          var _LanguageUtils = require('./LanguageUtils');
          var _LanguageUtils2 = _interopRequireDefault(_LanguageUtils);
          var _PluralResolver = require('./PluralResolver');
          var _PluralResolver2 = _interopRequireDefault(_PluralResolver);
          var _Interpolator = require('./Interpolator');
          var _Interpolator2 = _interopRequireDefault(_Interpolator);
          var _BackendConnector = require('./BackendConnector');
          var _BackendConnector2 = _interopRequireDefault(_BackendConnector);
          var _CacheConnector = require('./CacheConnector');
          var _CacheConnector2 = _interopRequireDefault(_CacheConnector);
          var _defaults = require('./defaults');
          var _postProcessor = require('./postProcessor');
          var _postProcessor2 = _interopRequireDefault(_postProcessor);
          var _compatibilityV1 = require('./compatibility/v1');
          var compat = _interopRequireWildcard(_compatibilityV1);
          var I18n = function (_EventEmitter) {
            _inherits(I18n, _EventEmitter);
            function I18n(options, callback) {
              if (options === undefined)
                options = {};
              _classCallCheck(this, I18n);
              _get(Object.getPrototypeOf(I18n.prototype), 'constructor', this).call(this);
              this.options = options;
              this.services = {};
              this.logger = _logger2['default'];
              this.modules = {};
              if (callback && !this.isInitialized)
                this.init(options, callback);
            }
            _createClass(I18n, [
              {
                key: 'init',
                value: function init(options, callback) {
                  var _this = this;
                  if (typeof options === 'function') {
                    callback = options;
                    options = {};
                  }
                  if (options.compatibilityAPI === 'v1') {
                    this.options = _extends({}, (0, _defaults.get)(), (0, _defaults.transformOptions)(compat.convertAPIOptions(options)), {});
                  } else if (options.compatibilityJSON === 'v1') {
                    this.options = _extends({}, (0, _defaults.get)(), (0, _defaults.transformOptions)(compat.convertJSONOptions(options)), {});
                  } else {
                    this.options = _extends({}, (0, _defaults.get)(), this.options, (0, _defaults.transformOptions)(options));
                  }
                  if (!callback)
                    callback = function () {
                    };
                  function createClassOnDemand(ClassOrObject) {
                    if (!ClassOrObject)
                      return;
                    if (typeof ClassOrObject === 'function')
                      return new ClassOrObject();
                    return ClassOrObject;
                  }
                  // init services
                  if (!this.options.isClone) {
                    if (this.modules.logger) {
                      _logger2['default'].init(createClassOnDemand(this.modules.logger), this.options);
                    } else {
                      _logger2['default'].init(null, this.options);
                    }
                    var lu = new _LanguageUtils2['default'](this.options);
                    this.store = new _ResourceStore2['default'](this.options.resources, this.options);
                    var s = this.services;
                    s.logger = _logger2['default'];
                    s.resourceStore = this.store;
                    s.resourceStore.on('added removed', function (lng, ns) {
                      s.cacheConnector.save();
                    });
                    s.languageUtils = lu;
                    s.pluralResolver = new _PluralResolver2['default'](lu, {
                      prepend: '_',
                      compatibilityJSON: this.options.compatibilityJSON
                    });
                    s.interpolator = new _Interpolator2['default'](this.options);
                    s.backendConnector = new _BackendConnector2['default'](createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
                    // pipe events from backendConnector
                    s.backendConnector.on('*', function (event) {
                      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                    s.backendConnector.on('loaded', function (loaded) {
                      s.cacheConnector.save();
                    });
                    s.cacheConnector = new _CacheConnector2['default'](createClassOnDemand(this.modules.cache), s.resourceStore, s, this.options);
                    // pipe events from backendConnector
                    s.cacheConnector.on('*', function (event) {
                      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                        args[_key2 - 1] = arguments[_key2];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                    if (this.modules.languageDetector) {
                      s.languageDetector = createClassOnDemand(this.modules.languageDetector);
                      s.languageDetector.init(s, this.options.detection, this.options);
                    }
                    this.translator = new _Translator2['default'](this.services, this.options);
                    // pipe events from translator
                    this.translator.on('*', function (event) {
                      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
                        args[_key3 - 1] = arguments[_key3];
                      }
                      _this.emit.apply(_this, [event].concat(args));
                    });
                  }
                  // append api
                  var storeApi = [
                    'addResource',
                    'addResources',
                    'addResourceBundle',
                    'removeResourceBundle',
                    'hasResourceBundle',
                    'getResourceBundle'
                  ];
                  storeApi.forEach(function (fcName) {
                    _this[fcName] = function () {
                      return this.store[fcName].apply(this.store, arguments);
                    };
                  });
                  // TODO: COMPATIBILITY remove this
                  if (this.options.compatibilityAPI === 'v1')
                    compat.appendBackwardsAPI(this);
                  this.changeLanguage(this.options.lng, function (err, t) {
                    _this.emit('initialized', _this.options);
                    _this.logger.log('initialized', _this.options);
                    callback(err, t);
                  });
                }
              },
              {
                key: 'loadResources',
                value: function loadResources(callback) {
                  var _this2 = this;
                  if (!callback)
                    callback = function () {
                    };
                  if (!this.options.resources) {
                    (function () {
                      var toLoad = [];
                      var append = function append(lng) {
                        var lngs = _this2.services.languageUtils.toResolveHierarchy(lng);
                        lngs.forEach(function (l) {
                          if (toLoad.indexOf(l) < 0)
                            toLoad.push(l);
                        });
                      };
                      append(_this2.language);
                      if (_this2.options.preload) {
                        _this2.options.preload.forEach(function (l) {
                          append(l);
                        });
                      }
                      _this2.services.cacheConnector.load(toLoad, _this2.options.ns, function () {
                        _this2.services.backendConnector.load(toLoad, _this2.options.ns, callback);
                      });
                    }());
                  } else {
                    callback(null);
                  }
                }
              },
              {
                key: 'use',
                value: function use(module) {
                  if (module.type === 'backend') {
                    this.modules.backend = module;
                  }
                  if (module.type === 'cache') {
                    this.modules.cache = module;
                  }
                  if (module.type === 'logger' || module.log && module.warn && module.warn) {
                    this.modules.logger = module;
                  }
                  if (module.type === 'languageDetector') {
                    this.modules.languageDetector = module;
                  }
                  if (module.type === 'postProcessor') {
                    _postProcessor2['default'].addPostProcessor(module);
                  }
                  return this;
                }
              },
              {
                key: 'changeLanguage',
                value: function changeLanguage(lng, callback) {
                  var _this3 = this;
                  var done = function done(err) {
                    if (lng) {
                      _this3.emit('languageChanged', lng);
                      _this3.logger.log('languageChanged', lng);
                    }
                    if (callback)
                      callback(err, function () {
                        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                          args[_key4] = arguments[_key4];
                        }
                        return _this3.t.apply(_this3, args);
                      });
                  };
                  if (!lng && this.services.languageDetector)
                    lng = this.services.languageDetector.detect();
                  if (lng) {
                    this.language = lng;
                    this.languages = this.services.languageUtils.toResolveHierarchy(lng);
                    this.translator.changeLanguage(lng);
                    if (this.services.languageDetector)
                      this.services.languageDetector.cacheUserLanguage(lng);
                  }
                  this.loadResources(function (err) {
                    done(err);
                  });
                }
              },
              {
                key: 'getFixedT',
                value: function getFixedT(lng, ns) {
                  var _this4 = this;
                  var fixedT = function fixedT(key, options) {
                    options = options || {};
                    options.lng = options.lng || fixedT.lng;
                    options.ns = options.ns || fixedT.ns;
                    return _this4.t(key, options);
                  };
                  fixedT.lng = lng;
                  fixedT.ns = ns;
                  return fixedT;
                }
              },
              {
                key: 't',
                value: function t() {
                  return this.translator && this.translator.translate.apply(this.translator, arguments);
                }
              },
              {
                key: 'exists',
                value: function exists() {
                  return this.translator && this.translator.exists.apply(this.translator, arguments);
                }
              },
              {
                key: 'setDefaultNamespace',
                value: function setDefaultNamespace(ns) {
                  this.options.defaultNS = ns;
                }
              },
              {
                key: 'loadNamespaces',
                value: function loadNamespaces(ns, callback) {
                  var _this5 = this;
                  if (!this.options.ns)
                    return callback && callback();
                  if (typeof ns === 'string')
                    ns = [ns];
                  ns.forEach(function (n) {
                    if (_this5.options.ns.indexOf(n) < 0)
                      _this5.options.ns.push(n);
                  });
                  this.loadResources(callback);
                }
              },
              {
                key: 'loadLanguages',
                value: function loadLanguages(lngs, callback) {
                  if (typeof lngs === 'string')
                    lngs = [lngs];
                  this.options.preload = this.options.preload ? this.options.preload.concat(lngs) : lngs;
                  this.loadResources(callback);
                }
              },
              {
                key: 'dir',
                value: function dir(lng) {
                  if (!lng)
                    lng = this.language;
                  var ltrLngs = [
                    'ar',
                    'shu',
                    'sqr',
                    'ssh',
                    'xaa',
                    'yhd',
                    'yud',
                    'aao',
                    'abh',
                    'abv',
                    'acm',
                    'acq',
                    'acw',
                    'acx',
                    'acy',
                    'adf',
                    'ads',
                    'aeb',
                    'aec',
                    'afb',
                    'ajp',
                    'apc',
                    'apd',
                    'arb',
                    'arq',
                    'ars',
                    'ary',
                    'arz',
                    'auz',
                    'avl',
                    'ayh',
                    'ayl',
                    'ayn',
                    'ayp',
                    'bbz',
                    'pga',
                    'he',
                    'iw',
                    'ps',
                    'pbt',
                    'pbu',
                    'pst',
                    'prp',
                    'prd',
                    'ur',
                    'ydd',
                    'yds',
                    'yih',
                    'ji',
                    'yi',
                    'hbo',
                    'men',
                    'xmn',
                    'fa',
                    'jpr',
                    'peo',
                    'pes',
                    'prs',
                    'dv',
                    'sam'
                  ];
                  return ltrLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) ? 'ltr' : 'rtl';
                }
              },
              {
                key: 'createInstance',
                value: function createInstance(options, callback) {
                  if (options === undefined)
                    options = {};
                  return new I18n(options, callback);
                }
              },
              {
                key: 'cloneInstance',
                value: function cloneInstance(options, callback) {
                  var _this6 = this;
                  if (options === undefined)
                    options = {};
                  var clone = new I18n(_extends({}, options, this.options, { isClone: true }), callback);
                  var membersToCopy = [
                    'store',
                    'translator',
                    'services',
                    'language'
                  ];
                  membersToCopy.forEach(function (m) {
                    clone[m] = _this6[m];
                  });
                  return clone;
                }
              }
            ]);
            return I18n;
          }(_EventEmitter3['default']);
          exports['default'] = new I18n();
          module.exports = exports['default'];
          return exports;
        },
        {
          './BackendConnector': 1,
          './CacheConnector': 2,
          './EventEmitter': 3,
          './Interpolator': 4,
          './LanguageUtils': 5,
          './PluralResolver': 6,
          './ResourceStore': 7,
          './Translator': 8,
          './compatibility/v1': 9,
          './defaults': 10,
          './logger': 12,
          './postProcessor': 13
        }
      ],
      12: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _extends = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var consoleLogger = {
            type: 'logger',
            log: function log(args) {
              this._output('log', args);
            },
            warn: function warn(args) {
              this._output('warn', args);
            },
            error: function error(args) {
              this._output('error', args);
            },
            _output: function _output(type, args) {
              if (console && console[type])
                console[type].apply(console, Array.prototype.slice.call(args));
            }
          };
          var Logger = function () {
            function Logger(concreteLogger) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Logger);
              this.subs = [];
              this.init(concreteLogger, options);
            }
            _createClass(Logger, [
              {
                key: 'init',
                value: function init(concreteLogger) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  this.prefix = options.prefix || 'i18next:';
                  this.logger = concreteLogger || consoleLogger;
                  this.options = options;
                  this.debug = options.debug === false ? false : true;
                }
              },
              {
                key: 'setDebug',
                value: function setDebug(bool) {
                  this.debug = bool;
                  this.subs.forEach(function (sub) {
                    sub.setDebug(bool);
                  });
                }
              },
              {
                key: 'log',
                value: function log() {
                  this.forward(arguments, 'log', '', true);
                }
              },
              {
                key: 'warn',
                value: function warn() {
                  this.forward(arguments, 'warn', '', true);
                }
              },
              {
                key: 'error',
                value: function error() {
                  this.forward(arguments, 'error', '');
                }
              },
              {
                key: 'deprecate',
                value: function deprecate() {
                  this.forward(arguments, 'warn', 'WARNING DEPRECATED: ', true);
                }
              },
              {
                key: 'forward',
                value: function forward(args, lvl, prefix, debugOnly) {
                  if (debugOnly && !this.debug)
                    return;
                  if (typeof args[0] === 'string')
                    args[0] = prefix + this.prefix + ' ' + args[0];
                  this.logger[lvl](args);
                }
              },
              {
                key: 'create',
                value: function create(moduleName) {
                  var sub = new Logger(this.logger, _extends({ prefix: this.prefix + ':' + moduleName + ':' }, this.options));
                  this.subs.push(sub);
                  return sub;
                }  // createInstance(options = {}) {
                   //   return new Logger(options, callback);
                   // }
              }
            ]);
            return Logger;
          }();
          exports['default'] = new Logger();
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      13: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            processors: {},
            addPostProcessor: function addPostProcessor(module) {
              this.processors[module.name] = module;
            },
            handle: function handle(processors, value, key, options, translator) {
              var _this = this;
              processors.forEach(function (processor) {
                if (_this.processors[processor])
                  value = _this.processors[processor].process(value, key, options, translator);
              });
              return value;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      14: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.makeString = makeString;
          exports.copy = copy;
          exports.setPath = setPath;
          exports.pushPath = pushPath;
          exports.getPath = getPath;
          exports.deepExtend = deepExtend;
          exports.regexEscape = regexEscape;
          exports.escape = escape;
          function makeString(object) {
            if (object == null)
              return '';
            return '' + object;
          }
          function copy(a, s, t) {
            a.forEach(function (m) {
              if (s[m])
                t[m] = s[m];
            });
          }
          function getLastOfPath(object, path, Empty) {
            function cleanKey(key) {
              return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
            }
            var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');
            while (stack.length > 1) {
              if (!object)
                return {};
              var key = cleanKey(stack.shift());
              if (!object[key] && Empty)
                object[key] = new Empty();
              object = object[key];
            }
            if (!object)
              return {};
            return {
              obj: object,
              k: cleanKey(stack.shift())
            };
          }
          function setPath(object, path, newValue) {
            var _getLastOfPath = getLastOfPath(object, path, Object);
            var obj = _getLastOfPath.obj;
            var k = _getLastOfPath.k;
            obj[k] = newValue;
          }
          function pushPath(object, path, newValue, concat) {
            var _getLastOfPath2 = getLastOfPath(object, path, Object);
            var obj = _getLastOfPath2.obj;
            var k = _getLastOfPath2.k;
            obj[k] = obj[k] || [];
            if (concat)
              obj[k] = obj[k].concat(newValue);
            if (!concat)
              obj[k].push(newValue);
          }
          function getPath(object, path) {
            var _getLastOfPath3 = getLastOfPath(object, path);
            var obj = _getLastOfPath3.obj;
            var k = _getLastOfPath3.k;
            if (!obj)
              return undefined;
            return obj[k];
          }
          function deepExtend(target, source, overwrite) {
            for (var prop in source) {
              if (prop in target) {
                // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
                if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
                  if (overwrite)
                    target[prop] = source[prop];
                } else {
                  deepExtend(target[prop], source[prop], overwrite);
                }
              } else {
                target[prop] = source[prop];
              }
            }
            return target;
          }
          function regexEscape(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
          }
          /* eslint-disable */
          var _entityMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '\'': '&#39;',
            '/': '&#x2F;'
          };
          /* eslint-enable */
          function escape(data) {
            if (typeof data === 'string') {
              return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
              });
            } else {
              return data;
            }
          }
          return exports;
        },
        {}
      ]
    }, {}, [11])(11);
  }));
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next_xhr_backend = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18nextXHRBackend = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          // https://gist.github.com/Xeoncross/7663273
          function ajax(url, options, callback, data, cache) {
            // Must encode data
            if (data && typeof data === 'object') {
              var y = '', e = encodeURIComponent;
              for (var m in data) {
                y += '&' + e(m) + '=' + e(data[m]);
              }
              data = y.slice(1) + (!cache ? '&_t=' + new Date() : '');
            }
            try {
              var x = new (XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');
              x.open(data ? 'POST' : 'GET', url, 1);
              if (!options.crossDomain) {
                x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
              }
              x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
              x.onreadystatechange = function () {
                x.readyState > 3 && callback && callback(x.responseText, x);
              };
              x.send(data);
            } catch (e) {
              window.console && console.log(e);
            }
          }
          // ajax.uriEncode = function(o) {
          //     var x, y = '', e = encodeURIComponent;
          //     for (x in o) y += '&' + e(x) + '=' + e(o[x]);
          //     return y.slice(1);
          // };
          //
          // ajax.collect = (a, f) {
          //     var n = [];
          //     for (var i = 0; i < a.length; i++) {
          //         var v = f(a[i]);
          //         if (v != null) n.push(v);
          //     }
          //     return n;
          // };
          //
          // ajax.serialize = function (f) {
          //     function g(n) {
          //         return f.getElementsByTagName(n);
          //     };
          //     var nv = function (e) {
          //         if (e.name) return encodeURIComponent(e.name) + '=' + encodeURIComponent(e.value);
          //     };
          //     var i = collect(g('input'), function (i) {
          //         if ((i.type != 'radio' && i.type != 'checkbox') || i.checked) return nv(i);
          //     });
          //     var s = collect(g('select'), nv);
          //     var t = collect(g('textarea'), nv);
          //     return i.concat(s).concat(t).join('&');
          // };
          //
          function getDefaults() {
            return {
              loadPath: '/locales/{{lng}}/{{ns}}.json',
              addPath: 'locales/add/{{lng}}/{{ns}}',
              allowMultiLoading: false,
              parse: JSON.parse,
              crossDomain: false,
              ajax: ajax
            };
          }
          var Backend = function () {
            function Backend(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Backend);
              this.init(services, options);
              this.type = 'backend';
            }
            _createClass(Backend, [
              {
                key: 'init',
                value: function init(services) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  this.services = services;
                  this.options = utils.defaults(options, this.options || {}, getDefaults());
                }
              },
              {
                key: 'readMulti',
                value: function readMulti(languages, namespaces, callback) {
                  var url = this.services.interpolator.interpolate(this.options.loadPath, {
                    lng: languages.join('+'),
                    ns: namespaces.join('+')
                  });
                  this.loadUrl(url, callback);
                }
              },
              {
                key: 'read',
                value: function read(language, namespace, callback) {
                  var url = this.services.interpolator.interpolate(this.options.loadPath, {
                    lng: language,
                    ns: namespace
                  });
                  this.loadUrl(url, callback);
                }
              },
              {
                key: 'loadUrl',
                value: function loadUrl(url, callback) {
                  var _this = this;
                  this.options.ajax(url, this.options, function (data, xhr) {
                    var statusCode = xhr.status.toString();
                    if (statusCode.indexOf('5') === 0)
                      return callback('failed loading ' + url, true  /* retry */);
                    if (statusCode.indexOf('4') === 0)
                      return callback('failed loading ' + url, false  /* no retry */);
                    var ret = undefined, err = undefined;
                    try {
                      ret = _this.options.parse(data);
                    } catch (e) {
                      err = 'failed parsing ' + url + ' to json';
                    }
                    if (err)
                      return callback(err, false);
                    callback(null, ret);
                  });
                }
              },
              {
                key: 'create',
                value: function create(languages, namespace, key, fallbackValue) {
                  var _this2 = this;
                  if (typeof languages === 'string')
                    languages = [languages];
                  var payload = {};
                  payload[key] = fallbackValue || '';
                  languages.forEach(function (lng) {
                    var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {
                      lng: lng,
                      ns: namespace
                    });
                    this.options.ajax(url, _this2.options, function (data, xhr) {
                    }, payload);
                  });
                }
              }
            ]);
            return Backend;
          }();
          Backend.type = 'backend';
          exports['default'] = Backend;
          module.exports = exports['default'];
          return exports;
        },
        { './utils': 2 }
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.defaults = defaults;
          exports.extend = extend;
          var arr = [];
          var each = arr.forEach;
          var slice = arr.slice;
          function defaults(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  if (obj[prop] === undefined)
                    obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          function extend(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          return exports;
        },
        {}
      ]
    }, {}, [1])(1);
  }));
  (function (f) {
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = f();
    } else if (true) {
      libs_i18next_browser_languageDetector = function () {
        return typeof f === 'function' ? f() : f;
      }();
    } else {
      var g;
      if (typeof window !== 'undefined') {
        g = window;
      } else if (typeof global !== 'undefined') {
        g = global;
      } else if (typeof self !== 'undefined') {
        g = self;
      } else {
        g = this;
      }
      g.i18nextBrowserLanguageDetector = f();
    }
  }(function () {
    var define, module, exports;
    return function e(t, n, r) {
      function s(o, u) {
        if (!n[o]) {
          if (!t[o]) {
            var a = typeof require == 'function' && require;
            if (!u && a)
              return a(o, !0);
            if (i)
              return i(o, !0);
            var f = new Error('Cannot find module \'' + o + '\'');
            throw f.code = 'MODULE_NOT_FOUND', f;
          }
          var l = n[o] = { exports: {} };
          t[o][0].call(l.exports, function (e) {
            var n = t[o][1][e];
            return s(n ? n : e);
          }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
      }
      var i = typeof require == 'function' && require;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({
      1: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var cookie = {
            create: function create(name, value, minutes, domain) {
              var expires = undefined;
              if (minutes) {
                var date = new Date();
                date.setTime(date.getTime() + minutes * 60 * 1000);
                expires = '; expires=' + date.toGMTString();
              } else
                expires = '';
              domain = domain ? 'domain=' + domain + ';' : '';
              document.cookie = name + '=' + value + expires + ';' + domain + 'path=/';
            },
            read: function read(name) {
              var nameEQ = name + '=';
              var ca = document.cookie.split(';');
              for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) === ' ')
                  c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0)
                  return c.substring(nameEQ.length, c.length);
              }
              return null;
            },
            remove: function remove(name) {
              this.create(name, '', -1);
            }
          };
          exports['default'] = {
            name: 'cookie',
            lookup: function lookup(options) {
              var found = undefined;
              if (options.lookupCookie && typeof document !== 'undefined') {
                var c = cookie.read(options.lookupCookie);
                if (c)
                  found = c;
              }
              return found;
            },
            cacheUserLanguage: function cacheUserLanguage(lng, options) {
              if (options.lookupCookie && typeof document !== 'undefined') {
                cookie.create(options.lookupCookie, lng, options.cookieMinutes, options.cookieDomain);
              }
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      2: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var storage = {
            setItem: function setItem(key, value) {
              if (window.localStorage) {
                try {
                  window.localStorage.setItem(key, value);
                } catch (e) {
                }
              }
            },
            getItem: function getItem(key, value) {
              if (window.localStorage) {
                try {
                  return window.localStorage.getItem(key, value);
                } catch (e) {
                  return undefined;
                }
              }
            }
          };
          var hasLocalStorageSupport = void 0;
          try {
            hasLocalStorageSupport = window !== 'undefined' && window.localStorage !== null;
            var testKey = 'i18next.translate.boo';
            window.localStorage.setItem(testKey, 'foo');
            window.localStorage.removeItem(testKey);
          } catch (e) {
            hasLocalStorageSupport = false;
          }
          exports['default'] = {
            name: 'localStorage',
            lookup: function lookup(options) {
              var found = undefined;
              if (options.lookupLocalStorage && typeof window !== 'undefined' && hasLocalStorageSupport) {
                var lng = storage.getItem(options.lookupLocalStorage);
                if (lng)
                  found = lng;
              }
              return found;
            },
            cacheUserLanguage: function cacheUserLanguage(lng, options) {
              if (options.lookupLocalStorage && typeof window !== 'undefined' && hasLocalStorageSupport) {
                storage.setItem(options.lookupLocalStorage, lng);
              }
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      3: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            name: 'navigator',
            lookup: function lookup(options) {
              var found = [];
              if (typeof navigator !== 'undefined') {
                if (navigator.languages) {
                  // chrome only; not an array, so can't use .push.apply instead of iterating
                  for (var i = 0; i < navigator.languages.length; i++) {
                    found.push(navigator.languages[i]);
                  }
                }
                if (navigator.userLanguage) {
                  found.push(navigator.userLanguage);
                }
                if (navigator.language) {
                  found.push(navigator.language);
                }
              }
              return found.length > 0 ? found : undefined;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      4: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports['default'] = {
            name: 'querystring',
            lookup: function lookup(options) {
              var found = undefined;
              if (typeof window !== 'undefined') {
                var query = window.location.search.substring(1);
                var params = query.split('&');
                for (var i = 0; i < params.length; i++) {
                  var pos = params[i].indexOf('=');
                  if (pos > 0) {
                    var key = params[i].substring(0, pos);
                    if (key === options.lookupQuerystring) {
                      found = params[i].substring(pos + 1);
                    }
                  }
                }
              }
              return found;
            }
          };
          module.exports = exports['default'];
          return exports;
        },
        {}
      ],
      5: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          var _createClass = function () {
            function defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                defineProperties(Constructor, staticProps);
              return Constructor;
            };
          }();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { 'default': obj };
          }
          function _interopRequireWildcard(obj) {
            if (obj && obj.__esModule) {
              return obj;
            } else {
              var newObj = {};
              if (obj != null) {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key))
                    newObj[key] = obj[key];
                }
              }
              newObj['default'] = obj;
              return newObj;
            }
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          var _utils = require('./utils');
          var utils = _interopRequireWildcard(_utils);
          var _browserLookupsCookie = require('./browserLookups/cookie');
          var _browserLookupsCookie2 = _interopRequireDefault(_browserLookupsCookie);
          var _browserLookupsQuerystring = require('./browserLookups/querystring');
          var _browserLookupsQuerystring2 = _interopRequireDefault(_browserLookupsQuerystring);
          var _browserLookupsLocalStorage = require('./browserLookups/localStorage');
          var _browserLookupsLocalStorage2 = _interopRequireDefault(_browserLookupsLocalStorage);
          var _browserLookupsNavigator = require('./browserLookups/navigator');
          var _browserLookupsNavigator2 = _interopRequireDefault(_browserLookupsNavigator);
          function getDefaults() {
            return {
              order: [
                'querystring',
                'cookie',
                'localStorage',
                'navigator'
              ],
              lookupQuerystring: 'lng',
              lookupCookie: 'i18next',
              lookupLocalStorage: 'i18nextLng',
              // cache user language
              caches: ['localStorage']  //cookieMinutes: 10,
                                //cookieDomain: 'myDomain'
            };
          }
          var Browser = function () {
            function Browser(services) {
              var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
              _classCallCheck(this, Browser);
              this.type = 'languageDetector';
              this.detectors = {};
              this.init(services, options);
            }
            _createClass(Browser, [
              {
                key: 'init',
                value: function init(services) {
                  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
                  var i18nOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
                  this.services = services;
                  this.options = utils.defaults(options, this.options || {}, getDefaults());
                  this.i18nOptions = i18nOptions;
                  this.addDetector(_browserLookupsCookie2['default']);
                  this.addDetector(_browserLookupsQuerystring2['default']);
                  this.addDetector(_browserLookupsLocalStorage2['default']);
                  this.addDetector(_browserLookupsNavigator2['default']);
                }
              },
              {
                key: 'addDetector',
                value: function addDetector(detector) {
                  this.detectors[detector.name] = detector;
                }
              },
              {
                key: 'detect',
                value: function detect(detectionOrder) {
                  var _this = this;
                  if (!detectionOrder)
                    detectionOrder = this.options.order;
                  var detected = [];
                  detectionOrder.forEach(function (detectorName) {
                    if (_this.detectors[detectorName]) {
                      var lookup = _this.detectors[detectorName].lookup(_this.options);
                      if (lookup && typeof lookup === 'string')
                        lookup = [lookup];
                      if (lookup)
                        detected = detected.concat(lookup);
                    }
                  });
                  var found = undefined;
                  detected.forEach(function (lng) {
                    if (found)
                      return;
                    var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
                    if (_this.services.languageUtils.isWhitelisted(cleanedLng))
                      found = cleanedLng;
                  });
                  return found || this.i18nOptions.fallbackLng[0];
                }
              },
              {
                key: 'cacheUserLanguage',
                value: function cacheUserLanguage(lng, caches) {
                  var _this2 = this;
                  if (!caches)
                    caches = this.options.caches;
                  caches.forEach(function (cacheName) {
                    if (_this2.detectors[cacheName])
                      _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
                  });
                }
              }
            ]);
            return Browser;
          }();
          Browser.type = 'languageDetector';
          exports['default'] = Browser;
          module.exports = exports['default'];
          return exports;
        },
        {
          './browserLookups/cookie': 1,
          './browserLookups/localStorage': 2,
          './browserLookups/navigator': 3,
          './browserLookups/querystring': 4,
          './utils': 6
        }
      ],
      6: [
        function (require, module, exports) {
          'use strict';
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.defaults = defaults;
          exports.extend = extend;
          var arr = [];
          var each = arr.forEach;
          var slice = arr.slice;
          function defaults(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  if (obj[prop] === undefined)
                    obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          function extend(obj) {
            each.call(slice.call(arguments, 1), function (source) {
              if (source) {
                for (var prop in source) {
                  obj[prop] = source[prop];
                }
              }
            });
            return obj;
          }
          return exports;
        },
        {}
      ]
    }, {}, [5])(5);
  }));
  i18next_loader = function (options, i18next, xhrBackend, browserLanguageDetector) {
    console.log('Loading i18next loader');
    i18next.use(xhrBackend).use(browserLanguageDetector).init(options, function () {
      console.log('Initialized i18n');
    });
    i18next.replace = function (template, fallbackProps, namespaces) {
      return template.replace(i18next.services.interpolator.regexp, function (match, key, format) {
        var options = {};
        if (namespaces) {
          options.ns = namespaces;
        }
        var translatedKey = fallbackProps && fallbackProps[key];
        if (!translatedKey && i18next.exists(key, options)) {
          translatedKey = i18next.t(key, options);
        }
        if (!translatedKey) {
          console.warn('MISSING TRANSLATION FOR KEY: ' + key);
          return key;
        }
        return translatedKey || key;
      });
    };
    return i18next;
  }(i18next_options, libs_i18next, libs_i18next_xhr_backend, libs_i18next_browser_languageDetector);
  i18next_inlineLocales = {
    load: function (id) {
      throw new Error('Dynamic load not allowed: ' + id);
    }
  };
  (function (i18next) {
    i18next.addResourceBundle('en-US', 'session', {
      'agent.supportProfileLabel': 'Support Profile',
      'agent.startCobrowsing': 'Start Co-Browsing',
      'agent.sharedMode': 'Shared',
      'agent.viewOnly': 'View Only',
      'agent.follow': 'Follow',
      'agent.serviceNumber': 'Service Number',
      'agent.start': 'Start',
      'agent.starting': 'Starting...',
      'agent.close': 'Close',
      'agent.logout': 'Logout',
      'agent.generate': 'Generate',
      'agent.noPermissionCobrowseMessage': 'You do not have required Permissions to view this page please contact your manager.',
      'agent.serviceNumberGenerateInfo': 'Generating Service Number Please wait',
      'agent.serviceNumberInvalid': 'Invalid Service Number',
      'agent.serviceNumberExpire': 'This Service Number expires in {{timerVal}} seconds',
      'agent.serviceNumberExpired': 'This Service Number expired, please generate new one',
      'agent.dialogStartingText': 'Setting up Connection',
      'agent.dialogConnectionEstablished': 'Connection Established Successfully',
      'agent.dialogWaitingForUserAccept': 'Waiting for Visitor to accept cobrowse offer...',
      'agent.dialogRequestingCoBrowse': 'Visitor requesting cobrowse session...',
      'agent.dialogMissingVisitorId': 'Missing visitor Id...',
      'agent.dialogUnableToGenerateServiceId': 'Unable to generate a new service number...',
      'agent.dialogInitiatingConnection': 'Initiating connection',
      'agent.dialogValuesMissing': 'Values missing...',
      'agent.visitorDeclinedOfferMessage': 'Visitor has declined the Cobrowse Request',
      'agent.openedInNewBrowser': 'Session opened in new browser window',
      'common.OK': 'OK',
      'common.JOIN': 'Join',
      'common.START': 'Start',
      'common.CLOSE': 'Close',
      'common.CANCEL': 'Cancel',
      'common.SUBMIT': 'Submit',
      'common.NAME': 'Name',
      'common.EMAIL': 'Email',
      'common.EMAIL_PLACEHOLDER': 'name@example.com',
      'common.CHANGE_NAME': 'Change Name',
      'common.CHANGE_NAME_TEXT': 'Please enter your name.',
      'common.MAKE_CHOICE': 'Make a choice',
      'common.AGO_PREFIX': '',
      'common.AGO_SUFFIX': 'ago',
      'common.FROM': '',
      'common.NOW': 'just now',
      'common.MINUTE': 'minute',
      'common.MINUTES': 'minutes',
      'common.HOUR': 'hour',
      'common.HOURS': 'hours',
      'common.DAY': 'day',
      'common.DAYS': 'days',
      'common.WEEK': 'week',
      'common.WEEKS': 'weeks',
      'common.MONTH': 'month',
      'common.MONTHS': 'months',
      'common.YEAR': 'year',
      'common.YEARS': 'years',
      'common.CONNECTION_DENIED_TITLE': 'Session expired...',
      'common.CONNECTION_DENIED_TEXT': 'We will try to automatically reconnect your session. You may have to login again.',
      'common.CONNECTION_RESTORING_TEXT': 'Attempting to restore connection. Changes made now may not be saved.',
      'common.CONNECTION_BROKEN_TEXT': 'Connection interrupted.',
      'integration.SUPPORT_NUMBER_IS': 'Reach our support hotline at:',
      'integration.ENTER_USERNAME': 'Please enter your name:',
      'integration.MISSING_VALUE': 'This value is required.',
      'integration.STEP': 'Step',
      'integration.START': 'Start',
      'integration.CANCEL': 'Cancel',
      'integration.CLOSE': 'Close',
      'integration.SHOW_SERVICE_TITLE': 'Online Support',
      'integration.SHOW_SERVICE_NUMBER_HEADER': 'Service Number',
      'integration.SHOW_SERVICE_NUMBER_INFO': 'Please give the service number to an agent in order to share your browser window.',
      'integration.ENTER_SERVICE_NUMBER_INFO': 'Please enter the service number.',
      'integration.SECURITY_HEADER': 'Info',
      'integration.SECURITY_INFORMATION': '<b>We will have no access to your computer. </b> We only share the same view as you in your current browser window.',
      'integration.STANDBY': '...is being created.',
      'integration.NO_SUPPORT_DIALOG_HEADER': 'No agent is available at the moment.',
      'integration.NO_SUPPORT_DIALOG_CENTER': 'Close this dialog to return to the website.',
      'integration.SERVICE_HOURS_INTRO': 'Our operators are available during these hours:',
      'integration.NO_SUPPORT_DIALOG_TITLE': 'Live-Support is unavailable',
      'integration.SUPPORT_DIALOG_HEADER': 'Do you have a question?',
      'integration.SUPPORT_DIALOG_TITLE': 'Welcome to Live Support',
      'integration.SUPPORT_DIALOG_INTRO': 'If you like we will guide you interactively through the website. Sharing the same view in the browser helps us to assist you better.',
      'integration.SUPPORT_DIALOG_AGENT_IS': 'Your support agent is:',
      'integration.SUPPORT_DIALOG_BTN_REQUEST': 'Request support',
      'integration.SUPPORT_STEP1_LABEL': 'Enter your name and request support.',
      'integration.SUPPORT_STEP2_LABEL': 'Wait for availability of support agents.',
      'integration.SUPPORT_STEP3_LABEL': 'Confirm live support and clarify any open questions.',
      'integration.ACCEPT_TERMS': 'I accept the terms of service.',
      'integration.SHOW_TERMS': 'Show terms of service',
      'integration.CHAT_WELCOME_MESSAGE': 'Leave a question or comment and our agents will try to attend to you shortly.',
      'session.cobrowseSession': 'CoBrowse Session',
      'session.videoCall': 'Video Call',
      'session.voiceCall': 'Voice Call',
      'session.visitorLeftError': 'Visitor left the session. Please start a new session to continue.',
      'session.agentLeftError': 'Agent left the session',
      'session.noDataError': 'No data has been received from Visitor.<br>Please try to restart the session.',
      'session.blockedContent': 'This element cannot be shown in your browser during the cobrowsing session. It will only be visible in the visitor\'s browser',
      'session.restrictedPage': 'The visitor is browsing on a restricted page.<br>The session will continue once the visitor navigates to a non-restricted area.',
      'session.restrictedPageVisitor': 'Due to its content, this page cannot be viewed by your Agent. Your CoBrowse session will continue once you navigate to a non-restricted page.',
      'session.accessblocked': 'Direct data entry is blocked.',
      'session.connectionReestablished': 'Connection re-established',
      'session.connectionUnavailable': 'Connection unavailable. Trying to reconnect...',
      'session.sessionStarted': 'CoBrowse Session started',
      'session.sessionEnded': 'CoBrowse Session ended',
      'session.sessionActive': 'CoBrowse session is active',
      'session.standbytext': 'Please wait until the contents of this website have been activated.',
      'session.sessionPaused': 'The session was paused.',
      'session.sessionUnpaused': 'The session was restarted.',
      'session.loading': 'Loading',
      'session.wait': 'Please wait',
      'session.unlock': 'Unlock',
      'session.lock': 'Lock',
      'session.invite': 'Send Invitation',
      'session.copyLink': 'Simply copy & paste the link below to invite participants via your preferred instant messaging client.',
      'session.invitationDialogHeader': 'Invite Participants',
      'session.end': 'End Session',
      'session.loginFailed': 'Invalid username or wrong password',
      'session.incorrectCaptcha': 'Incorrect captcha!',
      'session.incorrectLogin': 'Login failed!',
      'session.captchaHelp': 'To verify that you are a human, please enter the words you see in the box below, in order and separataed by a space. Further <a href=\'javascript:Recaptcha.showhelp()\'>help</a>.',
      'session.accountLocked': 'The account is locked!',
      'session.missingUsername': 'Please enter a username!',
      'session.emailSent': 'The e-mail was sent to the specified user.',
      'session.nonEqualPasswords': 'The passwords must be equal!',
      'session.passwordChangeRequired': 'A password change is required!',
      'session.passwordNotDifferent': 'The new password must differ from the previous password!',
      'session.invalidToken': 'Invalid Token! Possible reasons are: The token was already used, is too old or was modified.',
      'session.insecurePassword': 'The password is not long enough!',
      'session.resetPasswordSuccess': 'Password successfully changed.',
      'session.resetPasswordFail': 'Failed to reset password! Possible reasons: Username does not exist or the new password is insufficiently long.',
      'session.confirmSynchExitMessage': 'Do you really want to exit the current session?',
      'session.confirm': 'Confirm',
      'session.invitationEmailMessage': 'Invite participants via Email.',
      'session.emailMessage': 'Message (optional)',
      'session.emailYourName': 'Your Name',
      'session.emailReceiptName': 'Recipient Name',
      'session.emailReceiptMail': 'Recipient Email',
      'session.sendEmailButton': 'Send Email',
      'session.socialNetworkMessage': 'Invite participants via Twitter, Facebook or Google+.',
      'session.socialNetworkInfo': 'If you are currenty not logged into the correspondent service, the login window for the service will pop-up and you are prompted to enter your username and password.',
      'session.logoContextMessage': 'Customer Service 2.0',
      'session.refreshButtonContextMessage': 'Re-synchronize current page',
      'session.urlPlaceHolder': 'Enter the Address here',
      'session.backButtonContextMessage': 'Go Back',
      'session.forwardButtonContextMessage': 'Go Forward',
      'session.exitSynchContextMessage': 'Exit CoBrowsing session',
      'session.pauseSessionContextMessage': 'Pause or restart the CoBrowsing session',
      'session.agentMenuContextMessage': 'Change personal settings',
      'session.invitationItemContextMessage': 'Share this CoBrowsing session with other people',
      'session.usersInfoContextMessage': 'Number of participants in this session',
      'session.lockButtonContextMessage': 'Lock the session (Nobody can join)',
      'session.lockButtonText': 'Session Unlocked',
      'session.toggleSessionStateContextMessage': 'Changing session state...',
      'session.toggleSessionStateText': 'Working...',
      'session.unlockButtonContextMessage': 'Unlock the session (Anyone can join)',
      'session.unlockButtonText': 'Session Locked',
      'session.linkLabel': 'Session Link',
      'session.emailLabel': 'Email',
      'session.socialnetworksLabel': 'Social Networks',
      'session.SEND_MAIL_ERROR': 'We\'re sorry. Something went wrong while sending your email.',
      'session.ERROR': 'Error',
      'session.SEND_MAIL_SUCCESS': 'Email sent.',
      'session.SUCCESS': 'Success',
      'session.USERS_ONLINE': 'Users Online',
      'session.CHANGE_POINTER': 'Change Pointer',
      'session.SESSION_IS_PAUSED': 'Please wait. The session is currently paused.',
      'session.FEEDBACK_SUCCESS': 'Your feedback has been sent successfully.',
      'session.FEEDBACK_FAIL': 'Failed to sent your feedback.',
      'session.SEND_FEEDBACK_LINK': 'Send Feedback',
      'session.SEND_FEEDBACK_LINK_TITLE': 'Send feedback, report problems or issues.',
      'session.UPLOAD_FILE_LINK': 'Upload File',
      'session.UPLOAD_FILE_LINK_TITLE': 'Upload a image or PDF which should be shared with other participants.',
      'session.SEND_FEEDBACK_TITLE': 'Report a Problem',
      'session.SEND_FEEDBACK_DESCRIPTION_TITLE': 'Problem Description',
      'session.SEND_FEEDBACK_DESCRIPTION_PLACEHOLDER': 'Please enter your problem description here. The description should describe the steps to reproduce the problem.',
      'session.SEND_FEEDBACK_DESCRIPTION_HINT': 'If you\'re reporting a problem, a good description should provide answers to the following questions:<p><ol><li>What were you doing when the problem occurred?</li><li>What did you expect to happen?</li><li>What did happen instead?</li></ol></p>',
      'session.FEEDBACK_INCLUDE_SCREENSHOT': 'Include Screenshot',
      'session.FEEDBACK_SCREENSHOT_PREVIEW': 'Screenshot Preview',
      'session.FEEDBACK_NO_IMAGE': 'No Image',
      'session.GENERATE_SCREENSHOT': 'Generating Screenshot...',
      'session.NO_SCREENSHOT_SUPPORT': 'Screenshot generation is not supported by your browser!',
      'session.IS_TYPING': 'is typing...',
      'session.csatMessage': 'Please rate this CoBrowse session',
      'session.csatAnswerFeedback': 'Thank you for communicating with us',
      'session.csatDisclaimer': 'Your feedback helps us serve you better. It will not be shared with any customer service representative.',
      'session.browserNotSupported': 'Your browser is not supported.',
      'session.remoteConsumerBrowserNotSupported': 'The consumer\'s browser is not supported.',
      'session.agentDisconnected': 'The agent was disconnected.',
      'session.visitorDeniedAccess': 'The visitor did not allow access to the camera/microphone or has no camera/microphone connected',
      'session.remoteAgentProblemJoining': 'Your agent was unable to join the call.',
      'session.clickHereToStart': 'Click here to start',
      'session.unableToGetCameraAccess': 'Unable to access your camera/microphone.',
      'session.unableToGetCameraAccessWithTip': 'Unable to access your camera/microphone. If you wish to participate in this call, please allow access to the camera and microphone in your browser and reload the page.',
      'session.unableToConnect': 'Unable to connect to Agent.',
      'session.callDropped': 'Call ended. Could not reconnect.',
      'session.callHasEnded': 'The call you are trying to join has ended.',
      'session.generalCallInitializationError': 'Could not join call.',
      'session.joinedCallFromAnotherBrowser': 'You joined the call from another browser. Refresh to rejoin.',
      'session.disconnected': 'Disconnected'
    });
  }(i18next_loader));
  dojo_domReady = function () {
    var isTop, testDiv, scrollIntervalId, isBrowser = typeof window !== 'undefined' && window.document, isPageLoaded = !isBrowser, doc = isBrowser ? document : null, readyCalls = [];
    function runCallbacks(callbacks) {
      var i;
      for (i = 0; i < callbacks.length; i += 1) {
        callbacks[i](doc);
      }
    }
    function callReady() {
      var callbacks = readyCalls;
      if (isPageLoaded) {
        //Call the DOM ready callbacks
        if (callbacks.length) {
          readyCalls = [];
          runCallbacks(callbacks);
        }
      }
    }
    /**
     * Sets the page as loaded.
     */
    function pageLoaded() {
      if (!isPageLoaded) {
        isPageLoaded = true;
        if (scrollIntervalId) {
          clearInterval(scrollIntervalId);
        }
        callReady();
      }
    }
    if (isBrowser) {
      if (document.addEventListener) {
        //Standards. Hooray! Assumption here that if standards based,
        //it knows about DOMContentLoaded.
        document.addEventListener('DOMContentLoaded', pageLoaded, false);
        window.addEventListener('load', pageLoaded, false);
      } else if (window.attachEvent) {
        window.attachEvent('onload', pageLoaded);
        testDiv = document.createElement('div');
        try {
          isTop = window.frameElement === null;
        } catch (e) {
        }
        //DOMContentLoaded approximation that uses a doScroll, as found by
        //Diego Perini: http://javascript.nwbox.com/IEContentLoaded/,
        //but modified by other contributors, including jdalton
        if (testDiv.doScroll && isTop && window.external) {
          scrollIntervalId = setInterval(function () {
            try {
              testDiv.doScroll();
              pageLoaded();
            } catch (e) {
            }
          }, 30);
        }
      }
      //Check if document already complete, and if so, just trigger page load
      //listeners. Latest webkit browsers also use "interactive", and
      //will fire the onDOMContentLoaded before "interactive" but not after
      //entering "interactive" or "complete". More details:
      //http://dev.w3.org/html5/spec/the-end.html#the-end
      //http://stackoverflow.com/questions/3665561/document-readystate-of-interactive-vs-ondomcontentloaded
      //Hmm, this is more complicated on further use, see "firing too early"
      //bug: https://github.com/requirejs/domReady/issues/1
      //so removing the || document.readyState === "interactive" test.
      //There is still a window.onload binding that should get fired if
      //DOMContentLoaded is missed.
      //PATCH START
      var noInteractive = doc.documentElement.doScroll, loaded = (noInteractive ? /^loaded|^c/ : /^loaded|^i|^c/).test(document.readyState);
      if (loaded) {
        pageLoaded();
      }  //PATCH END
    }
    /** START OF PUBLIC API **/
    /**
     * Registers a callback for DOM ready. If DOM is already ready, the
     * callback is called immediately.
     * @param {Function} callback
     */
    function domReady(callback) {
      if (isPageLoaded) {
        callback(doc);
      } else {
        readyCalls.push(callback);
      }
      return domReady;
    }
    domReady.version = '2.0.1';
    /**
     * Loader Plugin API method
     */
    domReady.load = function (name, req, onLoad, config) {
      if (config.isBuild) {
        onLoad(null);
      } else {
        domReady(onLoad);
      }
    };
    /** END OF PUBLIC API **/
    return domReady;
  }();
  synchronite_constants_strings = function () {
    var SYNCHRONITE_WIN_REF = '_$W';
    var strings = {
      // Proxy Parameters
      TARGET_FRAME: 'targetFrame',
      TARGET_PROTOCOL: 'targetProtocol',
      IS_SCRIPT: 'isScript',
      IS_IMAGE: 'isImage',
      IS_XHR: 'isXHR',
      IS_POPUP: 'ispopup',
      DISABLE_CACHE: 'disableCache',
      CACHE_KEY: 'cacheKey',
      PUBLISH: 'publish',
      NO_PROTOCOL_CHANGE: 'noProtocolChange',
      NO_PROXY: 'noProxy',
      LOCALE: 'locale',
      WINDOW_ID: '__cobrowseWindowId',
      // We use this to mark monitored windows
      DATA_ATTR_NO: 'data-no',
      PROP_CHANGE_MONITORED: 'changeMonitored',
      PROP_CLICK_MONITORED: 'cobrowse_cm',
      PROP_KEY_MONITORED: 'cobrowse_km',
      // Synchronite References
      SYNCHRONITE_WIN_REF: SYNCHRONITE_WIN_REF,
      SYNCHRONITE_OBJ_REF: SYNCHRONITE_WIN_REF + '.synch',
      // Window Identifiers
      SYNCHRONIZED_WINDOW: 'displayContent',
      // Servlet Paths
      AJAX_PATH: '/ajax',
      ACCESS_TOKEN_LOGIN_PATH: '/login/access_token'
    };
    return strings;
  }();
  synchronite_constants_constants = {
    defaultChannel: '/pl',
    serviceChannel: '/t/sn',
    cssProxySuffix: '/cssproxy',
    imgProxySuffix: '/imgproxy',
    fontProxySuffix: '/fontproxy',
    cobrowsingFrameName: 'displayContent',
    // storage keys
    ticketIdKey: 's.tid',
    cometReloadKey: 's.connect',
    userIdKey: 's.uid',
    skillId: 'skillId',
    sessionIdKey: 's.sid',
    usernameKey: 's.userName',
    sendStateKey: 'sendState',
    startTimestampKey: 's.startTS',
    type: 's.type',
    cobrowseActive: 's.cobrowseActive',
    isLocalAudioEnabledKey: 's.isLocalAudioEnabled',
    isLocalVideoEnabledKey: 's.isLocalCameraEnabled',
    defaultUsername: 'Visitor',
    CONFIG: {
      CALL_TYPE: {
        VOICE: 'voice',
        VIDEO: 'video'
      }
    },
    // event types
    EVENT: {
      DOM: 'dom',
      TEXTCONTENT: 'textcontent',
      STATE: 'state',
      MOUSE: 'mouse',
      UWSTATE: 'uwState',
      RESIZE: 'window:resize',
      SELECT: 'select',
      RESTRICTEDPAGE: 'restrictedPage',
      ELEMENTVALUE: 'elementvalue',
      KEYBOARD: 'keyboard',
      SCROLL: 'scroll',
      CANVAS: 'canvas',
      MOUSEMOVE: 'mousemove',
      FOCUS: 'focus',
      LOADING: 'loading',
      DUMMY: 'dummy',
      CSAT: 'csat',
      HEARTBEAT: 'heartbeat',
      SIGNAL: 'signal',
      REMOTESIGNAL: 'remoteSignal',
      LOCALSIGNAL: 'localSignal',
      CANSTARTCALL: 'canStartCall',
      STARTCALL: 'startCall',
      GAINEDMEDIAPERMISSIONS: 'gainedMediaPermissions',
      TURNCONFIG: 'turnConfig',
      TOGGLEVIDEO: 'videoToggle',
      TOGGLEAUDIO: 'audioToggle',
      ENDSESSION: 'endSession',
      NOCAMERAACCESS: 'noCameraAccess',
      FLIPCAMERA: 'flipCamera',
      TURNUSAGE: 'turnIsUsed',
      BROWSERNOTSUPPORTED: 'browserNotSupported',
      CONNECTIONLOST: 'connectionLost',
      RECEIVEDREMOTESTREAM: 'receivedRemoteStream',
      CALLDROPPED: 'callDropped',
      STOPCALLANDRESTART: 'stopCallAndRestart',
      TICKETEXPIRED: 'ticketExpired',
      GENERALCALLINITIALIZATIONERROR: 'generalCallInitializationError',
      CONSUMERJOINING: 'consumerJoining',
      DUPLICATECONSUMERDETECTED: 'duplicateConsumerDetected'
    },
    COMMAND: {
      REQUESTSTATE: 'requestState',
      REQUESTTURN: 'requestTurnConfig',
      TURNLOGGING: 'turnLogging',
      CLIENTSIDELOGGING: 'clientSideLogging'
    },
    ERROR: {
      UNABLETOCONNECT: 'UNABLE_TO_CONNECT',
      BROWSERNOTSUPPORTED: 'BROWSER_NOT_SUPPORTED',
      NOCAMERAACCESS: 'NO_CAMERA_ACCESS',
      AGENTDISCONNECTED: 'AGENT_DISCONNECTED',
      TICKETEXPIRED: 'TICKET_EXPIRED',
      INITIALIZATIONERROR: 'INITIALIZATION_ERROR',
      JOINEDFROMOTHERBROWSER: 'JOINED_FROM_OTHER_BROWSER'
    },
    LOGGING: {
      LEVEL: {
        ERROR: 'error',
        WARN: 'warn',
        INFO: 'info',
        DEBUG: 'debug',
        TRACE: 'trace'
      }
    },
    ERRORNUMBER: {
      // client signals
      UNABLE_TO_CONNECT: 1510,
      BROWSER_NOT_SUPPORTED: 1511,
      NO_CAMERA_ACCESS: 1512,
      AGENT_DISCONNECTED: 1513,
      NO_MICROPHONE_OR_ENUMERATION_BLOCKED: 1514,
      NO_CAMERA_OR_ENUMERATION_BLOCKED: 1515,
      // app initialization
      ERROR_INIT_UNABLE_TO_CREATE_UI_WHEN_FIRST_START: 1530,
      ERROR_RESUMING_SESSION_UNABLE_TO_CREATE_UI_ON_SLIDER_OPENED: 1531,
      ERROR_RESUMING_SESSION_UNABLE_TO_CREATE_UI_ON_ALREADY_FIRED_EVENTS: 1532,
      ERROR_INIT_UNIFIED_WINDOW_DID_NOT_LOAD: 1533,
      ERROR_INIT_I18N_UNABLE_TO_CHANGE_LANGUAGE: 1534,
      ERROR_INIT_I18N_UNABLE_TO_LOAD_LANGUAGE_NAMESPACES: 1535,
      ERROR_INIT_UNKNOWN_ERROR: 1536,
      ERROR_TICKET_ID_NOT_VALID: 1537,
      ERROR_VALIDATING_TICKET_ID: 1538,
      ERROR_TICKET_ID_NOT_FOUND: 1539,
      ERROR_ACCESSING_STORAGE: 1540,
      ERROR_ACCESSING_STORAGE_SEND_STATE: 1541,
      ERROR_ACCESSING_STORAGE_SESSION_ID: 1542,
      // simple-peer WebRTC errors
      UNKNOWN_SIMPLE_PEER_ERROR: 1700,
      SIMPLE_PEER_DEPENDENCY_ERROR: 1701,
      ERR_WEBRTC_SUPPORT: 1702,
      ERR_CREATE_OFFER: 1703,
      ERR_CREATE_ANSWER: 1704,
      ERR_SET_LOCAL_DESCRIPTION: 1705,
      ERR_SET_REMOTE_DESCRIPTION: 1706,
      ERR_ADD_ICE_CANDIDATE: 1707,
      ERR_ICE_CONNECTION_FAILURE: 1708,
      ERR_SIGNALING: 1709,
      ERR_DATA_CHANNEL: 1710,
      ERR_CONNECTION_FAILURE: 1711,
      ERR_PC_CONSTRUCTOR: 1712,
      ERR_ADD_TRANSCEIVER: 1713,
      ERR_SENDER_REMOVED: 1714,
      ERR_SENDER_ALREADY_ADDED: 1715,
      ERR_TRACK_NOT_ADDED: 1716,
      ERR_UNSUPPORTED_REPLACETRACK: 1717,
      ERR_REMOVE_TRACK: 1718,
      ERR_ICE_CONNECTION_CLOSED: 1719,
      // misc.
      ERROR_AUTOPLAY_REMOTE_VIDEO: 1570,
      SECOND_ERROR_AFTER_ATTEMPT_TO_PLAY_VIDEO: 1572,
      ERROR_SYNCHRONIZING_STREAM_TO_PEER: 1573,
      UNKNOWN_ERROR_SYNCHRONIZING_STREAM_TO_PEER: 1574,
      ERROR_THROWN_DURING_SIGNALING: 1575,
      UNKNOWN_ERROR_THROWN_DURING_SIGNALING: 1576,
      GET_STATS_ERROR: 1577,
      UNKNOWN_GET_STATS_ERROR: 1578,
      ERROR_AUTOPLAY_LOCAL_VIDEO: 1579,
      NO_REMOTE_AUDIO_TRACK: 1580,
      NO_LOCAL_AUDIO_TRACK: 1581,
      TOO_MANY_LOCAL_VIDEO_TRACKS: 1582,
      TOO_MANY_LOCAL_AUDIO_TRACKS: 1583,
      TOO_MANY_REMOTE_VIDEO_TRACKS: 1584,
      TOO_MANY_REMOTE_AUDIO_TRACKS: 1585,
      ERROR_AUTOPLAY_TIMEOUT: 1586,
      SEVERE_ERROR_AUTOPLAY_LOCAL_VIDEO: 1587,
      SEVERE_ERROR_AUTOPLAY_REMOTE_VIDEO: 1588,
      DEVICE_ENUMERATION_FAILED: 1589,
      CALL_RESTARTING: 1590,
      CALL_MAX_RESTARTS_EXHAUSTED: 1591
    }
  };
  dojo_has = function (require, module) {
    // module:
    //		dojo/has
    // summary:
    //		Defines the has.js API and several feature tests used by dojo.
    // description:
    //		This module defines the has API as described by the project has.js with the following additional features:
    //
    //		- the has test cache is exposed at has.cache.
    //		- the method has.add includes a forth parameter that controls whether or not existing tests are replaced
    //		- the loader's has cache may be optionally copied into this module's has cahce.
    //
    //		This module adopted from https://github.com/phiggins42/has.js; thanks has.js team!
    // try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one
    // if using a foreign loader, then the has cache may be initialized via the config object for this module
    // WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail
    var has = require.has || function () {
    };
    if (!false) {
      var isBrowser = // the most fundamental decision: are we in the browser?
        typeof window != 'undefined' && typeof location != 'undefined' && typeof document != 'undefined' && window.location == location && window.document == document,
        // has API variables
        global = function () {
          return this;
        }(), doc = isBrowser && document, element = doc && doc.createElement('DiV'), cache = module.config && module.config() || {};
      has = function (name) {
        // summary:
        //		Return the current value of the named feature.
        //
        // name: String|Integer
        //		The name (if a string) or identifier (if an integer) of the feature to test.
        //
        // description:
        //		Returns the value of the feature named by name. The feature must have been
        //		previously added to the cache by has.add.
        return typeof cache[name] == 'function' ? cache[name] = cache[name](global, doc, element) : cache[name];  // Boolean
      };
      has.cache = cache;
      has.add = function (name, test, now, force) {
        // summary:
        //	 	Register a new feature test for some named feature.
        // name: String|Integer
        //	 	The name (if a string) or identifier (if an integer) of the feature to test.
        // test: Function
        //		 A test function to register. If a function, queued for testing until actually
        //		 needed. The test function should return a boolean indicating
        //	 	the presence of a feature or bug.
        // now: Boolean?
        //		 Optional. Omit if `test` is not a function. Provides a way to immediately
        //		 run the test and cache the result.
        // force: Boolean?
        //	 	Optional. If the test already exists and force is truthy, then the existing
        //	 	test will be replaced; otherwise, add does not replace an existing test (that
        //	 	is, by default, the first test advice wins).
        // example:
        //		A redundant test, testFn with immediate execution:
        //	|	has.add("javascript", function(){ return true; }, true);
        //
        // example:
        //		Again with the redundantness. You can do this in your tests, but we should
        //		not be doing this in any internal has.js tests
        //	|	has.add("javascript", true);
        //
        // example:
        //		Three things are passed to the testFunction. `global`, `document`, and a generic element
        //		from which to work your test should the need arise.
        //	|	has.add("bug-byid", function(g, d, el){
        //	|		// g	== global, typically window, yadda yadda
        //	|		// d	== document object
        //	|		// el == the generic element. a `has` element.
        //	|		return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer
        //	|	});
        (typeof cache[name] == 'undefined' || force) && (cache[name] = test);
        return now && has(name);
      };
      // since we're operating under a loader that doesn't provide a has API, we must explicitly initialize
      // has as it would have otherwise been initialized by the dojo loader; use has.add to the builder
      // can optimize these away iff desired
      has.add('host-browser', isBrowser);
      has.add('host-node', typeof process == 'object' && process.versions && process.versions.node && process.versions.v8);
      has.add('host-rhino', typeof load == 'function' && (typeof Packages == 'function' || typeof Packages == 'object'));
      has.add('dom', isBrowser);
      has.add('dojo-dom-ready-api', 1);
      has.add('dojo-sniff', 1);
    }
    if (has('host-browser')) {
      // Common application level tests
      has.add('dom-addeventlistener', !!document.addEventListener);
      // Do the device and browser have touch capability?
      has.add('touch', 'ontouchstart' in document || 'onpointerdown' in document && navigator.maxTouchPoints > 0 || window.navigator.msMaxTouchPoints);
      // Touch events support
      has.add('touch-events', 'ontouchstart' in document);
      // Pointer Events support
      has.add('pointer-events', 'onpointerdown' in document && navigator.userAgent.toLowerCase().indexOf('firefox') === -1);
      // PATCHED Firefox does not fully support pointer events, e.g. CTRL + touch (click) does not work
      has.add('MSPointer', 'msMaxTouchPoints' in navigator);
      //IE10 (+IE11 preview)
      // I don't know if any of these tests are really correct, just a rough guess
      has.add('device-width', screen.availWidth || innerWidth);
      // Tests for DOMNode.attributes[] behavior:
      //	 - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes
      //	 - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify
      //	 - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.
      var form = document.createElement('form');
      has.add('dom-attributes-explicit', form.attributes.length == 0);
      // W3C
      has.add('dom-attributes-specified-flag', form.attributes.length > 0 && form.attributes.length < 40);  // IE8
    }
    has.clearElement = function (element) {
      // summary:
      //	 Deletes the contents of the element passed to test functions.
      element.innerHTML = '';
      return element;
    };
    has.normalize = function (id, toAbsMid) {
      // summary:
      //	 Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).
      //
      // toAbsMid: Function
      //	 Resolves a relative module id into an absolute module id
      var tokens = id.match(/[\?:]|[^:\?]*/g), i = 0, get = function (skip) {
          var term = tokens[i++];
          if (term == ':') {
            // empty string module name, resolves to 0
            return 0;
          } else {
            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
            if (tokens[i++] == '?') {
              if (!skip && has(term)) {
                // matched the feature, get the first value from the options
                return get();
              } else {
                // did not match, get the second value, passing over the first
                get(true);
                return get(skip);
              }
            }
            // a module
            return term || 0;
          }
        };
      id = get();
      return id && toAbsMid(id);
    };
    has.load = function (id, parentRequire, loaded) {
      // summary:
      //		Conditional loading of AMD modules based on a has feature test value.
      // id: String
      //		Gives the resolved module id to load.
      // parentRequire: Function
      //		The loader require function with respect to the module that contained the plugin resource in it's
      //		dependency list.
      // loaded: Function
      //	 Callback to loader that consumes result of plugin demand.
      if (id) {
        parentRequire([id], loaded);
      } else {
        loaded();
      }
    };
    return has;
  }({}, {});
  dojo__base_config = function (has, require) {
    // module:
    //		dojo/_base/config
    /*=====
    return {
    	// summary:
    	//		This module defines the user configuration during bootstrap.
    	// description:
    	//		By defining user configuration as a module value, an entire configuration can be specified in a build,
    	//		thereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.
    	//		Also, when multiple instances of dojo exist in a single application, each will necessarily be located
    	//		at an unique absolute module identifier as given by the package configuration. Implementing configuration
    	//		as a module allows for specifying unique, per-instance configurations.
    	// example:
    	//		Create a second instance of dojo with a different, instance-unique configuration (assume the loader and
    	//		dojo.js are already loaded).
    	//		|	// specify a configuration that creates a new instance of dojo at the absolute module identifier "myDojo"
    	//		|;
    	//		|
    	//		|	// specify a configuration for the myDojo instance
    	//		|	define("myDojo/config", {
    	//		|		// normal configuration variables go here, e.g.,
    	//		|		locale:"fr-ca"
    	//		|	});
    	//		|
    	//		|	// load and use the new instance of dojo
    	//		|	require(["myDojo"], function(dojo){
    	//		|		// dojo is the new instance of dojo
    	//		|		// use as required
    	//		|	});
    
    	// isDebug: Boolean
    	//		Defaults to `false`. If set to `true`, ensures that Dojo provides
    	//		extended debugging feedback via Firebug. If Firebug is not available
    	//		on your platform, setting `isDebug` to `true` will force Dojo to
    	//		pull in (and display) the version of Firebug Lite which is
    	//		integrated into the Dojo distribution, thereby always providing a
    	//		debugging/logging console when `isDebug` is enabled. Note that
    	//		Firebug's `console.*` methods are ALWAYS defined by Dojo. If
    	//		`isDebug` is false and you are on a platform without Firebug, these
    	//		methods will be defined as no-ops.
    	isDebug: false,
    
    	// locale: String
    	//		The locale to assume for loading localized resources in this page,
    	//		specified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
    	//		Must be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.
    	//		See the documentation for `dojo.i18n` and `dojo.requireLocalization`
    	//		for details on loading localized resources. If no locale is specified,
    	//		Dojo assumes the locale of the user agent, according to `navigator.userLanguage`
    	//		or `navigator.language` properties.
    	locale: undefined,
    
    	// extraLocale: Array
    	//		No default value. Specifies additional locales whose
    	//		resources should also be loaded alongside the default locale when
    	//		calls to `dojo.requireLocalization()` are processed.
    	extraLocale: undefined,
    
    	// baseUrl: String
    	//		The directory in which `dojo.js` is located. Under normal
    	//		conditions, Dojo auto-detects the correct location from which it
    	//		was loaded. You may need to manually configure `baseUrl` in cases
    	//		where you have renamed `dojo.js` or in which `<base>` tags confuse
    	//		some browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned
    	//		either the value of `djConfig.baseUrl` if one is provided or the
    	//		auto-detected root if not. Other modules are located relative to
    	//		this path. The path should end in a slash.
    	baseUrl: undefined,
    
    	// modulePaths: [deprecated] Object
    	//		A map of module names to paths relative to `dojo.baseUrl`. The
    	//		key/value pairs correspond directly to the arguments which
    	//		`dojo.registerModulePath` accepts. Specifying
    	//		`djConfig.modulePaths = { "foo": "../../bar" }` is the equivalent
    	//		of calling `dojo.registerModulePath("foo", "../../bar");`. Multiple
    	//		modules may be configured via `djConfig.modulePaths`.
    	modulePaths: {},
    
    	// addOnLoad: Function|Array
    	//		Adds a callback via dojo/ready. Useful when Dojo is added after
    	//		the page loads and djConfig.afterOnLoad is true. Supports the same
    	//		arguments as dojo/ready. When using a function reference, use
    	//		`djConfig.addOnLoad = function(){};`. For object with function name use
    	//		`djConfig.addOnLoad = [myObject, "functionName"];` and for object with
    	//		function reference use
    	//		`djConfig.addOnLoad = [myObject, function(){}];`
    	addOnLoad: null,
    
    	// parseOnLoad: Boolean
    	//		Run the parser after the page is loaded
    	parseOnLoad: false,
    
    	// require: String[]
    	//		An array of module names to be loaded immediately after dojo.js has been included
    	//		in a page.
    	require: [],
    
    	// defaultDuration: Number
    	//		Default duration, in milliseconds, for wipe and fade animations within dijits.
    	//		Assigned to dijit.defaultDuration.
    	defaultDuration: 200,
    
    	// dojoBlankHtmlUrl: String
    	//		Used by some modules to configure an empty iframe. Used by dojo/io/iframe and
    	//		dojo/back, and dijit/popup support in IE where an iframe is needed to make sure native
    	//		controls do not bleed through the popups. Normally this configuration variable
    	//		does not need to be set, except when using cross-domain/CDN Dojo builds.
    	//		Save dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`
    	//		to the path on your domain your copy of blank.html.
    	dojoBlankHtmlUrl: undefined,
    
    	// ioPublish: Boolean?
    	//		Set this to true to enable publishing of topics for the different phases of
    	//		IO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list
    	//		of topics that are published.
    	ioPublish: false,
    
    	// useCustomLogger: Anything?
    	//		If set to a value that evaluates to true such as a string or array and
    	//		isDebug is true and Firebug is not available or running, then it bypasses
    	//		the creation of Firebug Lite allowing you to define your own console object.
    	useCustomLogger: undefined,
    
    	// transparentColor: Array
    	//		Array containing the r, g, b components used as transparent color in dojo.Color;
    	//		if undefined, [255,255,255] (white) will be used.
    	transparentColor: undefined,
    
    	// deps: Function|Array
    	//		Defines dependencies to be used before the loader has been loaded.
    	//		When provided, they cause the loader to execute require(deps, callback)
    	//		once it has finished loading. Should be used with callback.
    	deps: undefined,
    
    	// callback: Function|Array
    	//		Defines a callback to be used when dependencies are defined before
    	//		the loader has been loaded. When provided, they cause the loader to
    	//		execute require(deps, callback) once it has finished loading.
    	//		Should be used with deps.
    	callback: undefined,
    
    	// deferredInstrumentation: Boolean
    	//		Whether deferred instrumentation should be loaded or included
    	//		in builds.
    	deferredInstrumentation: true,
    
    	// useDeferredInstrumentation: Boolean|String
    	//		Whether the deferred instrumentation should be used.
    	//
    	//		* `"report-rejections"`: report each rejection as it occurs.
    	//		* `true` or `1` or `"report-unhandled-rejections"`: wait 1 second
    	//			in an attempt to detect unhandled rejections.
    	useDeferredInstrumentation: "report-unhandled-rejections"
    };
    =====*/
    var result = {};
    if (has('dojo-config-api')) {
      // must be the dojo loader; take a shallow copy of require.rawConfig
      var src = require.rawConfig, p;
      for (p in src) {
        result[p] = src[p];
      }
    } else {
      var adviseHas = function (featureSet, prefix, booting) {
        for (p in featureSet) {
          p != 'has' && has.add(prefix + p, featureSet[p], 0, booting);
        }
      };
      var global = function () {
        return this;
      }();
      result = has('dojo-loader') ? // must be a built version of the dojo loader; all config stuffed in require.rawConfig
      require.rawConfig : // a foreign loader
      global.synchroniteConfig || global.dojoConfig || global.djConfig || {};
      // PATCHED until we can discard dojo config entirely
      adviseHas(result, 'config', 1);
      adviseHas(result.has, '', 1);
    }
    if (!result.locale && typeof navigator != 'undefined') {
      // Default locale for browsers.
      var language = navigator.language || navigator.userLanguage;
      if (language) {
        result.locale = language.toLowerCase();
      }
    }
    return result;
  }(dojo_has, {});
  dojo__base_kernel = function (has, config, require, module) {
    // module:
    //		dojo/_base/kernel
    // This module is the foundational module of the dojo boot sequence; it defines the dojo object.
    var
      // loop variables for this module
      i, p,
      // create dojo, dijit, and dojox
      // FIXME: in 2.0 remove dijit, dojox being created by dojo
      global = function () {
        return this;
      }(), dijit = {}, dojox = {}, dojo = {
        // summary:
        //		This module is the foundational module of the dojo boot sequence; it defines the dojo object.
        // notice dojo takes ownership of the value of the config module
        config: config,
        global: global,
        dijit: dijit,
        dojox: dojox
      };
    // Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide
    // a _scopeName property for the dojo, dijit, and dojox root object so those packages can create
    // unique names in the global space.
    //
    // Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,
    // where global when in fact they are either global under different names or not global at all. In v1.6-, the
    // config variable "scopeMap" was used to map names as used within a module to global names. This has been
    // subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,
    // only the "*" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.
    //
    // The following computations contort the packageMap for this dojo instance into a scopeMap.
    var scopeMap = // a map from a name used in a legacy module to the (global variable name, object addressed by that name)
      // always map dojo, dijit, and dojox
      {
        dojo: [
          'dojo',
          dojo
        ],
        dijit: [
          'dijit',
          dijit
        ],
        dojox: [
          'dojox',
          dojox
        ]
      }, packageMap = require.map && require.map[module.id.match(/[^\/]+/)[0]], item;
    // process all mapped top-level names for this instance of dojo
    for (p in packageMap) {
      if (scopeMap[p]) {
        // mapped dojo, dijit, or dojox
        scopeMap[p][0] = packageMap[p];
      } else {
        // some other top-level name
        scopeMap[p] = [
          packageMap[p],
          {}
        ];
      }
    }
    // publish those names to _scopeName and, optionally, the global namespace
    for (p in scopeMap) {
      item = scopeMap[p];
      item[1]._scopeName = item[0];
      if (!config.noGlobals) {
        global[item[0]] = item[1];
      }
    }
    dojo.scopeMap = scopeMap;
    /*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/
    // FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated
    dojo.baseUrl = dojo.config.baseUrl = require.baseUrl;
    dojo.isAsync = !has('dojo-loader') || require.async;
    dojo.locale = config.locale;
    var rev = '$Rev: ae6be82 $'.match(/[0-9a-f]{7,}/);
    dojo.version = {
      // summary:
      //		Version number of the Dojo Toolkit
      // description:
      //		Hash about the version, including
      //
      //		- major: Integer: Major version. If total version is "1.2.0beta1", will be 1
      //		- minor: Integer: Minor version. If total version is "1.2.0beta1", will be 2
      //		- patch: Integer: Patch version. If total version is "1.2.0beta1", will be 0
      //		- flag: String: Descriptor flag. If total version is "1.2.0beta1", will be "beta1"
      //		- revision: Number: The Git rev from which dojo was pulled
      major: 1,
      minor: 10,
      patch: 3,
      flag: '',
      revision: rev ? rev[0] : NaN,
      toString: function () {
        var v = dojo.version;
        return v.major + '.' + v.minor + '.' + v.patch + v.flag + ' (' + v.revision + ')';  // String
      }
    };
    // If has("extend-dojo") is truthy, then as a dojo module is defined it should push it's definitions
    // into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object
    // as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code
    // is migrated. Absent specific advice otherwise, set extend-dojo to truthy.
    has.add('extend-dojo', 1);
    // PATCHED (Function("d", "d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}"))(dojo);
    /*=====
    	dojo.eval = function(scriptText){
    		// summary:
    		//		A legacy method created for use exclusively by internal Dojo methods. Do not use this method
    		//		directly unless you understand its possibly-different implications on the platforms your are targeting.
    		// description:
    		//		Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers
    		//		that support indirect eval.
    		//
    		//		As usual, IE does not. On IE, the only way to implement global eval is to
    		//		use execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.
    		//		This implementation uses the technique of executing eval in the scope of a function that is a single scope
    		//		frame below the global scope; thereby coming close to the global scope. Note carefully that
    		//
    		//		dojo.eval("var pi = 3.14;");
    		//
    		//		will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want
    		//		to define a global variable using dojo.eval, write something like
    		//
    		//		dojo.eval("window.pi = 3.14;")
    		// scriptText:
    		//		The text to evaluation.
    		// returns:
    		//		The result of the evaluation. Often `undefined`
    	};
    	=====*/
    if (false) {
      dojo.exit = function (exitcode) {
        quit(exitcode);
      };
    } else {
      dojo.exit = function () {
      };
    }
    has.add('dojo-guarantee-console', // ensure that console.log, console.warn, etc. are defined
    1);
    if (has('dojo-guarantee-console')) {
      typeof console != 'undefined' || (console = {});
      //	Be careful to leave 'log' always at the end
      var cn = [
        'assert',
        'count',
        'debug',
        'dir',
        'dirxml',
        'error',
        'group',
        'groupEnd',
        'info',
        'profile',
        'profileEnd',
        'time',
        'timeEnd',
        'trace',
        'warn',
        'log'
      ];
      var tn;
      i = 0;
      while (tn = cn[i++]) {
        if (!console[tn]) {
          (function () {
            var tcn = tn + '';
            console[tcn] = 'log' in console ? function () {
              var a = Array.prototype.slice.call(arguments);
              a.unshift(tcn + ':');
              console['log'](a.join(' '));
            } : function () {
            };
            console[tcn]._fake = true;
          }());
        }
      }
    }
    has.add('dojo-debug-messages', // include dojo.deprecated/dojo.experimental implementations
    !!config.isDebug);
    dojo.deprecated = dojo.experimental = function () {
    };
    if (false) {
      dojo.deprecated = function (behaviour, extra, removal) {
        // summary:
        //		Log a debug message to indicate that a behavior has been
        //		deprecated.
        // behaviour: String
        //		The API or behavior being deprecated. Usually in the form
        //		of "myApp.someFunction()".
        // extra: String?
        //		Text to append to the message. Often provides advice on a
        //		new function or facility to achieve the same goal during
        //		the deprecation period.
        // removal: String?
        //		Text to indicate when in the future the behavior will be
        //		removed. Usually a version number.
        // example:
        //	| dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");
        var message = 'DEPRECATED: ' + behaviour;
        if (extra) {
          message += ' ' + extra;
        }
        if (removal) {
          message += ' -- will be removed in version: ' + removal;
        }
        console.warn(message);
      };
      dojo.experimental = function (moduleName, extra) {
        // summary:
        //		Marks code as experimental.
        // description:
        //		This can be used to mark a function, file, or module as
        //		experimental.	 Experimental code is not ready to be used, and the
        //		APIs are subject to change without notice.	Experimental code may be
        //		completed deleted without going through the normal deprecation
        //		process.
        // moduleName: String
        //		The name of a module, or the name of a module file or a specific
        //		function
        // extra: String?
        //		some additional message for the user
        // example:
        //	| dojo.experimental("dojo.data.Result");
        // example:
        //	| dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");
        var message = 'EXPERIMENTAL: ' + moduleName + ' -- APIs subject to change without notice.';
        if (extra) {
          message += ' ' + extra;
        }
        console.warn(message);
      };
    }
    has.add('dojo-modulePaths', // consume dojo.modulePaths processing
    1);
    if (false) {
      // notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;
      // this is the v1.6- behavior.
      if (config.modulePaths) {
        dojo.deprecated('dojo.modulePaths', 'use paths configuration');
        var paths = {};
        for (p in config.modulePaths) {
          paths[p.replace(/\./g, '/')] = config.modulePaths[p];
        }
      }
    }
    has.add('dojo-moduleUrl', // include dojo.moduleUrl
    1);
    if (false) {
      dojo.moduleUrl = function (module, url) {
        // summary:
        //		Returns a URL relative to a module.
        // example:
        //	|	var pngPath = dojo.moduleUrl("acme","images/small.png");
        //	|	console.dir(pngPath); // list the object properties
        //	|	// create an image and set it's source to pngPath's value:
        //	|	var img = document.createElement("img");
        //	|	img.src = pngPath;
        //	|	// add our image to the document
        //	|	dojo.body().appendChild(img);
        // example:
        //		you may de-reference as far as you like down the package
        //		hierarchy.  This is sometimes handy to avoid lengthy relative
        //		urls or for building portable sub-packages. In this example,
        //		the `acme.widget` and `acme.util` directories may be located
        //		under different roots (see `dojo.registerModulePath`) but the
        //		the modules which reference them can be unaware of their
        //		relative locations on the filesystem:
        //	|	// somewhere in a configuration block
        //	|	dojo.registerModulePath("acme.widget", "../../acme/widget");
        //	|	dojo.registerModulePath("acme.util", "../../util");
        //	|
        //	|	// ...
        //	|
        //	|	// code in a module using acme resources
        //	|	var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
        //	|	var dataPath = dojo.moduleUrl("acme.util","resources/data.json");
        dojo.deprecated('dojo.moduleUrl()', 'use require.toUrl', '2.0');
        // require.toUrl requires a filetype; therefore, just append the suffix "/*.*" to guarantee a filetype, then
        // remove the suffix from the result. This way clients can request a url w/out a filetype. This should be
        // rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).
        // Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.
        var result = null;
        if (module) {
          result = require.toUrl(module.replace(/\./g, '/') + (url ? '/' + url : '') + '/*.*').replace(/\/\*\.\*/, '') + (url ? '' : '/');
        }
        return result;
      };
    }
    dojo._hasResource = {};
    // for backward compatibility with layers built with 1.6 tooling
    return dojo;
  }(dojo_has, dojo__base_config, {}, {});
  dojo_sniff = function (has) {
    // module:
    //		dojo/sniff
    /*=====
    	return function(){
    		// summary:
    		//		This module sets has() flags based on the current browser.
    		//		It returns the has() function.
    	};
    	=====*/
    if (has('host-browser')) {
      var n = navigator, dua = n.userAgent, dav = n.appVersion, tv = parseFloat(dav);
      has.add('air', dua.indexOf('AdobeAIR') >= 0);
      has.add('msapp', parseFloat(dua.split('MSAppHost/')[1]) || undefined);
      has.add('khtml', dav.indexOf('Konqueror') >= 0 ? tv : undefined);
      has.add('webkit', parseFloat(dua.split('WebKit/')[1]) || undefined);
      has.add('chrome', parseFloat(dua.split('Chrome/')[1]) || undefined);
      has.add('safari', dav.indexOf('Safari') >= 0 && !has('chrome') ? parseFloat(dav.split('Version/')[1]) : undefined);
      has.add('mac', dav.indexOf('Macintosh') >= 0);
      has.add('quirks', document.compatMode == 'BackCompat');
      if (dua.match(/(iPhone|iPod|iPad)/)) {
        var p = RegExp.$1.replace(/P/, 'p');
        var v = dua.match(/OS ([\d_]+)/) ? RegExp.$1 : '1';
        var os = parseFloat(v.replace(/_/, '.').replace(/_/g, ''));
        has.add(p, os);
        // "iphone", "ipad" or "ipod"
        has.add('ios', os);
      }
      has.add('android', parseFloat(dua.split('Android ')[1]) || undefined);
      has.add('bb', (dua.indexOf('BlackBerry') >= 0 || dua.indexOf('BB10') >= 0) && parseFloat(dua.split('Version/')[1]) || undefined);
      has.add('trident', parseFloat(dav.split('Trident/')[1]) || undefined);
      has.add('svg', typeof SVGAngle !== 'undefined');
      if (!has('webkit')) {
        // Opera
        if (dua.indexOf('Opera') >= 0) {
          // see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/
          // 9.8 has both styles; <9.8, 9.9 only old style
          has.add('opera', tv >= 9.8 ? parseFloat(dua.split('Version/')[1]) || tv : tv);
        }
        // Mozilla and firefox
        if (dua.indexOf('Gecko') >= 0 && !has('khtml') && !has('webkit') && !has('trident')) {
          has.add('mozilla', tv);
        }
        if (has('mozilla')) {
          //We really need to get away from this. Consider a sane isGecko approach for the future.
          has.add('ff', parseFloat(dua.split('Firefox/')[1] || dua.split('Minefield/')[1]) || undefined);
        }
        // IE
        if (document.all && !has('opera')) {
          var isIE = parseFloat(dav.split('MSIE ')[1]) || undefined;
          //In cases where the page has an HTTP header or META tag with
          //X-UA-Compatible, then it is in emulation mode.
          //Make sure isIE reflects the desired version.
          //document.documentMode of 5 means quirks mode.
          //Only switch the value if documentMode's major version
          //is different from isIE's major version.
          var mode = document.documentMode;
          if (mode && mode != 5 && Math.floor(isIE) != mode) {
            isIE = mode;
          }
          has.add('ie', isIE);
        }
        // Wii
        has.add('wii', typeof opera != 'undefined' && opera.wiiremote);
      }
    }
    return has;
  }(dojo_has);
  dojo__base_lang = function (dojo, has) {
    // module:
    //		dojo/_base/lang
    has.add('bug-for-in-skips-shadowed', function () {
      // if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)
      for (var i in { toString: 1 }) {
        return 0;
      }
      return 1;
    });
    // Helper methods
    var _extraNames = has('bug-for-in-skips-shadowed') ? 'hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor'.split('.') : [], _extraLen = _extraNames.length, getProp = function (parts, create, context) {
        if (!context) {
          if (parts[0] && dojo.scopeMap[parts[0]]) {
            // Voodoo code from the old days where "dojo" or "dijit" maps to some special object
            // rather than just window.dojo
            context = dojo.scopeMap[parts.shift()][1];
          } else {
            context = dojo.global;
          }
        }
        try {
          for (var i = 0; i < parts.length; i++) {
            var p = parts[i];
            if (!(p in context)) {
              if (create) {
                context[p] = {};
              } else {
                return;  // return undefined
              }
            }
            context = context[p];
          }
          return context;  // mixed
        } catch (e) {
        }
      }, opts = Object.prototype.toString, efficient = function (obj, offset, startWith) {
        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));
      }, _pattern = /\{([^\}]+)\}/g;
    // Module export
    var lang = {
      // summary:
      //		This module defines Javascript language extensions.
      // _extraNames: String[]
      //		Lists property names that must be explicitly processed during for-in iteration
      //		in environments that have has("bug-for-in-skips-shadowed") true.
      _extraNames: _extraNames,
      _mixin: function (dest, source, copyFunc) {
        // summary:
        //		Copies/adds all properties of source to dest; returns dest.
        // dest: Object
        //		The object to which to copy/add all properties contained in source.
        // source: Object
        //		The object from which to draw all properties to copy into dest.
        // copyFunc: Function?
        //		The process used to copy/add a property in source; defaults to the Javascript assignment operator.
        // returns:
        //		dest, as modified
        // description:
        //		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
        //		found in Object.prototype, are copied/added to dest. Copying/adding each particular property is
        //		delegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.
        //		Notice that by default, _mixin executes a so-called "shallow copy" and aggregate types are copied/added by reference.
        var name, s, i, empty = {};
        for (name in source) {
          // the (!(name in empty) || empty[name] !== s) condition avoids copying properties in "source"
          // inherited from Object.prototype.	 For example, if dest has a custom toString() method,
          // don't overwrite it with the toString() method that source inherited from Object.prototype
          s = source[name];
          if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
            dest[name] = copyFunc ? copyFunc(s) : s;
          }
        }
        if (has('bug-for-in-skips-shadowed')) {
          if (source) {
            for (i = 0; i < _extraLen; ++i) {
              name = _extraNames[i];
              s = source[name];
              if (!(name in dest) || dest[name] !== s && (!(name in empty) || empty[name] !== s)) {
                dest[name] = copyFunc ? copyFunc(s) : s;
              }
            }
          }
        }
        return dest;  // Object
      },
      mixin: function (dest, sources) {
        // summary:
        //		Copies/adds all properties of one or more sources to dest; returns dest.
        // dest: Object
        //		The object to which to copy/add all properties contained in source. If dest is falsy, then
        //		a new object is manufactured before copying/adding properties begins.
        // sources: Object...
        //		One of more objects from which to draw all properties to copy into dest. sources are processed
        //		left-to-right and if more than one of these objects contain the same property name, the right-most
        //		value "wins".
        // returns: Object
        //		dest, as modified
        // description:
        //		All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
        //		found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
        //		The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
        //		executes a so-called "shallow copy" and aggregate types are copied/added by reference.
        // example:
        //		make a shallow copy of an object
        //	|	var copy = lang.mixin({}, source);
        // example:
        //		many class constructors often take an object which specifies
        //		values to be configured on the object. In this case, it is
        //		often simplest to call `lang.mixin` on the `this` object:
        //	|	declare("acme.Base", null, {
        //	|		constructor: function(properties){
        //	|			// property configuration:
        //	|			lang.mixin(this, properties);
        //	|
        //	|			console.log(this.quip);
        //	|			//	...
        //	|		},
        //	|		quip: "I wasn't born yesterday, you know - I've seen movies.",
        //	|		// ...
        //	|	});
        //	|
        //	|	// create an instance of the class and configure it
        //	|	var b = new acme.Base({quip: "That's what it does!" });
        // example:
        //		copy in properties from multiple objects
        //	|	var flattened = lang.mixin(
        //	|		{
        //	|			name: "Frylock",
        //	|			braces: true
        //	|		},
        //	|		{
        //	|			name: "Carl Brutanananadilewski"
        //	|		}
        //	|	);
        //	|
        //	|	// will print "Carl Brutanananadilewski"
        //	|	console.log(flattened.name);
        //	|	// will print "true"
        //	|	console.log(flattened.braces);
        if (!dest) {
          dest = {};
        }
        for (var i = 1, l = arguments.length; i < l; i++) {
          lang._mixin(dest, arguments[i]);
        }
        return dest;  // Object
      },
      setObject: function (name, value, context) {
        // summary:
        //		Set a property from a dot-separated string, such as "A.B.C"
        // description:
        //		Useful for longer api chains where you have to test each object in
        //		the chain, or when you have an object reference in string format.
        //		Objects are created as needed along `path`. Returns the passed
        //		value if setting is successful or `undefined` if not.
        // name: String
        //		Path to a property, in the form "A.B.C".
        // value: anything
        //		value or object to place at location given by name
        // context: Object?
        //		Optional. Object to use as root of path. Defaults to
        //		`dojo.global`.
        // example:
        //		set the value of `foo.bar.baz`, regardless of whether
        //		intermediate objects already exist:
        //	| lang.setObject("foo.bar.baz", value);
        // example:
        //		without `lang.setObject`, we often see code like this:
        //	| // ensure that intermediate objects are available
        //	| if(!obj["parent"]){ obj.parent = {}; }
        //	| if(!obj.parent["child"]){ obj.parent.child = {}; }
        //	| // now we can safely set the property
        //	| obj.parent.child.prop = "some value";
        //		whereas with `lang.setObject`, we can shorten that to:
        //	| lang.setObject("parent.child.prop", "some value", obj);
        var parts = name.split('.'), p = parts.pop(), obj = getProp(parts, true, context);
        return obj && p ? obj[p] = value : undefined;  // Object
      },
      getObject: function (name, create, context) {
        // summary:
        //		Get a property from a dot-separated string, such as "A.B.C"
        // description:
        //		Useful for longer api chains where you have to test each object in
        //		the chain, or when you have an object reference in string format.
        // name: String
        //		Path to an property, in the form "A.B.C".
        // create: Boolean?
        //		Optional. Defaults to `false`. If `true`, Objects will be
        //		created at any point along the 'path' that is undefined.
        // context: Object?
        //		Optional. Object to use as root of path. Defaults to
        //		'dojo.global'. Null may be passed.
        return getProp(name ? name.split('.') : [], create, context);  // Object
      },
      exists: function (name, obj) {
        // summary:
        //		determine if an object supports a given method
        // description:
        //		useful for longer api chains where you have to test each object in
        //		the chain. Useful for object and method detection.
        // name: String
        //		Path to an object, in the form "A.B.C".
        // obj: Object?
        //		Object to use as root of path. Defaults to
        //		'dojo.global'. Null may be passed.
        // example:
        //	| // define an object
        //	| var foo = {
        //	|		bar: { }
        //	| };
        //	|
        //	| // search the global scope
        //	| lang.exists("foo.bar"); // true
        //	| lang.exists("foo.bar.baz"); // false
        //	|
        //	| // search from a particular scope
        //	| lang.exists("bar", foo); // true
        //	| lang.exists("bar.baz", foo); // false
        return lang.getObject(name, false, obj) !== undefined;  // Boolean
      },
      // Crockford (ish) functions
      isString: function (it) {
        // summary:
        //		Return true if it is a String
        // it: anything
        //		Item to test.
        return typeof it == 'string' || it instanceof String;  // Boolean
      },
      isArray: function (it) {
        // summary:
        //		Return true if it is an Array.
        //		Does not work on Arrays created in other windows.
        // it: anything
        //		Item to test.
        return it && (it instanceof Array || typeof it == 'array');  // Boolean
      },
      isFunction: function (it) {
        // summary:
        //		Return true if it is a Function
        // it: anything
        //		Item to test.
        return opts.call(it) === '[object Function]';
      },
      isObject: function (it) {
        // summary:
        //		Returns true if it is a JavaScript object (or an Array, a Function
        //		or null)
        // it: anything
        //		Item to test.
        return it !== undefined && (it === null || typeof it == 'object' || lang.isArray(it) || lang.isFunction(it));  // Boolean
      },
      isArrayLike: function (it) {
        // summary:
        //		similar to isArray() but more permissive
        // it: anything
        //		Item to test.
        // returns:
        //		If it walks like a duck and quacks like a duck, return `true`
        // description:
        //		Doesn't strongly test for "arrayness".  Instead, settles for "isn't
        //		a string or number and has a length property". Arguments objects
        //		and DOM collections will return true when passed to
        //		isArrayLike(), but will return false when passed to
        //		isArray().
        return it && it !== undefined && // Boolean
        // keep out built-in constructors (Number, String, ...) which have length
        // properties
        !lang.isString(it) && !lang.isFunction(it) && !(it.tagName && it.tagName.toLowerCase() == 'form') && (lang.isArray(it) || isFinite(it.length));
      },
      isAlien: function (it) {
        // summary:
        //		Returns true if it is a built-in function or some other kind of
        //		oddball that *should* report as a function but doesn't
        return it && !lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it));  // Boolean
      },
      extend: function (ctor, props) {
        // summary:
        //		Adds all properties and methods of props to constructor's
        //		prototype, making them available to all instances created with
        //		constructor.
        // ctor: Object
        //		Target constructor to extend.
        // props: Object
        //		One or more objects to mix into ctor.prototype
        for (var i = 1, l = arguments.length; i < l; i++) {
          lang._mixin(ctor.prototype, arguments[i]);
        }
        return ctor;  // Object
      },
      _hitchArgs: function (scope, method) {
        var pre = lang._toArray(arguments, 2);
        var named = lang.isString(method);
        return function () {
          // arrayify arguments
          var args = lang._toArray(arguments);
          // locate our method
          var f = named ? (scope || dojo.global)[method] : method;
          // invoke with collected args
          return f && f.apply(scope || this, pre.concat(args));  // mixed
        };  // Function
      },
      hitch: function (scope, method) {
        // summary:
        //		Returns a function that will only ever execute in the given scope.
        //		This allows for easy use of object member functions
        //		in callbacks and other places in which the "this" keyword may
        //		otherwise not reference the expected scope.
        //		Any number of default positional arguments may be passed as parameters
        //		beyond "method".
        //		Each of these values will be used to "placehold" (similar to curry)
        //		for the hitched function.
        // scope: Object
        //		The scope to use when method executes. If method is a string,
        //		scope is also the object containing method.
        // method: Function|String...
        //		A function to be hitched to scope, or the name of the method in
        //		scope to be hitched.
        // example:
        //	|	lang.hitch(foo, "bar")();
        //		runs foo.bar() in the scope of foo
        // example:
        //	|	lang.hitch(foo, myFunction);
        //		returns a function that runs myFunction in the scope of foo
        // example:
        //		Expansion on the default positional arguments passed along from
        //		hitch. Passed args are mixed first, additional args after.
        //	|	var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
        //	|	var fn = lang.hitch(foo, "bar", 1, 2);
        //	|	fn(3); // logs "1, 2, 3"
        // example:
        //	|	var foo = { bar: 2 };
        //	|	lang.hitch(foo, function(){ this.bar = 10; })();
        //		execute an anonymous function in scope of foo
        if (arguments.length > 2) {
          return lang._hitchArgs.apply(dojo, arguments);  // Function
        }
        if (!method) {
          method = scope;
          scope = null;
        }
        if (lang.isString(method)) {
          scope = scope || dojo.global;
          if (!scope[method]) {
            throw [
              'lang.hitch: scope["',
              method,
              '"] is null (scope="',
              scope,
              '")'
            ].join('');
          }
          return function () {
            return scope[method].apply(scope, arguments || []);
          };  // Function
        }
        return !scope ? method : function () {
          return method.apply(scope, arguments || []);
        };  // Function
      },
      delegate: function () {
        // boodman/crockford delegation w/ cornford optimization
        function TMP() {
        }
        return function (obj, props) {
          TMP.prototype = obj;
          var tmp = new TMP();
          TMP.prototype = null;
          if (props) {
            lang._mixin(tmp, props);
          }
          return tmp;  // Object
        };
      }(),
      /*=====
      delegate: function(obj, props){
      	// summary:
      	//		Returns a new object which "looks" to obj for properties which it
      	//		does not have a value for. Optionally takes a bag of properties to
      	//		seed the returned object with initially.
      	// description:
      	//		This is a small implementation of the Boodman/Crockford delegation
      	//		pattern in JavaScript. An intermediate object constructor mediates
      	//		the prototype chain for the returned object, using it to delegate
      	//		down to obj for property lookup when object-local lookup fails.
      	//		This can be thought of similarly to ES4's "wrap", save that it does
      	//		not act on types but rather on pure objects.
      	// obj: Object
      	//		The object to delegate to for properties not found directly on the
      	//		return object or in props.
      	// props: Object...
      	//		an object containing properties to assign to the returned object
      	// returns:
      	//		an Object of anonymous type
      	// example:
      	//	|	var foo = { bar: "baz" };
      	//	|	var thinger = lang.delegate(foo, { thud: "xyzzy"});
      	//	|	thinger.bar == "baz"; // delegated to foo
      	//	|	foo.thud == undefined; // by definition
      	//	|	thinger.thud == "xyzzy"; // mixed in from props
      	//	|	foo.bar = "thonk";
      	//	|	thinger.bar == "thonk"; // still delegated to foo's bar
      },
      =====*/
      _toArray: has('ie') ? function () {
        function slow(obj, offset, startWith) {
          var arr = startWith || [];
          for (var x = offset || 0; x < obj.length; x++) {
            arr.push(obj[x]);
          }
          return arr;
        }
        return function (obj) {
          return (obj.item ? slow : efficient).apply(this, arguments);
        };
      }() : efficient,
      /*=====
       _toArray: function(obj, offset, startWith){
      	 // summary:
      	 //		Converts an array-like object (i.e. arguments, DOMCollection) to an
      	 //		array. Returns a new Array with the elements of obj.
      	 // obj: Object
      	 //		the object to "arrayify". We expect the object to have, at a
      	 //		minimum, a length property which corresponds to integer-indexed
      	 //		properties.
      	 // offset: Number?
      	 //		the location in obj to start iterating from. Defaults to 0.
      	 //		Optional.
      	 // startWith: Array?
      	 //		An array to pack with the properties of obj. If provided,
      	 //		properties in obj are appended at the end of startWith and
      	 //		startWith is the returned array.
       },
       =====*/
      partial: function (method) {
        // summary:
        //		similar to hitch() except that the scope object is left to be
        //		whatever the execution context eventually becomes.
        // description:
        //		Calling lang.partial is the functional equivalent of calling:
        //		|	lang.hitch(null, funcName, ...);
        // method:
        //		The function to "wrap"
        var arr = [null];
        return lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments)));  // Function
      },
      clone: function (src) {
        // summary:
        //		Clones objects (including DOM nodes) and all children.
        //		Warning: do not clone cyclic structures.
        // src:
        //		The object to clone
        if (!src || typeof src != 'object' || lang.isFunction(src)) {
          // null, undefined, any non-object, or function
          return src;  // anything
        }
        if (src.nodeType && 'cloneNode' in src) {
          // DOM Node
          return src.cloneNode(true);  // Node
        }
        if (src instanceof Date) {
          // Date
          return new Date(src.getTime());  // Date
        }
        if (src instanceof RegExp) {
          // RegExp
          return new RegExp(src);  // RegExp
        }
        var r, i, l;
        if (lang.isArray(src)) {
          // array
          r = [];
          for (i = 0, l = src.length; i < l; ++i) {
            if (i in src) {
              r.push(lang.clone(src[i]));
            }
          }  // we don't clone functions for performance reasons
             //		}else if(d.isFunction(src)){
             //			// function
             //			r = function(){ return src.apply(this, arguments); };
        } else {
          // generic objects
          r = src.constructor ? new src.constructor() : {};
        }
        return lang._mixin(r, src, lang.clone);
      },
      trim: String.prototype.trim ? function (str) {
        return str.trim();
      } : function (str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
      },
      /*=====
       trim: function(str){
      	 // summary:
      	 //		Trims whitespace from both sides of the string
      	 // str: String
      	 //		String to be trimmed
      	 // returns: String
      	 //		Returns the trimmed string
      	 // description:
      	 //		This version of trim() was selected for inclusion into the base due
      	 //		to its compact size and relatively good performance
      	 //		(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
      	 //		Uses String.prototype.trim instead, if available.
      	 //		The fastest but longest version of this function is located at
      	 //		lang.string.trim()
       },
       =====*/
      replace: function (tmpl, map, pattern) {
        // summary:
        //		Performs parameterized substitutions on a string. Throws an
        //		exception if any parameter is unmatched.
        // tmpl: String
        //		String to be used as a template.
        // map: Object|Function
        //		If an object, it is used as a dictionary to look up substitutions.
        //		If a function, it is called for every substitution with following parameters:
        //		a whole match, a name, an offset, and the whole template
        //		string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
        //		for more details).
        // pattern: RegEx?
        //		Optional regular expression objects that overrides the default pattern.
        //		Must be global and match one item. The default is: /\{([^\}]+)\}/g,
        //		which matches patterns like that: "{xxx}", where "xxx" is any sequence
        //		of characters, which doesn't include "}".
        // returns: String
        //		Returns the substituted string.
        // example:
        //	|	// uses a dictionary for substitutions:
        //	|	lang.replace("Hello, {name.first} {name.last} AKA {nick}!",
        //	|		{
        //	|			nick: "Bob",
        //	|			name: {
        //	|				first:	"Robert",
        //	|				middle: "X",
        //	|				last:		"Cringely"
        //	|			}
        //	|		});
        //	|	// returns: Hello, Robert Cringely AKA Bob!
        // example:
        //	|	// uses an array for substitutions:
        //	|	lang.replace("Hello, {0} {2}!",
        //	|		["Robert", "X", "Cringely"]);
        //	|	// returns: Hello, Robert Cringely!
        // example:
        //	|	// uses a function for substitutions:
        //	|	function sum(a){
        //	|		var t = 0;
        //	|		arrayforEach(a, function(x){ t += x; });
        //	|		return t;
        //	|	}
        //	|	lang.replace(
        //	|		"{count} payments averaging {avg} USD per payment.",
        //	|		lang.hitch(
        //	|			{ payments: [11, 16, 12] },
        //	|			function(_, key){
        //	|				switch(key){
        //	|					case "count": return this.payments.length;
        //	|					case "min":		return Math.min.apply(Math, this.payments);
        //	|					case "max":		return Math.max.apply(Math, this.payments);
        //	|					case "sum":		return sum(this.payments);
        //	|					case "avg":		return sum(this.payments) / this.payments.length;
        //	|				}
        //	|			}
        //	|		)
        //	|	);
        //	|	// prints: 3 payments averaging 13 USD per payment.
        // example:
        //	|	// uses an alternative PHP-like pattern for substitutions:
        //	|	lang.replace("Hello, ${0} ${2}!",
        //	|		["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
        //	|	// returns: Hello, Robert Cringely!
        return tmpl.replace(pattern || _pattern, lang.isFunction(map) ? map : function (_, k) {
          return lang.getObject(k, false, map);
        });
      }
    };
    has('extend-dojo') && lang.mixin(dojo, lang);
    return lang;
  }(dojo__base_kernel, dojo_has);
  dojo_string = function (kernel, lang) {
    // module:
    //		dojo/string
    var ESCAPE_REGEXP = /[&<>'"\/]/g;
    var ESCAPE_MAP = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      '\'': '&#x27;',
      '/': '&#x2F;'
    };
    var string = {};
    lang.setObject('dojo.string', string);
    string.escape = function (str) {
      // summary:
      //		Efficiently escape a string for insertion into HTML (innerHTML or attributes), replacing &, <, >, ", ', and / characters.
      // str:
      //		the string to escape
      if (!str) {
        return '';
      }
      return str.replace(ESCAPE_REGEXP, function (c) {
        return ESCAPE_MAP[c];
      });
    };
    string.rep = function (str, num) {
      // summary:
      //		Efficiently replicate a string `n` times.
      // str:
      //		the string to replicate
      // num:
      //		number of times to replicate the string
      if (num <= 0 || !str) {
        return '';
      }
      var buf = [];
      for (;;) {
        if (num & 1) {
          buf.push(str);
        }
        if (!(num >>= 1)) {
          break;
        }
        str += str;
      }
      return buf.join('');  // String
    };
    string.pad = function (text, size, ch, end) {
      // summary:
      //		Pad a string to guarantee that it is at least `size` length by
      //		filling with the character `ch` at either the start or end of the
      //		string. Pads at the start, by default.
      // text:
      //		the string to pad
      // size:
      //		length to provide padding
      // ch:
      //		character to pad, defaults to '0'
      // end:
      //		adds padding at the end if true, otherwise pads at start
      // example:
      //	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
      //	|	string.pad("Dojo", 10, "+", true);
      if (!ch) {
        ch = '0';
      }
      var out = String(text), pad = string.rep(ch, Math.ceil((size - out.length) / ch.length));
      return end ? out + pad : pad + out;  // String
    };
    string.substitute = function (template, map, transform, thisObject) {
      // summary:
      //		Performs parameterized substitutions on a string. Throws an
      //		exception if any parameter is unmatched.
      // template:
      //		a string with expressions in the form `${key}` to be replaced or
      //		`${key:format}` which specifies a format function. keys are case-sensitive.
      // map:
      //		hash to search for substitutions
      // transform:
      //		a function to process all parameters before substitution takes
      //		place, e.g. mylib.encodeXML
      // thisObject:
      //		where to look for optional format function; default to the global
      //		namespace
      // example:
      //		Substitutes two expressions in a string from an Array or Object
      //	|	// returns "File 'foo.html' is not found in directory '/temp'."
      //	|	// by providing substitution data in an Array
      //	|	string.substitute(
      //	|		"File '${0}' is not found in directory '${1}'.",
      //	|		["foo.html","/temp"]
      //	|	);
      //	|
      //	|	// also returns "File 'foo.html' is not found in directory '/temp'."
      //	|	// but provides substitution data in an Object structure.  Dotted
      //	|	// notation may be used to traverse the structure.
      //	|	string.substitute(
      //	|		"File '${name}' is not found in directory '${info.dir}'.",
      //	|		{ name: "foo.html", info: { dir: "/temp" } }
      //	|	);
      // example:
      //		Use a transform function to modify the values:
      //	|	// returns "file 'foo.html' is not found in directory '/temp'."
      //	|	string.substitute(
      //	|		"${0} is not found in ${1}.",
      //	|		["foo.html","/temp"],
      //	|		function(str){
      //	|			// try to figure out the type
      //	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
      //	|			return prefix + " '" + str + "'";
      //	|		}
      //	|	);
      // example:
      //		Use a formatter
      //	|	// returns "thinger -- howdy"
      //	|	string.substitute(
      //	|		"${0:postfix}", ["thinger"], null, {
      //	|			postfix: function(value, key){
      //	|				return value + " -- howdy";
      //	|			}
      //	|		}
      //	|	);
      thisObject = thisObject || kernel.global;
      transform = transform ? lang.hitch(thisObject, transform) : function (v) {
        return v;
      };
      return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g, function (match, key, format) {
        var value = lang.getObject(key, false, map);
        if (format) {
          value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
        }
        return transform(value, key).toString();
      });  // String
    };
    string.trim = String.prototype.trim ? lang.trim : // aliasing to the native function
    function (str) {
      str = str.replace(/^\s+/, '');
      for (var i = str.length - 1; i >= 0; i--) {
        if (/\S/.test(str.charAt(i))) {
          str = str.substring(0, i + 1);
          break;
        }
      }
      return str;
    };
    /*=====
     string.trim = function(str){
    	 // summary:
    	 //		Trims whitespace from both sides of the string
    	 // str: String
    	 //		String to be trimmed
    	 // returns: String
    	 //		Returns the trimmed string
    	 // description:
    	 //		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
    	 //		The short yet performant version of this function is dojo/_base/lang.trim(),
    	 //		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
    	 return "";	// String
     };
     =====*/
    return string;
  }(dojo__base_kernel, dojo__base_lang);
  dojo__base_array = function (dojo, has, lang) {
    // module:
    //		dojo/_base/array
    // our old simple function builder stuff
    var cache = {}, u;
    function buildFn(fn) {
      return cache[fn] = new Function('item', 'index', 'array', fn);  // Function
    }
    // magic snippet: if(typeof fn == "string") fn = cache[fn] || buildFn(fn);
    // every & some
    function everyOrSome(some) {
      var every = !some;
      return function (a, fn, o) {
        var i = 0, l = a && a.length || 0, result;
        if (l && typeof a == 'string')
          a = a.split('');
        if (typeof fn == 'string')
          fn = cache[fn] || buildFn(fn);
        if (o) {
          for (; i < l; ++i) {
            result = !fn.call(o, a[i], i, a);
            if (some ^ result) {
              return !result;
            }
          }
        } else {
          for (; i < l; ++i) {
            result = !fn(a[i], i, a);
            if (some ^ result) {
              return !result;
            }
          }
        }
        return every;  // Boolean
      };
    }
    // indexOf, lastIndexOf
    function index(up) {
      var delta = 1, lOver = 0, uOver = 0;
      if (!up) {
        delta = lOver = uOver = -1;
      }
      return function (a, x, from, last) {
        if (last && delta > 0) {
          // TODO: why do we use a non-standard signature? why do we need "last"?
          return array.lastIndexOf(a, x, from);
        }
        var l = a && a.length || 0, end = up ? l + uOver : lOver, i;
        if (from === u) {
          i = up ? lOver : l + uOver;
        } else {
          if (from < 0) {
            i = l + from;
            if (i < 0) {
              i = lOver;
            }
          } else {
            i = from >= l ? l + uOver : from;
          }
        }
        if (l && typeof a == 'string')
          a = a.split('');
        for (; i != end; i += delta) {
          if (a[i] == x) {
            return i;  // Number
          }
        }
        return -1;  // Number
      };
    }
    var array = {
      // summary:
      //		The Javascript v1.6 array extensions.
      every: everyOrSome(false),
      /*=====
       every: function(arr, callback, thisObject){
      	 // summary:
      	 //		Determines whether or not every item in arr satisfies the
      	 //		condition implemented by callback.
      	 // arr: Array|String
      	 //		the array to iterate on. If a string, operates on individual characters.
      	 // callback: Function|String
      	 //		a function is invoked with three arguments: item, index,
      	 //		and array and returns true if the condition is met.
      	 // thisObject: Object?
      	 //		may be used to scope the call to callback
      	 // returns: Boolean
      	 // description:
      	 //		This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
      	 //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
      	 //		the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
      	 //		For more details, see:
      	 //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every
      	 // example:
      	 //	|	// returns false
      	 //	|	array.every([1, 2, 3, 4], function(item){ return item>1; });
      	 // example:
      	 //	|	// returns true
      	 //	|	array.every([1, 2, 3, 4], function(item){ return item>0; });
       },
       =====*/
      some: everyOrSome(true),
      /*=====
      some: function(arr, callback, thisObject){
      	// summary:
      	//		Determines whether or not any item in arr satisfies the
      	//		condition implemented by callback.
      	// arr: Array|String
      	//		the array to iterate over. If a string, operates on individual characters.
      	// callback: Function|String
      	//		a function is invoked with three arguments: item, index,
      	//		and array and returns true if the condition is met.
      	// thisObject: Object?
      	//		may be used to scope the call to callback
      	// returns: Boolean
      	// description:
      	//		This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
      	//		run over sparse arrays, this implementation passes the "holes" in the sparse array to
      	//		the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
      	//		For more details, see:
      	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some
      	// example:
      	//	| // is true
      	//	| array.some([1, 2, 3, 4], function(item){ return item>1; });
      	// example:
      	//	| // is false
      	//	| array.some([1, 2, 3, 4], function(item){ return item<1; });
      },
      =====*/
      indexOf: index(true),
      /*=====
      indexOf: function(arr, value, fromIndex, findLast){
      	// summary:
      	//		locates the first index of the provided value in the
      	//		passed array. If the value is not found, -1 is returned.
      	// description:
      	//		This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:
      	//
      	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
      	//		   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.
      	//		2. uses equality (==) rather than strict equality (===)
      	//
      	//		For details on this method, see:
      	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf
      	// arr: Array
      	// value: Object
      	// fromIndex: Integer?
      	// findLast: Boolean?
      	//		Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.
      	// returns: Number
      },
      =====*/
      lastIndexOf: index(false),
      /*=====
      lastIndexOf: function(arr, value, fromIndex){
      	// summary:
      	//		locates the last index of the provided value in the passed
      	//		array. If the value is not found, -1 is returned.
      	// description:
       	//		This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:
       	//
       	//		1. when run over sparse arrays, the Dojo function invokes the callback for every index
       	//		   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.
       	//		2. uses equality (==) rather than strict equality (===)
       	//
       	//		For details on this method, see:
       	//		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf
      	// arr: Array,
      	// value: Object,
      	// fromIndex: Integer?
      	// returns: Number
      },
      =====*/
      forEach: function (arr, callback, thisObject) {
        // summary:
        //		for every item in arr, callback is invoked. Return values are ignored.
        //		If you want to break out of the loop, consider using array.every() or array.some().
        //		forEach does not allow breaking out of the loop over the items in arr.
        // arr:
        //		the array to iterate over. If a string, operates on individual characters.
        // callback:
        //		a function is invoked with three arguments: item, index, and array
        // thisObject:
        //		may be used to scope the call to callback
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach
        // example:
        //	| // log out all members of the array:
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		function(item){
        //	|			console.log(item);
        //	|		}
        //	| );
        // example:
        //	| // log out the members and their indexes
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		function(item, idx, arr){
        //	|			console.log(item, "at index:", idx);
        //	|		}
        //	| );
        // example:
        //	| // use a scoped object member as the callback
        //	|
        //	| var obj = {
        //	|		prefix: "logged via obj.callback:",
        //	|		callback: function(item){
        //	|			console.log(this.prefix, item);
        //	|		}
        //	| };
        //	|
        //	| // specifying the scope function executes the callback in that scope
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		obj.callback,
        //	|		obj
        //	| );
        //	|
        //	| // alternately, we can accomplish the same thing with lang.hitch()
        //	| array.forEach(
        //	|		[ "thinger", "blah", "howdy", 10 ],
        //	|		lang.hitch(obj, "callback")
        //	| );
        // arr: Array|String
        // callback: Function|String
        // thisObject: Object?
        var i = 0, l = arr && arr.length || 0;
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            callback.call(thisObject, arr[i], i, arr);
          }
        } else {
          for (; i < l; ++i) {
            callback(arr[i], i, arr);
          }
        }
      },
      map: function (arr, callback, thisObject, Ctr) {
        // summary:
        //		applies callback to each element of arr and returns
        //		an Array with the results
        // arr: Array|String
        //		the array to iterate on. If a string, operates on
        //		individual characters.
        // callback: Function|String
        //		a function is invoked with three arguments, (item, index,
        //		array),	 and returns a value
        // thisObject: Object?
        //		may be used to scope the call to callback
        // returns: Array
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
        // example:
        //	| // returns [2, 3, 4, 5]
        //	| array.map([1, 2, 3, 4], function(item){ return item+1 });
        // TODO: why do we have a non-standard signature here? do we need "Ctr"?
        var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            out[i] = callback.call(thisObject, arr[i], i, arr);
          }
        } else {
          for (; i < l; ++i) {
            out[i] = callback(arr[i], i, arr);
          }
        }
        return out;  // Array
      },
      filter: function (arr, callback, thisObject) {
        // summary:
        //		Returns a new Array with those items from arr that match the
        //		condition implemented by callback.
        // arr: Array
        //		the array to iterate over.
        // callback: Function|String
        //		a function that is invoked with three arguments (item,
        //		index, array). The return of this function is expected to
        //		be a boolean which determines whether the passed-in item
        //		will be included in the returned array.
        // thisObject: Object?
        //		may be used to scope the call to callback
        // returns: Array
        // description:
        //		This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
        //		run over sparse arrays, this implementation passes the "holes" in the sparse array to
        //		the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
        //		For more details, see:
        //		https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
        // example:
        //	| // returns [2, 3, 4]
        //	| array.filter([1, 2, 3, 4], function(item){ return item>1; });
        // TODO: do we need "Ctr" here like in map()?
        var i = 0, l = arr && arr.length || 0, out = [], value;
        if (l && typeof arr == 'string')
          arr = arr.split('');
        if (typeof callback == 'string')
          callback = cache[callback] || buildFn(callback);
        if (thisObject) {
          for (; i < l; ++i) {
            value = arr[i];
            if (callback.call(thisObject, value, i, arr)) {
              out.push(value);
            }
          }
        } else {
          for (; i < l; ++i) {
            value = arr[i];
            if (callback(value, i, arr)) {
              out.push(value);
            }
          }
        }
        return out;  // Array
      },
      clearCache: function () {
        cache = {};
      }
    };
    has('extend-dojo') && lang.mixin(dojo, array);
    return array;
  }(dojo__base_kernel, dojo_has, dojo__base_lang);
  dojo__base_url = function (dojo) {
    // module:
    //		dojo/url
    var ore = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$'), ire = new RegExp('^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$'), _Url = function () {
        var n = null, _a = arguments, uri = [_a[0]];
        // resolve uri components relative to each other
        for (var i = 1; i < _a.length; i++) {
          if (!_a[i]) {
            continue;
          }
          // Safari doesn't support this.constructor so we have to be explicit
          // FIXME: Tracked (and fixed) in Webkit bug 3537.
          //		http://bugs.webkit.org/show_bug.cgi?id=3537
          var relobj = new _Url(_a[i] + ''), uriobj = new _Url(uri[0] + '');
          if (relobj.path == '' && !relobj.scheme && !relobj.authority && !relobj.query) {
            if (relobj.fragment != n) {
              uriobj.fragment = relobj.fragment;
            }
            relobj = uriobj;
          } else if (!relobj.scheme) {
            relobj.scheme = uriobj.scheme;
            if (!relobj.authority) {
              relobj.authority = uriobj.authority;
              if (relobj.path.charAt(0) != '/') {
                var path = uriobj.path.substring(0, uriobj.path.lastIndexOf('/') + 1) + relobj.path;
                var segs = path.split('/');
                for (var j = 0; j < segs.length; j++) {
                  if (segs[j] == '.') {
                    // flatten "./" references
                    if (j == segs.length - 1) {
                      segs[j] = '';
                    } else {
                      segs.splice(j, 1);
                      j--;
                    }
                  } else if (j > 0 && !(j == 1 && segs[0] == '') && segs[j] == '..' && segs[j - 1] != '..') {
                    // flatten "../" references
                    if (j == segs.length - 1) {
                      segs.splice(j, 1);
                      segs[j - 1] = '';
                    } else {
                      segs.splice(j - 1, 2);
                      j -= 2;
                    }
                  }
                }
                relobj.path = segs.join('/');
              }
            }
          }
          uri = [];
          if (relobj.scheme) {
            uri.push(relobj.scheme, ':');
          }
          if (relobj.authority) {
            uri.push('//', relobj.authority);
          }
          uri.push(relobj.path);
          if (relobj.query) {
            uri.push('?', relobj.query);
          }
          if (relobj.fragment) {
            uri.push('#', relobj.fragment);
          }
        }
        this.uri = uri.join('');
        // break the uri into its main components
        var r = this.uri.match(ore);
        this.scheme = r[2] || (r[1] ? '' : n);
        this.authority = r[4] || (r[3] ? '' : n);
        this.path = r[5];
        // can never be undefined
        this.query = r[7] || (r[6] ? '' : n);
        this.fragment = r[9] || (r[8] ? '' : n);
        if (this.authority != n) {
          //PATCHED: fix for usbank. url looked like this: https://onlinebanking---usbank---com.synchronite.de:/USB/
          // The character ":" without a port number caused an exception, so ":" will be removed
          if (this.authority.indexOf(':', this.authority.length - 1) !== -1) {
            this.authority = this.authority.substring(0, this.authority.length - 1);
          }
          //PATCH END
          // server based naming authority
          r = this.authority.match(ire);
          this.user = r[3] || n;
          this.password = r[4] || n;
          this.host = r[6] || r[7];
          // ipv6 || ipv4
          this.port = r[9] || n;
        }
      };
    _Url.prototype.toString = function () {
      return this.uri;
    };
    return dojo._Url = _Url;
  }(dojo__base_kernel);
  synchronite_libs_sizzle = function (window, undefined) {
    var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate,
      // Local document vars
      setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
      // Instance-specific data
      expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }
        return 0;
      },
      // Instance methods
      hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push = arr.push, slice = arr.slice,
      // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0, len = list.length;
        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|' + 'ismap|loop|multiple|open|readonly|required|scoped',
      // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = '[\\x20\\t\\r\\n\\f]',
      // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
      identifier = '(?:\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + // Operator (capture 2)
      '*([*^$|!~]?=)' + whitespace + // "Attribute values must be CSS identifiers [capture 5]
      // or strings [capture 3 or capture 4]"
      '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + // 2. simple (capture 6)
      '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + // 3. anything else (capture 2)
      '.*' + ')\\)|)',
      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rdescend = new RegExp(whitespace + '|>'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + identifier + ')'),
        'CLASS': new RegExp('^\\.(' + identifier + ')'),
        'TAG': new RegExp('^(' + identifier + '|[*])'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/,
      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/,
      // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp('\\\\[\\da-fA-F]{1,6}' + whitespace + '?|\\\\([^\\r\\n\\f])', 'g'), funescape = function (escape, nonHex) {
        var high = '0x' + escape.slice(1) - 65536;
        return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
        nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      },
      // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === '\0') {
            return '\uFFFD';
          }
          // Control characters and (dependent upon position) numbers get escaped as code points
          return ch.slice(0, -1) + '\\' + ch.charCodeAt(ch.length - 1).toString(16) + ' ';
        }
        // Other potentially-special ASCII characters get backslash-escaped
        return '\\' + ch;
      },
      // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      }, inDisabledFieldset = addCombinator(function (elem) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === 'fieldset';
      }, {
        dir: 'parentNode',
        next: 'legend'
      });
    // Optimize for push.apply( _, NodeList )
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
        // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
      results = results || [];
      // Return early from calls with invalid selector or context
      if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      // Try to shortcut find operations (as opposed to filters) in HTML documents
      if (!seed) {
        setDocument(context);
        context = context || document;
        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }  // Element context
              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }  // Type selector
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;  // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          // Take advantage of querySelectorAll
          if (support.qsa && !nonnativeSelectorCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== 'object')) {
            newSelector = selector;
            newContext = context;
            // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.
            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
              // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.
              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute('id')) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute('id', nid = expando);
                }
              }
              // Prefix every selector in the list
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = (nid ? '#' + nid : ':scope') + ' ' + toSelector(groups[i]);
              }
              newSelector = groups.join(',');
            }
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      // All others
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *    deleting the oldest entry
     */
    function createCache() {
      var keys = [];
      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + ' ') > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }
        return cache[key + ' '] = value;
      }
      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */
    function assert(fn) {
      var el = document.createElement('fieldset');
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        // release memory in IE
        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      // Use IE sourceIndex if available on both nodes
      if (diff) {
        return diff;
      }
      // Check if b follows a
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */
    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ('form' in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ('label' in elem) {
              if ('label' in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors
            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }
          return elem.disabled === disabled;  // Try to winnow out elements that can't be disabled before trusting the disabled property.
                                              // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                                              // even exist on them, let alone have a boolean value.
        } else if ('label' in elem) {
          return elem.disabled === disabled;
        }
        // Remaining elements are neither :enabled nor :disabled
        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          // Match elements found at the specified indexes
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== 'undefined' && context;
    }
    // Expose support vars for convenience
    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem.namespaceURI, docElem = (elem.ownerDocument || elem).documentElement;
      // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833
      return !rhtml.test(namespace || docElem && docElem.nodeName || 'HTML');
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
      // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      // Update global variables
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener('unload', unloadHandler, false);  // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent('onunload', unloadHandler);
        }
      }
      // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.
      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement('div'));
        return typeof el.querySelectorAll !== 'undefined' && !el.querySelectorAll(':scope fieldset div').length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)
      support.attributes = assert(function (el) {
        el.className = 'i';
        return !el.getAttribute('className');
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements
      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(''));
        return !el.getElementsByTagName('*').length;
      });
      // Support: IE<9
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      // ID filter and find
      if (support.getById) {
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
        // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
            var node, i, elems, elem = context.getElementById(id);
            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode('id');
              if (node && node.value === id) {
                return [elem];
              }
              // Fall back on getElementsByName
              elems = context.getElementsByName(id);
              i = 0;
              while (elem = elems[i++]) {
                node = elem.getAttributeNode('id');
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      // Tag
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== 'undefined') {
          return context.getElementsByTagName(tag);  // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0,
          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag);
        // Filter out possible comments
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      // Class
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];
      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];
      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359
          docElem.appendChild(el).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
          // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
          if (el.querySelectorAll('[msallowcapture^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          // Support: IE8
          // Boolean attributes and "value" are not treated correctly
          if (!el.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
          if (!el.querySelectorAll('[id~=' + expando + '-]').length) {
            rbuggyQSA.push('~=');
          }
          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if (!el.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
          // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails
          if (!el.querySelectorAll('a#' + expando + '+*').length) {
            rbuggyQSA.push('.#.+[+~]');
          }
        });
        assert(function (el) {
          el.innerHTML = '<a href=\'\' disabled=\'disabled\'></a>' + '<select disabled=\'disabled\'><option/></select>';
          // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment
          var input = document.createElement('input');
          input.setAttribute('type', 'hidden');
          el.appendChild(input).setAttribute('name', 'D');
          // Support: IE8
          // Enforce case-sensitivity of name attribute
          if (el.querySelectorAll('[name=d]').length) {
            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
          }
          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if (el.querySelectorAll(':enabled').length !== 2) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(':disabled').length !== 2) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.
          el.querySelectorAll('\\\f');
          rbuggyQSA.push('[\\r\\n\\f]');
          // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos
          el.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, '*');
          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call(el, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      /* Contains
      ---------------------------------------------------------------------- */
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself
      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting
      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1;
        // Disconnected nodes
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          // Maintain original order
          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        // Parentless nodes are either documents or disconnected
        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;  // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        // Walk down the tree looking for a discrepancy
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);
      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          // IE 9's matchesSelector returns false on disconnected nodes
          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function (sel) {
      return (sel + '').replace(rcssescape, fcssescape);
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225
      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes
      return ret;
    };
    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          // Move the given value to match[3] whether quoted or unquoted
          match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          /* matches from matchExpr["CHILD"]
              1 type (only|nth|...)
              2 what (child|of-type)
              3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              4 xn-component of xn+y argument ([+-]?\d*n|)
              5 sign of xn-component
              6 x of xn-component
              7 sign of y-component
              8 y of y-component
          */
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');  // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[6] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          // Accept quoted arguments as-is
          if (match[3]) {
            match[2] = match[4] || match[5] || '';  // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            /* eslint-disable max-len */
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;  /* eslint-enable max-len */
          };
        },
        'CHILD': function (type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  // Reverse direction for :only-* (if we haven't yet done so)
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              // non-xml :nth-child(...) stores cache data on `parent`
              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [
                          dirruns,
                          diff
                        ];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              // Incorporate the offset, then check against cycle size
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if (fn[expando]) {
            return fn(argument);
          }
          // But maintain support for old signatures
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        'not': markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            // Match elements unmatched by `matcher`
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            // Don't keep the element (issue #299)
            input[0] = null;
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        'lang': markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        // Miscellaneous
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        'enabled': createDisabledPseudo(false),
        'disabled': createDisabledPseudo(true),
        'checked': function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        // Contents
        'empty': function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        // Element/input types
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
        },
        // Position-in-collection
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    //Expr.pseudos["nth"] = Expr.pseudos["eq"];
    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    // Easy API for creating new setFilters
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        // Combinators
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        // Filters
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === 'parentNode', doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache, uniqueCache, outerCache, newCache = [
            dirruns,
            doneName
          ];
        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache;
                // A match means we're done; a fail means we have to keep checking
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
          // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn;
        // Find primary matches
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        // Apply postFilter
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }  // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0,
        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            // Avoid hanging onto element (issue #299)
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          // Return special upon seeing a positional matcher
          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
          var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find['TAG']('*', outermost),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
          if (outermost) {
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            outermostContext = context == document || context || outermost;
          }
          // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if (!context && elem.ownerDocument != document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
              }
            }
            // Track unmatched elements for set filters
            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              // Lengthen the array for every element, matched or not
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.
          matchedCount += i;
          // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              // Discard index placeholder values to get only actual matches
              setMatched = condense(setMatched);
            }
            // Add matches to results
            push.apply(results, setMatched);
            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          // Override manipulation of globals by nested matchers
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, match) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        // Cache the compiled function
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        // Save selector and tokenization
        cached.selector = selector;
      }
      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function (selector, context, results, seed) {
      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)
      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;  // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        // Fetch a seed set for right-to-left matching
        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          // Abort if we hit a combinator
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    // One-time assignments
    // Sort stability
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;
    // Initialize against the default document
    setDocument();
    // The document can be missing during requirejs.optimize()
    if (!document) {
      console.log('Document could not be found when initializing sizzle.');
      return Sizzle;
    }
    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement('fieldset')) & 1;
    });
    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!assert(function (el) {
        el.innerHTML = '<a href=\'#\'></a>';
        return el.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if (!support.attributes || !assert(function (el) {
        el.innerHTML = '<input/>';
        el.firstChild.setAttribute('value', '');
        return el.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if (!assert(function (el) {
        return el.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  }(typeof window != 'undefined' ? window : this);
  synchronite__base_query = function (queryEngine, baseArray, strings) {
    // NOTE: We should use native css3 queries wherever possible because nth-of-type
    // is buggy in IE8+. It seems that acme does not correctly support nth-of-type.
    //
    // WARN: AFTER DOJO UPDATE TO 1.9 WE NEED TO PATCH IN LITE.JS (Otherwise simple id queries fail)
    // var found = dojo.byId ? dojo.byId(match[2], doc) : doc.getElementById(match[2]);
    // str2array taken from dojo/dom-class.js
    var spaces = /\s+/, a1 = [''];
    var str2array = function (s) {
      if (typeof s === 'string' || s instanceof String) {
        if (s && !spaces.test(s)) {
          a1[0] = s;
          return a1;
        }
        var a = s.split(spaces);
        if (a.length && !a[0]) {
          a.shift();
        }
        if (a.length && !a[a.length - 1]) {
          a.pop();
        }
        return a;
      }
      // assumed to be an array
      if (!s) {
        return [];
      }
      return baseArray.filter(s, function (x) {
        return x;
      });
    };
    var _contains = function (arr, item) {
      return baseArray.indexOf(arr, item) >= 0;
    };
    var ignoreIds = synchroniteConfig.ignoreIds;
    var useClasses = synchroniteConfig.useClasses;
    var strClass = 'class';
    var _useClass = function (node) {
      // returns: classname that can be used in a selector or false
      // WARN: There seems to be no way of determining classes that have been present
      //       in the original markup. If there was we could further optimize the code
      //       below to detect behavioral html classes (such as .hover) and avoid using
      //       these in css selectors.
      //
      //       -> see testcase: http://jsfiddle.net/UdgrL/1/
      var htmlAttrClassesStr, htmlAttrClasses, l, i;
      if (typeof node.getAttribute === 'undefined') {
        return;
      }
      // Get array of classes  or quit if there are no classes assigned to node
      htmlAttrClassesStr = node.getAttribute(strClass);
      if (htmlAttrClassesStr) {
        htmlAttrClasses = str2array(htmlAttrClassesStr);
      } else {
        return;
      }
      if (useClasses && useClasses.length > 0) {
        //var useHeuristic = (useClasses[0] === "*");
        // Check if we found any classnames, that we know from configuration are safe to
        // be used. e.g. classnames that do not change on MouseEvents such as hover,
        // mouseover or node activation (click)
        l = useClasses.length;
        for (i = 0; i < l; i++) {
          if (_contains(htmlAttrClasses, useClasses[i])) {
            return useClasses[i];
          }
        }
      }
      // Use heuristic approach to determine classnames that can be used.
      l = htmlAttrClasses.length;
      var cls;
      for (i = 0; i < l; i++) {
        cls = htmlAttrClasses[i];
        // selected (results-select2) needed for https://www.sparkasse-musterstadt.de/privatkunden/bauen_wohnen/index.php?n=/privatkunden/bauen_wohnen/
        if (!/hover|focus|active|selected|highlight|over/i.test(cls)) {
          return cls;
        }
      }
      return false;
    };
    var _idIsUnique = function (parent, doc) {
      var id = escapeQuery(parent.id);
      var list = queryEngine('#' + id, doc);
      return list.length === 1 && list[0] === parent;
    };
    var _canUseId = function (node) {
      if (node && node.id && typeof node.id === 'string') {
        if (ignoreIds && ignoreIds.length > 0 && baseArray.indexOf(ignoreIds, node.id) >= 0) {
          return false;
        }
        if (/hover|focus|active|selected|highlight|over|\r\n|\n|\r/i.test(node.id)) {
          return false;
        }
        if (typeof synchroniteConfig != 'undefined' && synchroniteConfig.detectRandomIds) {
          if (/([\d]{4,})/i.test(node.id)) {
            return false;
          }
        }
        return node.id;
      }
      return false;
    };
    //////////////////////////////////////////
    // PRIVATE FUNCTIONS AND VARIABLES
    //////////////////////////////////////////
    var getText = function (elem) {
        //Get text content of node
        var i, node, nodeType = elem.nodeType, ret = '', rReturn = /\r\n/g;
        if (nodeType) {
          if (nodeType === 1) {
            // Use textContent || innerText for elements
            if (typeof elem.textContent === 'string') {
              return elem.textContent;
            } else if (typeof elem.innerText === 'string') {
              // Replace IE's carriage returns
              return elem.innerText.replace(rReturn, '');
            } else {
              // Traverse it's children
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
        } else {
          // If no nodeType, this is expected to be an array
          for (i = 0; i < elem[i].length; i++) {
            // Do not traverse comment nodes
            node = elem[i];
            if (node.nodeType !== 8) {
              ret += getText(node);
            }
          }
        }
        return ret;
      }, isUnique = function (part, selector, root) {
        return queryEngine(_selectorSoFar(part, selector), root).length === 1;
      }, synchronizedFrameId = strings.SYNCHRONIZED_WINDOW, synchronizedWindow = function () {
        // WARNING:
        // When using window.frames["name"]:
        //  - Chrome returns the iframe element
        //  - Firefox returns the window object
        // window.frames[strings.SYNCHRONIZED_WINDOW] only works in FF, when the synchronized page does
        // not set a window.name itself. This is the case for cosmosdirekt
        // (window.name="cosmos") so the main frame is not found.
        //
        // --> To avoid this problem we search for the iframe element in the main document
        //     instead.
        //                if (foundWindow) {
        //                    return foundWindow;
        //                }
        var foundWindow;
        try {
          foundWindow = findWindowByFrameName(window, synchronizedFrameId, true);
        } catch (e) {
          console.warn('Unable to get displayContent frame. Trying different method.');
        }
        if (!foundWindow) {
          var iframes = queryEngine('#' + synchronizedFrameId, document);
          if (iframes.length > 0) {
            foundWindow = iframes[0].contentWindow;
            console.warn('Returning window, but may be inaccessible.');
          }
        }
        return foundWindow || window;
      }, nthOfType = function (node) {
        var tagName = node.tagName;
        // the value of n is "1-indexed", meaning that the counting starts at 1
        var count = 1;
        if (tagName) {
          for (var sib = node.previousSibling; sib; sib = sib.previousSibling) {
            // get nth child
            if (sib.nodeType === 1 && sib.tagName === tagName) {
              // nodeyType == 1 => Elementknoten
              count++;
            }
          }
        }
        return count;
      }, _getFrameSelector = function (frame) {
        var frameSelector = null;
        if (frame) {
          if (frame.name) {
            frameSelector = frame.tagName.toLowerCase() + '[name=\'' + frame.name + '\']';
          } else if (frame.id) {
            frameSelector = frame.tagName.toLowerCase() + '#' + escapeQuery(frame.id);
          } else {
            frameSelector = identifyByRelatedNodes(frame);  //"frameset:nth-child(" + 0 + ")"; //frame
          }
        }
        return frameSelector;
      }, escapeQuery = function (s) {
        if (typeof s === 'string' && /(:|\w\.|~|\+| |\[|\]|\$|\/|@|\||\(|\)|{|}|%|=|&|;|#)/gi.test(s)) {
          // no need to escape ~ in dojo 1.7.1 with acme selector engine
          // USE IN FUTURE: https://github.com/mathiasbynens/cssesc
          //
          // FIXED: dojoQuery confuses colons in ids with pseudo
          // selectors, so they need to be escaped.
          // http://bugs.dojotoolkit.org/changeset/11210/dojo
          // FIXED: We need to escape spaces, too. (found on sparkasse-koelnbonn.de)
          //        see: http://stackoverflow.com/questions/596314/jquery-ids-with-spaces
          // FIXED: We need to escape square brackets, too (found in oxid demo shop)
          s = s.replace(/(:|\.|~|\+| |\[|\]|\$|\/|@|\||\(|\)|{|}|%|=|&|;|#)/gi, function ($0, character, idx) {
            // special case for # or . check if there is a character before a dot or #. If not, don't escape
            if (character === '.' && (idx === 0 || /\s/i.test(s.charAt(idx - 1)))) {
              return character;
            }
            if (character === '#' && (idx === 0 || /\s/i.test(s.charAt(idx - 1)))) {
              return character;
            }
            return '\\' + character;
          });
        }
        return s;
      }, _addPart = function (part, selector) {
        if (selector.length > 0) {
          selector.unshift(' > ');
        }
        selector.unshift(part.join(''));
      }, _selectorSoFar = function (part, selector) {
        var completeSelector = part.join('');
        if (selector.length > 0) {
          completeSelector += ' > ' + selector.join('');
        }
        return completeSelector;
      }, identifyByRelatedNodes = function (el, ctx) {
        var nth;
        var selector = [];
        var part = [];
        var list, eq;
        var nodeName;
        var id;
        var valAttr;
        var checkIfUnique;
        var doc = ctx || el.ownerDocument;
        //    win = doc.parentWindow || doc.defaultView;
        //var sid;
        var parent = el;
        while (parent && !isShadowRoot(parent)) {
          part = [];
          nodeName = parent.nodeName.toLowerCase();
          checkIfUnique = false;
          if (_canUseId(parent) && _idIsUnique(parent, doc)) {
            // This did not work with selectorEngine=acme and dojoQuery("#QR~QID651~4", frameDoc);
            // FIXED: http://bugs.dojotoolkit.org/ticket/15319
            id = escapeQuery(parent.id);
            list = queryEngine('#' + id, doc);
            if (list.length === 1 && list[0] === parent) {
              part.push('#' + id);
            }
            return _selectorSoFar(part, selector);
          } else if (/^(html|head|body|document|#document)$/i.test(nodeName)) {
            // there can only be one of these tags, so do not use id
            // or name, as those might vary (home of the brave)
            part.push(nodeName);
            // end when top of document is reached
            return _selectorSoFar(part, selector);
          } else if (nodeName.indexOf(':') !== -1) {
            //miele isa:content
            return _selectorSoFar(part, selector);
          } else if (parent.name && parent.getAttribute('name')) {
            // FIXED: We must use getAttribute, because a form with a child carrying
            //        a name="name" attribute will result in getting the child object
            //        instead of the forms name property.
            // if name is unique then use name as identifier since generated ids might
            // be different in same page (see SAP SYCOR B2B Webshop)
            part.push(nodeName);
            part.push('[name=\'' + parent.getAttribute('name') + '\']');
            if (parent.type && /checkbox|radio/i.test(parent.type)) {
              if (isUnique(part, selector, doc)) {
                return _selectorSoFar(part, selector);
              } else {
                //FIXED: only get the real attribute of the tag.
                //       properties can't be used for queries.
                valAttr = parent.getAttribute && parent.getAttribute('value');
                if (valAttr) {
                  part.push('[value=\'' + valAttr + '\']');
                }
              }
            }
            checkIfUnique = true;
          } else if (nodeName === 'option') {
            // option tags be uniquely identified as children of
            // a select node by their value
            part.push(nodeName);
            //FIXED: only get the real attribute of the tag.
            //       properties can't be used for queries.
            valAttr = parent.getAttribute && parent.getAttribute('value');
            if (valAttr) {
              part.push('[value=\'' + valAttr + '\']');
            } else {
              // needed for: <select><option>A</option><option>B</option><option>C</option></select>
              nth = nthOfType(parent);
              // also add if nth==1, because there might be more children of type
              part.push(':nth-of-type(' + nth + ')');
            }
            checkIfUnique = true;
          } else if (nodeName === 'label' && parent.getAttribute('for')) {
            part.push(nodeName);
            part.push('[for=\'' + parent.getAttribute('for') + '\']');
            checkIfUnique = true;
          } else if (nodeName === 'optgroup') {
            part.push(nodeName);
            if (parent.label) {
              part.push('[label=\'' + parent.label + '\']');
            }
            // Assume unique
            return _selectorSoFar(part, selector);  //} else if (nodeName === "img" && parent.src) {
                                                    //    // use img src if unique
                                                    //    // FIXED: Must get the actual attribute not the resolved img.src property
                                                    //    // FIXME: Maybe we should escape the srcAttribute
                                                    //    part.push(nodeName);
                                                    //
                                                    //    var srcAttribute = parent.getAttribute("src");
                                                    //    part.push("[src='" + escapeQuery(srcAttribute) + "']");
                                                    //
                                                    //    checkIfUnique = true;
          } else if (nodeName === 'a' && (parent.title || parent.rel)) {
            // use anchor title if unique
            part.push(nodeName);
            if (parent.title) {
              part.push('[title=\'' + parent.title + '\']');
            }
            if (parent.rel) {
              part.push('[rel=\'' + parent.rel + '\']');
            }
            checkIfUnique = true;
          } else {
            part.push(nodeName);
            var clsName = _useClass(parent);
            if (clsName) {
              part.push('.' + clsName);
              // Optimization: Also check before calculating nth-child.
              if (isUnique(part, selector, doc)) {
                return _selectorSoFar(part, selector);
              }
              checkIfUnique = true;
            }
            nth = nthOfType(parent);
            // also add if nth==1, because there might be more children of type
            part.push(':nth-of-type(' + nth + ')');
          }
          if (selector.length > 4) {
            // optimization test
            checkIfUnique = true;
          }
          if (checkIfUnique && isUnique(part, selector, doc) || parent.parentNode && isShadowRoot(parent.parentNode)) {
            return _selectorSoFar(part, selector);
          } else {
            _addPart(part, selector);
          }
          parent = parent.parentNode;
        }
        //}
        return selector;
      }, findWindowByFrameName = function (startWindow, frameName, noDeepSearch) {
        // summary: This method searches for a frame inside startWindow that is specified
        //          by the given name.
        //
        // description: This method traveres the window.frames array by numbers which is more
        //              reliable than using direct name access. As the name of the frame will
        //              not be found, when the corresponding window.name is changed.
        // noDeepSearch: Search on startWindow level only and do not go deeper into each sub frame.
        if (startWindow.name === frameName) {
          return startWindow;
        }
        var tempFrame;
        var windowFrames = startWindow.frames;
        var frameOrWindow;
        var frame, win;
        //Start searching for the specified frame
        for (var i = 0; i < windowFrames.length; i++) {
          try {
            // Get frame and window objects
            // WARNING:
            // When using window.frames["name"]:
            //  - Chrome returns the iframe element
            //  - Firefox returns the window object
            frameOrWindow = windowFrames[i];
            if (frameOrWindow.contentWindow) {
              frame = frameOrWindow;
              win = frameOrWindow.contentWindow;
            } else {
              frame = frameOrWindow.frameElement;
              win = frameOrWindow;
            }
            if (win.name === frameName || frame && frame.name === frameName) {
              return win;
            } else if (!noDeepSearch) {
              tempFrame = findWindowByFrameName(win, frameName);
              if (tempFrame) {
                return tempFrame;
              }
            }
          } catch (e) {
            if (frameName != 'displayContent') {
              console.warn('Frame not accessible.');
            }
          }
        }
        //If we get here then no frame was found...
        return null;
      };
    var closestAttr = function (node, attr) {
      while (node && node.nodeType === 1) {
        if (node.getAttribute(attr)) {
          return node;
        } else {
          node = node.parentNode;
        }
      }
      return false;
    };
    var closestProp = function (node, attr) {
      while (node && node.nodeType === 1) {
        if (node[attr]) {
          // changed from attribute
          return node;
        } else {
          node = node.parentNode;
        }
      }
      return false;
    };
    var isShadowRoot = function (node) {
      return node.toString() === '[object ShadowRoot]';
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchQuery = {
      closestAttr: closestAttr,
      closestEventMonitor: function (node, type) {
        var monitorId;
        if (/click|mousedown|mouseup/i.test(type)) {
          monitorId = strings.PROP_CLICK_MONITORED;
        } else if (/keydown|keypress/i.test(type)) {
          monitorId = strings.PROP_KEY_MONITORED;
        } else if (/change/.test(type)) {
          monitorId = strings.PROP_CHANGE_MONITORED;
        } else {
          return false;
        }
        return closestProp(node, monitorId);
      },
      synchronizedWindow: synchronizedWindow,
      closestParent: function (node, selector, deep) {
        //		Returns closest parent that matches query, including current node in this
        //		dojo/NodeList if it matches the query.
        var cur;
        do {
          for (cur = node; cur; cur = cur.parentNode) {
            if (// Don't pass non-elements to Sizzle
              cur.nodeType === 1 && queryEngine.matchesSelector(cur, selector)) {
              return cur;
            }
          }
          if (deep) {
            var nodeDoc = node.ownerDocument || node;
            var win = nodeDoc.defaultView || nodeDoc.parentWindow;
            if (win.frameElement) {
              node = win.frameElement;
            } else {
              return null;
            }
          }
        } while (deep);
        return null;
      },
      getWindowFromFrameName: function (frameName) {
        var win;
        // undefined frameName
        if (!frameName || frameName === 'undefined') {
          return synchronizedWindow();
        }
        // 0. Case: Close a popup that is open in the main window
        if (frameName === 'presenterWindow') {
          return window;
        }
        // 1. Case: Search for synchronization frame in main window (synchronizedWindow()).
        if (frameName === strings.SYNCHRONIZED_WINDOW) {
          return synchronizedWindow();
        }
        // 2. Case: Search for first level sub windows/frames of displayContent
        win = findWindowByFrameName(synchronizedWindow(), frameName, true);
        if (win) {
          return win;
        }
        // 3. Case: Subframe in popup window
        win = findWindowByFrameName(window, frameName, true);
        if (win) {
          return win;
        }
        // 4. Case: Locate nested subframe and search deep in all sub frames
        return findWindowByFrameName(synchronizedWindow(), frameName);
      },
      getTargetWindowName: function (node) {
        // Warning: formTag.action fails to retrieve the attribute when the form has an input
        //          child node with name='target'
        var targetName = node.getAttribute('target');
        if (!targetName) {
          var sourceDoc = node.ownerDocument;
          var sourceWindow = sourceDoc.defaultView || sourceDoc.parentWindow;
          return synchQuery.getFrameNameFromWindow(sourceWindow);
        }
        if (targetName === '_self' || targetName === '_top' || targetName === '_parent' || targetName === '_blank') {
          var targetFrame = this.getTargetWindow(node);
          return synchQuery.getFrameNameFromWindow(targetFrame);
        } else {
          return targetName;
        }
      },
      getTargetWindow: function (nodeOrTargetString, optionalSourceWin) {
        var targetFrame, sourceWin, sourceDoc;
        if (typeof nodeOrTargetString === 'string') {
          targetFrame = nodeOrTargetString;
          sourceWin = optionalSourceWin;
        } else {
          // Warning: formTag.action fails to retrieve the attribute when the form has an input
          //          child node with name='target'
          targetFrame = nodeOrTargetString.getAttribute('target');
          sourceDoc = nodeOrTargetString.ownerDocument;
          sourceWin = sourceDoc.defaultView || sourceDoc.parentWindow;
        }
        if (!targetFrame) {
          return sourceWin;
        }
        if (targetFrame === '_self') {
          return sourceWin;
        } else if (targetFrame === '_parent' || targetFrame === '_top') {
          //relative target
          var targetWin = sourceWin[targetFrame.substring(1)];
          if (targetWin === synchronizedWindow()) {
            return targetWin;
          } else if (sourceWin === synchronizedWindow()) {
            return sourceWin;
          } else if (targetWin === synchronizedWindow().parent) {
            return sourceWin;
          } else {
            return targetWin;
          }
        } else if (targetFrame === '_blank') {
          return synchronizedWindow();
        } else {
          return synchQuery.getWindowFromFrameName(targetFrame);
        }
      },
      getFrameNameFromWindow: function (frameWin) {
        if (frameWin.name) {
          return frameWin.name.split('|')[0];
        } else if (frameWin.frameElement && frameWin.frameElement.name) {
          return frameWin.frameElement.name;
        } else {
          // Assuming " + frameWin.location.href + " is the synchronized window."
          return strings.SYNCHRONIZED_WINDOW;
        }
      },
      getRelativeIdentifier: function (source, target) {
        if (source === target) {
          return '_self';
        } else if (source.parent === target) {
          return '_parent';
        } else {
          return strings.SYNCHRONIZED_WINDOW;
        }
      },
      getFrameSelector: function (frameWin) {
        var frameSelector = [];
        if (frameWin === synchronizedWindow()) {
          return null;
        }
        var tmpFrameWin = frameWin;
        while (tmpFrameWin && tmpFrameWin !== tmpFrameWin.parent && tmpFrameWin !== synchronizedWindow() && tmpFrameWin !== window) {
          var frame = tmpFrameWin.frameElement;
          frameSelector.push(_getFrameSelector(frame));
          tmpFrameWin = tmpFrameWin.parent;
        }
        if (frameSelector.length > 0) {
          return frameSelector;
        }
        return null;
      },
      getShadowSelector: function (node) {
        var shadowSelector = [];
        for (; node; node = node.parentNode) {
          if (isShadowRoot(node)) {
            shadowSelector.push(identifyByRelatedNodes(node.host));
            node = node.host;
          }
        }
        if (shadowSelector.length > 0) {
          return shadowSelector;
        }
        return null;
      },
      getNodeSelectorFromEvent: function (evt) {
        var target = evt.target;
        if (target.shadow || target.shadowRoot) {
          return synchQuery.getNodeSelector(evt.composedPath()[0]);
        } else {
          return synchQuery.getNodeSelector(target);
        }
      },
      getNodeSelector: function (el) {
        var windowName = null, frameSelector = [], elementSelector = null, frameDoc, frameWin, shadow;
        //First determine target frame
        frameDoc = el.ownerDocument;
        if (!frameDoc) {
          return null;
        }
        frameWin = frameDoc.parentWindow || frameDoc.defaultView;
        // Setting the document now prevents "Permission denied" error in IE9
        queryEngine.setDocument(frameDoc);
        try {
          if (frameWin.name) {
            windowName = frameWin.name.split('|')[0];
          }
          frameSelector = this.getFrameSelector(frameWin);
        } catch (e) {
          console.debug('getCssSelector: Window might have been unloaded already.');
        }
        shadow = this.getShadowSelector(el);
        //Second determine target element
        var nodeName = el.nodeName;
        if (/^(html|head|body|document|#document)$/i.test(nodeName)) {
          // there can only be one of these tags, so do not use id
          // or name, as those might vary (home of the brave)
          elementSelector = nodeName;
        } else if (shadow) {
          elementSelector = identifyByRelatedNodes(el, el.getRootNode());
        } else {
          elementSelector = identifyByRelatedNodes(el);
        }
        //do not include null values to keep network size small
        var selector = {};
        if (elementSelector) {
          selector.element = elementSelector;
        }
        if (frameSelector && frameSelector.length > 0) {
          selector.frame = frameSelector;
        }
        if (windowName) {
          selector.windowName = windowName;
        }
        if (shadow) {
          selector.shadow = shadow;
        }
        return selector;
      },
      /**
       * Returns the window based on frame selector.
       * @param _frameSelector
       * @returns window or undefined
       */
      queryFrame: function (_frameSelector, failOk) {
        var rootWin = synchronizedWindow();
        if (!_frameSelector || _frameSelector === strings.SYNCHRONIZED_WINDOW) {
          return rootWin;
        }
        var changedDoc = false;
        // Setting the document now prevents "Permission denied" error in IE9
        queryEngine.setDocument(rootWin.document);
        var frameSelector = typeof _frameSelector === 'string' ? [_frameSelector] : _frameSelector;
        for (var i = frameSelector.length - 1; i >= 0; i--) {
          var nl = queryEngine(frameSelector[i], rootWin.document);
          //MIELE FIXUP
          if (nl.length === 0) {
            i--;
            if (i > 0) {
              nl = queryEngine(frameSelector[i], rootWin.document);
            }
          }
          if (nl.length === 0) {
            i++;
            if (changedDoc) {
              console.warn('Unable to locate frame: ' + frameSelector[0]);
              if (failOk) {
                return;
              } else {
                break;
              }
              break;
            } else {
              changedDoc = true;
              rootWin = window;
              i++;
              continue;
            }
          }
          rootWin = nl[0].contentWindow;
        }
        return rootWin;
      },
      queryShadowHost: function (_shadowHostSelector, frame) {
        frame = frame || synchronizedWindow();
        var shadowHost = frame;
        var shadowHostSelector = typeof _shadowHostSelector === 'string' ? [_shadowHostSelector] : _shadowHostSelector;
        for (var i = shadowHostSelector.length - 1; i >= 0; i--) {
          var nl = queryEngine(shadowHostSelector[i], shadowHost);
          if (nl.length) {
            shadowHost = nl[0].shadowRoot;
          }
        }
        return shadowHost;
      },
      escapeQuery: escapeQuery,
      isProtected: function (node) {
        return node && (node.type === 'password' || node.getAttribute && (node.getAttribute('data-protected') || node.getAttribute('sync-disabled')));
      },
      getImageForMap: function (mapNode) {
        var img;
        if (mapNode.name) {
          img = queryEngine('img[usemap=#' + mapNode.name + ']', mapNode.ownerDocument);
          if (img.length > 0) {
            return img[0];
          }
        }
        return null;
      },
      queryElement: function (selector) {
        var elementSelector = selector.element;
        var frameSelector = selector.frame;
        var frameName = selector.frameName;
        var windowName = selector.windowName;
        var shadow = selector.shadow;
        var nodeList, frameDoc = null;
        if (frameName) {
          var frame = this.getWindowFromFrameName(frameName);
          frameDoc = frame.document;
        } else if (frameSelector) {
          var frameWin = synchQuery.queryFrame(frameSelector);
          if (frameWin) {
            frameDoc = frameWin.document;
          }
        } else if (windowName) {
          frameDoc = this.getWindowFromFrameName(windowName);
          //window[windowName].document;
          if (frameDoc) {
            frameDoc = frameDoc.document;
          } else {
            console.warn('Unable to find window: ' + windowName + ' using default instead');
            frameDoc = synchronizedWindow().document;
          }
        } else {
          frameDoc = synchronizedWindow().document;
        }
        var shadowRoot;
        if (shadow) {
          shadowRoot = this.queryShadowHost(shadow, frameDoc);
          nodeList = queryEngine(elementSelector, shadowRoot);
        } else {
          nodeList = queryEngine(elementSelector, frameDoc);
        }
        if (nodeList && nodeList.length > 0) {
          if (nodeList.length === 1) {
            // Found
            return nodeList[0];
          }
          // Multiple possible elements
          console.warn('queryElement: Multiple possible elements for ' + elementSelector + ' List: ' + nodeList);
          return nodeList[0];
        }
        console.warn('queryElement: Unable to locate element with selector ' + elementSelector);
        return null;
      }
    };
    return synchQuery;
  }(synchronite_libs_sizzle, dojo__base_array, synchronite_constants_strings);
  synchronite__base_url = function (dojoLang, dojoString, array, DojoUrl, synchQuery, strings) {
    var contextWindow = window;
    var PROXIFICATION_DOT_REPLACEMENT = '---', DATA_MAIL_VOID_URL = /^\s*(\/\/|data|mailto):/i,
      // jshint ignore:line
      DATA_MAIL_VOID_JS_URL = /^\s*(\/\/|data|mailto|javascript):/i, JS_URL = /^\s*javascript:/i,
      // jshint ignore:line
      synchParams = [
        strings.PUBLISH,
        strings.TARGET_FRAME,
        strings.TARGET_PROTOCOL,
        strings.CACHE_KEY
      ], findDotReplacementRegex = new RegExp(PROXIFICATION_DOT_REPLACEMENT, 'ig'), X_FORWARDED_PORT = 'xforwardedport', X_FORWARDED_PROTOCOL = 'xforwardedproto';
    // jshint ignore:line
    ////////////////////////////////////
    // PRIVATE VARIABLES & FUNCTIONS
    ////////////////////////////////////
    var unproxifyHost = function (hostname, protocol) {
      // hostname
      var unproxiedHost = hostname.replace('.' + synchroniteConfig.proxyHost, '');
      // protocol
      if (/https/i.test(protocol)) {
        // also matches "https:"
        findDotReplacementRegex.lastIndex = 0;
        unproxiedHost = unproxiedHost.replace(findDotReplacementRegex, '.');
      }
      return unproxiedHost;
    };
    function isCrossDomainSrc(frame) {
      var srcProperty = frame.src;
      var frameSrc = frame.src;
      if (frameSrc && frameSrc.length && frameSrc.length > 5 && frameSrc.indexOf('http') >= 0) {
        var presenterProtocol;
        try {
          presenterProtocol = contextWindow.location.protocol;
        } catch (e) {
          return true;
        }
        if (frameSrc.indexOf(presenterProtocol) == -1) {
          //http https protocols do not match.
          console.warn('Found xss frame: ' + frame.src);
          return true;
        }
      }
      return !synchUrl.isProxified(srcProperty) || srcProperty === 'about:blank' || srcProperty === '';
    }
    var unproxifyPort = function (proxiedURL) {
      var re = new RegExp(X_FORWARDED_PORT + '-(\\d+)\\.([\\w\\d\\-\\.]+)', 'i');
      // /xforwardedport-(\d+)\.([\w\d\-\.]+)/i
      proxiedURL = proxiedURL.replace(re, '$2:$1');
      return proxiedURL;
    };
    var unproxifyUrl = function (url) {
        var unproxied;
        if (url && url !== 'about:blank') {
          // Added isProxifiedByHost because otherwise ports get lost
          // -> e.g. unproxifyUrl("http://www.example.com:8181/")
          // -> returned "http://www.example.com/"
          if (!isProxifiedByHost(url)) {
            return url;
          }
          var djUrl = new DojoUrl(url.toString());
          // hostname
          var unproxiedHost = unproxifyHost(djUrl.host, djUrl.scheme);
          // port
          unproxiedHost = unproxifyPort(unproxiedHost);
          if (unproxiedHost.split('.').length <= 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
            // Unusual case, where we use synchronite on the synchronite website:
            // test.synchronite.de/present/?targetURL=http://www.synchronite.de
            // maybe also on singleTenant on-premise deployments
            return url;
          }
          unproxied = djUrl.scheme + '://' + unproxiedHost;
          if (djUrl.path) {
            unproxied += djUrl.path;
          }
          if (djUrl.query) {
            unproxied += '?' + djUrl.query;
          }
          unproxied = synchUrl.removeSynchParams(unproxied);
          if (djUrl.fragment) {
            unproxied += '#' + djUrl.fragment;
          }  //console.info("unproxifyUrl: " +  url + " --> " + unproxied);
        }
        return unproxied;
      }, proxifyUrl = function (url, noQuery, context) {
        //summary: Reroutes URLs found in websites to point to synchronite proxy.
        //description: Rewrites "http://www.xample.com/a/b/c?q=test" to
        //  "http://www.example.com.SYNCHRONITE_PROXY_SERVER/a/b/c?q=test"
        if (url) {
          // FIXED: url might be the (proxied) location object.
          url = url.toString();
        }
        if (!isAbsolute(url) && url.indexOf('//') !== 0) {
          // only proxify absolute urls and protocol relative urls e.g. //www.google.de
          return url;
        }
        //url is already proxified
        if (isProxifiedByHost(url)) {
          return url;
        }
        // make sure url is absolute
        url = synchUrl.resolveURL(url, context);
        var djUrl = new DojoUrl(url);
        //case https://search.google.de.synchronite.de
        if (djUrl.scheme === 'https' && djUrl.host.indexOf(synchroniteConfig.proxyHost) !== -1) {
          var newUrl = djUrl.scheme + '://';
          newUrl += djUrl.host.replace('.' + synchroniteConfig.proxyHost, '');
          if (djUrl.path) {
            newUrl += djUrl.path;
          }
          if (djUrl.query) {
            newUrl += '?' + djUrl.query;
          }
          if (djUrl.fragment != null) {
            newUrl += '#' + djUrl.fragment;
          }
          djUrl = new DojoUrl(newUrl);
        }
        var proxifiedUrl = djUrl.host;
        // do not set explicitly if the following standard ports are used:
        // Port  80 - HTTP
        // Port 443 - HTTPS
        if (!(!djUrl.port || djUrl.port == 80 && djUrl.scheme === 'http' || djUrl.port == 443 && djUrl.scheme === 'https')) {
          proxifiedUrl = X_FORWARDED_PORT + '-' + djUrl.port + '.' + proxifiedUrl;
        }
        if (djUrl.scheme === 'https') {
          proxifiedUrl = proxifiedUrl.replace(/\./gi, PROXIFICATION_DOT_REPLACEMENT);
        }
        proxifiedUrl += '.' + synchroniteConfig.proxyHost;
        proxifiedUrl = djUrl.scheme + '://' + proxifiedUrl;
        if (djUrl.path) {
          proxifiedUrl += djUrl.path;
        }
        if (!noQuery) {
          if (djUrl.query) {
            proxifiedUrl += '?' + djUrl.query;
          }
        }
        // The fragment might be an empty string. In that case
        // we still need to set it.
        // e.g. http://www.example.com/#
        if (djUrl.fragment != null) {
          proxifiedUrl += '#' + djUrl.fragment;
        }
        return proxifiedUrl;
      }, isAbsolute = function (href) {
        return /^([a-z]+):\/\//.test(href);
      }, isProxifiedByHost = function (url) {
        // URL might be a location object so we need to stringify first
        var djUrl = new DojoUrl(url.toString());
        var host = djUrl.host;
        var path = djUrl.path;
        var scheme = djUrl.scheme;
        if (!host) {
          // relative url
          return false;
        }
        // returns de.wikipedia.org for de.wikipedia.org
        // returns www for www.synchronite.de
        // return www--example--org for https://www--example--org.synchronite.de
        var unproxiedHost = host.replace('.' + synchroniteConfig.proxyHost, '');
        if (unproxiedHost.split('.').length <= 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
          // www.synchronite.de
          return false;
        }
        if (scheme === 'https' && unproxiedHost.split('.').length > 1 && unproxiedHost.indexOf(PROXIFICATION_DOT_REPLACEMENT) === -1) {
          // return false for something like https://google.de.synchronite.de
          return false;
        }
        return host.indexOf('.' + synchroniteConfig.proxyHost) > 0 || path && path.indexOf('resync') === 0;
      }, dojoUrlToString = function (relobj) {
        var uri = [];
        if (relobj.scheme) {
          uri.push(relobj.scheme, ':');
        }
        if (relobj.authority) {
          uri.push('//', relobj.authority);
        }
        uri.push(relobj.path);
        if (relobj.query) {
          uri.push('?', relobj.query);
        }
        if (relobj.fragment) {
          uri.push('#', relobj.fragment);
        }
        return uri.join('');
      };
    ///////////////////////////////////////////////
    // PUBLIC PROPERTIES & METHODS
    //////////////////////////////////////////////
    var synchUrl = {
      dojoUrlToString: dojoUrlToString,
      unproxifyHost: unproxifyHost,
      isAbsolute: function (url) {
        return isAbsolute(url);
      },
      isProxified: function (url) {
        // summary: Checks if the url is absolute and proxified.
        return isProxifiedByHost(url);
      },
      toSynchroniteURL: function (url, noQuery, context) {
        //e.g. #p0 (jump within site)
        //        if (url.indexOf("#")==0) {
        //            return url;
        //        }
        //do not proxify data urls
        if (DATA_MAIL_VOID_JS_URL.test(url)) {
          return url;
        }
        url = proxifyUrl(url, noQuery, context);
        return url;
      },
      fromSynchroniteURL: unproxifyUrl,
      prependPath: function (url, path) {
        var djUrl = new DojoUrl(url);
        djUrl.path = '/' + path + djUrl.path;
        url = dojoUrlToString(djUrl);
        return url;
      },
      correctURL: function (url) {
        if (url) {
          url = url.replace(/(^\s+|\s+$)/g, '');
          //allow typing www.google.de instead of http://www.google.de
          if (url.indexOf('http') !== 0) {
            url = 'http://' + url;  //assume http
          }
        }
        return url;
      },
      addParam: function (url, name, value) {
        if (DATA_MAIL_VOID_JS_URL.test(url)) {
          return url;
        }
        var djUrl = new DojoUrl(url);
        var query = djUrl.query;
        if (query) {
          // The url contains query parameters
          var pairs = query.split('&');
          //like dojo.forEach, but can be cancelled with "return false;"
          var inQuery = array.some(pairs, function (pair, index) {
            // should be pair.indexOf(name) == 0) instead of >= 0
            // otherwise we get a false positive for
            // "cacheKey" in http://mozilla.github.io/pdf.js/web/viewer.html?file=http%3A%2F%2Fwww.selab.isti.cnr.it.my.synchronite.de%2Fws-mate%2Fexample.pdf%3FcacheKey%3D-1045444555%26noProxy%3Dtrue
            if (pair.indexOf(name) === 0) {
              //parameter already exists
              pairs[index] = name + '=' + value;
              djUrl.query = pairs.join('&');
              return true;
            }
          });
          if (!inQuery) {
            // The parameter is not yet part of the query
            //url = url + "&" + name + "=" + value;
            djUrl.query += '&' + name + '=' + value;
          }
        } else {
          //url = url + "?" + name + "=" + value;
          djUrl.query = name + '=' + value;
        }
        url = dojoUrlToString(djUrl);
        return url;
      },
      removeParam: function (url, parameter) {
        var urlparts = url.split('?');
        if (urlparts.length >= 2) {
          var prefix = encodeURIComponent(parameter) + '=';
          var pars = urlparts[1].split(/[&;]/g);
          for (var i = pars.length; i-- > 0;) {
            if (pars[i].lastIndexOf(prefix, 0) !== -1) {
              pars.splice(i, 1);
            }
          }
          if (pars.length > 0) {
            url = urlparts[0] + '?' + pars.join('&');
          } else {
            url = urlparts[0];
          }
        }
        return url;
      },
      getParam: function (url, name) {
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var keyValueRegExp = '[\\?&]' + name + '=([^&#]*)';
        var regex = new RegExp(keyValueRegExp);
        var results = regex.exec(url);
        if (results) {
          return results[1];
        } else {
          return '';
        }
      },
      getBaseUrl: function (contextWindow) {
        var contextDoc = contextWindow.document;
        var bases = contextDoc.getElementsByTagName('base');
        if (bases.length > 0) {
          var basehref = bases[0].getAttribute('href');
          if (basehref) {
            return basehref;
          }
        }
        if (contextDoc.baseURI) {
          var cleanURL = synchUrl.removeSynchParams(contextDoc.baseURI);
          return cleanURL;
        }
        console.debug('WARNING BASEURI NOT FOUND!');
        return this.fromSynchroniteURL(contextWindow.location.href);
      },
      getHostWithoutSubdomains: function () {
        var i = 0, domain = document.domain, p = domain.split('.'), s = '_gd' + new Date().getTime();
        while (i < p.length - 1 && document.cookie.indexOf(s + '=' + s) == -1) {
          domain = p.slice(-1 - ++i).join('.');
          document.cookie = s + '=' + s + ';domain=' + domain + ';';
        }
        document.cookie = s + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=' + domain + ';';
        return domain;
      },
      removeSynchParams: function (url) {
        for (var i = 0; i < synchParams.length; i++) {
          url = synchUrl.removeParam(url, synchParams[i]);
        }
        return url;
      },
      isHashOnly: function (absoluteUrlA, absoluteUrlB) {
        // summary: Checks if the only thing that changes is the hash tag which won't trigger
        //          a page reload.
        var i1, i2, partA, partB;
        if (absoluteUrlA && absoluteUrlB) {
          i1 = absoluteUrlA.indexOf('#');
          i2 = absoluteUrlB.indexOf('#');
          if (i1 == -1 && i2 == -1) {
            return false;
          }
          i1 = i1 >= 0 ? i1 : absoluteUrlA.length;
          i2 = i2 >= 0 ? i2 : absoluteUrlB.length;
          partA = absoluteUrlA.substring(0, i1);
          partB = absoluteUrlB.substring(0, i2);
          return partA === partB;
        }
        return false;
      },
      //qualify an HREF to form a complete URI
      resolveURL: function (href, contextOrWindow) {
        // FIXED: Cosmos Bug, where relative url with leading whitespace is assigned to window.location
        // Trim Whitespace from href
        if (typeof href === 'string') {
          href = dojoString.trim(href);
        }
        //Performance Optimization, check if URL is already qualified
        if (/^([a-z]+):\/\//.test(href)) {
          return href;
        }
        //look for a base element to use instead
        var here;
        // if the context argument is present and non-empty string, use that instead
        if (contextOrWindow) {
          if (dojoLang.isString(contextOrWindow)) {
            here = contextOrWindow;
          }
        } else {
          contextOrWindow = synchQuery.synchronizedWindow();
        }
        if (!here) {
          here = this.getBaseUrl(contextOrWindow);
          if (!here) {
            here = this.fromSynchroniteURL(contextOrWindow.location.href);
          }
        }
        //extract the protocol, host and path
        //and create a location object with the data
        var parts = here.replace('//', '/').split('/');
        var loc = {
          protocol: parts[0],
          host: parts[1]
        };
        //check if href is relative to protocol
        if (href.indexOf('//') === 0) {
          return loc.protocol + href;
        }
        var resolved = new DojoUrl(here, href).toString();
        //console.debug("Resolved URL: " + resolved);
        return resolved;  //            parts.splice(0, 2);
                          //            loc.pathname = "/" + parts.join("/");
                          //            //build a base URI from the protocol plus host (which includes port if applicable)
                          //            var uri = loc.protocol + "//" + loc.host;
                          //            //if the input path is relative-from-here
                          //            //just delete the ./ token to make it relative
                          //            if(/^(\.\/)([^\/]?)/.test(href))
                          //            {
                          //                href = href.replace(/^(\.\/)([^\/]?)/, "$2");
                          //            }
                          //
                          //            //if the input href is already qualified, copy it unchanged
                          //            if(/^([a-z]+)\:\/\//.test(href)) {
                          //                uri = href;
                          //            }
                          //            //or if the input href begins with a leading slash, then it"s base relative
                          //            //so just add the input href to the base URI
                          //            else if(href.substr(0, 1) == "/")
                          //            {
                          //                uri += href;
                          //            }
                          //            //or if it's an up-reference we need to compute the path
                          //            else if(/^((\.\.\/)+)([^\/].*$)/.test(href))
                          //            {
                          //                //get the last part of the path, minus up-references
                          //                var lastpath = href.match(/^((\.\.\/)+)([^\/].*$)/);
                          //                lastpath = lastpath[lastpath.length - 1];
                          //                //count the number of up-references
                          //                var references = href.split("../").length - 1;
                          //                //get the path parts and delete the last one (this page or directory)
                          //                parts = loc.pathname.split("/");
                          //                parts = parts.splice(0, parts.length - 1);
                          //                //for each of the up-references, delete the last part of the path
                          //                for(var i=0; i<references; i++)
                          //                {
                          //                    parts = parts.splice(0, parts.length - 1);
                          //                }
                          //                //now rebuild the path
                          //                var path = "";
                          //                for(i=0; i<parts.length; i++)
                          //                {
                          //                    if(parts[i] != "")
                          //                    {
                          //                        path += "/" + parts[i];
                          //                    }
                          //                }
                          //                path += "/";
                          //                //and add the last part of the path
                          //                path += lastpath;
                          //                //then add the path and input href to the base URI
                          //                uri += path;
                          //            }
                          //            else if (/^#/.test(href)) { //hash
                          //                var newloc = uri + loc.pathname + href;
                          //                return newloc;
                          //            } else { //otherwise it"s a relative path,
                          //
                          //                //calculate the path to this directory
                          //                path = "";
                          //                parts = loc.pathname.split("/");
                          //                parts = parts.splice(0, parts.length - 1);
                          //                for(var i=0; i<parts.length; i++)
                          //                {
                          //                    if(parts[i] != "")
                          //                    {
                          //                        path += "/" + parts[i];
                          //                    }
                          //                }
                          //                path += "/";
                          //                //then add the path and input href to the base URI
                          //                uri += path + href;
                          //            }
                          //            //return the final uri
                          //            return uri;
      },
      isCrossDomainSrc: isCrossDomainSrc
    };
    return synchUrl;
  }(dojo__base_lang, dojo_string, dojo__base_array, dojo__base_url, synchronite__base_query, synchronite_constants_strings);
  dojo__base_window = function (dojo, lang, has) {
    // module:
    //		dojo/_base/window
    var ret = {
      // summary:
      //		API to save/set/restore the global/document scope.
      global: dojo.global,
      /*=====
      global: {
       // summary:
       //		Alias for the current window. 'global' can be modified
       //		for temporary context shifting. See also withGlobal().
       // description:
       //		Use this rather than referring to 'window' to ensure your code runs
       //		correctly in managed contexts.
      },
      =====*/
      doc: dojo.global['document'] || null,
      /*=====
      	doc: {
      		// summary:
      		//		Alias for the current document. 'doc' can be modified
      		//		for temporary context shifting. See also withDoc().
      		// description:
      		//		Use this rather than referring to 'window.document' to ensure your code runs
      		//		correctly in managed contexts.
      		// example:
      		//	|	n.appendChild(dojo.doc.createElement('div'));
      	},
      	=====*/
      body: function (doc) {
        // summary:
        //		Return the body element of the specified document or of dojo/_base/window::doc.
        // example:
        //	|	win.body().appendChild(dojo.doc.createElement('div'));
        // Note: document.body is not defined for a strict xhtml document
        // Would like to memoize this, but dojo.doc can change vi dojo.withDoc().
        doc = doc || dojo.doc;
        return doc.body || doc.getElementsByTagName('body')[0];  // Node
      },
      setContext: function (globalObject, globalDocument) {
        // summary:
        //		changes the behavior of many core Dojo functions that deal with
        //		namespace and DOM lookup, changing them to work in a new global
        //		context (e.g., an iframe). The varibles dojo.global and dojo.doc
        //		are modified as a result of calling this function and the result of
        //		`dojo.body()` likewise differs.
        dojo.global = ret.global = globalObject;
        dojo.doc = ret.doc = globalDocument;
      },
      withGlobal: function (globalObject, callback, thisObject, cbArguments) {
        // summary:
        //		Invoke callback with globalObject as dojo.global and
        //		globalObject.document as dojo.doc.
        // description:
        //		Invoke callback with globalObject as dojo.global and
        //		globalObject.document as dojo.doc. If provided, globalObject
        //		will be executed in the context of object thisObject
        //		When callback() returns or throws an error, the dojo.global
        //		and dojo.doc will be restored to its previous state.
        var oldGlob = dojo.global;
        try {
          dojo.global = ret.global = globalObject;
          return ret.withDoc.call(null, globalObject.document, callback, thisObject, cbArguments);
        } finally {
          dojo.global = ret.global = oldGlob;
        }
      },
      withDoc: function (documentObject, callback, thisObject, cbArguments) {
        // summary:
        //		Invoke callback with documentObject as dojo/_base/window::doc.
        // description:
        //		Invoke callback with documentObject as dojo/_base/window::doc. If provided,
        //		callback will be executed in the context of object thisObject
        //		When callback() returns or throws an error, the dojo/_base/window::doc will
        //		be restored to its previous state.
        var oldDoc = ret.doc, oldQ = has('quirks'), oldIE = has('ie'), isIE, mode, pwin;
        try {
          dojo.doc = ret.doc = documentObject;
          // update dojo.isQuirks and the value of the has feature "quirks".
          // remove setting dojo.isQuirks and dojo.isIE for 2.0
          dojo.isQuirks = has.add('quirks', dojo.doc.compatMode == 'BackCompat', true, true);
          // no need to check for QuirksMode which was Opera 7 only
          if (has('ie')) {
            if ((pwin = documentObject.parentWindow) && pwin.navigator) {
              // re-run IE detection logic and update dojo.isIE / has("ie")
              // (the only time parentWindow/navigator wouldn't exist is if we were not
              // passed an actual legitimate document object)
              isIE = parseFloat(pwin.navigator.appVersion.split('MSIE ')[1]) || undefined;
              mode = documentObject.documentMode;
              if (mode && mode != 5 && Math.floor(isIE) != mode) {
                isIE = mode;
              }
              dojo.isIE = has.add('ie', isIE, true, true);
            }
          }
          if (thisObject && typeof callback == 'string') {
            callback = thisObject[callback];
          }
          return callback.apply(thisObject, cbArguments || []);
        } finally {
          dojo.doc = ret.doc = oldDoc;
          dojo.isQuirks = has.add('quirks', oldQ, true, true);
          dojo.isIE = has.add('ie', oldIE, true, true);
        }
      }
    };
    has('extend-dojo') && lang.mixin(dojo, ret);
    return ret;
  }(dojo__base_kernel, dojo__base_lang, dojo_sniff);
  dojo_dom = function (has, win) {
    // module:
    //		dojo/dom
    // FIXME: need to add unit tests for all the semi-public methods
    if (has('ie') <= 7) {
      try {
        document.execCommand('BackgroundImageCache', false, true);
      } catch (e) {
      }
    }
    // =============================
    // DOM Functions
    // =============================
    // the result object
    var dom = {};
    if (has('ie')) {
      dom.byId = function (id, doc) {
        if (typeof id != 'string') {
          return id;
        }
        var _d = doc || win.doc, te = id && _d.getElementById(id);
        // attributes.id.value is better than just id in case the
        // user has a name=id inside a form
        if (te && (te.attributes.id.value == id || te.id == id)) {
          return te;
        } else {
          var eles = _d.all[id];
          if (!eles || eles.nodeName) {
            eles = [eles];
          }
          // if more than 1, choose first with the correct id
          var i = 0;
          while (te = eles[i++]) {
            if (te.attributes && te.attributes.id && te.attributes.id.value == id || te.id == id) {
              return te;
            }
          }
        }
      };
    } else {
      dom.byId = function (id, doc) {
        // inline'd type check.
        // be sure to return null per documentation, to match IE branch.
        return (typeof id == 'string' ? (doc || win.doc).getElementById(id) : id) || null;  // DOMNode
      };
    }
    /*=====
    dom.byId = function(id, doc){
    // summary:
    //		Returns DOM node with matching `id` attribute or falsy value (ex: null or undefined)
    //		if not found.  If `id` is a DomNode, this function is a no-op.
    //
    // id: String|DOMNode
    //		A string to match an HTML id attribute or a reference to a DOM Node
    //
    // doc: Document?
    //		Document to work in. Defaults to the current value of
    //		dojo/_base/window.doc.  Can be used to retrieve
    //		node references from other documents.
    //
    // example:
    //		Look up a node by ID:
    //	|	require(["dojo/dom"], function(dom){
    //	|		var n = dom.byId("foo");
    //	|	});
    //
    // example:
    //		Check if a node exists, and use it.
    //	|	require(["dojo/dom"], function(dom){
    //	|		var n = dom.byId("bar");
    //	|		if(n){ doStuff() ... }
    //	|	});
    //
    // example:
    //		Allow string or DomNode references to be passed to a custom function:
    //	|	require(["dojo/dom"], function(dom){
    //	|		var foo = function(nodeOrId){
    //	|			nodeOrId = dom.byId(nodeOrId);
    //	|			// ... more stuff
    //	|		}
    //	|	});
    };
    =====*/
    dom.isDescendant = function (node, ancestor) {
      // summary:
      //		Returns true if node is a descendant of ancestor
      // node: DOMNode|String
      //		string id or node reference to test
      // ancestor: DOMNode|String
      //		string id or node reference of potential parent to test against
      //
      // example:
      //		Test is node id="bar" is a descendant of node id="foo"
      //	|	require(["dojo/dom"], function(dom){
      //	|		if(dom.isDescendant("bar", "foo")){ ... }
      //	|	});
      try {
        node = dom.byId(node);
        ancestor = dom.byId(ancestor);
        while (node) {
          if (node == ancestor) {
            return true;  // Boolean
          }
          node = node.parentNode;
        }
      } catch (e) {
      }
      return false;  // Boolean
    };
    // TODO: do we need setSelectable in the base?
    // Add feature test for user-select CSS property
    // (currently known to work in all but IE < 10 and Opera)
    // TODO: The user-select CSS property as of May 2014 is no longer part of
    // any CSS specification. In IE, -ms-user-select does not do the same thing
    // as the unselectable attribute on elements; namely, dijit Editor buttons
    // do not properly prevent the content of the editable content frame from
    // unblurring. As a result, the -ms- prefixed version is omitted here.
    has.add('css-user-select', function (global, doc, element) {
      // Avoid exception when dom.js is loaded in non-browser environments
      if (!element) {
        return false;
      }
      var style = element.style;
      var prefixes = [
          'Khtml',
          'O',
          'Moz',
          'Webkit'
        ], i = prefixes.length, name = 'userSelect', prefix;
      // Iterate prefixes from most to least likely
      do {
        if (typeof style[name] !== 'undefined') {
          // Supported; return property name
          return name;
        }
      } while (i-- && (name = prefixes[i] + 'UserSelect'));
      // Not supported if we didn't return before now
      return false;
    });
    /*=====
    	dom.setSelectable = function(node, selectable){
    		// summary:
    		//		Enable or disable selection on a node
    		// node: DOMNode|String
    		//		id or reference to node
    		// selectable: Boolean
    		//		state to put the node in. false indicates unselectable, true
    		//		allows selection.
    		// example:
    		//		Make the node id="bar" unselectable
    		//	|	require(["dojo/dom"], function(dom){
    		//	|		dom.setSelectable("bar");
    		//	|	});
    		// example:
    		//		Make the node id="bar" selectable
    		//	|	require(["dojo/dom"], function(dom){
    		//	|		dom.setSelectable("bar", true);
    		//	|	});
    	};
    	=====*/
    var cssUserSelect = has('css-user-select');
    dom.setSelectable = cssUserSelect ? function (node, selectable) {
      // css-user-select returns a (possibly vendor-prefixed) CSS property name
      dom.byId(node).style[cssUserSelect] = selectable ? '' : 'none';
    } : function (node, selectable) {
      node = dom.byId(node);
      // (IE < 10 / Opera) Fall back to setting/removing the
      // unselectable attribute on the element and all its children
      var nodes = node.getElementsByTagName('*'), i = nodes.length;
      if (selectable) {
        node.removeAttribute('unselectable');
        while (i--) {
          nodes[i].removeAttribute('unselectable');
        }
      } else {
        node.setAttribute('unselectable', 'on');
        while (i--) {
          nodes[i].setAttribute('unselectable', 'on');
        }
      }
    };
    return dom;
  }(dojo_sniff, dojo__base_window);
  dojo_on = function (aspect, dojo, has) {
    if (true) {
      // check to make sure we are in a browser, this module should work anywhere
      var major = window.ScriptEngineMajorVersion;
      has.add('jscript', major && major() + ScriptEngineMinorVersion() / 10);
      has.add('event-orientationchange', has('touch') && !has('android'));
      // TODO: how do we detect this?
      has.add('event-stopimmediatepropagation', window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);
      has.add('event-focusin', function (global, doc, element) {
        return 'onfocusin' in element;
      });
      if (has('touch')) {
        has.add('touch-can-modify-event-delegate', function () {
          // This feature test checks whether deleting a property of an event delegate works
          // for a touch-enabled device. If it works, event delegation can be used as fallback
          // for browsers such as Safari in older iOS where deleting properties of the original
          // event does not work.
          var EventDelegate = function () {
          };
          EventDelegate.prototype = document.createEvent('MouseEvents');
          // original event
          // Attempt to modify a property of an event delegate and check if
          // it succeeds. Depending on browsers and on whether dojo/on's
          // strict mode is stripped in a Dojo build, there are 3 known behaviors:
          // it may either succeed, or raise an error, or fail to set the property
          // without raising an error.
          try {
            var eventDelegate = new EventDelegate();
            eventDelegate.target = null;
            return eventDelegate.target === null;
          } catch (e) {
            return false;
          }
        });
      }
    }
    var on = function (target, type, listener, dontFix) {
      // summary:
      //		A function that provides core event listening functionality. With this function
      //		you can provide a target, event type, and listener to be notified of
      //		future matching events that are fired.
      // target: Element|Object
      //		This is the target object or DOM element that to receive events from
      // type: String|Function
      //		This is the name of the event to listen for or an extension event type.
      // listener: Function
      //		This is the function that should be called when the event fires.
      // returns: Object
      //		An object with a remove() method that can be used to stop listening for this
      //		event.
      // description:
      //		To listen for "click" events on a button node, we can do:
      //		|	define(["dojo/on"], function(listen){
      //		|		on(button, "click", clickHandler);
      //		|		...
      //		Evented JavaScript objects can also have their own events.
      //		|	var obj = new Evented;
      //		|	on(obj, "foo", fooHandler);
      //		And then we could publish a "foo" event:
      //		|	on.emit(obj, "foo", {key: "value"});
      //		We can use extension events as well. For example, you could listen for a tap gesture:
      //		|	define(["dojo/on", "dojo/gesture/tap", function(listen, tap){
      //		|		on(button, tap, tapHandler);
      //		|		...
      //		which would trigger fooHandler. Note that for a simple object this is equivalent to calling:
      //		|	obj.onfoo({key:"value"});
      //		If you use on.emit on a DOM node, it will use native event dispatching when possible.
      if (typeof target.on == 'function' && typeof type != 'function' && !target.nodeType) {
        // delegate to the target's on() method, so it can handle it's own listening if it wants (unless it
        // is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the
        // Element prototype
        return target.on(type, listener);
      }
      // delegate to main listener code
      return on.parse(target, type, listener, addListener, dontFix, this);
    };
    on.pausable = function (target, type, listener, dontFix) {
      // summary:
      //		This function acts the same as on(), but with pausable functionality. The
      //		returned signal object has pause() and resume() functions. Calling the
      //		pause() method will cause the listener to not be called for future events. Calling the
      //		resume() method will cause the listener to again be called for future events.
      var paused;
      var signal = on(target, type, function () {
        if (!paused) {
          return listener.apply(this, arguments);
        }
      }, dontFix);
      signal.pause = function () {
        paused = true;
      };
      signal.resume = function () {
        paused = false;
      };
      return signal;
    };
    on.once = function (target, type, listener, dontFix) {
      // summary:
      //		This function acts the same as on(), but will only call the listener once. The
      //		listener will be called for the first
      //		event that takes place and then listener will automatically be removed.
      var signal = on(target, type, function () {
        // remove this listener
        signal.remove();
        // proceed to call the listener
        return listener.apply(this, arguments);
      });
      return signal;
    };
    on.parse = function (target, type, listener, addListener, dontFix, matchesTarget) {
      if (type.call) {
        // event handler function
        // on(node, touch.press, touchListener);
        return type.call(matchesTarget, target, listener);
      }
      if (type instanceof Array) {
        // allow an array of event names (or event handler functions)
        events = type;
      } else if (type.indexOf(',') > -1) {
        // we allow comma delimited event names, so you can register for multiple events at once
        var events = type.split(/\s*,\s*/);
      }
      if (events) {
        var handles = [];
        var i = 0;
        var eventName;
        while (eventName = events[i++]) {
          handles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));
        }
        handles.remove = function () {
          for (var i = 0; i < handles.length; i++) {
            handles[i].remove();
          }
        };
        return handles;
      }
      return addListener(target, type, listener, dontFix, matchesTarget);
    };
    var touchEvents = /^touch/;
    function addListener(target, type, listener, dontFix, matchesTarget) {
      // event delegation:
      var selector = type.match(/(.*):(.*)/);
      // if we have a selector:event, the last one is interpreted as an event, and we use event delegation
      if (selector) {
        type = selector[2];
        selector = selector[1];
        // create the extension event for selectors and directly call it
        return on.selector(selector, type).call(matchesTarget, target, listener);
      }
      // test to see if it a touch event right now, so we don't have to do it every time it fires
      if (has('touch')) {
        if (touchEvents.test(type)) {
          // touch event, fix it
          listener = fixTouchListener(listener);
        }
        if (!has('event-orientationchange') && type == 'orientationchange') {
          //"orientationchange" not supported <= Android 2.1,
          //but works through "resize" on window
          type = 'resize';
          target = window;
          listener = fixTouchListener(listener);
        }
      }
      if (addStopImmediate) {
        // add stopImmediatePropagation if it doesn't exist
        listener = addStopImmediate(listener);
      }
      // normal path, the target is |this|
      if (target.addEventListener) {
        // the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)
        // check for capture conversions
        var capture = type in captures, adjustedType = capture ? captures[type] : type;
        target.addEventListener(adjustedType, listener, capture);
        // create and return the signal
        return {
          remove: function () {
            target.removeEventListener(adjustedType, listener, capture);
          }
        };
      }
      type = 'on' + type;
      if (fixAttach && target.attachEvent) {
        return fixAttach(target, type, listener);
      }
      throw new Error('Target must be an event emitter');
    }
    on.matches = function (node, selector, context, children, matchesTarget) {
      // summary:
      //		Check if a node match the current selector within the constraint of a context
      // node: DOMNode
      //		The node that originate the event
      // selector: String
      //		The selector to check against
      // context: DOMNode
      //		The context to search in.
      // children: Boolean
      //		Indicates if children elements of the selector should be allowed. This defaults to
      //		true
      // matchesTarget: Object|dojo/query?
      //		An object with a property "matches" as a function. Default is dojo/query.
      //		Matching DOMNodes will be done against this function
      //		The function must return a Boolean.
      //		It will have 3 arguments: "node", "selector" and "context"
      //		True is expected if "node" is matching the current "selector" in the passed "context"
      // returns: DOMNode?
      //		The matching node, if any. Else you get false
      // see if we have a valid matchesTarget or default to dojo/query
      matchesTarget = matchesTarget && matchesTarget.matches ? matchesTarget : dojo.query;
      children = children !== false;
      // there is a selector, so make sure it matches
      if (node.nodeType != 1) {
        // text node will fail in native match selector
        node = node.parentNode;
      }
      while (!matchesTarget.matches(node, selector, context)) {
        if (node == context || children === false || !(node = node.parentNode) || node.nodeType != 1) {
          // intentional assignment
          return false;
        }
      }
      return node;
    };
    on.selector = function (selector, eventType, children) {
      // summary:
      //		Creates a new extension event with event delegation. This is based on
      //		the provided event type (can be extension event) that
      //		only calls the listener when the CSS selector matches the target of the event.
      //
      //		The application must require() an appropriate level of dojo/query to handle the selector.
      // selector:
      //		The CSS selector to use for filter events and determine the |this| of the event listener.
      // eventType:
      //		The event to listen for
      // children:
      //		Indicates if children elements of the selector should be allowed. This defaults to
      //		true
      // example:
      // |	require(["dojo/on", "dojo/mouse", "dojo/query!css2"], function(listen, mouse){
      // |		on(node, on.selector(".my-class", mouse.enter), handlerForMyHover);
      return function (target, listener) {
        // if the selector is function, use it to select the node, otherwise use the matches method
        var matchesTarget = typeof selector == 'function' ? { matches: selector } : this, bubble = eventType.bubble;
        function select(eventTarget) {
          return on.matches(eventTarget, selector, target, children, matchesTarget);
        }
        if (bubble) {
          // the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself
          return on(target, bubble(select), listener);
        }
        // standard event delegation
        return on(target, eventType, function (event) {
          // call select to see if we match
          var eventTarget = select(event.target);
          // if it matches we call the listener
          if (eventTarget) {
            return listener.call(eventTarget, event);
          }
        });
      };
    };
    function syntheticPreventDefault() {
      this.cancelable = false;
      this.defaultPrevented = true;
    }
    function syntheticStopPropagation() {
      this.bubbles = false;
    }
    var slice = [].slice, syntheticDispatch = on.emit = function (target, type, event) {
        // summary:
        //		Fires an event on the target object.
        // target:
        //		The target object to fire the event on. This can be a DOM element or a plain
        //		JS object. If the target is a DOM element, native event emitting mechanisms
        //		are used when possible.
        // type:
        //		The event type name. You can emulate standard native events like "click" and
        //		"mouseover" or create custom events like "open" or "finish".
        // event:
        //		An object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent
        //		for some of the properties. These properties are copied to the event object.
        //		Of particular importance are the cancelable and bubbles properties. The
        //		cancelable property indicates whether or not the event has a default action
        //		that can be cancelled. The event is cancelled by calling preventDefault() on
        //		the event object. The bubbles property indicates whether or not the
        //		event will bubble up the DOM tree. If bubbles is true, the event will be called
        //		on the target and then each parent successively until the top of the tree
        //		is reached or stopPropagation() is called. Both bubbles and cancelable
        //		default to false.
        // returns:
        //		If the event is cancelable and the event is not cancelled,
        //		emit will return true. If the event is cancelable and the event is cancelled,
        //		emit will return false.
        // details:
        //		Note that this is designed to emit events for listeners registered through
        //		dojo/on. It should actually work with any event listener except those
        //		added through IE's attachEvent (IE8 and below's non-W3C event emitting
        //		doesn't support custom event types). It should work with all events registered
        //		through dojo/on. Also note that the emit method does do any default
        //		action, it only returns a value to indicate if the default action should take
        //		place. For example, emitting a keypress event would not cause a character
        //		to appear in a textbox.
        // example:
        //		To fire our own click event
        //	|	require(["dojo/on", "dojo/dom"
        //	|	], function(on, dom){
        //	|		on.emit(dom.byId("button"), "click", {
        //	|			cancelable: true,
        //	|			bubbles: true,
        //	|			screenX: 33,
        //	|			screenY: 44
        //	|		});
        //		We can also fire our own custom events:
        //	|		on.emit(dom.byId("slider"), "slide", {
        //	|			cancelable: true,
        //	|			bubbles: true,
        //	|			direction: "left-to-right"
        //	|		});
        //	|	});
        var args = slice.call(arguments, 2);
        var method = 'on' + type;
        if ('parentNode' in target) {
          // node (or node-like), create event controller methods
          var newEvent = args[0] = {};
          for (var i in event) {
            newEvent[i] = event[i];
          }
          newEvent.preventDefault = syntheticPreventDefault;
          newEvent.stopPropagation = syntheticStopPropagation;
          newEvent.target = target;
          newEvent.type = type;
          event = newEvent;
        }
        do {
          // call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)
          target[method] && target[method].apply(target, args);  // and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)
        } while (event && event.bubbles && (target = target.parentNode));
        return event && event.cancelable && event;  // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen
      };
    var captures = has('event-focusin') ? {} : {
      focusin: 'focus',
      focusout: 'blur'
    };
    if (!has('event-stopimmediatepropagation')) {
      var stopImmediatePropagation = function () {
        this.immediatelyStopped = true;
        this.modified = true;  // mark it as modified so the event will be cached in IE
      };
      var addStopImmediate = function (listener) {
        return function (event) {
          if (!event.immediatelyStopped) {
            // check to make sure it hasn't been stopped immediately
            event.stopImmediatePropagation = stopImmediatePropagation;
            return listener.apply(this, arguments);
          }
        };
      };
    }
    if (has('dom-addeventlistener')) {
      // emitter that works with native event handling
      on.emit = function (target, type, event) {
        if (target.dispatchEvent && document.createEvent) {
          // use the native event emitting mechanism if it is available on the target object
          // create a generic event
          // we could create branch into the different types of event constructors, but
          // that would be a lot of extra code, with little benefit that I can see, seems
          // best to use the generic constructor and copy properties over, making it
          // easy to have events look like the ones created with specific initializers
          var ownerDocument = target.ownerDocument || document;
          var nativeEvent = ownerDocument.createEvent('HTMLEvents');
          nativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);
          // and copy all our properties over
          for (var i in event) {
            if (!(i in nativeEvent)) {
              nativeEvent[i] = event[i];
            }
          }
          return target.dispatchEvent(nativeEvent) && nativeEvent;
        }
        return syntheticDispatch.apply(on, arguments);  // emit for a non-node
      };
    } else {
      // no addEventListener, basically old IE event normalization
      on._fixEvent = function (evt, sender) {
        // summary:
        //		normalizes properties on the event object including event
        //		bubbling methods, keystroke normalization, and x/y positions
        // evt:
        //		native event object
        // sender:
        //		node to treat as "currentTarget"
        if (!evt) {
          var w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;
          evt = w.event;
        }
        if (!evt) {
          return evt;
        }
        try {
          if (lastEvent && evt.type == lastEvent.type && evt.srcElement == lastEvent.target) {
            // should be same event, reuse event object (so it can be augmented);
            // accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below
            evt = lastEvent;
          }
        } catch (e) {
        }
        if (!evt.target) {
          // check to see if it has been fixed yet
          evt.target = evt.srcElement;
          evt.currentTarget = sender || evt.srcElement;
          if (evt.type == 'mouseover') {
            evt.relatedTarget = evt.fromElement;
          }
          if (evt.type == 'mouseout') {
            evt.relatedTarget = evt.toElement;
          }
          if (!evt.stopPropagation) {
            evt.stopPropagation = stopPropagation;
            evt.preventDefault = preventDefault;
          }
          switch (evt.type) {
          case 'keypress':
            var c = 'charCode' in evt ? evt.charCode : evt.keyCode;
            if (c == 10) {
              // CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla
              c = 0;
              evt.keyCode = 13;
            } else if (c == 13 || c == 27) {
              c = 0;  // Mozilla considers ENTER and ESC non-printable
            } else if (c == 3) {
              c = 99;  // Mozilla maps CTRL-BREAK to CTRL-c
            }
            // Mozilla sets keyCode to 0 when there is a charCode
            // but that stops the event on IE.
            evt.charCode = c;
            _setKeyChar(evt);
            break;
          }
        }
        return evt;
      };
      var lastEvent, IESignal = function (handle) {
          this.handle = handle;
        };
      IESignal.prototype.remove = function () {
        delete _dojoIEListeners_[this.handle];
      };
      var fixListener = function (listener) {
        // this is a minimal function for closing on the previous listener with as few as variables as possible
        return function (evt) {
          evt = on._fixEvent(evt, this);
          var result = listener.call(this, evt);
          if (evt.modified) {
            // cache the last event and reuse it if we can
            if (!lastEvent) {
              setTimeout(function () {
                lastEvent = null;
              });
            }
            lastEvent = evt;
          }
          return result;
        };
      };
      var fixAttach = function (target, type, listener) {
        listener = fixListener(listener);
        if (((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top || has('jscript') < 5.8) && !has('config-_allow_leaks')) {
          // IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.
          // Here we use global redirection to solve the memory leaks
          if (typeof _dojoIEListeners_ == 'undefined') {
            _dojoIEListeners_ = [];
          }
          var emitter = target[type];
          if (!emitter || !emitter.listeners) {
            var oldListener = emitter;
            emitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');
            emitter.listeners = [];
            target[type] = emitter;
            emitter.global = this;
            if (oldListener) {
              emitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);
            }
          }
          var handle;
          emitter.listeners.push(handle = emitter.global._dojoIEListeners_.push(listener) - 1);
          return new IESignal(handle);
        }
        return aspect.after(target, type, listener, true);
      };
      var _setKeyChar = function (evt) {
        evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
        evt.charOrCode = evt.keyChar || evt.keyCode;  // TODO: remove for 2.0
      };
      // Called in Event scope
      var stopPropagation = function () {
        this.cancelBubble = true;
      };
      var preventDefault = on._preventDefault = function () {
        // Setting keyCode to 0 is the only way to prevent certain keypresses (namely
        // ctrl-combinations that correspond to menu accelerator keys).
        // Otoh, it prevents upstream listeners from getting this information
        // Try to split the difference here by clobbering keyCode only for ctrl
        // combinations. If you still need to access the key upstream, bubbledKeyCode is
        // provided as a workaround.
        this.bubbledKeyCode = this.keyCode;
        if (this.ctrlKey) {
          try {
            // squelch errors when keyCode is read-only
            // (e.g. if keyCode is ctrl or shift)
            this.keyCode = 0;
          } catch (e) {
          }
        }
        this.defaultPrevented = true;
        this.returnValue = false;
        this.modified = true;  // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE
      };
    }
    if (has('touch')) {
      var EventDelegate = function () {
      };
      var windowOrientation = window.orientation;
      var fixTouchListener = function (listener) {
        return function (originalEvent) {
          //Event normalization(for ontouchxxx and resize):
          //1.incorrect e.pageX|pageY in iOS
          //2.there are no "e.rotation", "e.scale" and "onorientationchange" in Android
          //3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY
          // see if it has already been corrected
          var event = originalEvent.corrected;
          if (!event) {
            var type = originalEvent.type;
            try {
              delete originalEvent.type;  // on some JS engines (android), deleting properties makes them mutable
            } catch (e) {
            }
            if (originalEvent.type) {
              // Deleting the property of the original event did not work (this is the case of
              // browsers such as older Safari iOS), hence fallback:
              if (has('touch-can-modify-event-delegate')) {
                // If deleting properties of delegated event works, use event delegation:
                EventDelegate.prototype = originalEvent;
                event = new EventDelegate();
              } else {
                // Otherwise last fallback: other browsers, such as mobile Firefox, do not like
                // delegated properties, so we have to copy
                event = {};
                for (var name in originalEvent) {
                  event[name] = originalEvent[name];
                }
              }
              // have to delegate methods to make them work
              event.preventDefault = function () {
                originalEvent.preventDefault();
              };
              event.stopPropagation = function () {
                originalEvent.stopPropagation();
              };
            } else {
              // deletion worked, use property as is
              event = originalEvent;
              event.type = type;
            }
            originalEvent.corrected = event;
            if (type == 'resize') {
              if (windowOrientation == window.orientation) {
                return null;  //double tap causes an unexpected 'resize' in Android
              }
              windowOrientation = window.orientation;
              event.type = 'orientationchange';
              return listener.call(this, event);
            }
            // We use the original event and augment, rather than doing an expensive mixin operation
            if (!('rotation' in event)) {
              // test to see if it has rotation
              event.rotation = 0;
              event.scale = 1;
            }
            //use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target
            var firstChangeTouch = event.changedTouches[0];
            for (var i in firstChangeTouch) {
              // use for-in, we don't need to have dependency on dojo/_base/lang here
              delete event[i];
              // delete it first to make it mutable
              event[i] = firstChangeTouch[i];
            }
          }
          return listener.call(this, event);
        };
      };
    }
    return on;
  }(dojo_aspect, dojo__base_kernel, dojo_sniff);
  dojo_selector__loader = function (has, sizzle) {
    // PATCH START
    has.add('dom-qsa2.1', function (global, doc, element) {
      return !!element.querySelectorAll;
    });
    has.add('dom-qsa3', function (global, doc, element) {
      // test to see if we have a reasonable native selector engine available
      try {
        element.innerHTML = '<p class=\'TEST\'></p>';
        // test kind of from sizzle
        // Safari can't handle uppercase or unicode characters when
        // in quirks mode, IE8 can't handle pseudos like :empty
        return element.querySelectorAll('.TEST:empty').length == 1;
      } catch (e) {
      }
    });
    // PATCH END (COMPAT WITH REQUIREJS)
    return {
      // summary:
      //		This module handles loading the appropriate selector engine for the given browser
      load: function (id, parentRequire, loaded, config) {
        loaded(sizzle);
      }
    };
  }(dojo_has, synchronite_libs_sizzle);
  dojo_query = function (dojo, has, dom, on, array, lang, loader, defaultEngine) {
    has.add('array-extensible', function () {
      // test to see if we can extend an array (not supported in old IE)
      return lang.delegate([], { length: 1 }).length == 1 && !has('bug-for-in-skips-shadowed');
    });
    var ap = Array.prototype, aps = ap.slice, apc = ap.concat, forEach = array.forEach;
    var tnl = function (a, parent, NodeListCtor) {
      // summary:
      //		decorate an array to make it look like a `dojo/NodeList`.
      // a:
      //		Array of nodes to decorate.
      // parent:
      //		An optional parent NodeList that generated the current
      //		list of nodes. Used to call _stash() so the parent NodeList
      //		can be accessed via end() later.
      // NodeListCtor:
      //		An optional constructor function to use for any
      //		new NodeList calls. This allows a certain chain of
      //		NodeList calls to use a different object than dojo/NodeList.
      var nodeList = new (NodeListCtor || this._NodeListCtor || nl)(a);
      return parent ? nodeList._stash(parent) : nodeList;
    };
    var loopBody = function (f, a, o) {
      a = [0].concat(aps.call(a, 0));
      o = o || dojo.global;
      return function (node) {
        a[0] = node;
        return f.apply(o, a);
      };
    };
    // adapters
    var adaptAsForEach = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the forEach-type
      //		actions. The initial object is returned from the specialized
      //		function.
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        this.forEach(loopBody(f, arguments, o));
        return this;  // Object
      };
    };
    var adaptAsMap = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the map-type
      //		actions. The return is a new array of values, as via `dojo/_base/array.map`
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        return this.map(loopBody(f, arguments, o));
      };
    };
    var adaptAsFilter = function (f, o) {
      // summary:
      //		adapts a single node function to be used in the filter-type actions
      // f: Function
      //		a function to adapt
      // o: Object?
      //		an optional context for f
      return function () {
        return this.filter(loopBody(f, arguments, o));
      };
    };
    var adaptWithCondition = function (f, g, o) {
      // summary:
      //		adapts a single node function to be used in the map-type
      //		actions, behaves like forEach() or map() depending on arguments
      // f: Function
      //		a function to adapt
      // g: Function
      //		a condition function, if true runs as map(), otherwise runs as forEach()
      // o: Object?
      //		an optional context for f and g
      return function () {
        var a = arguments, body = loopBody(f, a, o);
        if (g.call(o || dojo.global, a)) {
          return this.map(body);  // self
        }
        this.forEach(body);
        return this;  // self
      };
    };
    var NodeList = function (array) {
      // summary:
      //		Array-like object which adds syntactic
      //		sugar for chaining, common iteration operations, animation, and
      //		node manipulation. NodeLists are most often returned as the
      //		result of dojo/query() calls.
      // description:
      //		NodeList instances provide many utilities that reflect
      //		core Dojo APIs for Array iteration and manipulation, DOM
      //		manipulation, and event handling. Instead of needing to dig up
      //		functions in the dojo package, NodeLists generally make the
      //		full power of Dojo available for DOM manipulation tasks in a
      //		simple, chainable way.
      // example:
      //		create a node list from a node
      //		|	require(["dojo/query", "dojo/dom"
      //		|	], function(query, dom){
      //		|		query.NodeList(dom.byId("foo"));
      //		|	});
      // example:
      //		get a NodeList from a CSS query and iterate on it
      //		|	require(["dojo/on", "dojo/dom"
      //		|	], function(on, dom){
      //		|		var l = query(".thinger");
      //		|		l.forEach(function(node, index, nodeList){
      //		|			console.log(index, node.innerHTML);
      //		|		});
      //		|	});
      // example:
      //		use native and Dojo-provided array methods to manipulate a
      //		NodeList without needing to use dojo.* functions explicitly:
      //		|	require(["dojo/query", "dojo/dom-construct", "dojo/dom"
      //		|	], function(query, domConstruct, dom){
      //		|		var l = query(".thinger");
      //		|		// since NodeLists are real arrays, they have a length
      //		|		// property that is both readable and writable and
      //		|		// push/pop/shift/unshift methods
      //		|		console.log(l.length);
      //		|		l.push(domConstruct.create("span"));
      //		|
      //		|		// dojo's normalized array methods work too:
      //		|		console.log( l.indexOf(dom.byId("foo")) );
      //		|		// ...including the special "function as string" shorthand
      //		|		console.log( l.every("item.nodeType == 1") );
      //		|
      //		|		// NodeLists can be [..] indexed, or you can use the at()
      //		|		// function to get specific items wrapped in a new NodeList:
      //		|		var node = l[3]; // the 4th element
      //		|		var newList = l.at(1, 3); // the 2nd and 4th elements
      //		|	});
      // example:
      //		chainability is a key advantage of NodeLists:
      //		|	require(["dojo/query", "dojo/NodeList-dom"
      //		|	], function(query){
      //		|		query(".thinger")
      //		|			.onclick(function(e){ /* ... */ })
      //		|			.at(1, 3, 8) // get a subset
      //		|				.style("padding", "5px")
      //		|				.forEach(console.log);
      //		|	});
      var isNew = this instanceof nl && has('array-extensible');
      if (typeof array == 'number') {
        array = Array(array);
      }
      var nodeArray = array && 'length' in array ? array : arguments;
      if (isNew || !nodeArray.sort) {
        // make sure it's a real array before we pass it on to be wrapped 
        var target = isNew ? this : [], l = target.length = nodeArray.length;
        for (var i = 0; i < l; i++) {
          target[i] = nodeArray[i];
        }
        if (isNew) {
          // called with new operator, this means we are going to use this instance and push
          // the nodes on to it. This is usually much faster since the NodeList properties
          //	don't need to be copied (unless the list of nodes is extremely large).
          return target;
        }
        nodeArray = target;
      }
      // called without new operator, use a real array and copy prototype properties,
      // this is slower and exists for back-compat. Should be removed in 2.0.
      lang._mixin(nodeArray, nlp);
      nodeArray._NodeListCtor = function (array) {
        // call without new operator to preserve back-compat behavior
        return nl(array);
      };
      return nodeArray;
    };
    var nl = NodeList, nlp = nl.prototype = has('array-extensible') ? [] : {};
    // extend an array if it is extensible
    // expose adapters and the wrapper as private functions
    nl._wrap = nlp._wrap = tnl;
    nl._adaptAsMap = adaptAsMap;
    nl._adaptAsForEach = adaptAsForEach;
    nl._adaptAsFilter = adaptAsFilter;
    nl._adaptWithCondition = adaptWithCondition;
    // mass assignment
    // add array redirectors
    forEach([
      'slice',
      'splice'
    ], function (name) {
      var f = ap[name];
      //Use a copy of the this array via this.slice() to allow .end() to work right in the splice case.
      // CANNOT apply ._stash()/end() to splice since it currently modifies
      // the existing this array -- it would break backward compatibility if we copy the array before
      // the splice so that we can use .end(). So only doing the stash option to this._wrap for slice.
      nlp[name] = function () {
        return this._wrap(f.apply(this, arguments), name == 'slice' ? this : null);
      };
    });
    // concat should be here but some browsers with native NodeList have problems with it
    // add array.js redirectors
    forEach([
      'indexOf',
      'lastIndexOf',
      'every',
      'some'
    ], function (name) {
      var f = array[name];
      nlp[name] = function () {
        return f.apply(dojo, [this].concat(aps.call(arguments, 0)));
      };
    });
    lang.extend(NodeList, {
      // copy the constructors
      constructor: nl,
      _NodeListCtor: nl,
      toString: function () {
        // Array.prototype.toString can't be applied to objects, so we use join
        return this.join(',');
      },
      _stash: function (parent) {
        // summary:
        //		private function to hold to a parent NodeList. end() to return the parent NodeList.
        //
        // example:
        //		How to make a `dojo/NodeList` method that only returns the third node in
        //		the dojo/NodeList but allows access to the original NodeList by using this._stash:
        //	|	require(["dojo/query", "dojo/_base/lang", "dojo/NodeList", "dojo/NodeList-dom"
        //	|	], function(query, lang){
        //	|		lang.extend(NodeList, {
        //	|			third: function(){
        //	|				var newNodeList = NodeList(this[2]);
        //	|				return newNodeList._stash(this);
        //	|			}
        //	|		});
        //	|		// then see how _stash applies a sub-list, to be .end()'ed out of
        //	|		query(".foo")
        //	|			.third()
        //	|				.addClass("thirdFoo")
        //	|			.end()
        //	|			// access to the orig .foo list
        //	|			.removeClass("foo")
        //	|	});
        //
        this._parent = parent;
        return this;  // dojo/NodeList
      },
      on: function (eventName, listener) {
        // summary:
        //		Listen for events on the nodes in the NodeList. Basic usage is:
        //
        // example:
        //		|	require(["dojo/query"
        //		|	], function(query){
        //		|		query(".my-class").on("click", listener);
        //			This supports event delegation by using selectors as the first argument with the event names as
        //			pseudo selectors. For example:
        //		| 		query("#my-list").on("li:click", listener);
        //			This will listen for click events within `<li>` elements that are inside the `#my-list` element.
        //			Because on supports CSS selector syntax, we can use comma-delimited events as well:
        //		| 		query("#my-list").on("li button:mouseover, li:click", listener);
        //		|	});
        var handles = this.map(function (node) {
          return on(node, eventName, listener);  // TODO: apply to the NodeList so the same selector engine is used for matches
        });
        handles.remove = function () {
          for (var i = 0; i < handles.length; i++) {
            handles[i].remove();
          }
        };
        return handles;
      },
      end: function () {
        // summary:
        //		Ends use of the current `NodeList` by returning the previous NodeList
        //		that generated the current NodeList.
        // description:
        //		Returns the `NodeList` that generated the current `NodeList`. If there
        //		is no parent NodeList, an empty NodeList is returned.
        // example:
        //	|	require(["dojo/query", "dojo/NodeList-dom"
        //	|	], function(query){
        //	|		query("a")
        //	|			.filter(".disabled")
        //	|				// operate on the anchors that only have a disabled class
        //	|				.style("color", "grey")
        //	|			.end()
        //	|			// jump back to the list of anchors
        //	|			.style(...)
        //	|	});
        //
        if (this._parent) {
          return this._parent;
        } else {
          //Just return empty list.
          return new this._NodeListCtor(0);
        }
      },
      // http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array#Methods
      // FIXME: handle return values for #3244
      //		http://trac.dojotoolkit.org/ticket/3244
      // FIXME:
      //		need to wrap or implement:
      //			join (perhaps w/ innerHTML/outerHTML overload for toString() of items?)
      //			reduce
      //			reduceRight
      /*=====
      		slice: function(begin, end){
      			// summary:
      			//		Returns a new NodeList, maintaining this one in place
      			// description:
      			//		This method behaves exactly like the Array.slice method
      			//		with the caveat that it returns a `dojo/NodeList` and not a
      			//		raw Array. For more details, see Mozilla's [slice
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/slice)
      			// begin: Integer
      			//		Can be a positive or negative integer, with positive
      			//		integers noting the offset to begin at, and negative
      			//		integers denoting an offset from the end (i.e., to the left
      			//		of the end)
      			// end: Integer?
      			//		Optional parameter to describe what position relative to
      			//		the NodeList's zero index to end the slice at. Like begin,
      			//		can be positive or negative.
      			return this._wrap(a.slice.apply(this, arguments));
      		},
      
      		splice: function(index, howmany, item){
      			// summary:
      			//		Returns a new NodeList, manipulating this NodeList based on
      			//		the arguments passed, potentially splicing in new elements
      			//		at an offset, optionally deleting elements
      			// description:
      			//		This method behaves exactly like the Array.splice method
      			//		with the caveat that it returns a `dojo/NodeList` and not a
      			//		raw Array. For more details, see Mozilla's [splice
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)
      			//		For backwards compatibility, calling .end() on the spliced NodeList
      			//		does not return the original NodeList -- splice alters the NodeList in place.
      			// index: Integer
      			//		begin can be a positive or negative integer, with positive
      			//		integers noting the offset to begin at, and negative
      			//		integers denoting an offset from the end (i.e., to the left
      			//		of the end)
      			// howmany: Integer?
      			//		Optional parameter to describe what position relative to
      			//		the NodeList's zero index to end the slice at. Like begin,
      			//		can be positive or negative.
      			// item: Object...?
      			//		Any number of optional parameters may be passed in to be
      			//		spliced into the NodeList
      			return this._wrap(a.splice.apply(this, arguments));	// dojo/NodeList
      		},
      
      		indexOf: function(value, fromIndex){
      			// summary:
      			//		see `dojo/_base/array.indexOf()`. The primary difference is that the acted-on
      			//		array is implicitly this NodeList
      			// value: Object
      			//		The value to search for.
      			// fromIndex: Integer?
      			//		The location to start searching from. Optional. Defaults to 0.
      			// description:
      			//		For more details on the behavior of indexOf, see Mozilla's
      			//		[indexOf
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf)
      			// returns:
      			//		Positive Integer or 0 for a match, -1 of not found.
      			return d.indexOf(this, value, fromIndex); // Integer
      		},
      
      		lastIndexOf: function(value, fromIndex){
      			// summary:
      			//		see `dojo/_base/array.lastIndexOf()`. The primary difference is that the
      			//		acted-on array is implicitly this NodeList
      			// description:
      			//		For more details on the behavior of lastIndexOf, see
      			//		Mozilla's [lastIndexOf
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf)
      			// value: Object
      			//		The value to search for.
      			// fromIndex: Integer?
      			//		The location to start searching from. Optional. Defaults to 0.
      			// returns:
      			//		Positive Integer or 0 for a match, -1 of not found.
      			return d.lastIndexOf(this, value, fromIndex); // Integer
      		},
      
      		every: function(callback, thisObject){
      			// summary:
      			//		see `dojo/_base/array.every()` and the [Array.every
      			//		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every).
      			//		Takes the same structure of arguments and returns as
      			//		dojo/_base/array.every() with the caveat that the passed array is
      			//		implicitly this NodeList
      			// callback: Function
      			//		the callback
      			// thisObject: Object?
      			//		the context
      			return d.every(this, callback, thisObject); // Boolean
      		},
      
      		some: function(callback, thisObject){
      			// summary:
      			//		Takes the same structure of arguments and returns as
      			//		`dojo/_base/array.some()` with the caveat that the passed array is
      			//		implicitly this NodeList.  See `dojo/_base/array.some()` and Mozilla's
      			//		[Array.some
      			//		documentation](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some).
      			// callback: Function
      			//		the callback
      			// thisObject: Object?
      			//		the context
      			return d.some(this, callback, thisObject); // Boolean
      		},
      		=====*/
      concat: function (item) {
        // summary:
        //		Returns a new NodeList comprised of items in this NodeList
        //		as well as items passed in as parameters
        // description:
        //		This method behaves exactly like the Array.concat method
        //		with the caveat that it returns a `NodeList` and not a
        //		raw Array. For more details, see the [Array.concat
        //		docs](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/concat)
        // item: Object?
        //		Any number of optional parameters may be passed in to be
        //		spliced into the NodeList
        //return this._wrap(apc.apply(this, arguments));
        // the line above won't work for the native NodeList, or for Dojo NodeLists either :-(
        // implementation notes:
        // Array.concat() doesn't recognize native NodeLists or Dojo NodeLists
        // as arrays, and so does not inline them into a unioned array, but
        // appends them as single entities. Both the original NodeList and the
        // items passed in as parameters must be converted to raw Arrays
        // and then the concatenation result may be re-_wrap()ed as a Dojo NodeList.
        var t = aps.call(this, 0), m = array.map(arguments, function (a) {
            return aps.call(a, 0);
          });
        return this._wrap(apc.apply(t, m), this);  // dojo/NodeList
      },
      map: function (func, obj) {
        // summary:
        //		see `dojo/_base/array.map()`. The primary difference is that the acted-on
        //		array is implicitly this NodeList and the return is a
        //		NodeList (a subclass of Array)
        return this._wrap(array.map(this, func, obj), this);  // dojo/NodeList
      },
      forEach: function (callback, thisObj) {
        // summary:
        //		see `dojo/_base/array.forEach()`. The primary difference is that the acted-on
        //		array is implicitly this NodeList. If you want the option to break out
        //		of the forEach loop, use every() or some() instead.
        forEach(this, callback, thisObj);
        // non-standard return to allow easier chaining
        return this;  // dojo/NodeList
      },
      filter: function (filter) {
        // summary:
        //		"masks" the built-in javascript filter() method (supported
        //		in Dojo via `dojo/_base/array.filter`) to support passing a simple
        //		string filter in addition to supporting filtering function
        //		objects.
        // filter:
        //		If a string, a CSS rule like ".thinger" or "div > span".
        // example:
        //		"regular" JS filter syntax as exposed in `dojo/_base/array.filter`:
        //		|	require(["dojo/query", "dojo/NodeList-dom"
        //		|	], function(query){
        //		|		query("*").filter(function(item){
        //		|			// highlight every paragraph
        //		|			return (item.nodeName == "p");
        //		|		}).style("backgroundColor", "yellow");
        //		|	});
        // example:
        //		the same filtering using a CSS selector
        //		|	require(["dojo/query", "dojo/NodeList-dom"
        //		|	], function(query){
        //		|		query("*").filter("p").styles("backgroundColor", "yellow");
        //		|	});
        var a = arguments, items = this, start = 0;
        if (typeof filter == 'string') {
          // inline'd type check
          items = query._filterResult(this, a[0]);
          if (a.length == 1) {
            // if we only got a string query, pass back the filtered results
            return items._stash(this);  // dojo/NodeList
          }
          // if we got a callback, run it over the filtered items
          start = 1;
        }
        return this._wrap(array.filter(items, a[start], a[start + 1]), this);  // dojo/NodeList
      },
      instantiate: function (declaredClass, properties) {
        // summary:
        //		Create a new instance of a specified class, using the
        //		specified properties and each node in the NodeList as a
        //		srcNodeRef.
        // example:
        //		Grabs all buttons in the page and converts them to dijit/form/Button's.
        //	|	var buttons = query("button").instantiate(Button, {showLabel: true});
        var c = lang.isFunction(declaredClass) ? declaredClass : lang.getObject(declaredClass);
        properties = properties || {};
        return this.forEach(function (node) {
          new c(properties, node);
        });  // dojo/NodeList
      },
      at: function () {
        // summary:
        //		Returns a new NodeList comprised of items in this NodeList
        //		at the given index or indices.
        //
        // index: Integer...
        //		One or more 0-based indices of items in the current
        //		NodeList. A negative index will start at the end of the
        //		list and go backwards.
        //
        // example:
        //	Shorten the list to the first, second, and third elements
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("a").at(0, 1, 2).forEach(fn);
        //	|	});
        //
        // example:
        //	Retrieve the first and last elements of a unordered list:
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("ul > li").at(0, -1).forEach(cb);
        //	|	});
        //
        // example:
        //	Do something for the first element only, but end() out back to
        //	the original list and continue chaining:
        //	|	require(["dojo/query"
        //	|	], function(query){
        //	|		query("a").at(0).onclick(fn).end().forEach(function(n){
        //	|			console.log(n); // all anchors on the page.
        //	|	})
        //	|	});
        var t = new this._NodeListCtor(0);
        forEach(arguments, function (i) {
          if (i < 0) {
            i = this.length + i;
          }
          if (this[i]) {
            t.push(this[i]);
          }
        }, this);
        return t._stash(this);  // dojo/NodeList
      }
    });
    function queryForEngine(engine, NodeList) {
      var query = function (query, root) {
        // summary:
        //		Returns nodes which match the given CSS selector, searching the
        //		entire document by default but optionally taking a node to scope
        //		the search by. Returns an instance of NodeList.
        if (typeof root == 'string') {
          root = dom.byId(root);
          if (!root) {
            return new NodeList([]);
          }
        }
        var results = typeof query == 'string' ? engine(query, root) : query ? query.end && query.on ? query : [query] : [];
        if (results.end && results.on) {
          // already wrapped
          return results;
        }
        return new NodeList(results);
      };
      query.matches = engine.match || function (node, selector, root) {
        // summary:
        //		Test to see if a node matches a selector
        return query.filter([node], selector, root).length > 0;
      };
      // the engine provides a filtering function, use it to for matching
      query.filter = engine.filter || function (nodes, selector, root) {
        // summary:
        //		Filters an array of nodes. Note that this does not guarantee to return a NodeList, just an array.
        return query(selector, root).filter(function (node) {
          return array.indexOf(nodes, node) > -1;
        });
      };
      if (typeof engine != 'function') {
        var search = engine.search;
        engine = function (selector, root) {
          // Slick does it backwards (or everyone else does it backwards, probably the latter)
          return search(root || document, selector);
        };
      }
      return query;
    }
    var query = queryForEngine(defaultEngine, NodeList);
    /*=====
    	query = function(selector, context){
    		// summary:
    		//		This modules provides DOM querying functionality. The module export is a function
    		//		that can be used to query for DOM nodes by CSS selector and returns a NodeList
    		//		representing the matching nodes.
    		// selector: String
    		//		A CSS selector to search for.
    		// context: String|DomNode?
    		//		An optional context to limit the searching scope. Only nodes under `context` will be
    		//		scanned.
    		// example:
    		//		add an onclick handler to every submit button in the document
    		//		which causes the form to be sent via Ajax instead:
    		//	|	require(["dojo/query", "dojo/request", "dojo/dom-form", "dojo/dom-construct", "dojo/dom-style"
    		//	|	], function(query, request, domForm, domConstruct, domStyle){
    		//	|		query("input[type='submit']").on("click", function(e){
    		//	|			e.preventDefault(); // prevent sending the form
    		//	|			var btn = e.target;
    		//	|			request.post("http://example.com/", {
    		//	|				data: domForm.toObject(btn.form)
    		//	|			}).then(function(response){
    		//	|				// replace the form with the response
    		//	|				domConstruct.create(div, {innerHTML: response}, btn.form, "after");
    		//	|				domStyle.set(btn.form, "display", "none");
    		//	|			});
    		//	|		});
    		//	|	});
    		//
    		// description:
    		//		dojo/query is responsible for loading the appropriate query engine and wrapping
    		//		its results with a `NodeList`. You can use dojo/query with a specific selector engine
    		//		by using it as a plugin. For example, if you installed the sizzle package, you could
    		//		use it as the selector engine with:
    		//		|	require(["dojo/query!sizzle"], function(query){
    		//		|		query("div")...
    		//
    		//		The id after the ! can be a module id of the selector engine or one of the following values:
    		//
    		//		- acme: This is the default engine used by Dojo base, and will ensure that the full
    		//		Acme engine is always loaded.
    		//
    		//		- css2: If the browser has a native selector engine, this will be used, otherwise a
    		//		very minimal lightweight selector engine will be loaded that can do simple CSS2 selectors
    		//		(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (>)
    		//		operators) and nothing more.
    		//
    		//		- css2.1: If the browser has a native selector engine, this will be used, otherwise the
    		//		full Acme engine will be loaded.
    		//
    		//		- css3: If the browser has a native selector engine with support for CSS3 pseudo
    		//		selectors (most modern browsers except IE8), this will be used, otherwise the
    		//		full Acme engine will be loaded.
    		//
    		//		- Or the module id of a selector engine can be used to explicitly choose the selector engine
    		//
    		//		For example, if you are using CSS3 pseudo selectors in module, you can specify that
    		//		you will need support them with:
    		//		|	require(["dojo/query!css3"], function(query){
    		//		|		query('#t > h3:nth-child(odd)')...
    		//
    		//		You can also choose the selector engine/load configuration by setting the query-selector:
    		//		For example:
    		//		|	<script data-dojo-config="query-selector:'css3'" src="dojo.js"></script>
    		//
    		return new NodeList(); // dojo/NodeList
    	 };
    	 =====*/
    // the query that is returned from this module is slightly different than dojo.query,
    // because dojo.query has to maintain backwards compatibility with returning a
    // true array which has performance problems. The query returned from the module
    // does not use true arrays, but rather inherits from Array, making it much faster to
    // instantiate.
    dojo.query = queryForEngine(defaultEngine, function (array) {
      // call it without the new operator to invoke the back-compat behavior that returns a true array
      return NodeList(array);  // dojo/NodeList
    });
    query.load = function (id, parentRequire, loaded) {
      // summary:
      //		can be used as AMD plugin to conditionally load new query engine
      // example:
      //	|	require(["dojo/query!custom"], function(qsa){
      //	|		// loaded selector/custom.js as engine
      //	|		qsa("#foobar").forEach(...);
      //	|	});
      loader.load(id, parentRequire, function (engine) {
        loaded(queryForEngine(engine, NodeList));
      });
    };
    dojo._filterQueryResult = query._filterResult = function (nodes, selector, root) {
      return new NodeList(query.filter(nodes, selector, root));
    };
    dojo.NodeList = query.NodeList = NodeList;
    return query;
  }(dojo__base_kernel, dojo_has, dojo_dom, dojo_on, dojo__base_array, dojo__base_lang, dojo_selector__loader, synchronite_libs_sizzle);
  dojo_dom_class = function (lang, array, dom) {
    // module:
    //		dojo/dom-class
    var className = 'className';
    /* Part I of classList-based implementation is preserved here for posterity
    	var classList = "classList";
    	has.add("dom-classList", function(){
    		return classList in document.createElement("p");
    	});
    	*/
    // =============================
    // (CSS) Class Functions
    // =============================
    var cls,
      // exports object
      spaces = /\s+/, a1 = [''];
    function str2array(s) {
      if (typeof s == 'string' || s instanceof String) {
        if (s && !spaces.test(s)) {
          a1[0] = s;
          return a1;
        }
        var a = s.split(spaces);
        if (a.length && !a[0]) {
          a.shift();
        }
        if (a.length && !a[a.length - 1]) {
          a.pop();
        }
        return a;
      }
      // assumed to be an array
      if (!s) {
        return [];
      }
      return array.filter(s, function (x) {
        return x;
      });
    }
    /* Part II of classList-based implementation is preserved here for posterity
    	if(has("dom-classList")){
    		// new classList version
    		cls = {
    			contains: function containsClass(node, classStr){
    				var clslst = classStr && dom.byId(node)[classList];
    				return clslst && clslst.contains(classStr); // Boolean
    			},
    
    			add: function addClass(node, classStr){
    				node = dom.byId(node);
    				classStr = str2array(classStr);
    				for(var i = 0, len = classStr.length; i < len; ++i){
    					node[classList].add(classStr[i]);
    				}
    			},
    
    			remove: function removeClass(node, classStr){
    				node = dom.byId(node);
    				if(classStr === undefined){
    					node[className] = "";
    				}else{
    					classStr = str2array(classStr);
    					for(var i = 0, len = classStr.length; i < len; ++i){
    						node[classList].remove(classStr[i]);
    					}
    				}
    			},
    
    			replace: function replaceClass(node, addClassStr, removeClassStr){
    				node = dom.byId(node);
    				if(removeClassStr === undefined){
    					node[className] = "";
    				}else{
    					removeClassStr = str2array(removeClassStr);
    					for(var i = 0, len = removeClassStr.length; i < len; ++i){
    						node[classList].remove(removeClassStr[i]);
    					}
    				}
    				addClassStr = str2array(addClassStr);
    				for(i = 0, len = addClassStr.length; i < len; ++i){
    					node[classList].add(addClassStr[i]);
    				}
    			},
    
    			toggle: function toggleClass(node, classStr, condition){
    				node = dom.byId(node);
    				if(condition === undefined){
    					classStr = str2array(classStr);
    					for(var i = 0, len = classStr.length; i < len; ++i){
    						node[classList].toggle(classStr[i]);
    					}
    				}else{
    					cls[condition ? "add" : "remove"](node, classStr);
    				}
    				return condition;   // Boolean
    			}
    		}
    	}
    	*/
    // regular DOM version
    var fakeNode = {};
    // for effective replacement
    cls = {
      // summary:
      //		This module defines the core dojo DOM class API.
      contains: function containsClass(node, classStr) {
        // summary:
        //		Returns whether or not the specified classes are a portion of the
        //		class list currently applied to the node.
        // node: String|DOMNode
        //		String ID or DomNode reference to check the class for.
        // classStr: String
        //		A string class name to look for.
        // example:
        //		Do something if a node with id="someNode" has class="aSillyClassName" present
        //	|	if(dojo.hasClass("someNode","aSillyClassName")){ ... }
        return (' ' + dom.byId(node)[className] + ' ').indexOf(' ' + classStr + ' ') >= 0;  // Boolean
      },
      add: function addClass(node, classStr) {
        // summary:
        //		Adds the specified classes to the end of the class list on the
        //		passed node. Will not re-apply duplicate classes.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to add a class string too
        //
        // classStr: String|Array
        //		A String class name to add, or several space-separated class names,
        //		or an array of class names.
        //
        // example:
        //		Add a class to some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", "anewClass");
        //	|	});
        //
        // example:
        //		Add two classes at once:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", "firstClass secondClass");
        //	|	});
        //
        // example:
        //		Add two classes at once (using array):
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.add("someNode", ["firstClass", "secondClass"]);
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple additions
        //	|	require(["dojo/query"], function(query){
        //	|		query("ul > li").addClass("firstLevel");
        //	|	});
        node = dom.byId(node);
        classStr = str2array(classStr);
        var cls = node[className], oldLen;
        cls = cls ? ' ' + cls + ' ' : ' ';
        oldLen = cls.length;
        for (var i = 0, len = classStr.length, c; i < len; ++i) {
          c = classStr[i];
          if (c && cls.indexOf(' ' + c + ' ') < 0) {
            cls += c + ' ';
          }
        }
        if (oldLen < cls.length) {
          node[className] = cls.substr(1, cls.length - 2);
        }
      },
      remove: function removeClass(node, classStr) {
        // summary:
        //		Removes the specified classes from node. No `contains()`
        //		check is required.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to remove the class from.
        //
        // classStr: String|Array
        //		An optional String class name to remove, or several space-separated
        //		class names, or an array of class names. If omitted, all class names
        //		will be deleted.
        //
        // example:
        //		Remove a class from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", "firstClass");
        //	|	});
        //
        // example:
        //		Remove two classes from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", "firstClass secondClass");
        //	|	});
        //
        // example:
        //		Remove two classes from some node (using array):
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode", ["firstClass", "secondClass"]);
        //	|	});
        //
        // example:
        //		Remove all classes from some node:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.remove("someNode");
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple removal
        //	|	require(["dojo/query"], function(query){
        //	|		query("ul > li").removeClass("foo");
        //	|	});
        node = dom.byId(node);
        var cls;
        if (classStr !== undefined) {
          classStr = str2array(classStr);
          cls = ' ' + node[className] + ' ';
          for (var i = 0, len = classStr.length; i < len; ++i) {
            cls = cls.replace(' ' + classStr[i] + ' ', ' ');
          }
          cls = lang.trim(cls);
        } else {
          cls = '';
        }
        if (node[className] != cls) {
          node[className] = cls;
        }
      },
      replace: function replaceClass(node, addClassStr, removeClassStr) {
        // summary:
        //		Replaces one or more classes on a node if not present.
        //		Operates more quickly than calling dojo.removeClass and dojo.addClass
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to remove the class from.
        //
        // addClassStr: String|Array
        //		A String class name to add, or several space-separated class names,
        //		or an array of class names.
        //
        // removeClassStr: String|Array?
        //		A String class name to remove, or several space-separated class names,
        //		or an array of class names.
        //
        // example:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.replace("someNode", "add1 add2", "remove1 remove2");
        //	|	});
        //
        // example:
        //	Replace all classes with addMe
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.replace("someNode", "addMe");
        //	|	});
        //
        // example:
        //	Available in `dojo/NodeList` for multiple toggles
        //	|	require(["dojo/query"], function(query){
        //	|		query(".findMe").replaceClass("addMe", "removeMe");
        //	|	});
        node = dom.byId(node);
        fakeNode[className] = node[className];
        cls.remove(fakeNode, removeClassStr);
        cls.add(fakeNode, addClassStr);
        if (node[className] !== fakeNode[className]) {
          node[className] = fakeNode[className];
        }
      },
      toggle: function toggleClass(node, classStr, condition) {
        // summary:
        //		Adds a class to node if not present, or removes if present.
        //		Pass a boolean condition if you want to explicitly add or remove.
        //		Returns the condition that was specified directly or indirectly.
        //
        // node: String|DOMNode
        //		String ID or DomNode reference to toggle a class string
        //
        // classStr: String|Array
        //		A String class name to toggle, or several space-separated class names,
        //		or an array of class names.
        //
        // condition:
        //		If passed, true means to add the class, false means to remove.
        //		Otherwise dojo.hasClass(node, classStr) is used to detect the class presence.
        //
        // example:
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.toggle("someNode", "hovered");
        //	|	});
        //
        // example:
        //		Forcefully add a class
        //	|	require(["dojo/dom-class"], function(domClass){
        //	|		domClass.toggle("someNode", "hovered", true);
        //	|	});
        //
        // example:
        //		Available in `dojo/NodeList` for multiple toggles
        //	|	require(["dojo/query"], function(query){
        //	|		query(".toggleMe").toggleClass("toggleMe");
        //	|	});
        node = dom.byId(node);
        if (condition === undefined) {
          classStr = str2array(classStr);
          for (var i = 0, len = classStr.length, c; i < len; ++i) {
            c = classStr[i];
            cls[cls.contains(node, c) ? 'remove' : 'add'](node, c);
          }
        } else {
          cls[condition ? 'add' : 'remove'](node, classStr);
        }
        return condition;  // Boolean
      }
    };
    return cls;
  }(dojo__base_lang, dojo__base_array, dojo_dom);
  dojo_aspect = function () {
    var undefined, nextId = 0;
    function advise(dispatcher, type, advice, receiveArguments) {
      var previous = dispatcher[type];
      var around = type == 'around';
      var signal;
      if (around) {
        var advised = advice(function () {
          return previous.advice(this, arguments);
        });
        signal = {
          remove: function () {
            if (advised) {
              advised = dispatcher = advice = null;
            }
          },
          advice: function (target, args) {
            return advised ? advised.apply(target, args) : // called the advised function
            previous.advice(target, args);  // cancelled, skip to next one
          }
        };
      } else {
        // create the remove handler
        signal = {
          remove: function () {
            if (signal.advice) {
              var previous = signal.previous;
              var next = signal.next;
              if (!next && !previous) {
                delete dispatcher[type];
              } else {
                if (previous) {
                  previous.next = next;
                } else {
                  dispatcher[type] = next;
                }
                if (next) {
                  next.previous = previous;
                }
              }
              // remove the advice to signal that this signal has been removed
              dispatcher = advice = signal.advice = null;
            }
          },
          id: nextId++,
          advice: advice,
          receiveArguments: receiveArguments
        };
      }
      if (previous && !around) {
        if (type == 'after') {
          // add the listener to the end of the list
          // note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug
          while (previous.next && (previous = previous.next)) {
          }
          previous.next = signal;
          signal.previous = previous;
        } else if (type == 'before') {
          // add to beginning
          dispatcher[type] = signal;
          signal.next = previous;
          previous.previous = signal;
        }
      } else {
        // around or first one just replaces
        dispatcher[type] = signal;
      }
      return signal;
    }
    function aspect(type) {
      return function (target, methodName, advice, receiveArguments) {
        var existing = target[methodName], dispatcher;
        if (!existing || existing.target != target) {
          // no dispatcher in place
          target[methodName] = dispatcher = function () {
            var executionId = nextId;
            // before advice
            var args = arguments;
            var before = dispatcher.before;
            while (before) {
              args = before.advice.apply(this, args) || args;
              before = before.next;
            }
            // around advice
            if (dispatcher.around) {
              var results = dispatcher.around.advice(this, args);
            }
            // after advice
            var after = dispatcher.after;
            while (after && after.id < executionId) {
              if (after.receiveArguments) {
                var newResults = after.advice.apply(this, args);
                // change the return value only if a new value was returned
                results = newResults === undefined ? results : newResults;
              } else {
                results = after.advice.call(this, results, args);
              }
              after = after.next;
            }
            return results;
          };
          if (existing) {
            dispatcher.around = {
              advice: function (target, args) {
                return existing.apply(target, args);
              }
            };
          }
          dispatcher.target = target;
        }
        var results = advise(dispatcher || existing, type, advice, receiveArguments);
        advice = null;
        return results;
      };
    }
    // TODOC: after/before/around return object
    var after = aspect('after');
    /*=====
    	after = function(target, methodName, advice, receiveArguments){
    		// summary:
    		//		The "after" export of the aspect module is a function that can be used to attach
    		//		"after" advice to a method. This function will be executed after the original method
    		//		is executed. By default the function will be called with a single argument, the return
    		//		value of the original method, or the the return value of the last executed advice (if a previous one exists).
    		//		The fourth (optional) argument can be set to true to so the function receives the original
    		//		arguments (from when the original method was called) rather than the return value.
    		//		If there are multiple "after" advisors, they are executed in the order they were registered.
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called after the original method
    		// receiveArguments: Boolean?
    		//		If this is set to true, the advice function receives the original arguments (from when the original mehtod
    		//		was called) rather than the return value of the original/previous method.
    		// returns:
    		//		A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will
    		//		stop the advice function from being executed.
    	};
    	=====*/
    var before = aspect('before');
    /*=====
    	before = function(target, methodName, advice){
    		// summary:
    		//		The "before" export of the aspect module is a function that can be used to attach
    		//		"before" advice to a method. This function will be executed before the original method
    		//		is executed. This function will be called with the arguments used to call the method.
    		//		This function may optionally return an array as the new arguments to use to call
    		//		the original method (or the previous, next-to-execute before advice, if one exists).
    		//		If the before method doesn't return anything (returns undefined) the original arguments
    		//		will be preserved.
    		//		If there are multiple "before" advisors, they are executed in the reverse order they were registered.
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called before the original method
    	};
    	=====*/
    var around = aspect('around');
    /*=====
    	 around = function(target, methodName, advice){
    		// summary:
    		//		The "around" export of the aspect module is a function that can be used to attach
    		//		"around" advice to a method. The advisor function is immediately executed when
    		//		the around() is called, is passed a single argument that is a function that can be
    		//		called to continue execution of the original method (or the next around advisor).
    		//		The advisor function should return a function, and this function will be called whenever
    		//		the method is called. It will be called with the arguments used to call the method.
    		//		Whatever this function returns will be returned as the result of the method call (unless after advise changes it).
    		// example:
    		//		If there are multiple "around" advisors, the most recent one is executed first,
    		//		which can then delegate to the next one and so on. For example:
    		//		|	around(obj, "foo", function(originalFoo){
    		//		|		return function(){
    		//		|			var start = new Date().getTime();
    		//		|			var results = originalFoo.apply(this, arguments); // call the original
    		//		|			var end = new Date().getTime();
    		//		|			console.log("foo execution took " + (end - start) + " ms");
    		//		|			return results;
    		//		|		};
    		//		|	});
    		// target: Object
    		//		This is the target object
    		// methodName: String
    		//		This is the name of the method to attach to.
    		// advice: Function
    		//		This is function to be called around the original method
    	};
    	=====*/
    return {
      // summary:
      //		provides aspect oriented programming functionality, allowing for
      //		one to add before, around, or after advice on existing methods.
      // example:
      //	|	define(["dojo/aspect"], function(aspect){
      //	|		var signal = aspect.after(targetObject, "methodName", function(someArgument){
      //	|			this will be called when targetObject.methodName() is called, after the original function is called
      //	|		});
      //
      // example:
      //	The returned signal object can be used to cancel the advice.
      //	|	signal.remove(); // this will stop the advice from being executed anymore
      //	|	aspect.before(targetObject, "methodName", function(someArgument){
      //	|		// this will be called when targetObject.methodName() is called, before the original function is called
      //	|	 });
      before: before,
      around: around,
      after: after
    };
  }();
  dojo_Evented = function (aspect, on) {
    var after = aspect.after;
    function Evented() {
    }
    Evented.prototype = {
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      }
    };
    return Evented;
  }(dojo_aspect, dojo_on);
  dojo__base_Color = function (dojo, lang, ArrayUtil, config) {
    var Color = dojo.Color = function (color) {
      // summary:
      //		Takes a named string, hex string, array of rgb or rgba values,
      //		an object with r, g, b, and a properties, or another `Color` object
      //		and creates a new Color instance to work from.
      //
      // example:
      //		Work with a Color instance:
      //	|	require(["dojo/_base/color"], function(Color){
      //	|		var c = new Color();
      //	|		c.setColor([0,0,0]); // black
      //	|		var hex = c.toHex(); // #000000
      //	|	});
      //
      // example:
      //		Work with a node's color:
      //	| 
      //	|	require(["dojo/_base/color", "dojo/dom-style"], function(Color, domStyle){
      //	|		var color = domStyle("someNode", "backgroundColor");
      //	|		var n = new Color(color);
      //	|		// adjust the color some
      //	|		n.r *= .5;
      //	|		console.log(n.toString()); // rgb(128, 255, 255);
      //	|	});
      if (color) {
        this.setColor(color);
      }
    };
    // FIXME:
    // there's got to be a more space-efficient way to encode or discover
    // these!! Use hex?
    Color.named = {
      // summary:
      //		Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.
      'black': [
        0,
        0,
        0
      ],
      'silver': [
        192,
        192,
        192
      ],
      'gray': [
        128,
        128,
        128
      ],
      'white': [
        255,
        255,
        255
      ],
      'maroon': [
        128,
        0,
        0
      ],
      'red': [
        255,
        0,
        0
      ],
      'purple': [
        128,
        0,
        128
      ],
      'fuchsia': [
        255,
        0,
        255
      ],
      'green': [
        0,
        128,
        0
      ],
      'lime': [
        0,
        255,
        0
      ],
      'olive': [
        128,
        128,
        0
      ],
      'yellow': [
        255,
        255,
        0
      ],
      'navy': [
        0,
        0,
        128
      ],
      'blue': [
        0,
        0,
        255
      ],
      'teal': [
        0,
        128,
        128
      ],
      'aqua': [
        0,
        255,
        255
      ],
      'transparent': config.transparentColor || [
        0,
        0,
        0,
        0
      ]
    };
    lang.extend(Color, {
      r: 255,
      g: 255,
      b: 255,
      a: 1,
      _set: function (r, g, b, a) {
        var t = this;
        t.r = r;
        t.g = g;
        t.b = b;
        t.a = a;
      },
      setColor: function (color) {
        // summary:
        //		Takes a named string, hex string, array of rgb or rgba values,
        //		an object with r, g, b, and a properties, or another `Color` object
        //		and sets this color instance to that value.
        //
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color(); // no color
        //	|		c.setColor("#ededed"); // greyish
        //	|	});
        if (lang.isString(color)) {
          Color.fromString(color, this);
        } else if (lang.isArray(color)) {
          Color.fromArray(color, this);
        } else {
          this._set(color.r, color.g, color.b, color.a);
          if (!(color instanceof Color)) {
            this.sanitize();
          }
        }
        return this;  // Color
      },
      sanitize: function () {
        // summary:
        //		Ensures the object has correct attributes
        // description:
        //		the default implementation does nothing, include dojo.colors to
        //		augment it with real checks
        return this;  // Color
      },
      toRgb: function () {
        // summary:
        //		Returns 3 component array of rgb values
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color("#000000");
        //	|		console.log(c.toRgb()); // [0,0,0]
        //	|	});
        var t = this;
        return [
          t.r,
          t.g,
          t.b
        ];  // Array
      },
      toRgba: function () {
        // summary:
        //		Returns a 4 component array of rgba values from the color
        //		represented by this object.
        var t = this;
        return [
          t.r,
          t.g,
          t.b,
          t.a
        ];  // Array
      },
      toHex: function () {
        // summary:
        //		Returns a CSS color string in hexadecimal representation
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		console.log(new Color([0,0,0]).toHex()); // #000000
        //	|	});
        var arr = ArrayUtil.map([
          'r',
          'g',
          'b'
        ], function (x) {
          var s = this[x].toString(16);
          return s.length < 2 ? '0' + s : s;
        }, this);
        return '#' + arr.join('');  // String
      },
      toCss: function (includeAlpha) {
        // summary:
        //		Returns a css color string in rgb(a) representation
        // example:
        //	|	require(["dojo/_base/color"], function(Color){
        //	|		var c = new Color("#FFF").toCss();
        //	|		console.log(c); // rgb('255','255','255')
        //	|	});
        var t = this, rgb = t.r + ', ' + t.g + ', ' + t.b;
        return (includeAlpha ? 'rgba(' + rgb + ', ' + t.a : 'rgb(' + rgb) + ')';  // String
      },
      toString: function () {
        // summary:
        //		Returns a visual representation of the color
        return this.toCss(true);  // String
      }
    });
    Color.blendColors = dojo.blendColors = function (start, end, weight, obj) {
      // summary:
      //		Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
      //		can reuse a previously allocated Color object for the result
      var t = obj || new Color();
      ArrayUtil.forEach([
        'r',
        'g',
        'b',
        'a'
      ], function (x) {
        t[x] = start[x] + (end[x] - start[x]) * weight;
        if (x != 'a') {
          t[x] = Math.round(t[x]);
        }
      });
      return t.sanitize();  // Color
    };
    Color.fromRgb = dojo.colorFromRgb = function (color, obj) {
      // summary:
      //		Returns a `Color` instance from a string of the form
      //		"rgb(...)" or "rgba(...)". Optionally accepts a `Color`
      //		object to update with the parsed value and return instead of
      //		creating a new object.
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var m = color.toLowerCase().match(/^rgba?\(([\s\.,0-9]+)\)/);
      return m && Color.fromArray(m[1].split(/\s*,\s*/), obj);  // Color
    };
    Color.fromHex = dojo.colorFromHex = function (color, obj) {
      // summary:
      //		Converts a hex string with a '#' prefix to a color object.
      //		Supports 12-bit #rgb shorthand. Optionally accepts a
      //		`Color` object to update with the parsed value.
      //
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      //
      // example:
      //	|	require(["dojo/_base/color"], function(Color){
      //	|		var thing = new Color().fromHex("#ededed"); // grey, longhand
      //	|		var thing2 = new Color().fromHex("#000"); // black, shorthand
      //	|	});
      var t = obj || new Color(), bits = color.length == 4 ? 4 : 8, mask = (1 << bits) - 1;
      color = Number('0x' + color.substr(1));
      if (isNaN(color)) {
        return null;  // Color
      }
      ArrayUtil.forEach([
        'b',
        'g',
        'r'
      ], function (x) {
        var c = color & mask;
        color >>= bits;
        t[x] = bits == 4 ? 17 * c : c;
      });
      t.a = 1;
      return t;  // Color
    };
    Color.fromArray = dojo.colorFromArray = function (a, obj) {
      // summary:
      //		Builds a `Color` from a 3 or 4 element array, mapping each
      //		element in sequence to the rgb(a) values of the color.
      // example:
      //		|	require(["dojo/_base/color"], function(Color){
      //		|		var myColor = new Color().fromArray([237,237,237,0.5]); // grey, 50% alpha
      //		|	});
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var t = obj || new Color();
      t._set(Number(a[0]), Number(a[1]), Number(a[2]), Number(a[3]));
      if (isNaN(t.a)) {
        t.a = 1;
      }
      return t.sanitize();  // Color
    };
    Color.fromString = dojo.colorFromString = function (str, obj) {
      // summary:
      //		Parses `str` for a color value. Accepts hex, rgb, and rgba
      //		style color values.
      // description:
      //		Acceptable input values for str may include arrays of any form
      //		accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
      //		rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
      //		10, 50)"
      // returns:
      //		A Color object. If obj is passed, it will be the return value.
      var a = Color.named[str];
      return a && Color.fromArray(a, obj) || Color.fromRgb(str, obj) || Color.fromHex(str, obj);  // Color
    };
    return Color;
  }(dojo__base_kernel, dojo__base_lang, dojo__base_array, dojo__base_config);
  dojo_dom_style = function (has, dom) {
    // module:
    //		dojo/dom-style
    // =============================
    // Style Functions
    // =============================
    // getComputedStyle drives most of the style code.
    // Wherever possible, reuse the returned object.
    //
    // API functions below that need to access computed styles accept an
    // optional computedStyle parameter.
    // If this parameter is omitted, the functions will call getComputedStyle themselves.
    // This way, calling code can access computedStyle once, and then pass the reference to
    // multiple API functions.
    // Although we normally eschew argument validation at this
    // level, here we test argument 'node' for (duck)type,
    // by testing nodeType, ecause 'document' is the 'parentNode' of 'body'
    // it is frequently sent to this function even
    // though it is not Element.
    var getComputedStyle, style = {};
    if (has('webkit')) {
      getComputedStyle = function (node) {
        var s;
        if (node.nodeType == 1) {
          var dv = node.ownerDocument.defaultView;
          s = dv.getComputedStyle(node, null);
          if (!s && node.style) {
            node.style.display = '';
            s = dv.getComputedStyle(node, null);
          }
        }
        return s || {};
      };
    } else if (has('ie') && (has('ie') < 9 || has('quirks'))) {
      getComputedStyle = function (node) {
        // IE (as of 7) doesn't expose Element like sane browsers
        // currentStyle can be null on IE8!
        return node.nodeType == 1  /* ELEMENT_NODE*/ && node.currentStyle ? node.currentStyle : {};
      };
    } else {
      getComputedStyle = function (node) {
        return node.nodeType == 1  /* ELEMENT_NODE*/ ? node.ownerDocument.defaultView.getComputedStyle(node, null) : {};
      };
    }
    style.getComputedStyle = getComputedStyle;
    /*=====
    	style.getComputedStyle = function(node){
    		// summary:
    		//		Returns a "computed style" object.
    		//
    		// description:
    		//		Gets a "computed style" object which can be used to gather
    		//		information about the current state of the rendered node.
    		//
    		//		Note that this may behave differently on different browsers.
    		//		Values may have different formats and value encodings across
    		//		browsers.
    		//
    		//		Note also that this method is expensive.  Wherever possible,
    		//		reuse the returned object.
    		//
    		//		Use the dojo/dom-style.get() method for more consistent (pixelized)
    		//		return values.
    		//
    		// node: DOMNode
    		//		A reference to a DOM node. Does NOT support taking an
    		//		ID string for speed reasons.
    		// example:
    		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    		//	|		domStyle.getComputedStyle(dom.byId('foo')).borderWidth;
    		//	|	});
    		//
    		// example:
    		//		Reusing the returned object, avoiding multiple lookups:
    		//	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
    		//	|		var cs = domStyle.getComputedStyle(dom.byId("someNode"));
    		//	|		var w = cs.width, h = cs.height;
    		//	|	});
    		return; // CSS2Properties
    	};
    	=====*/
    var toPixel;
    if (!has('ie')) {
      toPixel = function (element, value) {
        // style values can be floats, client code may want
        // to round for integer pixels.
        return parseFloat(value) || 0;
      };
    } else {
      toPixel = function (element, avalue) {
        if (!avalue) {
          return 0;
        }
        // on IE7, medium is usually 4 pixels
        if (avalue == 'medium') {
          return 4;
        }
        // style values can be floats, client code may
        // want to round this value for integer pixels.
        if (avalue.slice && avalue.slice(-2) == 'px') {
          return parseFloat(avalue);
        }
        var s = element.style, rs = element.runtimeStyle, cs = element.currentStyle, sLeft = s.left, rsLeft = rs.left;
        rs.left = cs.left;
        try {
          // 'avalue' may be incompatible with style.left, which can cause IE to throw
          // this has been observed for border widths using "thin", "medium", "thick" constants
          // those particular constants could be trapped by a lookup
          // but perhaps there are more
          s.left = avalue;
          avalue = s.pixelLeft;
        } catch (e) {
          avalue = 0;
        }
        s.left = sLeft;
        rs.left = rsLeft;
        return avalue;
      };
    }
    style.toPixelValue = toPixel;
    /*=====
    	style.toPixelValue = function(node, value){
    		// summary:
    		//		converts style value to pixels on IE or return a numeric value.
    		// node: DOMNode
    		// value: String
    		// returns: Number
    	};
    	=====*/
    // FIXME: there opacity quirks on FF that we haven't ported over. Hrm.
    var astr = 'DXImageTransform.Microsoft.Alpha';
    var af = function (n, f) {
      try {
        return n.filters.item(astr);
      } catch (e) {
        return f ? {} : null;
      }
    };
    var _getOpacity = has('ie') < 9 || has('ie') < 10 && has('quirks') ? function (node) {
      try {
        return af(node).Opacity / 100;  // Number
      } catch (e) {
        return 1;
      }
    } : function (node) {
      return getComputedStyle(node).opacity;
    };
    var _setOpacity = has('ie') < 9 || has('ie') < 10 && has('quirks') ? function (node, opacity) {
      if (opacity === '') {
        opacity = 1;
      }
      var ov = opacity * 100, fullyOpaque = opacity === 1;
      // on IE7 Alpha(Filter opacity=100) makes text look fuzzy so disable it altogether (bug #2661),
      // but still update the opacity value so we can get a correct reading if it is read later:
      // af(node, 1).Enabled = !fullyOpaque;
      if (fullyOpaque) {
        node.style.zoom = '';
        if (af(node)) {
          node.style.filter = node.style.filter.replace(new RegExp('\\s*progid:' + astr + '\\([^\\)]+?\\)', 'i'), '');
        }
      } else {
        node.style.zoom = 1;
        if (af(node)) {
          af(node, 1).Opacity = ov;
        } else {
          node.style.filter += ' progid:' + astr + '(Opacity=' + ov + ')';
        }
        af(node, 1).Enabled = true;
      }
      if (node.tagName.toLowerCase() == 'tr') {
        for (var td = node.firstChild; td; td = td.nextSibling) {
          if (td.tagName.toLowerCase() == 'td') {
            _setOpacity(td, opacity);
          }
        }
      }
      return opacity;
    } : function (node, opacity) {
      return node.style.opacity = opacity;
    };
    var _pixelNamesCache = {
      left: true,
      top: true
    };
    var _pixelRegExp = /margin|padding|width|height|max|min|offset/;
    // |border
    function _toStyleValue(node, type, value) {
      //TODO: should we really be doing string case conversion here? Should we cache it? Need to profile!
      type = type.toLowerCase();
      if (has('ie') || has('trident')) {
        if (value == 'auto') {
          if (type == 'height') {
            return node.offsetHeight;
          }
          if (type == 'width') {
            return node.offsetWidth;
          }
        }
        if (type == 'fontweight') {
          switch (value) {
          case 700:
            return 'bold';
          case 400:
          default:
            return 'normal';
          }
        }
      }
      if (!(type in _pixelNamesCache)) {
        _pixelNamesCache[type] = _pixelRegExp.test(type);
      }
      return _pixelNamesCache[type] ? toPixel(node, value) : value;
    }
    var _floatAliases = {
      cssFloat: 1,
      styleFloat: 1,
      'float': 1
    };
    // public API
    style.get = function getStyle(node, name) {
      // summary:
      //		Accesses styles on a node.
      // description:
      //		Getting the style value uses the computed style for the node, so the value
      //		will be a calculated value, not just the immediate node.style value.
      //		Also when getting values, use specific style names,
      //		like "borderBottomWidth" instead of "border" since compound values like
      //		"border" are not necessarily reflected as expected.
      //		If you want to get node dimensions, use `dojo/dom-geometry.getMarginBox()`,
      //		`dojo/dom-geometry.getContentBox()` or `dojo/dom-geometry.getPosition()`.
      // node: DOMNode|String
      //		id or reference to node to get style for
      // name: String?
      //		the style property to get
      // example:
      //		Passing only an ID or node returns the computed style object of
      //		the node:
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.get("thinger");
      //	|	});
      // example:
      //		Passing a node and a style property returns the current
      //		normalized, computed value for that property:
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.get("thinger", "opacity"); // 1 by default
      //	|	});
      var n = dom.byId(node), l = arguments.length, op = name == 'opacity';
      if (l == 2 && op) {
        return _getOpacity(n);
      }
      name = _floatAliases[name] ? 'cssFloat' in n.style ? 'cssFloat' : 'styleFloat' : name;
      var s = style.getComputedStyle(n);
      return l == 1 ? s : _toStyleValue(n, name, s[name] || n.style[name]);  /* CSS2Properties||String||Number */
    };
    style.set = function setStyle(node, name, value) {
      // summary:
      //		Sets styles on a node.
      // node: DOMNode|String
      //		id or reference to node to set style for
      // name: String|Object
      //		the style property to set in DOM-accessor format
      //		("borderWidth", not "border-width") or an object with key/value
      //		pairs suitable for setting each property.
      // value: String?
      //		If passed, sets value on the node for style, handling
      //		cross-browser concerns.  When setting a pixel value,
      //		be sure to include "px" in the value. For instance, top: "200px".
      //		Otherwise, in some cases, some browsers will not apply the style.
      //
      // example:
      //		Passing a node, a style property, and a value changes the
      //		current display of the node and returns the new computed value
      //	|	require(["dojo/dom-style"], function(domStyle){
      //	|		domStyle.set("thinger", "opacity", 0.5); // == 0.5
      //	|	});
      //
      // example:
      //		Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
      //	|	require(["dojo/dom-style"], function(domStyle){
      //	|		domStyle.set("thinger", {
      //	|			"opacity": 0.5,
      //	|			"border": "3px solid black",
      //	|			"height": "300px"
      //	|		});
      //	|	});
      //
      // example:
      //		When the CSS style property is hyphenated, the JavaScript property is camelCased.
      //		font-size becomes fontSize, and so on.
      //	|	require(["dojo/dom-style", "dojo/dom"], function(domStyle, dom){
      //	|		domStyle.set("thinger",{
      //	|			fontSize:"14pt",
      //	|			letterSpacing:"1.2em"
      //	|		});
      //	|	});
      //
      // example:
      //		dojo/NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
      //		dojo/dom-style.get() on every element of the list. See: `dojo/query` and `dojo/NodeList`
      //	|	require(["dojo/dom-style", "dojo/query", "dojo/NodeList-dom"],
      //	|	function(domStyle, query){
      //	|		query(".someClassName").style("visibility","hidden");
      //	|		// or
      //	|		query("#baz > div").style({
      //	|			opacity:0.75,
      //	|			fontSize:"13pt"
      //	|		});
      //	|	});
      var n = dom.byId(node), l = arguments.length, op = name == 'opacity';
      name = _floatAliases[name] ? 'cssFloat' in n.style ? 'cssFloat' : 'styleFloat' : name;
      if (l == 3) {
        return op ? _setOpacity(n, value) : n.style[name] = value;  // Number
      }
      for (var x in name) {
        style.set(node, x, name[x]);
      }
      return style.getComputedStyle(n);
    };
    return style;
  }(dojo_sniff, dojo_dom);
  dojo__base_fx = function (dojo, config, lang, Evented, Color, aspect, has, dom, style) {
    // module:
    //		dojo/_base/fx
    // notes:
    //		Animation loosely package based on Dan Pupius' work, contributed under CLA; see
    //		http://pupius.co.uk/js/Toolkit.Drawing.js
    var _mixin = lang.mixin;
    // Module export
    var basefx = {};
    var _Line = basefx._Line = function (start, end) {
      // summary:
      //		Object used to generate values from a start value to an end value
      // start: int
      //		Beginning value for range
      // end: int
      //		Ending value for range
      this.start = start;
      this.end = end;
    };
    _Line.prototype.getValue = function (n) {
      // summary:
      //		Returns the point on the line
      // n:
      //		a floating point number greater than 0 and less than 1
      return (this.end - this.start) * n + this.start;  // Decimal
    };
    var Animation = basefx.Animation = function (args) {
      // summary:
      //		A generic animation class that fires callbacks into its handlers
      //		object at various states.
      // description:
      //		A generic animation class that fires callbacks into its handlers
      //		object at various states. Nearly all dojo animation functions
      //		return an instance of this method, usually without calling the
      //		.play() method beforehand. Therefore, you will likely need to
      //		call .play() on instances of `Animation` when one is
      //		returned.
      // args: Object
      //		The 'magic argument', mixing all the properties into this
      //		animation instance.
      _mixin(this, args);
      if (lang.isArray(this.curve)) {
        this.curve = new _Line(this.curve[0], this.curve[1]);
      }
    };
    Animation.prototype = new Evented();
    lang.extend(Animation, {
      // duration: Integer
      //		The time in milliseconds the animation will take to run
      duration: 350,
      /*=====
      		// curve: _Line|Array
      		//		A two element array of start and end values, or a `_Line` instance to be
      		//		used in the Animation.
      		curve: null,
      
      		// easing: Function?
      		//		A Function to adjust the acceleration (or deceleration) of the progress
      		//		across a _Line
      		easing: null,
      	=====*/
      // repeat: Integer?
      //		The number of times to loop the animation
      repeat: 0,
      // rate: Integer?
      //		the time in milliseconds to wait before advancing to next frame
      //		(used as a fps timer: 1000/rate = fps)
      rate: 20  /* 50 fps */,
      /*=====
      		// delay: Integer?
      		//		The time in milliseconds to wait before starting animation after it
      		//		has been .play()'ed
      		delay: null,
      
      		// beforeBegin: Event?
      		//		Synthetic event fired before a Animation begins playing (synchronous)
      		beforeBegin: null,
      
      		// onBegin: Event?
      		//		Synthetic event fired as a Animation begins playing (useful?)
      		onBegin: null,
      
      		// onAnimate: Event?
      		//		Synthetic event fired at each interval of the Animation
      		onAnimate: null,
      
      		// onEnd: Event?
      		//		Synthetic event fired after the final frame of the Animation
      		onEnd: null,
      
      		// onPlay: Event?
      		//		Synthetic event fired any time the Animation is play()'ed
      		onPlay: null,
      
      		// onPause: Event?
      		//		Synthetic event fired when the Animation is paused
      		onPause: null,
      
      		// onStop: Event
      		//		Synthetic event fires when the Animation is stopped
      		onStop: null,
      
      	=====*/
      _percent: 0,
      _startRepeatCount: 0,
      _getStep: function () {
        var _p = this._percent, _e = this.easing;
        return _e ? _e(_p) : _p;
      },
      _fire: function (evt, args) {
        // summary:
        //		Convenience function.  Fire event "evt" and pass it the
        //		arguments specified in "args".
        // description:
        //		Convenience function.  Fire event "evt" and pass it the
        //		arguments specified in "args".
        //		Fires the callback in the scope of this Animation
        //		instance.
        // evt:
        //		The event to fire.
        // args:
        //		The arguments to pass to the event.
        var a = args || [];
        if (this[evt]) {
          if (config.debugAtAllCosts) {
            this[evt].apply(this, a);
          } else {
            try {
              this[evt].apply(this, a);
            } catch (e) {
              console.error('exception in animation handler for:', evt);
              console.error(e);
            }
          }
        }
        return this;  // Animation
      },
      play: function (delay, gotoStart) {
        // summary:
        //		Start the animation.
        // delay:
        //		How many milliseconds to delay before starting.
        // gotoStart:
        //		If true, starts the animation from the beginning; otherwise,
        //		starts it from its current position.
        // returns: Animation
        //		The instance to allow chaining.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        if (gotoStart) {
          _t._stopTimer();
          _t._active = _t._paused = false;
          _t._percent = 0;
        } else if (_t._active && !_t._paused) {
          return _t;
        }
        _t._fire('beforeBegin', [_t.node]);
        var de = delay || _t.delay, _p = lang.hitch(_t, '_play', gotoStart);
        if (de > 0) {
          _t._delayTimer = setTimeout(_p, de);
          return _t;
        }
        _p();
        return _t;  // Animation
      },
      _play: function (gotoStart) {
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        _t._startTime = new Date().valueOf();
        if (_t._paused) {
          _t._startTime -= _t.duration * _t._percent;
        }
        _t._active = true;
        _t._paused = false;
        var value = _t.curve.getValue(_t._getStep());
        if (!_t._percent) {
          if (!_t._startRepeatCount) {
            _t._startRepeatCount = _t.repeat;
          }
          _t._fire('onBegin', [value]);
        }
        _t._fire('onPlay', [value]);
        _t._cycle();
        return _t;  // Animation
      },
      pause: function () {
        // summary:
        //		Pauses a running animation.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        _t._stopTimer();
        if (!_t._active) {
          return _t;  /*Animation*/
        }
        _t._paused = true;
        _t._fire('onPause', [_t.curve.getValue(_t._getStep())]);
        return _t;  // Animation
      },
      gotoPercent: function (percent, andPlay) {
        // summary:
        //		Sets the progress of the animation.
        // percent:
        //		A percentage in decimal notation (between and including 0.0 and 1.0).
        // andPlay:
        //		If true, play the animation after setting the progress.
        var _t = this;
        _t._stopTimer();
        _t._active = _t._paused = true;
        _t._percent = percent;
        if (andPlay) {
          _t.play();
        }
        return _t;  // Animation
      },
      stop: function (gotoEnd) {
        // summary:
        //		Stops a running animation.
        // gotoEnd:
        //		If true, the animation will end.
        var _t = this;
        if (_t._delayTimer) {
          _t._clearTimer();
        }
        if (!_t._timer) {
          return _t;  /* Animation */
        }
        _t._stopTimer();
        if (gotoEnd) {
          _t._percent = 1;
        }
        _t._fire('onStop', [_t.curve.getValue(_t._getStep())]);
        _t._active = _t._paused = false;
        return _t;  // Animation
      },
      destroy: function () {
        // summary:
        //		cleanup the animation
        this.stop();
      },
      status: function () {
        // summary:
        //		Returns a string token representation of the status of
        //		the animation, one of: "paused", "playing", "stopped"
        if (this._active) {
          return this._paused ? 'paused' : 'playing';  // String
        }
        return 'stopped';  // String
      },
      _cycle: function () {
        var _t = this;
        if (_t._active) {
          var curr = new Date().valueOf();
          // Allow durations of 0 (instant) by setting step to 1 - see #13798
          var step = _t.duration === 0 ? 1 : (curr - _t._startTime) / _t.duration;
          if (step >= 1) {
            step = 1;
          }
          _t._percent = step;
          // Perform easing
          if (_t.easing) {
            step = _t.easing(step);
          }
          _t._fire('onAnimate', [_t.curve.getValue(step)]);
          if (_t._percent < 1) {
            _t._startTimer();
          } else {
            _t._active = false;
            if (_t.repeat > 0) {
              _t.repeat--;
              _t.play(null, true);
            } else if (_t.repeat == -1) {
              _t.play(null, true);
            } else {
              if (_t._startRepeatCount) {
                _t.repeat = _t._startRepeatCount;
                _t._startRepeatCount = 0;
              }
            }
            _t._percent = 0;
            _t._fire('onEnd', [_t.node]);
            !_t.repeat && _t._stopTimer();
          }
        }
        return _t;  // Animation
      },
      _clearTimer: function () {
        // summary:
        //		Clear the play delay timer
        clearTimeout(this._delayTimer);
        delete this._delayTimer;
      }
    });
    // the local timer, stubbed into all Animation instances
    var ctr = 0, timer = null, runner = {
        run: function () {
        }
      };
    lang.extend(Animation, {
      _startTimer: function () {
        if (!this._timer) {
          this._timer = aspect.after(runner, 'run', lang.hitch(this, '_cycle'), true);
          ctr++;
        }
        if (!timer) {
          timer = setInterval(lang.hitch(runner, 'run'), this.rate);
        }
      },
      _stopTimer: function () {
        if (this._timer) {
          this._timer.remove();
          this._timer = null;
          ctr--;
        }
        if (ctr <= 0) {
          clearInterval(timer);
          timer = null;
          ctr = 0;
        }
      }
    });
    var _makeFadeable = has('ie') ? function (node) {
      // only set the zoom if the "tickle" value would be the same as the
      // default
      var ns = node.style;
      // don't set the width to auto if it didn't already cascade that way.
      // We don't want to f anyones designs
      if (!ns.width.length && style.get(node, 'width') == 'auto') {
        ns.width = 'auto';
      }
    } : function () {
    };
    basefx._fade = function (args) {
      // summary:
      //		Returns an animation that will fade the node defined by
      //		args.node from the start to end values passed (args.start
      //		args.end) (end is mandatory, start is optional)
      args.node = dom.byId(args.node);
      var fArgs = _mixin({ properties: {} }, args), props = fArgs.properties.opacity = {};
      props.start = !('start' in fArgs) ? function () {
        return +style.get(fArgs.node, 'opacity') || 0;
      } : fArgs.start;
      props.end = fArgs.end;
      var anim = basefx.animateProperty(fArgs);
      aspect.after(anim, 'beforeBegin', lang.partial(_makeFadeable, fArgs.node), true);
      return anim;  // Animation
    };
    /*=====
    	var __FadeArgs = declare(null, {
    		// node: DOMNode|String
    		//		The node referenced in the animation
    		// duration: Integer?
    		//		Duration of the animation in milliseconds.
    		// easing: Function?
    		//		An easing function.
    	});
    	=====*/
    basefx.fadeIn = function (args) {
      // summary:
      //		Returns an animation that will fade node defined in 'args' from
      //		its current opacity to fully opaque.
      return basefx._fade(_mixin({ end: 1 }, args));  // Animation
    };
    basefx.fadeOut = function (args) {
      // summary:
      //		Returns an animation that will fade node defined in 'args'
      //		from its current opacity to fully transparent.
      return basefx._fade(_mixin({ end: 0 }, args));  // Animation
    };
    basefx._defaultEasing = function (n) {
      // summary:
      //		The default easing function for Animation(s)
      return 0.5 + Math.sin((n + 1.5) * Math.PI) / 2;  // Decimal
    };
    var PropLine = function (properties) {
      // PropLine is an internal class which is used to model the values of
      // an a group of CSS properties across an animation lifecycle. In
      // particular, the "getValue" function handles getting interpolated
      // values between start and end for a particular CSS value.
      this._properties = properties;
      for (var p in properties) {
        var prop = properties[p];
        if (prop.start instanceof Color) {
          // create a reusable temp color object to keep intermediate results
          prop.tempColor = new Color();
        }
      }
    };
    PropLine.prototype.getValue = function (r) {
      var ret = {};
      for (var p in this._properties) {
        var prop = this._properties[p], start = prop.start;
        if (start instanceof Color) {
          ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
        } else if (!lang.isArray(start)) {
          ret[p] = (prop.end - start) * r + start + (p != 'opacity' ? prop.units || 'px' : 0);
        }
      }
      return ret;
    };
    /*=====
    	var __AnimArgs = declare(__FadeArgs, {
    		// properties: Object?
    		//		A hash map of style properties to Objects describing the transition,
    		//		such as the properties of _Line with an additional 'units' property
    		properties: {}
    
    		//TODOC: add event callbacks
    	});
    	=====*/
    basefx.animateProperty = function (args) {
      // summary:
      //		Returns an animation that will transition the properties of
      //		node defined in `args` depending how they are defined in
      //		`args.properties`
      //
      // description:
      //		Foundation of most `dojo/_base/fx`
      //		animations. It takes an object of "properties" corresponding to
      //		style properties, and animates them in parallel over a set
      //		duration.
      //
      // example:
      //		A simple animation that changes the width of the specified node.
      //	|	basefx.animateProperty({
      //	|		node: "nodeId",
      //	|		properties: { width: 400 },
      //	|	}).play();
      //		Dojo figures out the start value for the width and converts the
      //		integer specified for the width to the more expressive but
      //		verbose form `{ width: { end: '400', units: 'px' } }` which you
      //		can also specify directly. Defaults to 'px' if omitted.
      //
      // example:
      //		Animate width, height, and padding over 2 seconds... the
      //		pedantic way:
      //	|	basefx.animateProperty({ node: node, duration:2000,
      //	|		properties: {
      //	|			width: { start: '200', end: '400', units:"px" },
      //	|			height: { start:'200', end: '400', units:"px" },
      //	|			paddingTop: { start:'5', end:'50', units:"px" }
      //	|		}
      //	|	}).play();
      //		Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
      //		are written using "mixed case", as the hyphen is illegal as an object key.
      //
      // example:
      //		Plug in a different easing function and register a callback for
      //		when the animation ends. Easing functions accept values between
      //		zero and one and return a value on that basis. In this case, an
      //		exponential-in curve.
      //	|	basefx.animateProperty({
      //	|		node: "nodeId",
      //	|		// dojo figures out the start value
      //	|		properties: { width: { end: 400 } },
      //	|		easing: function(n){
      //	|			return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
      //	|		},
      //	|		onEnd: function(node){
      //	|			// called when the animation finishes. The animation
      //	|			// target is passed to this function
      //	|		}
      //	|	}).play(500); // delay playing half a second
      //
      // example:
      //		Like all `Animation`s, animateProperty returns a handle to the
      //		Animation instance, which fires the events common to Dojo FX. Use `aspect.after`
      //		to access these events outside of the Animation definition:
      //	|	var anim = basefx.animateProperty({
      //	|		node:"someId",
      //	|		properties:{
      //	|			width:400, height:500
      //	|		}
      //	|	});
      //	|	aspect.after(anim, "onEnd", function(){
      //	|		console.log("animation ended");
      //	|	}, true);
      //	|	// play the animation now:
      //	|	anim.play();
      //
      // example:
      //		Each property can be a function whose return value is substituted along.
      //		Additionally, each measurement (eg: start, end) can be a function. The node
      //		reference is passed directly to callbacks.
      //	|	basefx.animateProperty({
      //	|		node:"mine",
      //	|		properties:{
      //	|			height:function(node){
      //	|				// shrink this node by 50%
      //	|				return domGeom.position(node).h / 2
      //	|			},
      //	|			width:{
      //	|				start:function(node){ return 100; },
      //	|				end:function(node){ return 200; }
      //	|			}
      //	|		}
      //	|	}).play();
      //
      var n = args.node = dom.byId(args.node);
      if (!args.easing) {
        args.easing = dojo._defaultEasing;
      }
      var anim = new Animation(args);
      aspect.after(anim, 'beforeBegin', lang.hitch(anim, function () {
        var pm = {};
        for (var p in this.properties) {
          // Make shallow copy of properties into pm because we overwrite
          // some values below. In particular if start/end are functions
          // we don't want to overwrite them or the functions won't be
          // called if the animation is reused.
          if (p == 'width' || p == 'height') {
            this.node.display = 'block';
          }
          var prop = this.properties[p];
          if (lang.isFunction(prop)) {
            prop = prop(n);
          }
          prop = pm[p] = _mixin({}, lang.isObject(prop) ? prop : { end: prop });
          if (lang.isFunction(prop.start)) {
            prop.start = prop.start(n);
          }
          if (lang.isFunction(prop.end)) {
            prop.end = prop.end(n);
          }
          var isColor = p.toLowerCase().indexOf('color') >= 0;
          function getStyle(node, p) {
            // domStyle.get(node, "height") can return "auto" or "" on IE; this is more reliable:
            var v = {
              height: node.offsetHeight,
              width: node.offsetWidth
            }[p];
            if (v !== undefined) {
              return v;
            }
            v = style.get(node, p);
            return p == 'opacity' ? +v : isColor ? v : parseFloat(v);
          }
          if (!('end' in prop)) {
            prop.end = getStyle(n, p);
          } else if (!('start' in prop)) {
            prop.start = getStyle(n, p);
          }
          if (isColor) {
            prop.start = new Color(prop.start);
            prop.end = new Color(prop.end);
          } else {
            prop.start = p == 'opacity' ? +prop.start : parseFloat(prop.start);
          }
        }
        this.curve = new PropLine(pm);
      }), true);
      aspect.after(anim, 'onAnimate', lang.hitch(style, 'set', anim.node), true);
      return anim;  // Animation
    };
    basefx.anim = function (node, properties, duration, easing, onEnd, delay) {
      // summary:
      //		A simpler interface to `animateProperty()`, also returns
      //		an instance of `Animation` but begins the animation
      //		immediately, unlike nearly every other Dojo animation API.
      // description:
      //		Simpler (but somewhat less powerful) version
      //		of `animateProperty`.  It uses defaults for many basic properties
      //		and allows for positional parameters to be used in place of the
      //		packed "property bag" which is used for other Dojo animation
      //		methods.
      //
      //		The `Animation` object returned will be already playing, so
      //		calling play() on it again is (usually) a no-op.
      // node:
      //		a DOM node or the id of a node to animate CSS properties on
      // duration:
      //		The number of milliseconds over which the animation
      //		should run. Defaults to the global animation default duration
      //		(350ms).
      // easing:
      //		An easing function over which to calculate acceleration
      //		and deceleration of the animation through its duration.
      //		A default easing algorithm is provided, but you may
      //		plug in any you wish. A large selection of easing algorithms
      //		are available in `dojo/fx/easing`.
      // onEnd:
      //		A function to be called when the animation finishes
      //		running.
      // delay:
      //		The number of milliseconds to delay beginning the
      //		animation by. The default is 0.
      // example:
      //		Fade out a node
      //	|	basefx.anim("id", { opacity: 0 });
      // example:
      //		Fade out a node over a full second
      //	|	basefx.anim("id", { opacity: 0 }, 1000);
      return basefx.animateProperty({
        // Animation
        node: node,
        duration: duration || Animation.prototype.duration,
        properties: properties,
        easing: easing,
        onEnd: onEnd
      }).play(delay || 0);
    };
    if (has('extend-dojo')) {
      _mixin(dojo, basefx);
      // Alias to drop come 2.0:
      dojo._Animation = Animation;
    }
    return basefx;
  }(dojo__base_kernel, dojo__base_config, dojo__base_lang, dojo_Evented, dojo__base_Color, dojo_aspect, dojo_sniff, dojo_dom, dojo_dom_style);
  dojo_dom_geometry = function (has, win, dom, style) {
    // module:
    //		dojo/dom-geometry
    // the result object
    var geom = {};
    // Box functions will assume this model.
    // On IE/Opera, BORDER_BOX will be set if the primary document is in quirks mode.
    // Can be set to change behavior of box setters.
    // can be either:
    //	"border-box"
    //	"content-box" (default)
    geom.boxModel = 'content-box';
    // We punt per-node box mode testing completely.
    // If anybody cares, we can provide an additional (optional) unit
    // that overrides existing code to include per-node box sensitivity.
    // Opera documentation claims that Opera 9 uses border-box in BackCompat mode.
    // but experiments (Opera 9.10.8679 on Windows Vista) indicate that it actually continues to use content-box.
    // IIRC, earlier versions of Opera did in fact use border-box.
    // Opera guys, this is really confusing. Opera being broken in quirks mode is not our fault.
    if (has('ie')  /*|| has("opera")*/) {
      // client code may have to adjust if compatMode varies across iframes
      geom.boxModel = document.compatMode == 'BackCompat' ? 'border-box' : 'content-box';
    }
    geom.getPadExtents = function getPadExtents(node, computedStyle) {
      // summary:
      //		Returns object with special values specifically useful for node
      //		fitting.
      // description:
      //		Returns an object with `w`, `h`, `l`, `t` properties:
      //	|		l/t/r/b = left/top/right/bottom padding (respectively)
      //	|		w = the total of the left and right padding
      //	|		h = the total of the top and bottom padding
      //		If 'node' has position, l/t forms the origin for child nodes.
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.paddingLeft), t = px(node, s.paddingTop), r = px(node, s.paddingRight), b = px(node, s.paddingBottom);
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    var none = 'none';
    geom.getBorderExtents = function getBorderExtents(node, computedStyle) {
      // summary:
      //		returns an object with properties useful for noting the border
      //		dimensions.
      // description:
      //		- l/t/r/b = the sum of left/top/right/bottom border (respectively)
      //		- w = the sum of the left and right border
      //		- h = the sum of the top and bottom border
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var px = style.toPixelValue, s = computedStyle || style.getComputedStyle(node), l = s.borderLeftStyle != none ? px(node, s.borderLeftWidth) : 0, t = s.borderTopStyle != none ? px(node, s.borderTopWidth) : 0, r = s.borderRightStyle != none ? px(node, s.borderRightWidth) : 0, b = s.borderBottomStyle != none ? px(node, s.borderBottomWidth) : 0;
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    geom.getPadBorderExtents = function getPadBorderExtents(node, computedStyle) {
      // summary:
      //		Returns object with properties useful for box fitting with
      //		regards to padding.
      // description:
      //		- l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)
      //		- w = the sum of the left and right padding and border
      //		- h = the sum of the top and bottom padding and border
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), p = geom.getPadExtents(node, s), b = geom.getBorderExtents(node, s);
      return {
        l: p.l + b.l,
        t: p.t + b.t,
        r: p.r + b.r,
        b: p.b + b.b,
        w: p.w + b.w,
        h: p.h + b.h
      };
    };
    geom.getMarginExtents = function getMarginExtents(node, computedStyle) {
      // summary:
      //		returns object with properties useful for box fitting with
      //		regards to box margins (i.e., the outer-box).
      //
      //		- l/t = marginLeft, marginTop, respectively
      //		- w = total width, margin inclusive
      //		- h = total height, margin inclusive
      //
      //		The w/h are used for calculating boxes.
      //		Normally application code will not need to invoke this
      //		directly, and will use the ...box... functions instead.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), px = style.toPixelValue, l = px(node, s.marginLeft), t = px(node, s.marginTop), r = px(node, s.marginRight), b = px(node, s.marginBottom);
      return {
        l: l,
        t: t,
        r: r,
        b: b,
        w: l + r,
        h: t + b
      };
    };
    // Box getters work in any box context because offsetWidth/clientWidth
    // are invariant wrt box context
    //
    // They do *not* work for display: inline objects that have padding styles
    // because the user agent ignores padding (it's bogus styling in any case)
    //
    // Be careful with IMGs because they are inline or block depending on
    // browser and browser mode.
    // Although it would be easier to read, there are not separate versions of
    // _getMarginBox for each browser because:
    // 1. the branching is not expensive
    // 2. factoring the shared code wastes cycles (function call overhead)
    // 3. duplicating the shared code wastes bytes
    geom.getMarginBox = function getMarginBox(node, computedStyle) {
      // summary:
      //		returns an object that encodes the width, height, left and top
      //		positions of the node's margin box.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), me = geom.getMarginExtents(node, s), l = node.offsetLeft - me.l, t = node.offsetTop - me.t, p = node.parentNode, px = style.toPixelValue, pcs;
      if (has('mozilla')) {
        // Mozilla:
        // If offsetParent has a computed overflow != visible, the offsetLeft is decreased
        // by the parent's border.
        // We don't want to compute the parent's style, so instead we examine node's
        // computed left/top which is more stable.
        var sl = parseFloat(s.left), st = parseFloat(s.top);
        if (!isNaN(sl) && !isNaN(st)) {
          l = sl;
          t = st;
        } else {
          // If child's computed left/top are not parseable as a number (e.g. "auto"), we
          // have no choice but to examine the parent's computed style.
          if (p && p.style) {
            pcs = style.getComputedStyle(p);
            if (pcs.overflow != 'visible') {
              l += pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
              t += pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
            }
          }
        }
      } else if (has('opera') || has('ie') == 8 && !has('quirks')) {
        // On Opera and IE 8, offsetLeft/Top includes the parent's border
        if (p) {
          pcs = style.getComputedStyle(p);
          l -= pcs.borderLeftStyle != none ? px(node, pcs.borderLeftWidth) : 0;
          t -= pcs.borderTopStyle != none ? px(node, pcs.borderTopWidth) : 0;
        }
      }
      return {
        l: l,
        t: t,
        w: node.offsetWidth + me.w,
        h: node.offsetHeight + me.h
      };
    };
    geom.getContentBox = function getContentBox(node, computedStyle) {
      // summary:
      //		Returns an object that encodes the width, height, left and top
      //		positions of the node's content box, irrespective of the
      //		current box model.
      // node: DOMNode
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      // clientWidth/Height are important since the automatically account for scrollbars
      // fallback to offsetWidth/Height for special cases (see #3378)
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), w = node.clientWidth, h, pe = geom.getPadExtents(node, s), be = geom.getBorderExtents(node, s);
      if (!w) {
        w = node.offsetWidth;
        h = node.offsetHeight;
      } else {
        h = node.clientHeight;
        be.w = be.h = 0;
      }
      // On Opera, offsetLeft includes the parent's border
      if (has('opera')) {
        pe.l += be.l;
        pe.t += be.t;
      }
      return {
        l: pe.l,
        t: pe.t,
        w: w - pe.w - be.w,
        h: h - pe.h - be.h
      };
    };
    // Box setters depend on box context because interpretation of width/height styles
    // vary wrt box context.
    //
    // The value of boxModel is used to determine box context.
    // boxModel can be set directly to change behavior.
    //
    // Beware of display: inline objects that have padding styles
    // because the user agent ignores padding (it's a bogus setup anyway)
    //
    // Be careful with IMGs because they are inline or block depending on
    // browser and browser mode.
    //
    // Elements other than DIV may have special quirks, like built-in
    // margins or padding, or values not detectable via computedStyle.
    // In particular, margins on TABLE do not seems to appear
    // at all in computedStyle on Mozilla.
    function setBox(node, l, t, w, h, u) {
      // summary:
      //		sets width/height/left/top in the current (native) box-model
      //		dimensions. Uses the unit passed in u.
      // node:
      //		DOM Node reference. Id string not supported for performance
      //		reasons.
      // l:
      //		left offset from parent.
      // t:
      //		top offset from parent.
      // w:
      //		width in current box model.
      // h:
      //		width in current box model.
      // u:
      //		unit measure to use for other measures. Defaults to "px".
      u = u || 'px';
      var s = node.style;
      if (!isNaN(l)) {
        s.left = l + u;
      }
      if (!isNaN(t)) {
        s.top = t + u;
      }
      if (w >= 0) {
        s.width = w + u;
      }
      if (h >= 0) {
        s.height = h + u;
      }
    }
    function isButtonTag(node) {
      // summary:
      //		True if the node is BUTTON or INPUT.type="button".
      return node.tagName.toLowerCase() == 'button' || node.tagName.toLowerCase() == 'input' && (node.getAttribute('type') || '').toLowerCase() == 'button';  // boolean
    }
    function usesBorderBox(node) {
      // summary:
      //		True if the node uses border-box layout.
      // We could test the computed style of node to see if a particular box
      // has been specified, but there are details and we choose not to bother.
      // TABLE and BUTTON (and INPUT type=button) are always border-box by default.
      // If you have assigned a different box to either one via CSS then
      // box functions will break.
      return geom.boxModel == 'border-box' || node.tagName.toLowerCase() == 'table' || isButtonTag(node);  // boolean
    }
    geom.setContentSize = function setContentSize(node, box, computedStyle) {
      // summary:
      //		Sets the size of the node's contents, irrespective of margins,
      //		padding, or borders.
      // node: DOMNode
      // box: Object
      //		hash with optional "w", and "h" properties for "width", and "height"
      //		respectively. All specified properties should have numeric values in whole pixels.
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var w = box.w, h = box.h;
      if (usesBorderBox(node)) {
        var pb = geom.getPadBorderExtents(node, computedStyle);
        if (w >= 0) {
          w += pb.w;
        }
        if (h >= 0) {
          h += pb.h;
        }
      }
      setBox(node, NaN, NaN, w, h);
    };
    var nilExtents = {
      l: 0,
      t: 0,
      w: 0,
      h: 0
    };
    geom.setMarginBox = function setMarginBox(node, box, computedStyle) {
      // summary:
      //		sets the size of the node's margin box and placement
      //		(left/top), irrespective of box model. Think of it as a
      //		passthrough to setBox that handles box-model vagaries for
      //		you.
      // node: DOMNode
      // box: Object
      //		hash with optional "l", "t", "w", and "h" properties for "left", "right", "width", and "height"
      //		respectively. All specified properties should have numeric values in whole pixels.
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var s = computedStyle || style.getComputedStyle(node), w = box.w, h = box.h,
        // Some elements have special padding, margin, and box-model settings.
        // To use box functions you may need to set padding, margin explicitly.
        // Controlling box-model is harder, in a pinch you might set dojo/dom-geometry.boxModel.
        pb = usesBorderBox(node) ? nilExtents : geom.getPadBorderExtents(node, s), mb = geom.getMarginExtents(node, s);
      if (has('webkit')) {
        // on Safari (3.1.2), button nodes with no explicit size have a default margin
        // setting an explicit size eliminates the margin.
        // We have to swizzle the width to get correct margin reading.
        if (isButtonTag(node)) {
          var ns = node.style;
          if (w >= 0 && !ns.width) {
            ns.width = '4px';
          }
          if (h >= 0 && !ns.height) {
            ns.height = '4px';
          }
        }
      }
      if (w >= 0) {
        w = Math.max(w - pb.w - mb.w, 0);
      }
      if (h >= 0) {
        h = Math.max(h - pb.h - mb.h, 0);
      }
      setBox(node, box.l, box.t, w, h);
    };
    // =============================
    // Positioning
    // =============================
    geom.isBodyLtr = function isBodyLtr(doc) {
      // summary:
      //		Returns true if the current language is left-to-right, and false otherwise.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Boolean
      doc = doc || win.doc;
      return (win.body(doc).dir || doc.documentElement.dir || 'ltr').toLowerCase() == 'ltr';  // Boolean
    };
    geom.docScroll = function docScroll(doc) {
      // summary:
      //		Returns an object with {node, x, y} with corresponding offsets.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Object
      doc = doc || win.doc;
      var node = win.doc.parentWindow || win.doc.defaultView;
      // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
      return 'pageXOffset' in node ? {
        x: node.pageXOffset,
        y: node.pageYOffset
      } : (node = has('quirks') ? win.body(doc) : doc.documentElement) && {
        x: geom.fixIeBiDiScrollLeft(node.scrollLeft || 0, doc),
        y: node.scrollTop || 0
      };
    };
    if (has('ie')) {
      geom.getIeDocumentElementOffset = function getIeDocumentElementOffset(doc) {
        // summary:
        //		returns the offset in x and y from the document body to the
        //		visual edge of the page for IE
        // doc: Document?
        //		Optional document to query.   If unspecified, use win.doc.
        // description:
        //		The following values in IE contain an offset:
        //	|		event.clientX
        //	|		event.clientY
        //	|		node.getBoundingClientRect().left
        //	|		node.getBoundingClientRect().top
        //		But other position related values do not contain this offset,
        //		such as node.offsetLeft, node.offsetTop, node.style.left and
        //		node.style.top. The offset is always (2, 2) in LTR direction.
        //		When the body is in RTL direction, the offset counts the width
        //		of left scroll bar's width.  This function computes the actual
        //		offset.
        //NOTE: assumes we're being called in an IE browser
        doc = doc || win.doc;
        var de = doc.documentElement;
        // only deal with HTML element here, position() handles body/quirks
        if (has('ie') < 8) {
          var r = de.getBoundingClientRect(),
            // works well for IE6+
            l = r.left, t = r.top;
          if (has('ie') < 7) {
            l += de.clientLeft;
            // scrollbar size in strict/RTL, or,
            t += de.clientTop;  // HTML border size in strict
          }
          return {
            x: l < 0 ? 0 : l,
            // FRAME element border size can lead to inaccurate negative values
            y: t < 0 ? 0 : t
          };
        } else {
          return {
            x: 0,
            y: 0
          };
        }
      };
    }
    geom.fixIeBiDiScrollLeft = function fixIeBiDiScrollLeft(scrollLeft, doc) {
      // summary:
      //		In RTL direction, scrollLeft should be a negative value, but IE
      //		returns a positive one. All codes using documentElement.scrollLeft
      //		must call this function to fix this error, otherwise the position
      //		will offset to right when there is a horizontal scrollbar.
      // scrollLeft: Number
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Number
      // In RTL direction, scrollLeft should be a negative value, but IE
      // returns a positive one. All codes using documentElement.scrollLeft
      // must call this function to fix this error, otherwise the position
      // will offset to right when there is a horizontal scrollbar.
      doc = doc || win.doc;
      var ie = has('ie');
      if (ie && !geom.isBodyLtr(doc)) {
        var qk = has('quirks'), de = qk ? win.body(doc) : doc.documentElement, pwin = win.global;
        // TODO: use winUtils.get(doc) after resolving circular dependency b/w dom-geometry.js and dojo/window.js
        if (ie == 6 && !qk && pwin.frameElement && de.scrollHeight > de.clientHeight) {
          scrollLeft += de.clientLeft;  // workaround ie6+strict+rtl+iframe+vertical-scrollbar bug where clientWidth is too small by clientLeft pixels
        }
        return ie < 8 || qk ? scrollLeft + de.clientWidth - de.scrollWidth : -scrollLeft;  // Integer
      }
      return scrollLeft;  // Integer
    };
    geom.position = function (node, includeScroll) {
      // summary:
      //		Gets the position and size of the passed element relative to
      //		the viewport (if includeScroll==false), or relative to the
      //		document root (if includeScroll==true).
      //
      // description:
      //		Returns an object of the form:
      //		`{ x: 100, y: 300, w: 20, h: 15 }`.
      //		If includeScroll==true, the x and y values will include any
      //		document offsets that may affect the position relative to the
      //		viewport.
      //		Uses the border-box model (inclusive of border and padding but
      //		not margin).  Does not act as a setter.
      // node: DOMNode|String
      // includeScroll: Boolean?
      // returns: Object
      node = dom.byId(node);
      var db = win.body(node.ownerDocument), ret = node.getBoundingClientRect();
      ret = {
        x: ret.left,
        y: ret.top,
        w: ret.right - ret.left,
        h: ret.bottom - ret.top
      };
      if (has('ie') < 9) {
        // On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()
        var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
        // fixes the position in IE, quirks mode
        ret.x -= offset.x + (has('quirks') ? db.clientLeft + db.offsetLeft : 0);
        ret.y -= offset.y + (has('quirks') ? db.clientTop + db.offsetTop : 0);
      }
      // account for document scrolling
      // if offsetParent is used, ret value already includes scroll position
      // so we may have to actually remove that value if !includeScroll
      if (includeScroll) {
        var scroll = geom.docScroll(node.ownerDocument);
        ret.x += scroll.x;
        ret.y += scroll.y;
      }
      return ret;  // Object
    };
    // random "private" functions wildly used throughout the toolkit
    geom.getMarginSize = function getMarginSize(node, computedStyle) {
      // summary:
      //		returns an object that encodes the width and height of
      //		the node's margin box
      // node: DOMNode|String
      // computedStyle: Object?
      //		This parameter accepts computed styles object.
      //		If this parameter is omitted, the functions will call
      //		dojo/dom-style.getComputedStyle to get one. It is a better way, calling
      //		dojo/dom-style.getComputedStyle once, and then pass the reference to this
      //		computedStyle parameter. Wherever possible, reuse the returned
      //		object of dojo/dom-style.getComputedStyle().
      node = dom.byId(node);
      var me = geom.getMarginExtents(node, computedStyle || style.getComputedStyle(node));
      var size = node.getBoundingClientRect();
      return {
        w: size.right - size.left + me.w,
        h: size.bottom - size.top + me.h
      };
    };
    geom.normalizeEvent = function (event) {
      // summary:
      //		Normalizes the geometry of a DOM event, normalizing the pageX, pageY,
      //		offsetX, offsetY, layerX, and layerX properties
      // event: Object
      if (!('layerX' in event)) {
        event.layerX = event.offsetX;
        event.layerY = event.offsetY;
      }
      if (!has('dom-addeventlistener')) {
        // old IE version
        // FIXME: scroll position query is duped from dojo/_base/html to
        // avoid dependency on that entire module. Now that HTML is in
        // Base, we should convert back to something similar there.
        var se = event.target;
        var doc = se && se.ownerDocument || document;
        // DO NOT replace the following to use dojo/_base/window.body(), in IE, document.documentElement should be used
        // here rather than document.body
        var docBody = has('quirks') ? doc.body : doc.documentElement;
        var offset = geom.getIeDocumentElementOffset(doc);
        event.pageX = event.clientX + geom.fixIeBiDiScrollLeft(docBody.scrollLeft || 0, doc) - offset.x;
        event.pageY = event.clientY + (docBody.scrollTop || 0) - offset.y;
      }
    };
    // TODO: evaluate separate getters/setters for position and sizes?
    return geom;
  }(dojo_sniff, dojo__base_window, dojo_dom, dojo_dom_style);
  dojo__base_event = function (dojo, on, has, dom) {
    // module:
    //		dojo/_base/event
    if (on._fixEvent) {
      var fixEvent = on._fixEvent;
      on._fixEvent = function (evt, se) {
        // add some additional normalization for back-compat, this isn't in on.js because it is somewhat more expensive
        evt = fixEvent(evt, se);
        if (evt) {
          dom.normalizeEvent(evt);
        }
        return evt;
      };
    }
    var ret = {
      // summary:
      //		This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +
      //		evt.preventDefault(), rather than this module.
      fix: function (evt, sender) {
        // summary:
        //		normalizes properties on the event object including event
        //		bubbling methods, keystroke normalization, and x/y positions
        // evt: Event
        //		native event object
        // sender: DOMNode
        //		node to treat as "currentTarget"
        if (on._fixEvent) {
          return on._fixEvent(evt, sender);
        }
        return evt;  // Event
      },
      stop: function (evt) {
        // summary:
        //		prevents propagation and clobbers the default action of the
        //		passed event
        // evt: Event
        //		The event object. If omitted, window.event is used on IE.
        if (has('dom-addeventlistener') || evt && typeof evt.preventDefault === 'function') {
          //PATCHED
          try {
            evt.preventDefault();
            evt.stopPropagation();
          } catch (e) {
            console.warn('Failed to stop event propagation');
          }
        } else {
          evt = evt || window.event;
          evt.cancelBubble = true;
          on._preventDefault.call(evt);
        }
      }
    };
    if (has('extend-dojo')) {
      dojo.fixEvent = ret.fix;
      dojo.stopEvent = ret.stop;
    }
    return ret;
  }(dojo__base_kernel, dojo_on, dojo_has, dojo_dom_geometry);
  synchronite__base_event = function (i18next, has, query, baseEvent) {
    ////////////////////////////////////
    // PRIVATE VARIABLES & FUNCTIONS
    ////////////////////////////////////
    var _stackTraceContains = function (fnName) {
        var caller;
        var getName = function (fn) {
          if (fn.name) {
            return fn.name;
          }
          var definition = fn.toString().split('\n')[0];
          var exp = /^function ([^\s(]+).+/;
          if (exp.test(definition)) {
            return definition.split('\n')[0].replace(exp, '$1') || 'anonymous';
          }
          return 'anonymous';
        };
        try {
          caller = arguments.callee.caller.caller;
        } catch (e) {
          console.warn('isSimulated: Error getting stack trace. Assuming event is NOT simulated.');
          return false;
        }
        var iDepth = 0, gotName;
        while (caller && iDepth < 10) {
          //FIXED: caller!=null
          iDepth++;
          gotName = getName(caller);
          if (gotName.indexOf(fnName) === 0) {
            return true;
          } else {
            try {
              caller = caller.caller;
            } catch (e) {
              console.warn('isSimulated: Error getting stack trace. Assuming event is NOT simulated.');
              return false;
            }
          }
        }
        return false;
      }, _msgShown = 0;
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchEvent = {
      blockEvent: function (evt) {
        if (this.isSimulated(evt)) {
          return true;
        }
        if (!_msgShown) {
          var blocked_text = i18next.t('accessblocked', { ns: ['session'] });
          this.displayMsg(blocked_text);
          window.setTimeout(this.resetMsg, 5000);
        }
        baseEvent.stop(evt);
        return false;
      },
      previousReturnValue: function (event) {
        var isDefaultPrevented = event.defaultPrevented || /* Chrome 18, Firefox 6.0, IE9, Opera 11, Safari 5.0 */
        event.returnValue === false || event.getPreventDefault && event.getPreventDefault() || /* non-standard, deprecated */
        event.result === false  /* jQuery specific http://api.jquery.com/event.result/ */;
        if (isDefaultPrevented) {
          event.preventDefault();
          console.debug('previous return value: ' + false);
          return false;
        } else {
          console.debug('previous return value: ' + true);
          return true;
        }
      },
      isSimulated: function (event) {
        //FIXED: Did not detect simulated keyEvents in SAFARI/Chrome
        if (event) {
          if (event.synthetic) {
            return true;
          }
          if (event.screenX == 1 && event.screenY == 1) {
            return true;
          }
          // Property only exists in FF (and not for scroll)
          if (event.type != 'scroll') {
            if (typeof event.isTrusted == 'boolean') {
              if (event.isTrusted === false) {
                return true;  // FF3: isTrusted=false => simulated event
              }
              var target = event.target || event.srcElement;
              // We do not trust clicks on input checkboxes /radios as these can be triggered automatically
              // from simulated label clicks in IE9
              if (event.isTrusted === true && !(/^input$/i.test(target.nodeName) && /^(checkbox|radio)$/i.test(target.type))) {
                // FF3: isTrusted=true => user initiated event
                return false;
              }
            }
          }
          if (_stackTraceContains('synchroniteDispatch') || _stackTraceContains('handle')) {
            return true;
          }
          return event.screenX == 1 && event.screenY == 1 || event.clientX === 0 && event.clientY === 0;
        } else {
          return true;
        }
      },
      /**
       * Binds to a DOM element event
       * @param elem
       * @param eventName
       * @param callback
       * @returns signal to remove event call signal.remove();
       */
      on: function (elem, eventName, callback, capture) {
        capture = !!capture;
        if (elem.addEventListener) {
          elem.addEventListener(eventName, callback, capture);
          return {
            remove: function () {
              elem.removeEventListener(eventName, callback, capture);
            }
          };
        } else {
          elem.attachEvent('on' + eventName, callback);
          return {
            remove: function () {
              elem.detachEvent('on' + eventName, callback);
            }
          };
        }
      },
      resetMsg: function () {
        _msgShown = 0;
        query('#msg').style({ display: 'none' });
        query('#msg').removeClass('shakeanim');
        query('#msg > span').empty();
      },
      displayMsg: function (message) {
        _msgShown = 1;
        query('#msg > span').attr({ innerHTML: message });
        query('#msg').style({ display: 'block' });
        query('#msg').addClass('shakeanim');
      },
      getNodeFromEvent: function (event) {
        if (event.composedPath) {
          return event.composedPath()[0];
        } else {
          return event.target || event.srcElement;
        }
      }
    };
    return synchEvent;
  }(i18next_loader, dojo_has, dojo_query, dojo__base_event);
  synchronite__base_goog = function () {
    // The 'sinkValue' function is required to signal to the closure
    // compiler that a variable should not be removed.
    // see: http://docs.closure-library.googlecode.com/git/closure_goog_reflect_reflect.js.source.html
    // bug reports:
    // https://code.google.com/p/closure-compiler/issues/detail?id=506
    // https://code.google.com/p/closure-compiler/issues/detail?id=451
    /**
     * To assert to the compiler that an operation is needed when it would
     * otherwise be stripped. For example:
     * <code>
     *     // Force a layout
     *     goog.reflect.sinkValue(dialog.offsetHeight);
     * </code>
     * @type {!Function}
     */
    var sinkValue = function (x) {
      sinkValue[' '](x);
      return x;
    };
    /**
     * The compiler should optimize this function away iff no one ever uses
     * goog.reflect.sinkValue.
     */
    sinkValue[' '] = function () {
    };
    var goog = {
      sinkValue: sinkValue,
      keepFunctionName: function (name, anonFunc) {
        if (anonFunc.toString) {
          var functionComplete = anonFunc.toString();
          var functionParamsAndBody = functionComplete.slice(functionComplete.indexOf('('), functionComplete.length + 1);
          //noinspection JSHint
          return new Function('return function ' + name + functionParamsAndBody)();
        }
        return anonFunc;
      }
    };
    return goog;
  }();
  synchronite_micro_dom = function (has, goog, baseArray) {
    //PRIVATE
    var _isVisible = function (node) {
      // summary: Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
      // description: Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
      // Some SVG elements do not implement getBox() and throw a "NS_ERROR_NOT_IMPLEMENTED" exception
      var visible = false;
      try {
        visible = node.offsetWidth && node.offsetHeight || node.clientWidth && node.clientHeight || node.getBBox && node.getBBox() && node.getBBox().width && node.getBBox().width;
      } catch (e) {
        console.warn('Failed to determine if element is visible ' + e);
      }
      return visible;
    };
    /**
     * For feature detection
     * @param {Function} fn The function to test for native support
     */
    var _isNative = function (f) {
      try {
        return !!f && ((typeof f).toLowerCase() == 'function' || (typeof f).toLowerCase() == 'object') && (f === Function.prototype || /\s*\[native code\]\s*s*/i.test(String(f)));
      } catch (e) {
        return true;
      }
    };
    var scrollable = function (theoreticallyScrollable, contextWindow) {
      var filter = function (element) {
        var elementStyle = contextWindow.getComputedStyle(element);
        if (!elementStyle) {
          return false;
        }
        var overflow = elementStyle.overflow, overflowX = elementStyle.overflowX, overflowY = elementStyle.overflowY;
        if (!(overflow || overflowX || overflowY)) {
          // Shortcut when styles are not set at all
          return false;
        }
        if (element.className.indexOf('scrollWindow') >= 0) {
          // Fixes dijit scrollable view on HSBC website
          return true;
        }
        var SCROLLABLE = {
          scroll: 1,
          auto: 1  // visible: 1 // Overflow is not clipped. It renders outside the element's box. This is default
        };
        var vertically_scrollable, horizontally_scrollable;
        if (overflow in SCROLLABLE) {
          return true;
        }
        vertically_scrollable = (theoreticallyScrollable || element.clientHeight < element.scrollHeight) && (overflowY in SCROLLABLE || overflow in SCROLLABLE);
        if (vertically_scrollable) {
          return true;
        }
        horizontally_scrollable = (theoreticallyScrollable || element.clientWidth < element.scrollWidth) && (overflowX in SCROLLABLE || overflow in SCROLLABLE);
        if (horizontally_scrollable) {
          return true;
        }
        return false;
      };
      return filter;
    };
    var docScroll = function docScroll(doc) {
      // summary:
      //		Returns an object with {node, x, y} with corresponding offsets.
      // doc: Document?
      //		Optional document to query.   If unspecified, use win.doc.
      // returns: Object
      var scrollRoot = doc.parentWindow || doc.defaultView;
      // use UI window, not dojo.global window.   TODO: use dojo/window::get() except for circular dependency problem
      return 'pageXOffset' in scrollRoot ? {
        x: scrollRoot.pageXOffset,
        y: scrollRoot.pageYOffset
      } : (scrollRoot = has('quirks') ? _getBody(doc) : doc.documentElement) && {
        x: scrollRoot.scrollLeft || 0,
        y: scrollRoot.scrollTop || 0
      };
    };
    var getPosition = function (node, includeScroll) {
      // summary:
      //		Gets the position and size of the passed element relative to
      //		the viewport (if includeScroll==false), or relative to the
      //		document root (if includeScroll==true).
      //
      // description:
      //		Returns an object of the form:
      //		`{ x: 100, y: 300, w: 20, h: 15 }`.
      //		If includeScroll==true, the x and y values will include any
      //		document offsets that may affect the position relative to the
      //		viewport.
      //		Uses the border-box model (inclusive of border and padding but
      //		not margin).  Does not act as a setter.
      // node: DOMNode|String
      // includeScroll: Boolean?
      // returns: Object
      var db = _getBody(node.ownerDocument), ret = node.getBoundingClientRect();
      ret = {
        x: ret.left,
        y: ret.top,
        w: ret.right - ret.left,
        h: ret.bottom - ret.top
      };
      if (has('ie') < 9) {
        // On IE<9 there's a 2px offset that we need to adjust for, see dojo.getIeDocumentElementOffset()
        //var offset = geom.getIeDocumentElementOffset(node.ownerDocument);
        // fixes the position in IE, quirks mode
        ret.x -= has('quirks') ? db.clientLeft + db.offsetLeft : 0;
        ret.y -= has('quirks') ? db.clientTop + db.offsetTop : 0;
      }
      // account for document scrolling
      // if offsetParent is used, ret value already includes scroll position
      // so we may have to actually remove that value if !includeScroll
      if (includeScroll) {
        var scroll = docScroll(node.ownerDocument);
        ret.x += scroll.x;
        ret.y += scroll.y;
      }
      return ret;  // Object
    };
    var getNodePosition = function (node) {
      // summary: Gets the x,y position of an element target including scroll.
      if (_isVisible(node)) {
        try {
          // Uses the border-box model (inclusive of border and padding but
          // not margin).
          return getPosition(node, true);
        } catch (e) {
          console.warn('getNodePosition: Unable to get node position. Page unloaded?');
        }
      }
      return null;
    };
    var _isTextType = function (type) {
      return /text|search|tel|url|email|datetime|date|month|week|time|number|range|color/i.test(type);
    };
    var _isHtml5Typeable = function (el) {
      var tagName = el.tagName;
      return /input/i.test(tagName) && _isTextType(el.type);
    };
    var _getBody = function (doc) {
      return doc.body || doc.getElementsByTagName('body')[0];  // Node
    };
    var _getWin = function (doc) {
      return doc.parentWindow || doc.defaultView;  // Window
    };
    ///////////////
    /**
     * Check if a property can be accessed without throwing an exception.
     * Adapted from goog.reflect.canAccessProperty
     * @param {Object} obj The owner of the property.
     * @param {string} prop The property name.
     * @return {boolean} Whether the property is accessible. Will also return true
     *     if obj is null.
     *
     */
    var _canAccessProperty = function (obj, prop) {
      /** @preserveTry */
      try {
        goog.sinkValue(obj[prop]);
        return true;
      } catch (e) {
      }
      return false;
    };
    // get inherited background color to use as endColor
    // Derives color of child node by parent nodes color
    var getInheritedBgcolor = function (aNode) {
      var parentNode = aNode;
      var body = synchDom.getBody(aNode.ownerDocument);
      if (body && parentNode && parentNode.style) {
        var color = null;
        do {
          color = parentNode.style.backgroundColor;
          if (!color || color.toLowerCase() == 'rgba(0, 0, 0, 0)') {
            color = 'transparent';
          }
          if (parentNode == body) {
            parentNode = null;
            return color;
          }
          parentNode = parentNode.parentNode;
        } while (parentNode && color == 'transparent');
        return color;
      } else {
        return null;
      }
    };
    //PUBLIC
    var synchDom = {
      getInheritedBgcolor: getInheritedBgcolor,
      canAccessProperty: _canAccessProperty,
      canAccessNode: function (node) {
        return _canAccessProperty(node, 'nodeType');
      },
      byId: function (id, doc) {
        if (typeof id != 'string') {
          return id;
        }
        doc = doc || document;
        return doc.getElementById(id);
      },
      setAttributes: function (node, attrs) {
        for (var key in attrs) {
          if (attrs.hasOwnProperty(key)) {
            if (/(innerHTML|className)/.test(key)) {
              node[key] = attrs[key];
            } else {
              node.setAttribute(key, attrs[key]);
            }
          }
        }
      },
      setStyles: function (node, styles) {
        var nodeStyle = node.style;
        for (var key in styles) {
          if (styles.hasOwnProperty(key)) {
            nodeStyle[key] = styles[key];
          }
        }
      },
      toDom: function (html, doc) {
        doc = doc || document;
        html = html.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, html);
        // trim
        var div = doc.createElement('div');
        div.innerHTML = html;
        return div.firstChild;
      },
      create: function (name, attrs, styles, container) {
        if (arguments.length == 3) {
          container = styles;
        }
        var doc = container.ownerDocument, el = doc.createElement(name);
        synchDom.setStyles(el, styles);
        synchDom.setAttributes(el, attrs);
        return container.appendChild(el);
      },
      canAccessWindow: function (win) {
        return _canAccessProperty(win, 'document');
      },
      isWindowScroll: function (node) {
        // summary: Checks if the node scroll should be executed on the window.
        return node.nodeType && node.nodeType == 9 || node.nodeName && /^html$/i.test(node.nodeName);
      },
      isTextType: _isTextType,
      isHtml5Typeable: _isHtml5Typeable,
      isTypeable: function (el) {
        // FIXED: Removed password field
        return el && (/textarea|input/i.test(el.tagName) && (/text|password/i.test(el.type) || _isHtml5Typeable(el)));
      },
      isVisible: _isVisible,
      isNative: _isNative,
      scrollable: scrollable,
      loadScript: function (doc, script, url, id, callback) {
        var scriptNode, exisitingNode = doc.getElementsByTagName(script)[0];
        if (doc.getElementById(id)) {
          if (callback) {
            callback({ scriptExists: true });
          }
          return;
        }
        scriptNode = doc.createElement(script);
        scriptNode.id = id;
        scriptNode.onload = callback;
        scriptNode.src = url;
        exisitingNode.parentNode.insertBefore(scriptNode, exisitingNode);
      },
      scrollableDoc: function (win) {
        var doc = win.document;
        var body = _getBody(doc);
        var scrollRoot = doc.compatMode === 'BackCompat' ? body : doc.documentElement;
        if (scrollRoot) {
          return scrollable(true)(scrollRoot);
        }
        return false;
      },
      addEvent: function (target, eventName, listener) {
        if (target.attachEvent) {
          //Internet Explorer
          target.attachEvent('on' + eventName, function () {
            listener.call(target);
          });
          return {
            remove: function () {
            }
          };
        } else if (target.addEventListener) {
          //Firefox & company
          target.addEventListener(eventName, listener, false);
          //don't need the 'call' trick because in FF everything already works in the right way
          return {
            remove: function () {
              target.removeEventListener(eventName, listener);
            }
          };
        }
      },
      getWin: _getWin,
      getBody: _getBody,
      getNodePosition: getNodePosition,
      getNormalizedMouseOffset: function (element, pageX, pageY) {
        // get x,y position of event target
        var pos;
        try {
          pos = getNodePosition(element);
        } catch (e) {
          console.warn('Unable to get element position. Window may have been unloaded: ' + e);
        }
        if (!pos) {
          return {
            nx: 0.5,
            ny: 0.5
          };
        }
        // position may contain half pixels that we should round
        var offsetX = Math.round(pageX - pos.x);
        var offsetY = Math.round(pageY - pos.y);
        var normalizedX = offsetX / pos.w;
        var normalizedY = offsetY / pos.h;
        if (normalizedX === Infinity || normalizedY === Infinity) {
          normalizedX = 0.5;
          normalizedY = 0.5;
        }
        return {
          ox: offsetX,
          oy: offsetY,
          nx: normalizedX,
          ny: normalizedY
        };
      }
    };
    return synchDom;
  }(dojo_has, synchronite__base_goog, dojo__base_array);
  dojo_regexp = function (dojo, lang) {
    // module:
    //		dojo/regexp
    var regexp = {};
    lang.setObject('dojo.regexp', regexp);
    regexp.escapeString = function (str, except) {
      // summary:
      //		Adds escape sequences for special characters in regular expressions
      // except:
      //		a String with special characters to be left unescaped
      return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, function (ch) {
        if (except && except.indexOf(ch) != -1) {
          return ch;
        }
        return '\\' + ch;
      });  // String
    };
    regexp.buildGroupRE = function (arr, re, nonCapture) {
      // summary:
      //		Builds a regular expression that groups subexpressions
      // description:
      //		A utility function used by some of the RE generators. The
      //		subexpressions are constructed by the function, re, in the second
      //		parameter.  re builds one subexpression for each elem in the array
      //		a, in the first parameter. Returns a string for a regular
      //		expression that groups all the subexpressions.
      // arr:
      //		A single value or an array of values.
      // re:
      //		A function. Takes one parameter and converts it to a regular
      //		expression.
      // nonCapture:
      //		If true, uses non-capturing match, otherwise matches are retained
      //		by regular expression. Defaults to false
      // case 1: a is a single value.
      if (!(arr instanceof Array)) {
        return re(arr);  // String
      }
      // case 2: a is an array
      var b = [];
      for (var i = 0; i < arr.length; i++) {
        // convert each elem to a RE
        b.push(re(arr[i]));
      }
      // join the REs as alternatives in a RE group.
      return regexp.group(b.join('|'), nonCapture);  // String
    };
    regexp.group = function (expression, nonCapture) {
      // summary:
      //		adds group match to expression
      // nonCapture:
      //		If true, uses non-capturing match, otherwise matches are retained
      //		by regular expression.
      return '(' + (nonCapture ? '?:' : '') + expression + ')';  // String
    };
    return regexp;
  }(dojo__base_kernel, dojo__base_lang);
  synchronite__base_cookie = function (dojoRegexp) {
    return function (doc, name, value, props) {
      // PACTHED FROM DEFAULT DOJO COOKIE NOT TO USE decodeURIComponent.
      //  summary:
      //      Get or set a cookie.
      //  description:
      //      If one argument is passed, returns the value of the cookie
      //      For two or more arguments, acts as a setter.
      //  doc:
      //      document object to operate on
      //  name:
      //      Name of the cookie
      //  value:
      //      Value for the cookie
      //  props:
      //      Properties for the cookie
      //  example:
      //      set a cookie with the JSON-serialized contents of an object which
      //      will expire 5 days from now:
      //  |   dojoCookie("configObj", dojoJson.stringify(config), { expires: 5 });
      //
      //  example:
      //      de-serialize a cookie back into a JavaScript object:
      //  |   var config = dojoJson.parse(dojoCookie("configObj"));
      //
      //  example:
      //      delete a cookie:
      //  |   dojoCookie("configObj", null, {expires: -1});
      var c = doc.cookie, ret;
      if (arguments.length == 2) {
        var matches = c.match(new RegExp('(?:^|; )' + dojoRegexp.escapeString(name) + '=([^;]*)'));
        ret = matches ? matches[1] : undefined;  // String or undefined
      } else {
        props = props || {};
        // FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
        var exp = props.expires;
        if (typeof exp == 'number') {
          var d = new Date();
          d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1000);
          exp = props.expires = d;
        }
        if (exp && exp.toUTCString) {
          props.expires = exp.toUTCString();
        }
        var updatedCookie = name + '=' + value, propName;
        for (propName in props) {
          updatedCookie += '; ' + propName;
          var propValue = props[propName];
          if (propValue !== true) {
            updatedCookie += '=' + propValue;
          }
        }
        doc.cookie = updatedCookie;
      }
      return ret;  // String|undefined
    };
  }(dojo_regexp);
  synchronite__base_window = function (synchQuery, synchCookie, strings) {
    ////////////////////////////////////
    // PRIVATE VARIABLES & FUNCTIONS
    ////////////////////////////////////
    var win = window, config = win.synchroniteConfig;
    var _isWindow = function (o) {
      return 'navigator' in o && 'clearInterval' in o && 'moveBy' in o && o.self === o.window;
    };
    var topOrExternalTargets = {
      '_top': 1,
      '_parent': 1,
      '_blank': 1,
      '_new': 1
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchWindow = {
      // http://stackoverflow.com/questions/679112/copying-a-function-object-from-one-window-to-another
      exportFunction: function (fn, win) {
        var code;
        try {
          code = fn.toString();
          var params = code.match(/\(([^)]*)\)/);
          if (typeof params[1] !== 'undefined') {
            params = params[1].split(/\s*,\s*/);
          } else {
            params = null;
          }
          code = code.replace(/^[^{]*\{/, '');
          code = code.replace(/}$/, '');
          if (params) {
            return new win.Function(params, code);
          }
          return new win.Function(code);
        } catch (e) {
          console.error('exportFunction: Cannot export function: ' + code);
        }
      },
      hasInflightRequest: function (method) {
        if (win.synch && !win.synch.allFramesLoaded) {
          if (!method) {
            // We just want to know if a new page load is in progress and are not interested in the method
            // that caused the page load (e.g. GET or POST)
            console.debug('hasInflightRequest(' + (method ? method : '') + ') -> true');
            return true;
          }
          // mouse click triggered has triggered new page load
          // Two scenarios:
          // 1. GET Request (e.g. Click on link)
          if (method == 'post') {
            console.debug('hasInflightRequest(' + (method ? method : '') + ') -> ' + !!synch.postInProgress);
            return !!synch.postInProgress;
          }
          console.debug('hasInflightRequest(' + (method ? method : '') + ') -> true');
          return true;
        }
        console.debug('hasInflightRequest(' + (method ? method : '') + ') -> false');
        return false;
      },
      isWindowInitialized: function (selector) {
        var aWindow = null;
        try {
          if (_isWindow(selector)) {
            aWindow = selector;
          } else {
            var frameSelector = selector.frame;
            var frameName = selector.frameName;
            var windowName = selector.windowName;
            if (frameName) {
              aWindow = synchQuery.getWindowFromFrameName(frameName);
            } else if (windowName == strings.SYNCHRONIZED_WINDOW) {
              aWindow = synchQuery.synchronizedWindow();
            } else if (windowName && window[windowName]) {
              aWindow = window[windowName];
            } else if (windowName && window.name == windowName) {
              console.warn('Accessing presenter window. Dialog open?');
              aWindow = window;
            } else if (frameSelector) {
              aWindow = synchQuery.queryFrame(frameSelector);
            } else {
              aWindow = synchQuery.synchronizedWindow();
            }
          }
          //            if (aWindow && aWindow.document) {
          //                console.debug("readyState: " + aWindow.document.readyState);
          //                console.debug("initialized: " + aWindow.initialized);
          //            }
          if (aWindow && (aWindow.document && (aWindow.document.readyState == 'interactive' || aWindow.document.readyState == 'complete') || aWindow.initialized)) {
            return true;
          } else {
            console.warn('WINDOW LOADING: ' + selector.frame);
            return false;
          }
        } catch (e) {
          if (typeof selector === 'undefined') {
            console.warn('WINDOW LOADING');
          } else {
            console.warn('WINDOW LOADING:  ', selector.frame);
          }
          return false;
        }
      },
      rewriteLinkTarget: function (linkNode) {
        // summary: Adjusts/Rewrites the target attribute of the anchor node, to make sure
        //          the new window is opened in the main synchronized window.
        // Warning: formTag.action fails to retrieve the attribute when the form has an input
        //          child node with name='target'
        var currentLinkTarget = linkNode.getAttribute('target');
        var newLinkTarget;
        if (currentLinkTarget) {
          var sourceDoc = linkNode.ownerDocument, sourceWin = sourceDoc.parentWindow || sourceDoc.defaultView;
          var synchronizedWindow = synchQuery.synchronizedWindow();
          var synchronizedWindowName = synchronizedWindow.name;
          // May be changed by scripts inside synchronized page
          if (sourceWin == synchronizedWindow && currentLinkTarget in topOrExternalTargets) {
            // FIXED: Bug where strings.SYNCHRONIZED_WINDOW target cannot be found because
            //        the name of the synchronized window has changed and windows
            //        with target == "_top" --> strings.SYNCHRONIZED_WINDOW open in new window.
            linkNode.removeAttribute('target');
          } else if (currentLinkTarget === '_top') {
            newLinkTarget = synchronizedWindowName;
          } else if (currentLinkTarget === '_parent') {
            //relative target
            var targetWin = sourceWin[currentLinkTarget.substring(1)];
            if (targetWin == synchronizedWindow) {
              newLinkTarget = currentLinkTarget;
            } else if (sourceWin == synchronizedWindow) {
              newLinkTarget = '_self';
            } else if (targetWin == window) {
              newLinkTarget = synchronizedWindowName;
            } else {
              newLinkTarget = currentLinkTarget;
            }
          } else if (currentLinkTarget === '_blank' || currentLinkTarget === '_new') {
            newLinkTarget = synchQuery.getRelativeIdentifier(sourceWin, synchQuery.synchronizedWindow());
          } else {
            newLinkTarget = currentLinkTarget;
          }
          if (newLinkTarget) {
            linkNode.setAttribute('target', newLinkTarget);
          }
        }
      },
      eraseCookies: function (cookieWin) {
        var cookieDoc;
        try {
          cookieWin = cookieWin || synchQuery.synchronizedWindow();
          cookieDoc = cookieWin.document;
        } catch (e) {
          console.error('Unable to find cookieWin. Possible XSS issue.');
        }
        // Try to remove all cookies using javascript
        if (cookieDoc) {
          var cookies = cookieDoc.cookie.split(';');
          var cookieName;
          // SYNCHRONITEID should not and cannot be deleted since it is
          // HttpOnly. Other s.xyz cookies should also not be deleted.
          for (var i = 0; i < cookies.length; i++) {
            cookieName = cookies[i].split('=')[0];
            cookieName = cookieName.replace(/\s/gi, '');
            if (cookieName && !/s\.[\w]{3}/.test(cookieName)) {
              // I. TRY: Delete cookie on current domain and current path
              synchCookie(cookieDoc, cookieName, null, { expires: -1 });
              // II. TRY: Delete cookies on current domain name and root path
              synchCookie(cookieDoc, cookieName, null, {
                expires: -1,
                path: '/'
              });
              // III. TRY: If cookie still exists
              // delete cookie with proxy host
              if (synchCookie(cookieDoc, cookieName)) {
                synchCookie(cookieDoc, cookieName, null, {
                  expires: -1,
                  path: '/',
                  domain: '.' + config.proxyHost
                });
              }
            }
          }
        }
      }
    };
    return synchWindow;
  }(synchronite__base_query, synchronite__base_cookie, synchronite_constants_strings);
  dojo_errors_create = function (lang) {
    return function (name, ctor, base, props) {
      base = base || Error;
      var ErrorCtor = function (message) {
        if (base === Error) {
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorCtor);
          }
          // Error.call() operates on the returned error
          // object rather than operating on |this|
          var err = Error.call(this, message), prop;
          // Copy own properties from err to |this|
          for (prop in err) {
            if (err.hasOwnProperty(prop)) {
              this[prop] = err[prop];
            }
          }
          // messsage is non-enumerable in ES5
          this.message = message;
          // stack is non-enumerable in at least Firefox
          this.stack = err.stack;
        } else {
          base.apply(this, arguments);
        }
        if (ctor) {
          ctor.apply(this, arguments);
        }
      };
      ErrorCtor.prototype = lang.delegate(base.prototype, props);
      ErrorCtor.prototype.name = name;
      ErrorCtor.prototype.constructor = ErrorCtor;
      return ErrorCtor;
    };
  }(dojo__base_lang);
  dojo_errors_CancelError = function (create) {
    // module:
    //		dojo/errors/CancelError
    /*=====
    	return function(){
    		// summary:
    		//		Default error if a promise is canceled without a reason.
    	};
    	=====*/
    return create('CancelError', null, null, { dojoType: 'cancel' });
  }(dojo_errors_create);
  dojo_promise_Promise = function (lang) {
    // module:
    //		dojo/promise/Promise
    function throwAbstract() {
      throw new TypeError('abstract');
    }
    return lang.extend(function Promise() {
    }, {
      then: function (callback, errback, progback) {
        // summary:
        //		Add new callbacks to the promise.
        // description:
        //		Add new callbacks to the deferred. Callbacks can be added
        //		before or after the deferred is fulfilled.
        // callback: Function?
        //		Callback to be invoked when the promise is resolved.
        //		Receives the resolution value.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        //		Receives the rejection error.
        // progback: Function?
        //		Callback to be invoked when the promise emits a progress
        //		update. Receives the progress update.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback(s).
        //		This can be used for chaining many asynchronous operations.
        throwAbstract();
      },
      cancel: function (reason, strict) {
        // summary:
        //		Inform the deferred it may cancel its asynchronous operation.
        // description:
        //		Inform the deferred it may cancel its asynchronous operation.
        //		The deferred's (optional) canceler is invoked and the
        //		deferred will be left in a rejected state. Can affect other
        //		promises that originate with the same deferred.
        // reason: any
        //		A message that may be sent to the deferred's canceler,
        //		explaining why it's being canceled.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be canceled.
        // returns: any
        //		Returns the rejection reason if the deferred was canceled
        //		normally.
        throwAbstract();
      },
      isResolved: function () {
        // summary:
        //		Checks whether the promise has been resolved.
        // returns: Boolean
        throwAbstract();
      },
      isRejected: function () {
        // summary:
        //		Checks whether the promise has been rejected.
        // returns: Boolean
        throwAbstract();
      },
      isFulfilled: function () {
        // summary:
        //		Checks whether the promise has been resolved or rejected.
        // returns: Boolean
        throwAbstract();
      },
      isCanceled: function () {
        // summary:
        //		Checks whether the promise has been canceled.
        // returns: Boolean
        throwAbstract();
      },
      always: function (callbackOrErrback) {
        // summary:
        //		Add a callback to be invoked when the promise is resolved
        //		or rejected.
        // callbackOrErrback: Function?
        //		A function that is used both as a callback and errback.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback/errback.
        return this.then(callbackOrErrback, callbackOrErrback);
      },
      otherwise: function (errback) {
        // summary:
        //		Add new errbacks to the promise.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the errback.
        return this.then(null, errback);
      },
      trace: function () {
        return this;
      },
      traceRejected: function () {
        return this;
      },
      toString: function () {
        // returns: string
        //		Returns `[object Promise]`.
        return '[object Promise]';
      }
    });
  }(dojo__base_lang);
  dojo_Deferred = function (has, lang, CancelError, Promise, instrumentation) {
    // module:
    //		dojo/Deferred
    var PROGRESS = 0, RESOLVED = 1, REJECTED = 2;
    var FULFILLED_ERROR_MESSAGE = 'This deferred has already been fulfilled.';
    var freezeObject = Object.freeze || function () {
    };
    var signalWaiting = function (waiting, type, result, rejection, deferred) {
      if (false) {
        if (type === REJECTED && Deferred.instrumentRejected && waiting.length === 0) {
          Deferred.instrumentRejected(result, false, rejection, deferred);
        }
      }
      for (var i = 0; i < waiting.length; i++) {
        signalListener(waiting[i], type, result, rejection);
      }
    };
    var signalListener = function (listener, type, result, rejection) {
      var func = listener[type];
      var deferred = listener.deferred;
      if (func) {
        try {
          var newResult = func(result);
          if (type === PROGRESS) {
            if (typeof newResult !== 'undefined') {
              signalDeferred(deferred, type, newResult);
            }
          } else {
            if (newResult && typeof newResult.then === 'function') {
              listener.cancel = newResult.cancel;
              newResult.then(// Only make resolvers if they're actually going to be used
              makeDeferredSignaler(deferred, RESOLVED), makeDeferredSignaler(deferred, REJECTED), makeDeferredSignaler(deferred, PROGRESS));
              return;
            }
            signalDeferred(deferred, RESOLVED, newResult);
          }
        } catch (error) {
          signalDeferred(deferred, REJECTED, error);
        }
      } else {
        signalDeferred(deferred, type, result);
      }
      if (false) {
        if (type === REJECTED && Deferred.instrumentRejected) {
          Deferred.instrumentRejected(result, !!func, rejection, deferred.promise);
        }
      }
    };
    var makeDeferredSignaler = function (deferred, type) {
      return function (value) {
        signalDeferred(deferred, type, value);
      };
    };
    var signalDeferred = function (deferred, type, result) {
      if (!deferred.isCanceled()) {
        switch (type) {
        case PROGRESS:
          deferred.progress(result);
          break;
        case RESOLVED:
          deferred.resolve(result);
          break;
        case REJECTED:
          deferred.reject(result);
          break;
        }
      }
    };
    var Deferred = function (canceler) {
      // summary:
      //		Creates a new deferred. This API is preferred over
      //		`dojo/_base/Deferred`.
      // description:
      //		Creates a new deferred, as an abstraction over (primarily)
      //		asynchronous operations. The deferred is the private interface
      //		that should not be returned to calling code. That's what the
      //		`promise` is for. See `dojo/promise/Promise`.
      // canceler: Function?
      //		Will be invoked if the deferred is canceled. The canceler
      //		receives the reason the deferred was canceled as its argument.
      //		The deferred is rejected with its return value, or a new
      //		`dojo/errors/CancelError` instance.
      // promise: dojo/promise/Promise
      //		The public promise object that clients can add callbacks to. 
      var promise = this.promise = new Promise();
      var deferred = this;
      var fulfilled, result, rejection;
      var canceled = false;
      var waiting = [];
      if (false && Error.captureStackTrace) {
        Error.captureStackTrace(deferred, Deferred);
        Error.captureStackTrace(promise, Deferred);
      }
      this.isResolved = promise.isResolved = function () {
        // summary:
        //		Checks whether the deferred has been resolved.
        // returns: Boolean
        return fulfilled === RESOLVED;
      };
      this.isRejected = promise.isRejected = function () {
        // summary:
        //		Checks whether the deferred has been rejected.
        // returns: Boolean
        return fulfilled === REJECTED;
      };
      this.isFulfilled = promise.isFulfilled = function () {
        // summary:
        //		Checks whether the deferred has been resolved or rejected.
        // returns: Boolean
        return !!fulfilled;
      };
      this.isCanceled = promise.isCanceled = function () {
        // summary:
        //		Checks whether the deferred has been canceled.
        // returns: Boolean
        return canceled;
      };
      this.progress = function (update, strict) {
        // summary:
        //		Emit a progress update on the deferred.
        // description:
        //		Emit a progress update on the deferred. Progress updates
        //		can be used to communicate updates about the asynchronous
        //		operation before it has finished.
        // update: any
        //		The progress update. Passed to progbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently no progress can be emitted.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          signalWaiting(waiting, PROGRESS, update, null, deferred);
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      this.resolve = function (value, strict) {
        // summary:
        //		Resolve the deferred.
        // description:
        //		Resolve the deferred, putting it in a success state.
        // value: any
        //		The result of the deferred. Passed to callbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be resolved.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          // Set fulfilled, store value. After signaling waiting listeners unset
          // waiting.
          signalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);
          waiting = null;
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      var reject = this.reject = function (error, strict) {
        // summary:
        //		Reject the deferred.
        // description:
        //		Reject the deferred, putting it in an error state.
        // error: any
        //		The error result of the deferred. Passed to errbacks.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be rejected.
        // returns: dojo/promise/Promise
        //		Returns the original promise for the deferred.
        if (!fulfilled) {
          if (false && Error.captureStackTrace) {
            Error.captureStackTrace(rejection = {}, reject);
          }
          signalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);
          waiting = null;
          return promise;
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        } else {
          return promise;
        }
      };
      this.then = promise.then = function (callback, errback, progback) {
        // summary:
        //		Add new callbacks to the deferred.
        // description:
        //		Add new callbacks to the deferred. Callbacks can be added
        //		before or after the deferred is fulfilled.
        // callback: Function?
        //		Callback to be invoked when the promise is resolved.
        //		Receives the resolution value.
        // errback: Function?
        //		Callback to be invoked when the promise is rejected.
        //		Receives the rejection error.
        // progback: Function?
        //		Callback to be invoked when the promise emits a progress
        //		update. Receives the progress update.
        // returns: dojo/promise/Promise
        //		Returns a new promise for the result of the callback(s).
        //		This can be used for chaining many asynchronous operations.
        var listener = [
          progback,
          callback,
          errback
        ];
        // Ensure we cancel the promise we're waiting for, or if callback/errback
        // have returned a promise, cancel that one.
        listener.cancel = promise.cancel;
        listener.deferred = new Deferred(function (reason) {
          // Check whether cancel is really available, returned promises are not
          // required to expose `cancel`
          return listener.cancel && listener.cancel(reason);
        });
        if (fulfilled && !waiting) {
          signalListener(listener, fulfilled, result, rejection);
        } else {
          waiting.push(listener);
        }
        return listener.deferred.promise;
      };
      this.cancel = promise.cancel = function (reason, strict) {
        // summary:
        //		Inform the deferred it may cancel its asynchronous operation.
        // description:
        //		Inform the deferred it may cancel its asynchronous operation.
        //		The deferred's (optional) canceler is invoked and the
        //		deferred will be left in a rejected state. Can affect other
        //		promises that originate with the same deferred.
        // reason: any
        //		A message that may be sent to the deferred's canceler,
        //		explaining why it's being canceled.
        // strict: Boolean?
        //		If strict, will throw an error if the deferred has already
        //		been fulfilled and consequently cannot be canceled.
        // returns: any
        //		Returns the rejection reason if the deferred was canceled
        //		normally.
        if (!fulfilled) {
          // Cancel can be called even after the deferred is fulfilled
          if (canceler) {
            var returnedReason = canceler(reason);
            reason = typeof returnedReason === 'undefined' ? reason : returnedReason;
          }
          canceled = true;
          if (!fulfilled) {
            // Allow canceler to provide its own reason, but fall back to a CancelError
            if (typeof reason === 'undefined') {
              reason = new CancelError();
            }
            reject(reason);
            return reason;
          } else if (fulfilled === REJECTED && result === reason) {
            return reason;
          }
        } else if (strict === true) {
          throw new Error(FULFILLED_ERROR_MESSAGE);
        }
      };
      freezeObject(promise);
    };
    Deferred.prototype.toString = function () {
      // returns: String
      //		Returns `[object Deferred]`.
      return '[object Deferred]';
    };
    if (instrumentation) {
      instrumentation(Deferred);
    }
    return Deferred;
  }(dojo_has, dojo__base_lang, dojo_errors_CancelError, dojo_promise_Promise, 0 /* removed ./has!config-deferredInstrumentation?./promise/instrumentation */);
  dojox_encoding_base64 = function (lang) {
    var base64 = lang.getObject('dojox.encoding.base64', true);
    var p = '=';
    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    base64.encode = function (ba) {
      // summary:
      //		Encode an array of bytes as a base64-encoded string
      var s = [], l = ba.length;
      var rm = l % 3;
      var x = l - rm;
      for (var i = 0; i < x;) {
        var t = ba[i++] << 16 | ba[i++] << 8 | ba[i++];
        s.push(tab.charAt(t >>> 18 & 63));
        s.push(tab.charAt(t >>> 12 & 63));
        s.push(tab.charAt(t >>> 6 & 63));
        s.push(tab.charAt(t & 63));
      }
      //	deal with trailers, based on patch from Peter Wood.
      switch (rm) {
      case 2: {
          var t = ba[i++] << 16 | ba[i++] << 8;
          s.push(tab.charAt(t >>> 18 & 63));
          s.push(tab.charAt(t >>> 12 & 63));
          s.push(tab.charAt(t >>> 6 & 63));
          s.push(p);
          break;
        }
      case 1: {
          var t = ba[i++] << 16;
          s.push(tab.charAt(t >>> 18 & 63));
          s.push(tab.charAt(t >>> 12 & 63));
          s.push(p);
          s.push(p);
          break;
        }
      }
      return s.join('');  //	string
    };
    base64.decode = function (str) {
      // summary:
      //		Convert a base64-encoded string to an array of bytes
      var s = str.split(''), out = [];
      var l = s.length;
      while (s[--l] == p) {
      }
      //	strip off trailing padding
      for (var i = 0; i < l;) {
        var t = tab.indexOf(s[i++]) << 18;
        if (i <= l) {
          t |= tab.indexOf(s[i++]) << 12;
        }
        if (i <= l) {
          t |= tab.indexOf(s[i++]) << 6;
        }
        if (i <= l) {
          t |= tab.indexOf(s[i++]);
        }
        out.push(t >>> 16 & 255);
        out.push(t >>> 8 & 255);
        out.push(t & 255);
      }
      //	strip off any null bytes
      while (out[out.length - 1] == 0) {
        out.pop();
      }
      return out;  //	byte[]
    };
    return base64;
  }(dojo__base_lang);
  synchronite__base_base64 = function (base64Coding) {
    // summary: base64 encoder/decoder that converts strings to UTF8 bytes
    // Using UTF-8 Encoding allows better handling of special characters and safe decoding/encoding
    // by server-side components
    var utf8getBytes = function (str) {
        var byteArray = [];
        for (var i = 0; i < str.length; i++) {
          if (str.charCodeAt(i) <= 127) {
            byteArray.push(str.charCodeAt(i));
          } else {
            var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
            for (var j = 0; j < h.length; j++) {
              byteArray.push(parseInt(h[j], 16));
            }
          }
        }
        return byteArray;
      }, utf8toString = function (byteArray) {
        var str = '';
        for (var i = 0; i < byteArray.length; i++) {
          str += byteArray[i] <= 127 ? byteArray[i] === 37 ? '%25' : // %
          String.fromCharCode(byteArray[i]) : '%' + byteArray[i].toString(16).toUpperCase();
        }
        return decodeURIComponent(str);
      };
    var base64 = {
      decode: function (input) {
        var byteArray = base64Coding.decode(input);
        return utf8toString(byteArray);
      },
      encode: function (input) {
        var byteArray = utf8getBytes(input);
        return base64Coding.encode(byteArray);
      },
      encodeChannel: function (input) {
        var reEqual = new RegExp('=', 'g');
        var byteArray = utf8getBytes(input);
        var encoded = base64Coding.encode(byteArray);
        return encoded.replace(reEqual, '');
      }
    };
    return base64;
  }(dojox_encoding_base64);
  dojo_cookie = function (dojo, regexp) {
    // module:
    //		dojo/cookie
    /*=====
    var __cookieProps = {
    	// expires: Date|String|Number?
    	//		If a number, the number of days from today at which the cookie
    	//		will expire. If a date, the date past which the cookie will expire.
    	//		If expires is in the past, the cookie will be deleted.
    	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
    	// path: String?
    	//		The path to use for the cookie.
    	// domain: String?
    	//		The domain to use for the cookie.
    	// secure: Boolean?
    	//		Whether to only send the cookie on secure connections
    };
    =====*/
    dojo.cookie = function (name, value, props) {
      // summary:
      //		Get or set a cookie.
      // description:
      //		If one argument is passed, returns the value of the cookie
      //		For two or more arguments, acts as a setter.
      // name:
      //		Name of the cookie
      // value:
      //		Value for the cookie
      // props:
      //		Properties for the cookie
      // example:
      //		set a cookie with the JSON-serialized contents of an object which
      //		will expire 5 days from now:
      //	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
      //	|		cookie("configObj", json.stringify(config, {expires: 5 }));
      //	|	});
      //
      // example:
      //		de-serialize a cookie back into a JavaScript object:
      //	|	require(["dojo/cookie", "dojo/json"], function(cookie, json){
      //	|		config = json.parse(cookie("configObj"));
      //	|	});
      //
      // example:
      //		delete a cookie:
      //	|	require(["dojo/cookie"], function(cookie){
      //	|		cookie("configObj", null, {expires: -1});
      //	|	});
      var c = document.cookie, ret;
      if (arguments.length == 1) {
        var matches = c.match(new RegExp('(?:^|; )' + regexp.escapeString(name) + '=([^;]*)'));
        ret = matches ? decodeURIComponent(matches[1]) : undefined;
      } else {
        props = props || {};
        // FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
        var exp = props.expires;
        if (typeof exp == 'number') {
          var d = new Date();
          d.setTime(d.getTime() + exp * 24 * 60 * 60 * 1000);
          exp = props.expires = d;
        }
        if (exp && exp.toUTCString) {
          props.expires = exp.toUTCString();
        }
        value = encodeURIComponent(value);
        var updatedCookie = name + '=' + value, propName;
        for (propName in props) {
          updatedCookie += '; ' + propName;
          var propValue = props[propName];
          if (propValue !== true) {
            updatedCookie += '=' + propValue;
          }
        }
        document.cookie = updatedCookie;
      }
      return ret;  // String|undefined
    };
    dojo.cookie.isSupported = function () {
      // summary:
      //		Use to determine if the current browser supports cookies or not.
      //
      //		Returns true if user allows cookies.
      //		Returns false if user doesn't allow cookies.
      if (!('cookieEnabled' in navigator)) {
        this('__djCookieTest__', 'CookiesAllowed');
        navigator.cookieEnabled = this('__djCookieTest__') == 'CookiesAllowed';
        if (navigator.cookieEnabled) {
          this('__djCookieTest__', '', { expires: -1 });
        }
      }
      return navigator.cookieEnabled;
    };
    return dojo.cookie;
  }(dojo__base_kernel, dojo_regexp);
  synchronite_proxyless_lib_lpSecureStorageAMD = function () {
    var win = window;
    /**
     * This taglet brings an iFrame to the page and then sets information inside.
     * It uses indexedDB, local storage, secure cookie or session storage (depends on browser limitations)
     * It limits the retrieval of data to the domain from which the data was set (and any other locations passed in on the set action)
     * and all liveperson domains. All keys are made up of key + siteId to ensure uniqueness per site
     * This only works in IE8 and up in Standards mode
     * @type {*}
     */
    if (win.lpTag && win.lpTag.taglets) {
      if (win.lpTag.taglets.lpSecureStorage) {
        return win.lpTag.taglets.lpSecureStorage;
      }
    } else {
      win.lpTag = win.lpTag || {};
      win.lpTag.taglets = win.lpTag.taglets || {};
    }
    lpTag.taglets.lpSecureStorage = lpTag.taglets.lpSecureStorage || function lpSecureStorage(window) {
      var name = 'lpSecureStorage', version = '2.0.4', sessionStorageStaticDomain = 'STATICSESSIONSTORAGE', windowLoaded = false, windowLoadPendingRequests = [], loadPendingFrames = [], frames = {}, pendingDomains = {}, pendingRequests = {}, domainErrors = {}, validResponseDomains = {}, requestQueue = {}, idCounter = 0, debugMode = false, frameMaxLoadTime = 7000, requestMaxResponseTime = 5000, errorCheckTimeout = 1000, faultToleranceLevel = 10, logLevel = {
          ERROR: 'ERROR',
          DEBUG: 'DEBUG',
          INFO: 'INFO'
        }, requestTypes = {
          SET: 'set',
          GET: 'get',
          REMOVE: 'remove'
        }, storageTypes = {
          LOCALSTORAGE: 'localStorage',
          SESSIONSTORAGE: 'sessionStorage',
          INDEXEDDB: 'indexedDB',
          COOKIE: 'secureSessionCookie',
          STATICSESSIONSTORAGE: sessionStorageStaticDomain
        }, errorTypes = { STORAGE: 'storage_error' }, chosenStorages = {}, chosenStoragesHandlers = {}, CHOSEN_STORAGE_KEY = 'SecureStorageClient/storageType', CROSS_DOMAIN_FEATURE = 'Common.LiveEngage_2_CrossDomainStorage', errorTimeoutId, sessionStorageMethodsObj, requestInProgress = {
          set: function (state, domain) {
            if (domain) {
              this[domain] = state;
            }
          },
          get: function (domain) {
            if (domain) {
              return this[domain];
            }
          }
        };
      /**
       * Binds to the window message or hash change event
       * depending on the protocol
       */
      bindEvent(window, 'message', _handleMessageFromFrame);
      _determineLoadState();
      function init() {
      }
      /**
       * Public get storage type method for a specified frame url
       * The entire chosenStorage object is returned when no url supplied
       * @param url - frame url to get storage of
       */
      function getStorageType(url) {
        if (url && chosenStorages[url]) {
          return chosenStorages[url];
        }
        return chosenStorages;
      }
      /**
       * Public get value method
       * Clears any value passed in on the request to prevent errors
       * @param request
       */
      function getValue(request) {
        if (request && request.value) {
          request.value = null;
          delete request.value;
        }
        request.type = requestTypes.GET;
        _makeRequest(request);
      }
      /**
       * Public set value method
       * @param request
       */
      function setValue(request) {
        if (request && request.expires === -1) {
          removeValue(request);
        } else {
          request.type = requestTypes.SET;
          _makeRequest(request);
        }
      }
      /**
       * Public remove value method
       * @param request
       */
      function removeValue(request) {
        if (request) {
          request.expires = -1;
        }
        request.type = requestTypes.REMOVE;
        _makeRequest(request);
      }
      /**
       * Public configure gets an object with :
       * url - the secure storager url
       * site - the siteid it needs
       * debug - a flag if debug should be enabled
       * initialStorageType - the type of the setorage to be initialized (if supplied)
       * force - force the selected storage
       * asyncStorageMaxRetry - number of retries to choose async storage type
       * @param configuration
       */
      function configure(configuration) {
        if (configuration && configuration.debug === true) {
          debugMode = true;
        }
        for (var key in configuration) {
          if (typeof configuration[key] === 'object' && configuration.hasOwnProperty(key) && configuration[key].site) {
            //noinspection JSUnresolvedVariable
            if (configuration[key].url && configuration[key].url.indexOf('http') === 0) {
              _debug('Configuring url ' + configuration[key].url);
              _attachFrame(configuration[key].url, configuration[key].site, configuration[key], configuration[key].chosenStorageHandler);
            } else if (configuration[key].url === sessionStorageStaticDomain) {
              _configureSessionStorage(configuration[key]);
            }
          }
        }
      }
      /**
       * Makes a single request
       * @param request
       * @private
       */
      function _makeRequest(request) {
        var forceSession = request.domain === sessionStorageStaticDomain;
        if (forceSession) {
          _makeSessionStorageRequest(request);
        } else {
          var domain = _getDomain(request.domain);
          //Get the domain, since this is localStorage different urls don't matter
          if (!requestInProgress.get(domain)) {
            makeIFrameStorageRequest(request, domain);
          } else {
            _addRequestToDomainQueue(request, domain);
          }
        }
      }
      /**
       * Creates the session storage constant object if the underlying libraries exist
       * Returns it's state if session storage works
       * @returns {*}
       * @private
       */
      function _isStorageEnabled() {
        if (lpTag.storageMethods && !sessionStorageMethodsObj) {
          sessionStorageMethodsObj = lpTag.storageMethods;
        }
        if (sessionStorageMethodsObj) {
          return sessionStorageMethodsObj.isSessionStorageEnabled();
        } else {
          return false;
        }
      }
      /**
       * Makes a session storage request locally
       * @param request
       * @private
       */
      function _makeSessionStorageRequest(request) {
        var key, result;
        if (_isStorageEnabled()) {
          key = '' + request.site + request.key;
          switch (request.type) {
          case requestTypes.GET:
            _runCallback(request.success, _getSessionData(key, request), request.key);
            break;
          case requestTypes.SET:
            _setSessionData(key, request);
            _runCallback(request.success, request.value, request.key);
            break;
          case requestTypes.REMOVE:
            result = { 'error': 'Object not found.' };
            if (_removeSessionData(key, request)) {
              result = void 0;
            }
            _runCallback(request.success, result, request.key);
            break;
          }
        } else {
          _runCallback(request.success, {
            error: 'SessionStorage is not active',
            code: 500
          }, request.key);
        }
      }
      /**
       * Extracts the value as it appears in the session storage
       * @param key
       * @returns {*}
       * @private
       */
      function _getRawSessionData(key) {
        var result = sessionStorageMethodsObj.getSessionData(key);
        try {
          result = result === '' ? '' : JSON.parse(result);
        } catch (exc) {
        }
        return result !== '' ? result : null;
      }
      /**
       * Extracts the data as it appears in the SecureStorage convention
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _getSessionData(key, request) {
        var result = _getRawSessionData(key);
        if (request.appName && result !== null && typeof result === 'object') {
          result = result[request.appName];
        }
        return result !== '' ? result : null;
      }
      /**
       * Sets a value in the Secure Storage convention
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _setSessionData(key, request) {
        var data = _getRawSessionData(key);
        if (data === null) {
          data = {};
        }
        if (typeof data === 'object') {
          data[request.appName] = request.value;
          return sessionStorageMethodsObj.setSessionData(key, _stringify(data));
        } else {
          return false;
        }
      }
      /**
       * Removes data from the session storage
       * @param key
       * @param request
       * @returns {*}
       * @private
       */
      function _removeSessionData(key, request) {
        var foundKeyAndAppName = false, keyHasOtherProps = false, data = _getRawSessionData(key);
        if (data !== null && typeof data === 'object' && data.hasOwnProperty(request.appName)) {
          data[request.appName] = null;
          delete data[request.appName];
          for (var dataKey in data) {
            if (data.hasOwnProperty(dataKey)) {
              keyHasOtherProps = true;
              break;
            }
          }
          foundKeyAndAppName = true;
        }
        if (foundKeyAndAppName && keyHasOtherProps) {
          //We're updating the data structure
          return sessionStorageMethodsObj.setSessionData(key, _stringify(data));
        } else if (foundKeyAndAppName) {
          //We found data and it's the last bit
          return sessionStorageMethodsObj.removeSessionData(key);
        } else {
          //Nothing to do, no data found
          return false;
        }
      }
      /**
       * Creates a postmessage cross iFrame request
       * @param request
       */
      function makeIFrameStorageRequest(request, domain) {
        //noinspection JSUnresolvedVariable
        if (request && (request.success || request.error) && request.key && request.appName && request.domain && request.site) {
          delete request.type;
          if (!windowLoaded) {
            windowLoadPendingRequests.push(function () {
              _makeRequest(request);
            });
          } else {
            if (frames[domain]) {
              //We have valid storage to service requests or no storage was yet chosen and this request will configure it
              if (!chosenStorages[domain] || chosenStorages[domain] && !chosenStorages[domain].error) {
                _addToPendingQueue(request);
                _sendPostMessageQuery(request);
                _debug('Made request for key: ' + request.key + ' appName: ' + request.appName);
              } else {
                _runCallback(request.error || request.success, null, request.key);
                _debug('No Storage Selected, Blocked request for key: ' + request.key + ' appName: ' + request.appName);
              }
            } else {
              //noinspection JSUnresolvedVariable
              _attachFrame(request.domain, request.site, request.initialStorageType, request.chosenStorageHandler);
              pendingDomains[domain].push(request);
            }
          }
        }
      }
      /**
       * Writes a request to a specific domain queue to be called
       * These requests have not begun
       * @param request
       * @param domain
       * @private
       */
      function _addRequestToDomainQueue(request, domain) {
        requestQueue[domain] = typeof requestQueue[domain] === 'undefined' ? [] : requestQueue[domain];
        requestQueue[domain].push(request);
      }
      /**
       * Checks our pending request queue for requests
       * that have not returned within a reasonable time frame
       * @private
       */
      function _checkForErrors() {
        var now = new Date().getTime(), activeRequests = false, diff;
        if (errorTimeoutId) {
          clearTimeout(errorTimeoutId);
          errorTimeoutId = null;
        }
        for (var id in pendingRequests) {
          if (pendingRequests.hasOwnProperty(id)) {
            diff = 0;
            diff = now - pendingRequests[id].startTime;
            if (diff >= requestMaxResponseTime) {
              _error('iFrame not responding in time to requests, domain: ' + pendingRequests[id].domain);
              _dispatchResult(id, pendingRequests[id].key, null, true);
            } else {
              activeRequests = true;
            }
          }
        }
        _setErrorTimeout(activeRequests);
      }
      /**
       * Sets the next time we check for errors
       * @param enable
       * @private
       */
      function _setErrorTimeout(enable) {
        if (enable && !errorTimeoutId) {
          errorTimeoutId = setTimeout(_checkForErrors, errorCheckTimeout);
        }
      }
      /**
       *
       * @param domain
       * @param error
       * @private
       */
      function _manageErrorState(domain, error) {
        if (error) {
          if (typeof domainErrors[domain] === 'undefined') {
            domainErrors[domain] = 1;
          } else {
            domainErrors[domain] = domainErrors[domain] + 1;
          }
        } else {
          domainErrors[domain] = 0;
        }
        _debug('Domain ' + domain + ' error count: ' + domainErrors[domain], '_manageErrorState');
        if (domainErrors[domain] > faultToleranceLevel) {
          _frameLoadError(requestQueue[domain], domain, 'iFrame not responding in time to requests');
        }
      }
      /**
       * Removes the iFrame from the DOM
       * and cleans up the internal object
       * @param domain
       */
      function _removeIFrame(domain) {
        if (frames[domain] && frames[domain].parentNode) {
          frames[domain].parentNode.removeChild(frames[domain]);
          frames[domain] = null;
          delete frames[domain];
          domainErrors[domain] = 0;
          _error('Removed iFrame for domain', '_removeIFrame');
        }
      }
      /**
       * Sets the window load status to be ASAP after page has begun to download
       * when the body opens
       */
      function _determineLoadState() {
        if (!document.body) {
          setTimeout(_determineLoadState, 0);
        } else {
          _loaded();
        }
      }
      /**
       * Listens for incoming messages fro the IFrame
       * @param msg
       */
      function _handleMessageFromFrame(msg) {
        if (msg && msg.data && validResponseDomains[msg.origin]) {
          _runListeners(msg.data, msg.origin);
        }
      }
      /**
       * Deletes requests after they've been completed
       * @param id
       */
      function _deletePendingRequest(id) {
        pendingRequests[id] = null;
        delete pendingRequests[id];
      }
      /**
       * Runs all listeners to this request
       * @param data
       * @param origin
       */
      function _runListeners(data, origin) {
        var id, key, responseData, res = _parseResponse(data);
        if (res) {
          id = res.id;
          key = res.key;
          if (CHOSEN_STORAGE_KEY === key) {
            _handleStorageSelection(res, origin);
          } else {
            responseData = typeof res.value !== 'undefined' ? res.value : res.error;
            _dispatchResult(id, res.key, responseData, !!res.error);
            _debug('Got result for key: ' + res.key + ' appName: ' + res.appName);
          }
        }
      }
      /**
       * Handles setting selected storage and notifying any listeners
       * @param res
       * @param origin
       * @private
       */
      function _handleStorageSelection(res, origin) {
        // In case the message key represents a storage type selection message
        // I'll set the chosenStorage for that origin for later use
        chosenStorages[origin] = res.value;
        _debug('Got storage type: ' + res.value + ' for origin: ' + origin + ' appName: ' + res.appName);
        // Invoke supplied handler for chosenStorage if any
        if (chosenStoragesHandlers[origin]) {
          _runCallback(chosenStoragesHandlers[origin], res.value);
        }
      }
      /**
       * Function for running callbacks and cleaning the queue
       * @param id
       * @param key
       * @param data
       * @param error
       * @private
       */
      function _dispatchResult(id, key, data, error) {
        var listener = _getListener(id), domain;
        if (listener) {
          domain = _getDomain(listener.domain);
          _runResponses(listener, data, key, error);
        }
        if (id) {
          _deletePendingRequest(id);
        }
        requestInProgress.set(false, domain);
        _manageErrorState(domain, error);
        if (requestQueue[domain] && requestQueue[domain].length > 0) {
          _makeRequest(requestQueue[domain].shift());
        }
      }
      /**
       * Returns a list of listeners for this data
       * @param id - the id of the specific request made
       * @return {Array} - returns an array of callbacks to trigger
       */
      function _getListener(id) {
        if (id && pendingRequests[id]) {
          return pendingRequests[id];
        }
      }
      /**
       * Runs all the requests pending for that key
       */
      function _runResponses(listener, responseData, key, error) {
        if (error) {
          _runCallback(listener.error, responseData, key);
        } else {
          _runCallback(listener.success, responseData, key);
        }
      }
      /**
       * Parses the response that we got for the event
       * @param res
       * @return {String}
       */
      function _parseResponse(res) {
        try {
          res = decodeURIComponent(res);
          res = JSON.parse(res);
        } catch (exc) {
        }
        return res;
      }
      /**
       * This function was added because of incompatibility between the JSON.stringify and Prototype.js library
       * When a costumer uses Prototype.js library, It overrides the Array.prototype.toJSON function the the native JSON
       * uses. This causes arrays to be double quoted and Shark to fail on those SDEs.
       * The function accepts a value and and uses the native JSON.stringify
       * Can throw an exception (same as JSON.stringify).
       */
      function _stringify(value) {
        var stringified, toJSONPrototype;
        if (typeof Array.prototype.toJSON === 'function') {
          toJSONPrototype = Array.prototype.toJSON;
          delete Array.prototype.toJSON;
          try {
            stringified = JSON.stringify(value);
          } catch (e) {
            Array.prototype.toJSON = toJSONPrototype;
            throw e;
          }
          Array.prototype.toJSON = toJSONPrototype;
        } else {
          stringified = JSON.stringify(value);
        }
        return stringified;
      }
      /**
       * Runs a callback function
       * @param func
       * @param data
       * @param key
       */
      function _runCallback(func, data, key) {
        if (typeof func === 'function') {
          try {
            func(data, key);
          } catch (exc) {
          }
        }
      }
      /**
       * Binds a DOM event to an object
       * @param elem
       * @param eventName
       * @param callback
       */
      function bindEvent(elem, eventName, callback) {
        if (window.addEventListener) {
          elem.addEventListener(eventName, callback, false);
        } else {
          elem.attachEvent('on' + eventName, callback);
        }
      }
      /**
       * Configures session storage with the same conventions as
       * attaching an iFrame
       * @param configuration
       * @private
       */
      function _configureSessionStorage(configuration) {
        var result = { value: 'NONE' };
        chosenStoragesHandlers[sessionStorageStaticDomain] = configuration.chosenStorageHandler;
        if (_isStorageEnabled()) {
          frames[sessionStorageStaticDomain] = true;
          result = { value: storageTypes.STATICSESSIONSTORAGE };
        }
        _handleStorageSelection(result, sessionStorageStaticDomain);
      }
      /**
       * Attaches the iFrame to the DOM
       * and sets it to load
       * @param url - the iFrame location
       * @param site - the first siteId to request this iFrame
       * @param configuration - the frame configuration
       * @param chosenStorageHandler - the handler function for when a storage type is chosen
       * @returns {*}
       * @private
       */
      function _attachFrame(url, site, configuration, chosenStorageHandler) {
        var frame, domain = _getDomain(url);
        if (!frames[domain] && !pendingDomains[domain]) {
          _debug('Attaching iFrame: ' + url + ' domain: ' + domain);
          frame = createIFrame();
          validResponseDomains[domain] = true;
          frame.setAttribute('src', _buildCurrentDomainOnUrl(url, site, configuration));
          pendingDomains[domain] = [];
          if (chosenStorageHandler) {
            chosenStoragesHandlers[domain] = chosenStorageHandler;
          }
          if (!windowLoaded) {
            loadPendingFrames.push(_createBindAndAppend(domain, frame));
          } else {
            _createBindAndAppend(domain, frame)();
          }
        }
        return frame;
      }
      /**
       * Creates an iFrame with all the needed properties
       * for display and accessibility compliance
       * @returns {HTMLElement}
       */
      function createIFrame() {
        var frame = document.createElement('iframe'), style = frame.style, id = 'lpSS_' + Math.floor(Math.random() * 90000000000), props = {
            //Hide iFrame from screen-readers
            'tabIndex': '-1',
            'aria-hidden': 'true',
            'role': 'presentation',
            'title': 'Intentionally blank',
            'name': id,
            'id': id
          };
        style.width = '0px';
        style.height = '0px';
        style.position = 'absolute';
        style.top = '-1000px';
        style.left = '-1000px';
        for (var key in props) {
          if (props.hasOwnProperty(key)) {
            frame.setAttribute(key, props[key]);
          }
        }
        return frame;
      }
      /**
       * Adds the iFrame to the DOM, adds a timeout listener and
       * binds to it's load event
       * @param domain
       * @param frame
       * @returns function
       * @private
       */
      function _createBindAndAppend(domain, frame) {
        return function _bindAndAppend() {
          var loadTimeout = setTimeout(function () {
            _frameLoadError(pendingDomains[domain], domain, 'unable to load iFrame for key');
          }, frameMaxLoadTime);
          bindEvent(frame, 'load', function () {
            _runPendingForDomain(frame, domain, loadTimeout);
          });
          document.body.appendChild(frame);
        };
      }
      /**
       * In case we have an issue loading the iFrame
       * @param requestsArray
       * @param domain
       * @param error
       * @private
       */
      function _frameLoadError(requestsArray, domain, error) {
        while (requestsArray.length > 0) {
          var request = requestsArray.shift();
          if (request.error) {
            setTimeout(_getAsyncCallback(request.error, error || {
              error: error,
              key: request.key
            }, request.key), 0);
          }
        }
        _removeIFrame(domain);
      }
      /**
       * Runs the callback async
       * @param func
       * @param data
       * @param key
       * @returns {Function}
       */
      function _getAsyncCallback(func, data, key) {
        return function () {
          _runCallback(func, data, key);
        };
      }
      /**
       * Register pointer to frame
       * Runs all pending requests for a specific iFrame
       * @param frame
       * @param domain
       * @param loadTimeout
       * @private
       */
      function _runPendingForDomain(frame, domain, loadTimeout) {
        if (loadTimeout) {
          clearTimeout(loadTimeout);
        }
        frames[domain] = frame;
        _debug('Frame loaded ' + domain + ' running pending request for frame');
        if (pendingDomains[domain]) {
          while (pendingDomains[domain].length > 0) {
            _makeRequest(pendingDomains[domain].shift());
          }
          pendingDomains[domain] = null;
          delete pendingDomains[domain];
        }
      }
      /**
       * Sets the current domain so we know where we're hosted
       * @param storagePath
       * @param site
       * @param configuration
       * @return {*}
       */
      function _buildCurrentDomainOnUrl(storagePath, site, configuration) {
        var port, env, storageFileName, url;
        if (storagePath && typeof storagePath === 'string') {
          env = _getEnv();
          storageFileName = _getStorageFileName(configuration);
          storagePath = _getStoragePath(storagePath);
          port = 0 < location.port.length ? ':' + location.port : '';
          url = storagePath + '/' + storageFileName + '?loc=' + encodeURIComponent(location.protocol + '//' + location.hostname + port) + '&site=' + encodeURIComponent(site) + (configuration.initialStorageType ? '&ist=' + encodeURIComponent(configuration.initialStorageType) : '') + (configuration.force ? '&force=' + 1 : '') + (env ? '&env=' + encodeURIComponent(env) : '') + (_isCrossDomainEnabled() ? '&isCrossDomain=true' : '');
        }
        return url;
      }
      function _getStoragePath(storageUrl) {
        var last = storageUrl.lastIndexOf('/'), query, result;
        if (last > 8) {
          result = storageUrl.substr(0, last);
        } else {
          query = storageUrl.indexOf('?');
          if (query > 0) {
            result = storageUrl.substr(0, query);
          }
        }
        return result;
      }
      function _getStorageFileName(configuration) {
        var fileName = 'storage.min.html';
        //Backward compatibility -Last version of secure storage
        if (debugMode) {
          fileName = 'storage.html';
        } else if (configuration.env) {
          //TODO - sync with coBrowse about storage version
          fileName = 'storage.secure.min.html';
        }
        return fileName;
      }
      /**
       * Gets the domain including protocol
       * @param url
       */
      function _getDomain(url) {
        //noinspection JSCheckFunctionSignatures
        var domainRegEx = new RegExp(/(http{1}s{0,1}?:\/\/){0,1}([^\/\?]+)(\/?)/gi), matches = domainRegEx.exec(url), domain = null;
        if (matches && matches.length >= 3 && matches[2] !== '') {
          domain = matches[1] + matches[2].toLowerCase();  // 0 - full match 1- HTTPS 2- domain
        }
        return domain;
      }
      /**
       * Builds an object we can use to run a post message query with
       * @param request
       */
      function _buildPostMessageQuery(request) {
        var postMessageRequest = {};
        postMessageRequest.id = request.id;
        postMessageRequest.key = request.key;
        postMessageRequest.site = request.site;
        postMessageRequest.appName = request.appName || '*';
        if (!isNaN(request.expires)) {
          postMessageRequest.expires = request.expires;
        }
        if (typeof request.value !== 'undefined') {
          postMessageRequest.value = request.value;
          //TODO - remove once coBrowse supports the new structured secure storage
          postMessageRequest.locations = _addDefaultLocation(request.locations);
        }
        return postMessageRequest;
      }
      /**
       * The locations where this data will be retrievable
       * @param locations
       * @deprecated - locations won't be available when cross-domain feature
       */
      function _addDefaultLocation(locations) {
        if (locations) {
          locations = locations.constructor === Array ? locations : [locations];
        } else {
          locations = [];
        }
        locations.push(document.location.hostname);
        return locations;
      }
      /**
       * Sends a post message query if possible
       * @param request
       */
      function _sendPostMessageQuery(request) {
        var query, domain = _getDomain(request.domain);
        if (frames[domain]) {
          request.startTime = new Date().getTime();
          query = _buildPostMessageQuery(request);
          requestInProgress.set(true, domain);
          _postTheMessage(query, domain);
          _setErrorTimeout(true);
        }
      }
      /**
       * Posts the message to the child iFrame
       * @param request
       * @param domain
       */
      function _postTheMessage(request, domain) {
        if (frames[domain]) {
          frames[domain].contentWindow.postMessage(_prepareRequestData(request), domain);
        }
      }
      /**
       * Stringifies and encodes a message before sending it
       * @param data
       */
      function _prepareRequestData(data) {
        try {
          data = _stringify(data);
          data = encodeURIComponent(data);
        } catch (exc) {
        }
        return data;
      }
      /**
       * Notifies of load and handles all request prior to
       * the body element existing
       */
      function _loaded() {
        windowLoaded = true;
        while (loadPendingFrames.length > 0) {
          try {
            loadPendingFrames.shift()();
          } catch (exc) {
          }
        }
        while (windowLoadPendingRequests.length > 0) {
          try {
            windowLoadPendingRequests.shift()();
          } catch (exc) {
          }
        }
      }
      /**
       * Creates a string Id
       * @returns {string}
       */
      function _createRandomKey() {
        idCounter++;
        if (idCounter > 20000) {
          idCounter = 0;
        }
        return 'k' + idCounter + new Date().getTime() + parseInt(Math.random() * 100, 10);
      }
      /**
       * Adds an item to our queue
       * @param request
       * @param key
       */
      function _addToPendingQueue(request, key) {
        request.id = key ? key : _createRandomKey();
        if (typeof request.value !== 'undefined') {
          request.type = 'set';
        }
        pendingRequests[request.id] = request;
      }
      function _isCrossDomainEnabled() {
        return lpTag.features && typeof lpTag.features.getFeature === 'function' && lpTag.features.getFeature(CROSS_DOMAIN_FEATURE);
      }
      function _getEnv() {
        return typeof lpTag.getEnv === 'function' && lpTag.getEnv();
      }
      /**
       * Log function
       * @param msg - the text information
       * @param lvl - INFO or ERROR
       */
      function _log(msg, lvl) {
        if (window.lpTag && lpTag.log) {
          lpTag.log(msg, lvl, name);
        }
      }
      /**
       * Shorthand for errors
       * @private
       */
      function _error(msg) {
        _log(msg, logLevel.ERROR);
      }
      /**
       * Shorthand for debug
       * @private
       */
      function _debug(msg) {
        _log(msg, logLevel.DEBUG);
      }
      /**
       * Shorthand for info
       * @private
       */
      function _info(msg) {
        _log(msg, logLevel.INFO);
      }
      return {
        storageTypes: storageTypes,
        getStorageType: getStorageType,
        getValue: getValue,
        setValue: setValue,
        removeValue: removeValue,
        configure: configure,
        sessionStorageStaticDomain: sessionStorageStaticDomain,
        errorTypes: errorTypes,
        v: version,
        name: name,
        init: init,
        inspect: function () {
          var configuredFrames = {};
          for (var key in frames) {
            if (frames.hasOwnProperty(key)) {
              // The configured frame consists of the
              // frame url and storageType (if known)
              configuredFrames[key] = {
                url: key,
                storageType: chosenStorages[key]
              };
            }
          }
          return {
            name: name,
            version: version,
            configuredFrames: configuredFrames
          };
        }
      };
    }(window);
    return win.lpTag.taglets.lpSecureStorage;
  }();
  synchronite_proxyless_storage = function (dojoCookie, lang, Deferred, lpSecureStorage, baseUrl) {
    var storage = {
      storageEngine: 'cookie',
      secureStorageFrameLocation: '/js/synchronite/webagent/libs/lpSecureStorage/storage.min.html',
      secureStorageDomain: '',
      secureStorageApp: 'cobrowse',
      // If changed must also be changed in cobrowse.js (taglet)
      site: '',
      defaultExpires: 7200 * 1000,
      // two hours
      initialized: false,
      init: function (params) {
        if (this.initialized) {
          return;
        }
        this.initialized = true;
        var win = window;
        if (win.lpTag && win.lpTag.taglets && win.lpTag.taglets.lpSecureStorage) {
          this.storageEngine = 'secureStorage';
          if (win.proxyless && win.proxyless.useCdn === true) {
            var leCdnDomain = win.lpTag.getDomain('leCdnDomain');
            var secureStorageTaglet = win.lpTag.taglets.lpSecureStorage;
            this.secureStorageDomain = 'https://' + leCdnDomain + '/le_secure_storage/' + (secureStorageTaglet.v ? secureStorageTaglet.v + '/' : '');
          } else {
            this.secureStorageDomain = params.cobrowseBaseUrl + this.secureStorageFrameLocation;
          }
          if (!/\:\/\/localhost/.test(this.secureStorageDomain) && this.secureStorageDomain.indexOf('http://') === 0) {
            this.secureStorageDomain = this.secureStorageDomain.replace('http://', 'https://');
          }
          this.site = params.site;
          var conf = {
            url: this.secureStorageDomain,
            site: params.site,
            initialStorageType: 'sessionStorage',
            app: this.secureStorageApp,
            chosenStorageHandler: function (h) {
              console.log('Using secureStorage type ' + h);
            }
          };
          var env = lpTag && lpTag.getEnv && lpTag.getEnv();
          if (env) {
            conf.env = env;
          }
          //init SecureStorage
          lpSecureStorage.configure({ conf: conf });
        }
      },
      setValue: function (paramsOrKey, value, options) {
        var key, ret, locations = (synchroniteConfig.restrictToDomains || []).slice(), deferred = new Deferred();
        options = options || {};
        if (value) {
          key = paramsOrKey;
        } else {
          key = paramsOrKey.key;
          value = paramsOrKey.value;
        }
        console.debug('storage.setValue(' + key + ', ' + value + ')...Engine = ' + this.storageEngine);
        if (this.storageEngine === 'cookie') {
          options = lang.mixin({
            domain: '.' + baseUrl.getHostWithoutSubdomains(),
            path: '/'
          }, options);
          ret = dojoCookie(key, value, options);
          deferred.resolve(ret);
        } else {
          console.log('cometd setValue saving to lpSecureStorage');
          lpSecureStorage.setValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            value: value,
            domain: this.secureStorageDomain,
            expires: this.defaultExpires,
            locations: locations,
            success: function (data) {
              console.debug('storage.setValue(' + key + ', ' + value + ')...SUCCESS');
              deferred.resolve(data);
            },
            error: function (error) {
              console.debug('storage.setValue(' + key + ', ' + value + ')...ERROR');
              deferred.reject(error);
            }
          });
        }
        return deferred;
      },
      getValue: function (key, successCallback, errorCallback) {
        console.debug('storage.getValue(' + key + ').....Engine = ' + this.storageEngine);
        if (this.storageEngine === 'cookie') {
          return successCallback(dojoCookie(key));
        } else {
          lpSecureStorage.getValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            domain: this.secureStorageDomain,
            success: function (data) {
              console.debug('SUCCESS storage.getValue(' + key + ') -> ' + data);
              if (successCallback) {
                successCallback(data);
              }
            },
            error: function (data) {
              console.error('ERROR storage.getValue(' + key + ') -> ' + data);
              if (errorCallback) {
                errorCallback(data);
              }
            }
          });
        }
      },
      removeValue: function (key) {
        console.debug('Remove ' + key + ' from storage');
        var deferred = new Deferred();
        if (this.storageEngine === 'cookie') {
          this.deleteCookie(key, '/', baseUrl.getHostWithoutSubdomains());
          deferred.resolve();
        } else {
          lpSecureStorage.removeValue({
            site: this.site,
            app: this.secureStorageApp,
            appName: 'cobrowse',
            key: key,
            domain: this.secureStorageDomain,
            success: function () {
              console.log(arguments);
              deferred.resolve();
            },
            error: function () {
              console.log(arguments);
              deferred.reject();
            }
          });
        }
        return deferred.promise;
      },
      deleteCookie: function (name, path, domain) {
        document.cookie = name + '=' + (path ? ';path=' + path : '') + (domain ? ';domain=' + domain : '') + ';expires=Thu, 01 Jan 1970 00:00:01 GMT';
      },
      setValueInLocalStorage: function (id, val) {
        localStorage.setItem(id, val);
      },
      itemInLocalStorageExists: function (id) {
        return localStorage.getItem(id) !== null;
      },
      removeValueInLocalStorage: function (id) {
        localStorage.removeItem(id);
      }
    };
    return storage;
  }(dojo_cookie, dojo__base_lang, dojo_Deferred, synchronite_proxyless_lib_lpSecureStorageAMD, synchronite__base_url);
  synchronite__base_state = function (synchQuery, synchDom, baseCookie, baseUrl, synchWindow, lang, Deferred, DojoURL, sizzle, string, baseArray, aspect, on, base64, strings, storage) {
    //////////////////////////////////////////
    // PRIVATE FUNCTIONS AND VARIABLES
    //////////////////////////////////////////
    var STATE_STORAGE_KEY = 's.state';
    var config = synchroniteConfig;
    var configScripts = config && config.scripts || config && config.integration && config.integration.scripts;
    var filterNodes = function (nodes, excludeNodes) {
      nodes = nodes.filter(function (node) {
        if (synchQuery.isProtected(node)) {
          return false;
        }
        for (var i = 0; i < excludeNodes.length; i++) {
          if (excludeNodes[i] == node) {
            return false;
          }
        }
        return true;
      });
      return nodes;
    };
    var isTextType = synchDom.isTextType;
    var val = function (node) {
      var ret = node.value;
      // Fixes IE8 / Win7 serialization bug.
      // http://blogs.msdn.com/b/jscript/archive/2009/06/23/serializing-the-value-of-empty-dom-elements-using-native-json-in-ie8.aspx
      if (ret === '') {
        ret = '';
      }
      return ret;
    };
    var _executeStateCallback = function (customStateFunction, state, win) {
      if (typeof customStateFunction == 'string') {
        try {
          console.info('Creating State Function');
          customStateFunction = synchWindow.exportFunction(customStateFunction, win);
        } catch (e) {
          console.warn('Error creating state get function: ', e);
          return state;
        }
      }
      var modifiedState;
      try {
        modifiedState = customStateFunction(state);
      } catch (e) {
        console.warn('Error customStateFunction: ', e);
      }
      if (modifiedState) {
        state = modifiedState;
      }
      return state;
    };
    var getState = function (activeWindow, ticketId, username, force) {
      var completeState = { state: synchState.getWindowState(activeWindow, force) };
      if (ticketId) {
        completeState.ticket = ticketId;
      }
      if (username) {
        completeState.username = username;
      }
      completeState.duration = synchState.getSessionDuration();
      if (typeof synch !== 'undefined') {
        if (synch.store) {
          completeState.storeEntries = synch.store.entries;
        }  // cthum: Do we still need this?
           //var chatUrl = synch.deferredLocalState && synch.deferredLocalState.chatUrl;
           //if (chatUrl) {
           //    completeState.chatUrl = chatUrl;
           //    if (completeState.state) {
           //        completeState.state.chatUrl = chatUrl;
           //    }
           //}
      }
      if (typeof config.telepointer != 'undefined') {
        completeState.telepointer = config.telepointer;
      }
      // Loading the local state should be forced, when we change
      // the targetURL because of a redirect from http to https or
      // vice versa
      console.info('completeState.state.force = ' + force);
      completeState.state.force = force;
      return completeState;
    };
    /* this method will catch all userinput from the site (e.g.
     * get the content of form fields)
     * @return all input of the website in json format */
    var getDOMState = function (aDocument) {
      var root, result = [];
      try {
        root = aDocument;
      } catch (e) {
        console.debug('Access to document not allowed. XSS Error?');
        return result;
      }
      var serializeNode = function (node) {
        try {
          var nodeState = synchState.getNodeState(node);
          nodeState.s = synchQuery.getNodeSelector(node);
          result.push(nodeState);
        } catch (e) {
          console.error('Unable to serializeNode ' + node);
        }
      };
      var DIALOG_REQUEST_SUPPORT = 'dialog-request-support';
      //get all input fields but exclude those created by synchronite
      var nodeList = sizzle('input:not([type=submit]):not([type=button]):not([type=hidden]):not([type=image])', root);
      var nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' input', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //get all drop down lists
      nodeList = sizzle('select', root);
      nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' select', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //get all textareas
      nodeList = sizzle('textarea', root);
      nodeListExclude = sizzle('#' + DIALOG_REQUEST_SUPPORT + ' textarea', root);
      nodeList = filterNodes(nodeList, nodeListExclude);
      nodeList.forEach(serializeNode);
      //add here maybe more input elements in the future
      console.debug('getDOMState result: ' + JSON.stringify(result));
      return result;
    };
    var COMPLETE_DOM = 'cD', DESIGN_MODE = 'dM';
    var DOMStateTries = 0, MAXDOMStateTries = 7, DOMStateTimeout = 1250, DOMStateTimer = null, setDOMState = function (state) {
        console.info('Starting to set DOM State. TRY: ' + DOMStateTries + ' of ' + MAXDOMStateTries);
        window.clearTimeout(DOMStateTimer);
        if (!state) {
          console.warn('DOMSTATE EMPTY!');
          return;
        }
        if (typeof synch != 'undefined') {
          baseArray.forEach(synch.frameLoadedListeners, function (entry) {
            entry.remove();
          });
          synch.frameLoadedListeners = [];
        }
        var domState = state.dom || state;
        if (domState && domState.length > 0) {
          //because the website content is in an iframe, the dojo.global
          //has to be temporary changed (if not, dojo isn't working
          //within the iframe, e.g. dojoDom.byId()
          var activeWindow = synchQuery.synchronizedWindow();
          // get the global scope object from the iframe
          var failedNodes = [];
          console.debug('...complete state: ' + JSON.stringify(state));
          baseArray.forEach(domState, function (nodeState, index) {
            if (nodeState && nodeState.s && nodeState.s.windowName == 'presenterWindow') {
              nodeState.s.windowName = strings.SYNCHRONIZED_WINDOW;
            }
            if (nodeState.s && nodeState.s.element && nodeState.s.element.indexOf(' &gt; ') >= 0) {
              nodeState.s.element = nodeState.s.element.replace(/ &gt; /g, ' > ');
            }
            var node = synchQuery.queryElement(nodeState.s);
            if (node) {
              //check if element exists
              synchState.setNodeState(node, nodeState);
            } else {
              //should not happen...
              failedNodes.push(nodeState);
              console.warn('setDOMState: Element with selector\'' + nodeState.s.element + '\' was not found. document.readyState=' + activeWindow.document.readyState);
            }
          });
          if (failedNodes.length === 0) {
            console.info('DOMState successfully set.');
            DOMStateTries = 0;
            runOnStateSet(activeWindow, state);
          } else if (DOMStateTries < MAXDOMStateTries) {
            console.info('Failed to set DOM State of ' + failedNodes.length + ' nodes.');
            DOMStateTries++;
            // only keep nodes that have already been not yet been set successfully
            state.dom = failedNodes;
            console.info('Unable to set dom state, maybe there are elements that are dynamically created via Ajax. So let\'s wait for them...');
            DOMStateTimer = window.setTimeout(lang.hitch(this, setDOMState, state), DOMStateTimeout);
          } else {
            console.info('Timeout waiting for DOMState.');
            DOMStateTries = 0;
            runOnStateSet(activeWindow, state);
          }
        }
      }, runOnStateSet = function (activeWindow, state) {
        if (configScripts && configScripts.onStateSet) {
          console.info('Executing runOnStateSet using state ' + JSON.stringify(state));
          var modifiedDomState = _executeStateCallback(configScripts.onStateSet, state, activeWindow);
          console.info('Executing State Function...Finished');
        }
      }, setCookieState = function (doc, cookies) {
        var changedCookies;
        for (var key in cookies) {
          var cookie = cookies[key];
          // dojoCookie modifies cookie value by using encodeURIComponent,
          // so use custom function
          var props = {};
          props.path = cookie.path || '/';
          if (props.domain) {
            props.domain = cookie.domain;
          }
          var existingCookieVal = baseCookie(doc, cookie.name);
          if (existingCookieVal) {
            // replace cookie value only if it has changed
            if (existingCookieVal != cookie.value) {
              // but don't set path
              changedCookies = true;
              baseCookie(doc, cookie.name, cookie.value, props);
            }
          } else {
            baseCookie(doc, cookie.name, cookie.value, props);
            changedCookies = true;
          }
        }
        return changedCookies;
      };
    var endsWith = function (str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };
    ///////////////////////////////////////////
    // PUBLIC METHODS AND PROPERTIES
    ///////////////////////////////////////////
    var synchState = {
      on: function (type, listener) {
        return on.parse(this, type, listener, function (target, type) {
          return aspect.after(target, 'on' + type, listener, true);
        });
      },
      emit: function (type, event) {
        var args = [this];
        args.push.apply(args, arguments);
        return on.emit.apply(on, args);
      },
      getWindowState: function (selector, force) {
        // 1. Select the window whose state should be saved.
        var activeWindow;
        try {
          if (selector && selector.frame) {
            activeWindow = synchQuery.queryFrame(selector.frame);
          } else {
            activeWindow = selector;
          }
        } catch (e) {
          console.warn('Unable to get window state for selector: ' + selector + ' getting top window state instead. Error: ' + e);
        }
        // 2. Get the URL of the window
        var state, windowUrl;
        try {
          if (typeof synch != 'undefined' && force) {
            // This happens when we switch between http/https
            state = { url: synch.currentURL };
          } else {
            //if (synchUrl.isProxified(activeWindow.location.href)) {
            if (typeof synch != 'undefined' && synch.currentURL) {
              windowUrl = synch.currentURL;
              // hash changes are not always reflected in currentURL, so we need to append it
              var windowHash = activeWindow.location.hash;
              if (windowHash) {
                var windowUrlObject = new DojoURL(windowUrl);
                if ('#' + windowUrlObject.fragment != windowHash) {
                  windowUrlObject.fragment = windowHash.substr(1);
                  windowUrl = baseUrl.dojoUrlToString(windowUrlObject);
                }
              }
            } else {
              windowUrl = activeWindow.location.href;
            }
            //                           //FIXED: Also add hash tag.
            //                            var hash = activeWindow.location.hash;
            //                            if (hash) {
            //                                windowUrl += hash;
            //                            }
            if (activeWindow.synchEndUrl) {
              var decodedURL = base64.decode(activeWindow.synchEndUrl);
              //  saved parameters of original post request
              if (windowUrl.indexOf('?') == -1) {
                windowUrl += '?';
              }
              windowUrl += decodedURL;
              console.info('Appending original post parameters: ' + activeWindow.synchEndUrl);
            }
            state = {
              url: baseUrl.fromSynchroniteURL(windowUrl + ''),
              cacheKey: activeWindow.synchCacheKey || null
            };
            state.dom = getDOMState(activeWindow.document);
            // if (config.lpPluginActive) {
            //     state.lpVisitId = activeWindow.lpVisitId || null;
            // }
            // Save document cookies?
            var activeDoc = activeWindow.document;
            if (activeDoc.cookie) {
              var jsonCookies = [];
              var documentCookies = activeDoc.cookie.split(';');
              baseArray.forEach(documentCookies, function (oneEntry) {
                var name, value = '';
                // FIXED: Limit number of splits since, cookie value might
                // contain "=" which might be cut off.
                var i = oneEntry.indexOf('=');
                if (i == -1) {
                  name = oneEntry;
                } else {
                  name = oneEntry.substring(0, i);
                  value = oneEntry.substring(i + 1);
                }
                //trim key, so the key is without leading whitespace (if one was existing)
                name = string.trim(name);
                if (/^(cometd|synchronite|s\.)/.test(name) || name.length === 0) {
                  return;
                }
                if (name.length !== 0) {
                  jsonCookies.push({
                    name: name,
                    value: value
                  });
                }
              });
              state.docCookies = jsonCookies;
            }
            // include userPrefs (mouse pointers of other users)
            if (typeof synch != 'undefined' && synch.store) {
              state.storeEntries = synch.store.entries;
            }
          }
        } catch (e) {
          console.warn('getWindowState: Probably unable to access window object. Unloaded or Xss? Details:' + e);
          state = { url: windowUrl };
        }
        if (configScripts && configScripts.onStateGet) {
          state = _executeStateCallback(configScripts.onStateGet, state, activeWindow);
        }
        console.info('getWindowState result: ' + JSON.stringify(state));
        // handlers can add info to the session state object
        this.emit('get', state, activeWindow);
        return state;
      },
      setNodeState: function (node, nodeState) {
        if (nodeState.p) {
          console.debug('     ...skipping protected node');
          return;
        }
        console.debug('     ...setting node type=' + nodeState.t + ' val=' + nodeState.v || nodeState.c);
        if (isTextType(nodeState.t) || nodeState.t == 'textarea') {
          //element is a textbox
          node.value = nodeState.v;
        } else if (nodeState.t == 'file') {
          // see: http://stackoverflow.com/questions/11780959/jquery-javascript-throws-error-the-operation-is-insecure-when-setting-value
          try {
            node.value = nodeState.v;
          } catch (e) {
            console.warn('Unable to set input file value: ' + nodeState.v);
          }
        } else if (nodeState.t == 'checkbox' || nodeState.t == 'radio') {
          //element is a checkbox or radiobox
          node.checked = nodeState.c;
        } else if (nodeState.t == 'select') {
          //element is a drop down list
          node.selectedIndex = nodeState.v;
          if (nodeState.m) {
            var optionState = nodeState.m;
            var optionNodes = node.options;
            if (optionNodes && optionNodes.length > 0) {
              baseArray.forEach(optionNodes, function (opts, index) {
                opts.selected = optionState[index];
              });
            }
          }
        } else if (nodeState.t == 'hidden' || nodeState.t == 'password' || nodeState.t == 'reset') {
        } else if (nodeState.t == DESIGN_MODE) {
          //type = designMode frame or node
          node.innerHTML = nodeState.v;
        } else if (nodeState.t == COMPLETE_DOM) {
          var iframeDoc = synchQuery.synchronizedWindow().document;
          // This is so evil...
          iframeDoc.open();
          iframeDoc.write(nodeState.v);
          iframeDoc.close();
        } else {
          //should not happen...
          console.debug('setNodeState: unknown type of element: [type=' + nodeState.t + ']');
        }
      },
      getNodeState: function (node) {
        var nodeState = {};
        var nodeName = node.nodeName.toLowerCase();
        if (synchQuery.isProtected(node)) {
          nodeState.p = true;
          //node is protected
          return nodeState;
        }
        if (nodeName == 'input') {
          nodeState.t = node.type;
          //t for type
          if (isTextType(node.type)) {
            //escape the text to prevent possible problems with e.g. & or ? characters
            //http://blogs.msdn.com/b/jscript/archive/2009/06/23/serializing-the-value-of-empty-dom-elements-using-native-json-in-ie8.aspx
            nodeState.v = val(node);  //synch.escape(node.value).replace(/'/g, "%27").replace(/"/g, "%22"); //v for value (value is the text of the field)
          } else if (node.type == 'checkbox' || node.type == 'radio') {
            nodeState.c = node.checked;  //v for value (value is true if selected; else false)
          }
        } else if (nodeName == 'select') {
          // single value select fields
          nodeState.t = 'select';
          //t for type
          nodeState.v = node.selectedIndex;
          //v for value (value is the selected index)
          // multi value select fields
          var m;
          if (node.multiple) {
            var optionNodes = node.options;
            if (optionNodes && optionNodes.length > 0) {
              m = [];
              baseArray.forEach(optionNodes, function (opt, index) {
                m[index] = opt.selected;
              });
            }
          }
          nodeState.m = m;
        } else if (nodeName == 'textarea') {
          nodeState.t = 'textarea';
          //t for type
          nodeState.v = val(node);  //v for value (value is the selected index)
        }
        return nodeState;
      },
      loadStateFromConfig: function () {
        var state = null;
        var base64EncodedState = config.initialState;
        if (base64EncodedState) {
          state = JSON.parse(base64.decode(base64EncodedState));
        }
        return state;
      },
      loadStateFromStorage: function () {
        var deferred = new Deferred();
        storage.getValue(STATE_STORAGE_KEY, function (state) {
          if (state) {
            state = JSON.parse(base64.decode(state));
          }
          deferred.resolve(state);
        });
        return deferred;
      },
      loadStateFromWindow: function (win, data) {
        var state;
        win = win || window;
        var windowData = data || win.name;
        if (windowData) {
          windowData = windowData.split('|', 2);
          if (windowData.length > 1) {
            win.name = windowData[0];
            try {
              state = windowData[1] ? JSON.parse(base64.decode(windowData[1])) : null;
            } catch (e) {
              console.warn('Error restoring session state from window.name:' + e);
              return null;
            }
            return state;
          }
        }
      },
      saveStateEncoded: function (activeWindow, ticketId, username, force) {
        var state = getState(activeWindow, ticketId, username, force);
        console.info('Getting encoded local state.');
        return base64.encode(JSON.stringify(state));
      },
      saveStateToStorage: function (activeWindow, ticketId, username, force) {
        try {
          var doc = activeWindow.document;
        } catch (e) {
          console.debug('Probably no page has been loaded in the iframe yet or there is a xss problem.');
          return false;
        }
        var state = getState(activeWindow, ticketId, username, force);
        var serializedState = JSON.stringify(state);
        console.info('Saving local state in storage: ' + serializedState);
        serializedState = base64.encode(serializedState);
        return storage.setValue(STATE_STORAGE_KEY, serializedState);
      },
      saveStateName: function (activeWindow, ticketId, username, force) {
        var completeState = getState(activeWindow, ticketId, username, force);
        console.info('Saving local state as cookie.');
        window.name = window.name + '|' + base64.encode(JSON.stringify(completeState));
        return completeState;
      },
      // in milliseconds
      getSessionDuration: function () {
        var duration = 1000;
        // default value
        if (typeof synchroniteConfig != 'undefined' && synchroniteConfig.duration && typeof synch !== 'undefined' && synch.creationDate) {
          var timeSinceReload = new Date().getTime() - synch.creationDate;
          duration = synchroniteConfig.duration + timeSinceReload;
          console.info('Server Ticket Session Duration: ' + parseInt(synchroniteConfig.duration / 1000, 10) + 'sec');
          console.info('Time Since Presenter Reload: ' + parseInt(timeSinceReload / 1000, 10) + 'sec');
        }
        return duration;
      },
      applyState: function (state, selector) {
        // WARN: Be careful, when accessing window.document. The page may have not been fully
        //       loaded yet. Early access will throw a security exception in chrome 30+.
        this.emit('set', state, selector);
        var synchronizedWindow = synchQuery.synchronizedWindow();
        var aWindow = null;
        try {
          if (selector && selector.frame) {
            aWindow = synchQuery.queryFrame(selector.frame);
          } else {
            aWindow = synchronizedWindow;
          }
        } catch (e) {
          if (typeof console != 'undefined') {
            console['error']('Failed to apply state. Access to window is probably denied.');
          }
          window.location.reload();
        }
        if (!aWindow) {
          if (typeof console != 'undefined') {
            console['error']('Failed to apply state. Access to window is probably denied.');
          }
          synchronizedWindow.location.reload();
        }
        if (synchronizedWindow == window) {
          // session has just ended and we need to restore cookies.
          var stateCookies = state.cookies;
          var needPageReload;
          if (!stateCookies && typeof synchroniteConfig != 'undefined' && synchroniteConfig.restoreDocumentCookies) {
            needPageReload = true;
            stateCookies = state.docCookies;
          }
          if (stateCookies) {
            needPageReload = setCookieState(aWindow.document, stateCookies) && needPageReload;
            if (needPageReload) {
              console.log('Die Seite wird nun neugeladenm, um den Warenkorb \nder Co-Browsing Sitzung wiederherstellen.');
              window.setTimeout(function () {
                // Delay so the synchroniteOnPageLoad Script has time to run
                window.location.reload();
              }, 20);
            }
          }
        }
        // if (config.lpPluginActive) {
        //     var lpVisitId = state.lpVisitId || synchronizedWindow.lpVisitId;
        //     if (lpVisitId) {
        //         window.lpVisitId = lpVisitId;
        //         //synchronizedWindow.lpVisitId = lpVisitId;
        //         config.lpVisitId = lpVisitId;
        //         config.useLPChatBackend = true;
        //     } else {
        //         console.warn("Liveperson Plugin is Active, but no lpVisitId was found :(");
        //     }
        // }
        var iframeURL = null;
        if (typeof synch != 'undefined') {
          if (state.storeEntries) {
            synch.store.putAll(state.storeEntries);
          }
          if (state.cacheKey) {
            console.warn('Loading page via cacheKey! (experimental)');
            synch.frameLoadedListeners.push(aspect.after(synch, 'synchroniteAllFramesLoaded', lang.hitch(this, setDOMState, state)));
            var redirectURL = baseUrl.addParam(state.url, 'cacheKey', state.cacheKey);
            redirectURL = baseUrl.toSynchroniteURL(redirectURL);
            synch.loadPage(redirectURL, aWindow, true);
            return;
          } else if (!state.url) {
            synch.loadPage(synch.inactivePage, aWindow, true);
            return;
          }
          try {
            iframeURL = baseUrl.fromSynchroniteURL(aWindow.location.href);
          } catch (e) {
            console.error('applyState: ', e);
          }
          if (iframeURL != state.url) {
            console.debug('applyState: Loading new page: ' + state.url);
            synch.frameLoadedListeners.push(aspect.after(synch, 'synchroniteAllFramesLoaded', lang.hitch(this, setDOMState, state)));
            synch.loadPage(baseUrl.toSynchroniteURL(state.url), aWindow, true);
            return;  //on(aWindow, "load", dojoLang.hitch(this, setDOMState, state.dom))
          }
        }
        iframeURL = baseUrl.fromSynchroniteURL(aWindow.location.href);
        console.debug('applyState: Loading page not required...');
        if (!synchWindow.isWindowInitialized(aWindow)) {
          console.debug('applyState: ...but the page has not fully loaded yet. Waiting for complete load...');
          on(aWindow, 'load', lang.hitch(this, setDOMState, state));
        } else {
          console.debug('applyState: ...and the page has fully loaded.');
          setDOMState(state);
        }
      }
    };
    return synchState;
  }(synchronite__base_query, synchronite_micro_dom, synchronite__base_cookie, synchronite__base_url, synchronite__base_window, dojo__base_lang, dojo_Deferred, dojo__base_url, synchronite_libs_sizzle, dojo_string, dojo__base_array, dojo_aspect, dojo_on, synchronite__base_base64, synchronite_constants_strings, synchronite_proxyless_storage);
  synchronite_events_scroll = function (lang, baseFx, baseWindow, domGeometry, on, has, query, baseArray, synchEvent, synchDom, Evented, synchQuery, state, strings) {
    var contextWindow = window,
      // execution context window
      contextDocument = contextWindow.document,
      // execution context document
      config = contextWindow.synchroniteConfig, localEvents = new Evented(), remoteEvents = new Evented(), replicatorHandle, replicatedScrollAnimation = {}, _blockScrollTimeout, profile, scrollTimer = {}, scrollWindowSignal = '_cbscrollWindowSignal', scrollNodeSignals = [], TYPE = 'scroll';
    // "scroll" do not change as value is hardcoded in many places
    //------------------- Scroll Listener Registration -----------------------//
    /* idempotent */
    function startListening(win) {
      if (profile.monitor.scroll) {
        listenToWindow(win);
        setTimeout(function () {
          // lengthy operation so better call async
          try {
            listenToScrollableNodes(win, win.document);
          } catch (e) {
            console.warn('Failed to listen to scrollable nodes', e);
          }
        }, 100);
      }
    }
    function stopListening(win) {
      if (win[scrollWindowSignal] && win[scrollWindowSignal].remove) {
        win[scrollWindowSignal].remove();
      }
    }
    /* idempotent */
    function startReplicating(_config) {
      if (!profile.handle.scroll) {
        return;
      }
      console.info('STARTREPLICATING scroll events');
      var replicatorConfig = _config || {};
      if (replicatorConfig.remoteEvents) {
        remoteEvents = replicatorConfig.remoteEvents;
      }
      if (replicatorHandle) {
        replicatorHandle.remove();
      }
      replicatorHandle = remoteEvents.on('scroll', replicateScroll);
    }
    /* idempotent */
    function listenToWindow(win) {
      stopListening(win);
      try {
        console.info('scroll.listenToWindow(' + win.location.href + ')');
      } catch (ignore) {
      }
      // LESSONS LEARNED:
      // (i) Safari iPad only registers scroll on document. (Note for recent iOS versions 4+?)
      if (has('ios')  /* && !synchDom.scrollableDoc(contextWindow)*/) {
        // if(scrollbars not supported)
        // http://stackoverflow.com/questions/6139564/iframe-size-on-ipad
        // Starting in version 4.2.1 of Safari iOS, and still going as of 4.3.3,
        // the entire content of an iFrame is forcibly shown. If your iframe's
        // content is in the same security sandbox as the outer page, you can
        // surround the iframe with a div tag and use that to do the scrolling.
        win[scrollWindowSignal] = synchEvent.on(contextWindow, 'scroll', function (event) {
          _monitorScroll(event, contextWindow);
        });
      } else {
        try {
          win[scrollWindowSignal] = synchEvent.on(win, 'scroll', function (event) {
            _monitorScroll(event, win);
          });
        } catch (e) {
          console.error(e);
        }
      }
    }
    /* idempotent */
    function listenToScrollableNodes(win, queryRoot) {
      // query root might be a new sub-tree that was just injected into the dom.
      if (!queryRoot) {
        queryRoot = win.document;
      }
      if (_mayHaveChildren(queryRoot)) {
        // FIXED: Check that queryRoot is a node that can have children e.g. not a TextNode
        try {
          // Get all theoretically scrollable elements.
          // (even if there are no scrollbars yet)
          //for (var i = 0; i < scrollNodeSignals.length; i++) {
          //    scrollNodeSignals[i].remove();
          //}
          var potentiallyScrollableElements = query('div,ul,tbody,body,textarea', queryRoot);
          //console.info("Found " + potentiallyScrollableElements.length + " potentially scrollable elements.");
          var reallyScrollableElements = potentiallyScrollableElements.filter(synchDom.scrollable(true, win));
          //console.info("Found " + reallyScrollableElements.length + " really scrollable elements.");
          scrollNodeSignals = reallyScrollableElements.on(TYPE, function (event) {
            //console.log("scrollableElements._monitorScroll");
            _monitorScroll(event, win);
          });
        } catch (e) {
          console.error(e);
        }
      }
    }
    //------------------- Scroll Event Handler -----------------------//
    function _monitorScroll(event, activeWindow) {
      // Correctly determine the event target.
      var eventTarget = event.target || event.srcElement;
      var selector = synchQuery.getNodeSelector(eventTarget);
      if (synchEvent.isSimulated(event) || Object.keys(replicatedScrollAnimation).length) {
        // Do not monitor this scroll Event, if
        // (i) the event is simulated or
        // (ii) a synthetic scroll animation is in progress.
        return true;
      }
      if (!eventTarget) {
        console.warn('Scroll event target is falsy, so we use the activeDocument as a target.');
        eventTarget = activeWindow.document;
      }
      if (eventTarget == contextDocument) {
        eventTarget = activeWindow.document;
      }
      if (!eventTarget) {
        console.error('scroll target undefined');
        return;
      }
      // check if the scroll event was fired on a window|document|html|body
      var isWinScroll = synchDom.isWindowScroll(eventTarget);
      if (isWinScroll) {
        //FIXED: enabled nested frame scrolling
        eventTarget = synchDom.getBody(eventTarget);
      }
      var normalizedScrollPos = isWinScroll ? _getNormalizedWindowScroll(activeWindow) : _getNormalizedNodeScroll(eventTarget);
      selector = synchQuery.getNodeSelector(eventTarget);
      // debounce delays signaling of the page load to other clients and will only
      if (scrollTimer[selector.element]) {
        contextWindow.clearTimeout(scrollTimer[selector.element]);
      }
      var delayedEmit = function (selector) {
        scrollTimer[selector.element] = null;
        // prevents the access denied issue in IE if the click causes the element to be destroyed
        if (!synchDom.canAccessNode(eventTarget)) {
          return;
        }
        var scrollEvent = {
          // senderId: config.userId,
          x: normalizedScrollPos.x,
          y: normalizedScrollPos.y,
          cssSelector: selector,
          isWinScroll: isWinScroll
        };
        localEvents.emit(TYPE, scrollEvent);
      };
      scrollTimer[selector.element] = contextWindow.setTimeout(function () {
        delayedEmit(selector);
      }, 250);
    }
    function blockScroll(duration) {
      console.debug('Scrolling blocked.');
      replicatedScrollAnimation = true;
      //scrolling is blocked
      //unblock, after waiting duration...
      contextWindow.setTimeout(lang.hitch(this, function () {
        console.debug('Scrolling unblocked.');
        replicatedScrollAnimation = null;
      }), duration);
    }
    function replicateScroll(data) {
      // console.log("Scrolling..." + JSON.stringify(data));
      // Stop animation to save resources.
      // effects.mouse.stopAnims(); TODO @cthum
      var node = synchQuery.queryElement(data.cssSelector);
      if (!node) {
        console.warn('handleScroll: Unable to find scrollTarget: ');
        return null;
      }
      // Check if a simple node or the entire document should be scrolled
      var isWinScroll = data.isWinScroll;
      var activeDocument = node.ownerDocument || node;
      var activeWindow = activeDocument.parentWindow || activeDocument.defaultView;
      //dojoWindow.get(element.ownerDocument);
      if (activeWindow == contextWindow) {
        //happens when receiving scroll event from ipad
        console.debug('Received scroll event for synchronite window. Assuming scroll on displayContentWindow.');
        activeWindow = synchQuery.synchronizedWindow();  // synch.displayContentWindow;
      }
      if (has('ios')  /*&& !synchDom.scrollableDoc(contextWindow)*/) {
        //  touch devices do not have scrollbars on iframes,
        //  so scroll topmost frame.
        activeWindow = contextWindow;
      }
      var scrollTarget = isWinScroll ? activeWindow : node;
      var getAbsoluteScrollDelta = isWinScroll ? _getAbsoluteScrollDeltaWin : _getAbsoluteScrollDeltaNode;
      var absoluteScrollPos;
      try {
        // Calculate normalized scroll positions
        absoluteScrollPos = getAbsoluteScrollDelta(scrollTarget, {
          x: data.x,
          y: data.y
        });
      } catch (e) {
        console.warn('handleScroll: Unable to access scrollRoot. Document unloaded?');
        return;
      }
      // Stop any existing scroll
      if (replicatedScrollAnimation[data.cssSelector.element] && replicatedScrollAnimation[data.cssSelector.element].stop) {
        // console.log("handleScroll: Stopping Scroll on " + data.cssSelector.element);
        replicatedScrollAnimation[data.cssSelector.element].stop();
      }
      if (_blockScrollTimeout) {
        contextWindow.clearTimeout(_blockScrollTimeout);
      }
      var _unblockScroll = function () {
        replicatedScrollAnimation[data.cssSelector.element] = null;
        delete replicatedScrollAnimation[data.cssSelector.element];
      };
      var _delayedUnblockScroll = function () {
        // Scroll Events are fired even after Animation has stopped
        // so insert delay before resetting animation
        _blockScrollTimeout = contextWindow.setTimeout(_unblockScroll, 300);
      };
      //FIXED: Uses dojo._docScroll, so must be executed in context of
      //       window to be scrolled.
      baseWindow.withGlobal(activeWindow, function (targetPosition, scrollTarget, isWinScroll) {
        //console.debug("Scroll to: " + targetPosition.y);
        replicatedScrollAnimation[data.cssSelector.element] = _smoothScroll({
          target: targetPosition,
          //this is actually not the target but the scroll position, i.e., delta!
          scrollRoot: scrollTarget,
          //the window or node to be scrolled
          duration: 350,
          isWindow: isWinScroll,
          onEnd: _delayedUnblockScroll,
          onStop: _delayedUnblockScroll
        });
        replicatedScrollAnimation[data.cssSelector.element].play();  //console.debug("handleScroll: Playing Scroll");
      }, this, [
        absoluteScrollPos,
        scrollTarget,
        isWinScroll
      ]);
    }
    //------------------- Helper/Utility Functions -----------------------//
    function _mayHaveChildren(node) {
      var nodeType = node && node.nodeType;
      return nodeType === 1 || nodeType === 9 || nodeType === 10 || nodeType === 11;
    }
    function _getAbsoluteScrollDeltaNode(node, normalized) {
      var scrollRootWidth = node.scrollWidth;
      var scrollRootHeight = node.scrollHeight;
      var nodeWidth = node.clientWidth;
      var nodeHeight = node.clientHeight;
      var maxScrollX = scrollRootWidth - nodeWidth;
      var maxScrollY = scrollRootHeight - nodeHeight;
      var targetLeftScroll = Math.round(normalized.x * maxScrollX);
      var targetTopScroll = Math.round(normalized.y * maxScrollY);
      //console.debug("Absolute scroll: " + scrollLeft + ", " + scrollTop);
      return {
        x: targetLeftScroll,
        y: targetTopScroll
      };
    }
    function _getDocScroll(doc) {
      // Change scroll root and use default function
      // in webkit browsers and quirksmode body is the scrollRoot
      var docEl = doc.documentElement, body = doc.body, scrollLeft = Math.max(docEl.scrollLeft, body.scrollLeft), scrollTop = Math.max(docEl.scrollTop, body.scrollTop);
      return {
        x: scrollLeft,
        y: scrollTop
      };
    }
    function _smoothScroll(args) {
      // summary: Returns an animation that will smooth-scroll to a node
      // description: This implementation support either horizontal or vertical scroll, as well as
      // both. In addition, element in iframe can be scrolled to correctly.
      // offset: {x: int, y: int} this will be added to the target position
      // duration: Duration of the animation in milliseconds.
      // scrollRoot: a node or window object to scroll
      var scrollRoot = args.scrollRoot;
      if (!args.target) {
        args.target = domGeometry.position(args.node);
      }
      var isWindow = args.isWindow;
      //dojo[(dojoHas("ie") ? "isObject" : "isFunction")](args["win"].scrollTo),
      var delta = {
        x: args.target.x,
        y: args.target.y
      };
      //        if(!isWindow){
      //		var winPos = dojoGeometry.position(scrollRoot);
      //		delta.x -= winPos.x;
      //		delta.y -= winPos.y;
      //	}
      // The defaullt
      var _scrollToAnim = function (val) {
        console.debug('Scroll Node x=' + val[0] + ', y=' + val[1]);
        scrollRoot.scrollLeft = val[0];
        scrollRoot.scrollTop = val[1];
      };
      if (isWindow && scrollRoot.scrollTo) {
        if (synchDom.isNative(scrollRoot.scrollTo)) {
          // Use Native Window Scroll
          _scrollToAnim = function (val) {
            scrollRoot.scrollTo(val[0], val[1]);
          };
        } else {
          var scrollDoc = scrollRoot.document;
          // Change scroll root and use default function
          // in webkit browsers and quirksmode body is the scrollRoot
          scrollRoot = has('webkit') || has('quirks') ? scrollDoc.body : scrollDoc.documentElement;
        }
      }
      var animProps = {
        beforeBegin: function () {
          var current = isWindow ? domGeometry.docScroll() : {
            x: scrollRoot.scrollLeft,
            y: scrollRoot.scrollTop
          };
          console.debug('Scrolling from: ' + current.x + ', ' + current.y + ' to ' + delta.x + ', ' + delta.y);
          if (this.curve) {
            delete this.curve;
          }
          this.curve = new MultiValueLine([
            current.x,
            current.y
          ], [
            delta.x,
            delta.y
          ]);
        },
        onAnimate: function (value) {
          _scrollToAnim(value);
        }
      };
      animProps = lang.mixin(animProps, args);
      var anim = new baseFx.Animation(animProps);
      return anim;  // dojoFx.Animation
    }
    function MultiValueLine(start, end) {
      // Taken from dojox/fx/_core to reduce dependency on whole dojo/fx stack including legacy dojo/ready.
      // summary:
      //		a custom _Line to accommodate multi-dimensional values
      // description:
      //		a normal dojo._Line is the curve, and does Line(start,end)
      //		for propertyAnimation. as we make more complicatied animations, we realize
      //		some properties can have 2, or 4 values relevant (x,y) or (t,l,r,b) for example
      //
      //		this function provides support for those Lines, and is ported directly from 0.4
      //		this is a lot of extra code for something so seldom used, so we'll put it here as
      //		and optional core addition. you can create a new line, and use it during onAnimate
      //		as you see fit.
      // start: Integer|Array
      //		An Integer (or an Array of integers) to use as a starting point
      // end: Integer|Array
      //		An Integer (or an Array of integers) to use as an ending point
      // example:
      //		see dojox.fx.smoothScroll
      // example:
      // |	// this is 10 .. 100 and 50 .. 500
      // |	var curve = new dojox.fx._Line([10,50],[100,500]);
      // |	// dojo.Animation.onAnimate is called at every step of the animation
      // |	// to define current values. this _Line returns an array
      // |    // at each step. arguments[0] and [1] in this example.
      this.start = start;
      this.end = end;
      var isArray = lang.isArray(start), d = isArray ? [] : end - start;
      if (isArray) {
        // multi-dimensional branch
        baseArray.forEach(this.start, function (s, i) {
          d[i] = this.end[i] - s;
        }, this);
        this.getValue = function (n) {
          var res = [];
          baseArray.forEach(this.start, function (s, i) {
            res[i] = d[i] * n + s;
          }, this);
          return res;  // Array
        };
      } else {
        // single value branch, document here for both branches:
        this.getValue = function (n) {
          // summary:
          //		Returns the point on the line, or an array of points
          // n:
          //		a floating point number greater than 0 and less than 1
          // returns: Mixed
          return d * n + this.start;  // Decimal
        };
      }
    }
    // Taken from dojo/window.js
    function getWindowBox(doc) {
      // summary:
      //		Returns the dimensions and scroll position of the viewable area of a browser window
      var scrollRoot = doc.compatMode == 'BackCompat' ? baseWindow.body(doc) : doc.documentElement,
        // get scroll position
        scroll = _getDocScroll(doc),
        // scrollRoot.scrollTop/Left should work
        w, h;
      if (has('touch')) {
        // if(scrollbars not supported)
        var uiWindow = doc.parentWindow || doc.defaultView;
        // use UI window, not dojo.global window
        // on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
        w = uiWindow.innerWidth || scrollRoot.clientWidth;
        // || scrollRoot.clientXXX probably never evaluated
        h = uiWindow.innerHeight || scrollRoot.clientHeight;
      } else {
        // on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
        // uiWindow.innerWidth/Height includes the scrollbar and cannot be used
        w = scrollRoot.clientWidth;
        h = scrollRoot.clientHeight;
      }
      return {
        l: scroll.x,
        t: scroll.y,
        w: w,
        h: h
      };
    }
    function _getAbsoluteScrollDeltaWin(activeWindow, normalized) {
      var activeDocument = activeWindow.document;
      var activeBody = synchDom.getBody(activeDocument);
      var viewport = getWindowBox(activeDocument);
      var pageWidth = Math.max(activeBody.scrollWidth || 0, activeDocument.documentElement.scrollWidth || 0);
      var pageHeight = Math.max(activeBody.scrollHeight, activeDocument.documentElement.scrollHeight || 0);
      var scrollRootSize = {
        w: pageWidth,
        //scrollRoot.scrollWidth,
        h: pageHeight  //scrollRoot.scrollHeight
      };
      //var scrollRootSize1 = dojo.contentBox(scrollRoot);
      //var scrollRootSize2 = dojo.marginBox(scrollRoot);
      var maxScrollX = scrollRootSize.w - viewport.w;
      var maxScrollY = scrollRootSize.h - viewport.h;
      var scrollLeft = Math.round(normalized.x * maxScrollX);
      var scrollTop = Math.round(normalized.y * maxScrollY);
      //console.debug("Absolute scroll: " + scrollLeft + ", " + scrollTop);
      return {
        x: scrollLeft,
        // - viewport.l,
        y: scrollTop  // - viewport.t
      };
    }
    function _getNormalizedWindowScroll(win) {
      //var scrollRoot = (dojo.doc.compatMode == 'BackCompat')? baseWindow.body() : dojo.doc.documentElement;
      var doc = win.document;
      var body = synchDom.getBody(doc);
      // dojoWindow.withDoc does NOT work because dojoWin.getBox uses d.global,
      // so use change global scope (window object) using dojoWindow.withGlobal!
      var viewportDimension = getWindowBox(doc);
      //FIXED: viewportHeight = Math.min(body.clientHeight, doc.documentElement.clientHeight);
      //       returns wrong height on cosmosdirekt kfz.
      var viewportWidth = viewportDimension.w;
      //Math.min(body.clientWidth, doc.documentElement.clientWidth);
      var viewportHeight = viewportDimension.h;
      //Math.min(body.clientHeight, doc.documentElement.clientHeight);
      var pageWidth = Math.max(body.scrollWidth || 0, doc.documentElement.scrollWidth || 0);
      var pageHeight = Math.max(body.scrollHeight, doc.documentElement.scrollHeight || 0);
      //                var scrollRootSize = {
      //                    w: pageWidth, //scrollRoot.scrollWidth,
      //                    h: pageHeight //scrollRoot.scrollHeight
      //                };
      var maxScrollX = pageWidth - viewportWidth;
      //viewportDimension.w;
      var maxScrollY = pageHeight - viewportHeight;
      //viewportDimension.h;
      var normalizedX = 0, normalizedY = 0;
      if (maxScrollX > 0) {
        normalizedX = viewportDimension.l / maxScrollX;
      }
      if (maxScrollY > 0) {
        normalizedY = viewportDimension.t / maxScrollY;
      }
      //console.debug("Normalized scroll: " + normalizedX + ", " + normalizedY);
      return {
        x: normalizedX,
        y: normalizedY
      };
    }
    function _getNormalizedNodeScroll(node) {
      var cw = node.clientWidth;
      var ch = node.clientHeight;
      var sh = node.scrollHeight;
      var sw = node.scrollWidth;
      var st = node.scrollTop;
      var sl = node.scrollLeft;
      var maxScrollX = sw - cw;
      var maxScrollY = sh - ch;
      var normalizedX = 0, normalizedY = 0;
      if (maxScrollX > 0) {
        normalizedX = sl / maxScrollX;
      }
      if (maxScrollY > 0) {
        normalizedY = st / maxScrollY;
      }
      return {
        x: normalizedX,
        y: normalizedY
      };
    }
    // EXPORTS
    /////////////////
    return {
      TYPE: TYPE,
      // "scroll" do not change as value is hardcoded in many places
      local: localEvents,
      remote: remoteEvents,
      listenToScrollableNodes: listenToScrollableNodes,
      startListening: startListening,
      startReplicating: startReplicating,
      configure: function (_config) {
        profile = profile || _config.profile;
      },
      tearDown: function () {
        stopListening(window);
      },
      blockScroll: blockScroll
    };
  }(dojo__base_lang, dojo__base_fx, dojo__base_window, dojo_dom_geometry, dojo_on, dojo_has, dojo_query, dojo__base_array, synchronite__base_event, synchronite_micro_dom, dojo_Evented, synchronite__base_query, synchronite__base_state, synchronite_constants_strings);
  synchronite_proxyless_dom_shadowHosts = function () {
    var filter = function (node) {
      if (node && node.shadowRoot) {
        return NodeFilter.FILTER_ACCEPT;
      }
      return NodeFilter.FILTER_SKIP;
    };
    var queryShadowHosts = function (rootEl) {
      var _document = window.document;
      var walker = _document.createTreeWalker(rootEl, NodeFilter.SHOW_ELEMENT, filter, false);
      var list = [];
      while (walker.nextNode()) {
        list.push(walker.currentNode);
      }
      return list;
    };
    return { queryShadowHosts: queryShadowHosts };
  }();
  synchronite_proxyless_utils = function (constants, synchUrl, synchQuery, query, baseArray, domClass, scroll, shadowHosts) {
    var elementState = {};
    // caches the latest element state so we don't have to send the full state each time
    var config = synchroniteConfig;
    var FONT_FILE_TYPES = [
      'ttf',
      'woff',
      'woff2',
      'otf',
      'eot'
    ];
    function sendStateOfFrame(frame, datachannel) {
      _protectFields(frame);
      function getElementKey(target) {
        var key = target.element;
        if (target.frame && target.frame.length > 0) {
          key = target.frame[0] + '.' + key;
        }
        return key;
      }
      var msg = [];
      function getVal(obj) {
        if (obj.type !== 'password' && !obj.getAttribute('data-protected')) {
          var target;
          try {
            target = synchQuery.getNodeSelector(obj);
          } catch (e) {
            console.error('Failed to get node selector for element ' + obj);
          }
          if (target) {
            var storedElement = elementState[getElementKey(target)];
            var value = obj.value;
            var checked = obj.checked;
            if (typeof storedElement === 'undefined' || storedElement.value !== value || storedElement.checked !== checked) {
              msg.push({
                type: 'elementvalue',
                msg: {
                  target: synchQuery.getNodeSelector(obj),
                  value: obj.value,
                  checked: obj.checked
                }
              });
              elementState[getElementKey(target)] = {
                value: value,
                checked: checked
              };
            }
          }
        }
      }
      function getCanvas(obj) {
        try {
          var b64png = obj.toDataURL('image/png');
          //we use png because jpg doesn't support transparency
          msg.push({
            'type': 'canvas',
            'msg': {
              target: synchQuery.getNodeSelector(obj),
              value: b64png,
              width: obj.width,
              height: obj.height
            }
          });
        } catch (e) {
          console.warn('Unable to send Canvas. Error: ' + e);
          domClass.add(obj, 'cobrowse-blocked');
        }
      }
      query('input:not([type=hidden])', frame).forEach(getVal);
      query('select', frame).forEach(getVal);
      query('textarea', frame).forEach(getVal);
      query('canvas', frame).forEach(getCanvas);
      if (msg.length > 0) {
        // console.debug("Sending state " + JSON.stringify(msg));
        datachannel.send(constants.EVENT.STATE, msg);
      } else {
        console.debug('No element state changed');
      }
    }
    function sendStateForAllFrames(doc, datachannel) {
      query('iframe,frame', doc).forEach(function (node) {
        try {
          if (node.contentDocument) {
            var iframeWindow = node.contentWindow;
            var iframeDocument = iframeWindow.document;
            sendStateOfFrame(iframeDocument, datachannel);
            sendStateForAllFrames(iframeDocument, datachannel);
          }
        } catch (e) {
        }
      });
      shadowHosts.queryShadowHosts(doc.body || doc).forEach(function (shadowHost) {
        try {
          sendStateOfFrame(shadowHost.shadowRoot, datachannel);
          sendStateForAllFrames(shadowHost.shadowRoot, datachannel);
        } catch (e) {
          console.warn('error sending state of shadow root', e);
        }
      });
    }
    function _protectFields(docOrNode) {
      var fields = config.protectedFields;
      try {
        if (fields && docOrNode && docOrNode.nodeType !== Node.TEXT_NODE) {
          baseArray.forEach(fields, function (selector) {
            if (docOrNode.nodeType === Node.ELEMENT_NODE) {
              docOrNode = docOrNode.ownerDocument;
            }
            query(selector, docOrNode).forEach(function (field) {
              field.setAttribute('data-protected', true);
              field.setAttribute('type', 'text');
            });
          });
        }
      } catch (e) {
        console.error(e);
        if (window.proxyless && window.proxyless.debug) {
          window.console.warn.call(null, 'Error while applying field masking: ' + e);
        }
      }
    }
    function _matchesURL(url, currentUrl) {
      if (!currentUrl) {
        return false;
      }
      if (url.indexOf('regex:') === 0) {
        var regex = new RegExp(url.replace('regex:', ''));
        if (regex.test(currentUrl)) {
          return true;
        }
      } else {
        if (currentUrl.indexOf(url) >= 0) {
          return true;
        }
      }
    }
    function _endsWithAny(sequence, searchStrings) {
      for (var i = 0; i < searchStrings.length; i++) {
        if (_endsWith(sequence, searchStrings[i])) {
          return true;
        }
      }
      return false;
    }
    function _endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function _getFileNameFromUrl(url) {
      return url.split('/').pop().split('#')[0].split('?')[0];
    }
    function _resolveUrl(url, contextUrl) {
      if (/^http:\/\//i.test(url) && !/^https/i.test(url)) {
        //absolute url
        url = url.replace('http', 'https');
      } else {
        // resolve relative urls and change protocol to https
        if (url.substring(0, 2) === '//') {
          url = 'https:' + url;
        }
        url = synchUrl.resolveURL(url, contextUrl);
        url = url.replace('http:', 'https:');
      }
      return url;
    }
    var Utils = {
      sendingState: false,
      sendStateAfterTimeout: false,
      requestStateTimeout: null,
      listenToScrollableNodesTimeout: null,
      protectingFields: false,
      protectFieldsAfterTimeout: false,
      pathRegex: /[^\/]*$/,
      cssProxy: 'https://' + (config.tenantHost || config.tenantId + '.' + config.proxyHost) + constants.cssProxySuffix,
      imgProxy: 'https://' + (config.tenantHost || config.tenantId + '.' + config.proxyHost) + constants.imgProxySuffix,
      fontProxy: 'https://' + (config.tenantHost || config.tenantId + '.' + config.proxyHost) + constants.fontProxySuffix,
      escapeHtml: function (unsafe) {
        return unsafe.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      },
      getURLParameter: function (name) {
        return decodeURI((new RegExp(name + '=' + '(.+?)(&|$)').exec(window.location.hash.substr(1)) || [null])[1]);
      },
      rewriteCssSource: function (url, contextUrl) {
        return this._proxySource(this.cssProxy, url, contextUrl);
      },
      rewriteSvgLink: function (url) {
        url = url.replace('url(', '').replace(')', '');
        if (!synchUrl.isAbsolute(url)) {
          if (/^#/i.test(url)) {
            url = window.location.href + url;
          }
        } else if (url.indexOf('#') > 0) {
          url = location.origin + location.pathname + url.substring(url.indexOf('#'));
        }
        return 'url(' + url + ')';
      },
      _proxySource: function (proxyUrl, url, contextUrl) {
        if (!url || !proxyUrl) {
          return;
        }
        url = synchUrl.resolveURL(url, contextUrl);
        if (url.indexOf(location.origin) === 0) {
          return url;
        }
        if (/\s*javascript:.*/i.test(url)) {
          return;
        }
        var urlFragment = 'url=' + this.fixedEncodeURIComponent(url);
        urlFragment += '&context=' + encodeURIComponent(contextUrl);
        return proxyUrl + '?' + urlFragment;
      },
      fixedEncodeURIComponent: function (str) {
        return encodeURIComponent(str).split('\'').join('%27');
      },
      rewriteImgUrl: function (url, contextUrl) {
        if (!url) {
          return url;
        }
        if (/^\s*data/i.test(url)) {
          if (/svg\+xml/i.test(url)) {
            return '';
          }
          return url;
        }
        if (/\s*javascript:.*/i.test(url)) {
          return '';
        }
        if (config.proxifyImages) {
          return this._proxySource(this.imgProxy, url, contextUrl);
        } else {
          return _resolveUrl(url, contextUrl);
        }
      },
      rewriteFontUrl: function (url, contextUrl) {
        if (!url) {
          return url;
        }
        if (/^\s*data/i.test(url)) {
          if (/svg\+xml/i.test(url)) {
            return '';
          }
          return url;
        }
        if (/\s*javascript:.*/i.test(url)) {
          return '';
        }
        if (config.proxifyImages) {
          return this._proxySource(this.fontProxy, url, contextUrl);
        } else {
          return _resolveUrl(url, contextUrl);
        }
      },
      parseCss: function (css, contextUrl) {
        if (!css || css === '') {
          return '';
        }
        //filter is not supported by browsers like IE, so don't use it.
        // Websites usually have a backup css rule for this to support older browsers.
        css = css.replace('filter:', 'nofilter:');
        var urlRegexSingleQuotes = /url\(\s*'((?:\\.|[^\\']|\\\n)*(?!;base64))'\s*\)/gi;
        var urlRegexDoubleQuotes = /url\(\s*"((?:\\.|[^\\"]|\\\n)*(?!;base64))"\s*\)/gi;
        var urlRegexNoQuotes = /url\(\s*((?!["'])(?:\\.|[^()\\])*(?!;base64)(?!["']))\)/gi;
        var importRegex = /@import\s*['"](.*)['"]/gi;
        var that = this;
        return css.replace(urlRegexSingleQuotes, function ($0, url) {
          return that.rewriteUrl(url, contextUrl);
        }).replace(urlRegexDoubleQuotes, function ($0, url) {
          return that.rewriteUrl(url, contextUrl);
        }).replace(urlRegexNoQuotes, function ($0, url) {
          return that.rewriteUrl(url, contextUrl);
        }).replace(importRegex, function ($0, url) {
          if (url.indexOf('.css') > 0) {
            return '@import \'' + that.rewriteCssSource(url, contextUrl) + '\'';
          }
          return $0;
        });
      },
      rewriteUrl: function (url, contextUrl) {
        var urlWithoutEscapes = url;
        if (window.synchroniteConfig.enableEscapingInCssUrlsOnAgentBrowser) {
          urlWithoutEscapes = urlWithoutEscapes.replace(/\\(?:([0-9A-Fa-f]{1,6})\s?|([^\r\f]))/g, function (match, hexString, otherCharacter) {
            if (hexString) {
              return String.fromCharCode(parseInt(hexString, 16));
            } else if (otherCharacter) {
              return otherCharacter;
            }
            return match;
          });
        }
        var rewrittenUrl;
        if (url.indexOf('.css') > 0) {
          rewrittenUrl = this.rewriteCssSource(urlWithoutEscapes, contextUrl);
        } else if (_endsWithAny(_getFileNameFromUrl(url), FONT_FILE_TYPES)) {
          rewrittenUrl = this.rewriteFontUrl(urlWithoutEscapes, contextUrl);
        } else {
          rewrittenUrl = this.rewriteImgUrl(urlWithoutEscapes, contextUrl);
        }
        return 'url(\'' + rewrittenUrl + '\')';
      },
      /**
       * Checks if the attribute value (e.g. src, href) to be set is https.
       * @param relativeOrAbsoluteUrl
       * @param absoluteBaseUrl
       * @returns {boolean}
       */
      isHttps: function (relativeOrAbsoluteUrl, absoluteBaseUrl) {
        // value is absolute https or value is relative but will be resolved to https anyway
        return /^https/i.test(relativeOrAbsoluteUrl) || /^https/i.test(absoluteBaseUrl) && !(synchUrl.isAbsolute(relativeOrAbsoluteUrl) || relativeOrAbsoluteUrl.indexOf('//') === 0);
      },
      isPageEmpty: function () {
        var frame = document.getElementById(constants.cobrowsingFrameName);
        if (!frame) {
          return true;
        }
        var doc = frame.contentDocument;
        if (!doc) {
          return true;
        }
        var head = doc.getElementsByTagName('head')[0];
        if (head && head.firstChild) {
          return false;
        }
        var body = doc.getElementsByTagName('body')[0];
        if (body && body.firstChild) {
          return false;
        }
        return true;
      },
      requestState: function (datachannel, force) {
        if (this.requestStateTimeout) {
          clearTimeout(this.requestStateTimeout);
        }
        this.requestStateTimeout = setTimeout(function () {
          console.log('requesting state');
          datachannel.send(constants.COMMAND.REQUESTSTATE, {
            noDom: true,
            force: !!force
          });
        }, 200);
      },
      listenToScrollableNodes: function (win) {
        if (this.listenToScrollableNodesTimeout) {
          clearTimeout(this.listenToScrollableNodesTimeout);
        }
        this.listenToScrollableNodesTimeout = setTimeout(function () {
          console.log('listen to scrollable nodes');
          scroll.listenToScrollableNodes(win, win.document);
        }, 200);
      },
      sendState: function (datachannel, forceFullState) {
        if (forceFullState) {
          elementState = {};
        }
        if (this.sendingState) {
          this.sendStateAfterTimeout = true;
          return;
        } else {
          this.sendingState = true;
        }
        sendStateOfFrame(document, datachannel);
        sendStateForAllFrames(document, datachannel);
        var that = this;
        setTimeout(function () {
          if (that.sendStateAfterTimeout) {
            sendStateOfFrame(document, datachannel);
            sendStateForAllFrames(document, datachannel);
          }
          that.sendStateAfterTimeout = false;
          that.sendingState = false;
        }, 1000);
      },
      protectFields: function (docOrNode) {
        if (this.protectingFields) {
          this.protectFieldsAfterTimeout = true;
          return;
        } else {
          this.protectingFields = true;
        }
        _protectFields(docOrNode);
        var that = this;
        setTimeout(function () {
          if (that.protectFieldsAfterTimeout) {
            _protectFields(docOrNode);
          }
          that.protectFieldsAfterTimeout = false;
          that.protectingFields = false;
        }, 100);
      },
      isBlacklistedUrl: function (url) {
        var blacklist = config.urlBlacklist;
        var whitelist = config.urlWhitelist;
        var lpTagUrl = window.lpTag && window.lpTag.url;
        if (whitelist && whitelist.length) {
          var foundWhitelistMatch = false;
          for (var j = 0; j < whitelist.length; j++) {
            var whitelistUrl = whitelist[j];
            if (_matchesURL(whitelistUrl, url) || _matchesURL(whitelistUrl, lpTagUrl)) {
              foundWhitelistMatch = true;
              break;
            }
          }
          if (foundWhitelistMatch === false) {
            return true;
          }
        }
        if (blacklist && blacklist.length) {
          for (var i = 0; i < blacklist.length; i++) {
            var blacklistUrl = blacklist[i];
            if (_matchesURL(blacklistUrl, url) || _matchesURL(blacklistUrl, lpTagUrl)) {
              return true;
            }
          }
        }
        return false;
      }
    };
    return Utils;
  }(synchronite_constants_constants, synchronite__base_url, synchronite__base_query, dojo_query, dojo__base_array, dojo_dom_class, synchronite_events_scroll, synchronite_proxyless_dom_shadowHosts);
  synchronite_proxyless_memberStateEvents_events = function (Evented) {
    //PRIVATE
    var _eventHandler = new Evented();
    //PUBLIC
    return _eventHandler;
  }(dojo_Evented);
  synchronite_proxyless_memberStateEvents_common = {
    NAMESPACE: 'memberStateEvent',
    LEFT: 'memberLeft',
    JOINED: 'memberJoined',
    REJOINED: 'memberRejoined',
    INACTIVE: 'memberInactive',
    ACTIVE: 'memberActive'
  };
  synchronite_proxyless_participantNotification = function (memberStateEvents, memberState, array) {
    var currentParticipants = {}, ownUserId, participantInfos = [], gotInitialState = false;
    var STATES = {
      joined: 'joined',
      active: 'active',
      inactive: 'inactive',
      left: 'left'
    };
    var observeIntervalRef, OBSERVE_INTERVAL = 5000;
    var uiPointers = synchroniteConfig.uiPointers;
    function startObserving(_ownUserId) {
      ownUserId = _ownUserId.toString();
      observeIntervalRef = setInterval(function () {
        for (var userId in currentParticipants) {
          if (currentParticipants.hasOwnProperty(userId) && userId !== ownUserId) {
            checkForStateChange(currentParticipants[userId]);
          }
        }
      }, OBSERVE_INTERVAL);
    }
    function publishEvent(user, state) {
      memberStateEvents.emit(memberState.NAMESPACE, {
        state: state,
        user: user,
        currentUsers: currentParticipants
      });
    }
    function checkForStateChange(user) {
      if (user.state === STATES.joined) {
        user.state = STATES.active;
        publishEvent(user, memberState.ACTIVE);
      } else if (user.state === STATES.active) {
        if (new Date().getTime() - user.lastSeen > 10000) {
          user.state = STATES.inactive;
          publishEvent(user, memberState.INACTIVE);
        }
      } else if (user.state === STATES.inactive) {
        if (new Date().getTime() - user.lastSeen > 20000) {
        }
      } else if (user.state === STATES.left) {
        delete currentParticipants[user.userId];
      }
    }
    function stopObserving() {
      clearInterval(observeIntervalRef);
      currentParticipants = {};
      participantInfos = [];
      gotInitialState = false;
    }
    function handleHeartbeat(beat) {
      if (beat.userId && currentParticipants[beat.userId]) {
        currentParticipants[beat.userId].lastSeen = new Date();
        currentParticipants[beat.userId].state = STATES.active;
        publishEvent(currentParticipants[beat.userId], memberState.ACTIVE);
      }
    }
    function addUser(user) {
      user.lastSeen = new Date().getTime();
      if (!currentParticipants[user.userId]) {
        user.state = STATES.joined;
        currentParticipants[user.userId] = user;
        console.log('user joined ' + user.userId);
        publishEvent(user, memberState.JOINED);
      } else {
        console.log('user rejoined ' + user.userId);
        publishEvent(user, memberState.REJOINED);
      }
    }
    function checkIfUserLeft(user, members) {
      if (!members[user.userId]) {
        user.state = STATES.left;
        console.log('user left ' + user.userId);
        checkForStateChange(user);
        publishEvent(user, memberState.LEFT);
      }
    }
    function addParticipantInfo(info) {
      var userId;
      console.log('handle participant info ' + JSON.stringify(info));
      for (userId in info.members) {
        if (info.members.hasOwnProperty(userId)) {
          var member = info.members[userId];
          addUser(member);
        }
      }
      // we only check if a visitor has left once we got the initial state (i.e. two users in the session)
      if (gotInitialState) {
        for (userId in currentParticipants) {
          if (currentParticipants.hasOwnProperty(userId)) {
            var user = currentParticipants[userId];
            checkIfUserLeft(user, info.members);
          }
        }
      }
      _assignCursors();
      participantInfos.push(info);
      if (!gotInitialState) {
        _checkForInitialState();
      }
    }
    function _assignCursors() {
      if (!uiPointers.useCustom) {
        return;
      }
      var count = 0;
      for (var userId in currentParticipants) {
        if (currentParticipants.hasOwnProperty(userId)) {
          var user = currentParticipants[userId];
          if (user.userId !== ownUserId) {
            var cursor = uiPointers.telepointer[count] && uiPointers.telepointer[count].cursor;
            var color = uiPointers.telepointer[count] && uiPointers.telepointer[count].color;
            if (cursor && color) {
              user.cursor = cursor;
              user.color = color;
              currentParticipants[user.userId] = user;
            }
            count++;
          }
        }
      }
    }
    function _checkForInitialState() {
      // We have the intial state once we receive ...
      // ... either one info with two participants ...
      if (participantInfos.length === 1 && Object.keys(participantInfos[0].members).length === 2) {
        gotInitialState = true;
      }
      // ... or two infos...
      if (participantInfos.length === 2) {
        var oneMemberCount = 0;
        // ... with 2 participants or...
        array.forEach(participantInfos, function (info) {
          if (Object.keys(info.members).length === 2) {
            gotInitialState = true;
          } else if (Object.keys(info.members).length === 1) {
            oneMemberCount++;
          }
        });
        // ... when both joined at the same time, two infos, both with one participant
        if (oneMemberCount === 2) {
          gotInitialState = true;
        }
      }
    }
    function _getNumberOfParticipants() {
      var size = 0, key;
      for (key in currentParticipants) {
        if (currentParticipants.hasOwnProperty(key)) {
          size++;
        }
      }
      return size;
    }
    return {
      addParticipantInfo: addParticipantInfo,
      handleHeartbeat: handleHeartbeat,
      startObserving: startObserving,
      gotInitialState: function () {
        return gotInitialState;
      },
      stopObserving: stopObserving,
      getNumberOfParticipants: _getNumberOfParticipants,
      get: function (id) {
        return currentParticipants[id];
      }
    };
  }(synchronite_proxyless_memberStateEvents_events, synchronite_proxyless_memberStateEvents_common, dojo__base_array);
  synchronite_proxyless_connectionEvents_events = function (Evented) {
    //PRIVATE
    var _eventHandler = new Evented();
    //PUBLIC
    return _eventHandler;
  }(dojo_Evented);
  synchronite_proxyless_connectionEvents_common = {
    NAMESPACE: 'connectionEvents',
    HEALTHY: 'HEALTHY',
    UNHEALTHY: 'UNHEALTHY'
  };
  synchronite_proxyless_reconnectNotification = function (connectionEvents, states) {
    var currentState = states.HEALTHY, emitTimeout;
    /**
     * Sets the connection state to 'unhealthy' and emits a 'unhealthy' event after 3 seconds if the connection did not
     * become 'healthy' again
     */
    function connectionUnhealthy() {
      emitTimeout = setTimeout(function () {
        if (currentState === states.UNHEALTHY) {
          connectionEvents.emit(states.NAMESPACE, states.UNHEALTHY);
        }
        emitTimeout = null;
      }, 3000);
      currentState = states.UNHEALTHY;
    }
    /**
     * Sets the connection state to 'healthy' and emits a healthy event if the connection was 'unhealthy' and there is no
     * pending 'unhealthy' event
     */
    function connectionHealthy() {
      if (!emitTimeout && currentState === states.UNHEALTHY) {
        connectionEvents.emit(states.NAMESPACE, states.HEALTHY);
      }
      currentState = states.HEALTHY;
    }
    return {
      connectionUnhealthy: connectionUnhealthy,
      connectionHealthy: connectionHealthy
    };
  }(synchronite_proxyless_connectionEvents_events, synchronite_proxyless_connectionEvents_common);
  // Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
  // This work is free. You can redistribute it and/or modify it
  // under the terms of the WTFPL, Version 2
  // For more information see LICENSE.txt or http://www.wtfpl.net/
  //
  // For more information, the home page:
  // http://pieroxy.net/blog/pages/lz-string/testing.html
  //
  // LZ-based compression algorithm, version 1.4.4
  var LZString = function () {
    // private property
    var f = String.fromCharCode;
    var keyStrBase64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var keyStrUriSafe = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$';
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i = 0; i < alphabet.length; i++) {
          baseReverseDic[alphabet][alphabet.charAt(i)] = i;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString = {
      compressToBase64: function (input) {
        if (input == null)
          return '';
        var res = LZString._compress(input, 6, function (a) {
          return keyStrBase64.charAt(a);
        });
        switch (res.length % 4) {
        // To produce valid Base64
        default:
        // When could this happen ?
        case 0:
          return res;
        case 1:
          return res + '===';
        case 2:
          return res + '==';
        case 3:
          return res + '=';
        }
      },
      decompressFromBase64: function (input) {
        if (input == null)
          return '';
        if (input == '')
          return null;
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrBase64, input.charAt(index));
        });
      },
      compressToUTF16: function (input) {
        if (input == null)
          return '';
        return LZString._compress(input, 15, function (a) {
          return f(a + 32);
        }) + ' ';
      },
      decompressFromUTF16: function (compressed) {
        if (compressed == null)
          return '';
        if (compressed == '')
          return null;
        return LZString._decompress(compressed.length, 16384, function (index) {
          return compressed.charCodeAt(index) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function (uncompressed) {
        var compressed = LZString.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);
        // 2 bytes per character
        for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
          var current_value = compressed.charCodeAt(i);
          buf[i * 2] = current_value >>> 8;
          buf[i * 2 + 1] = current_value % 256;
        }
        return buf;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function (compressed) {
        if (compressed === null || compressed === undefined) {
          return LZString.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);
          // 2 bytes per character
          for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
            buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
          }
          var result = [];
          buf.forEach(function (c) {
            result.push(f(c));
          });
          return LZString.decompress(result.join(''));
        }
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function (input) {
        if (input == null)
          return '';
        return LZString._compress(input, 6, function (a) {
          return keyStrUriSafe.charAt(a);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function (input) {
        if (input == null)
          return '';
        if (input == '')
          return null;
        input = input.replace(/ /g, '+');
        return LZString._decompress(input.length, 32, function (index) {
          return getBaseValue(keyStrUriSafe, input.charAt(index));
        });
      },
      compress: function (uncompressed) {
        return LZString._compress(uncompressed, 16, function (a) {
          return f(a);
        });
      },
      _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null)
          return '';
        var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = '', context_wc = '', context_w = '', context_enlargeIn = 2,
          // Compensate for the first entry which should not count
          context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            // Add wc to the dictionary.
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        // Output the code for w.
        if (context_w !== '') {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        // Mark the end of the stream
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        // Flush the last char
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else
            context_data_position++;
        }
        return context_data.join('');
      },
      decompress: function (compressed) {
        if (compressed == null)
          return '';
        if (compressed == '')
          return null;
        return LZString._decompress(compressed.length, 32768, function (index) {
          return compressed.charCodeAt(index);
        });
      },
      _decompress: function (length, resetValue, getNextValue) {
        var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = '', result = [], i, w, bits, resb, maxpower, power, c, data = {
            val: getNextValue(0),
            position: resetValue,
            index: 1
          };
        for (i = 0; i < 3; i += 1) {
          dictionary[i] = i;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (next = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 2:
          return '';
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return '';
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 2:
            return result.join('');
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          // Add w+entry[0] to the dictionary.
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    return LZString;
  }();
  if (true) {
    synchronite_libs_lz_string = function () {
      return LZString;
    }();
  } else if (typeof module !== 'undefined' && module != null) {
    module.exports = LZString;
  }
  synchronite_cometd_LargeMessageExtension = function (has, sniff, lzString) {
    var _cometd;
    function _getMaxCallbackPollingSize() {
      // The maximum size of a cometd message minus the data field
      // (Domain name and query parameters add up to hundreds of bytes)
      var ENVELOPE_SIZE = 1000;
      // The maximum URL size per browser determines the maximum size of callback-polling messages.
      //
      // 1. http://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers
      // 2. http://stackoverflow.com/questions/3721034/how-long-an-url-can-internet-explorer-9-take
      // 3. https://support.microsoft.com/en-us/kb/208427/en-us
      var MAX_URL_IE8 = 2000,
        // 2083 is the maximum URL length for GET requests in Internet Explorer 8
        MAX_URL_IE9 = 5000,
        // 5120 is the maximum URL length for GET requests in Internet Explorer 9
        MAX_URL_OTHER = 5000;
      var maxSize = MAX_URL_OTHER;
      if (has('ie') == 8) {
        maxSize = MAX_URL_IE8;
      } else if (has('ie') == 9) {
        maxSize = MAX_URL_IE9;
      }
      maxSize -= ENVELOPE_SIZE;
      // Better be on the safe side (Domain name and query parameters add up to hundreds of bytes)
      return maxSize;
    }
    var MAX_CHUNK_SIZE_DEFAULT = 1000, MAX_CHUNK_SIZE_WEBSOCKET = 1024 * 30,
      // maxMessageSize = 65520 -> http://docs.cometd.org/reference/java_server.html
      MAX_CHUNK_SIZE_LONGPOLLING = 1024 * 50,
      // 50KB
      MAX_CHUNK_SIZE_CALLBACKPOLLING = _getMaxCallbackPollingSize();
    var COMPRESS_IF_LARGER = 10 * 1024;
    // Always compress messages exceeding compression threshold
    var _chunkMap = {};
    var _getMaxMessageSize = function (currentTransport) {
        if (currentTransport == 'websocket') {
          return MAX_CHUNK_SIZE_WEBSOCKET;
        } else if (currentTransport == 'long-polling') {
          return MAX_CHUNK_SIZE_LONGPOLLING;
        } else if (currentTransport == 'callback-polling') {
          return MAX_CHUNK_SIZE_CALLBACKPOLLING;
        }
        return MAX_CHUNK_SIZE_DEFAULT;
      }, _splitAndEncodeText = function (text, maxChunkSize) {
        // NOTE: We must base64 encode the json string otherwise when splitting the string
        //       JS will automatically inject escape characters, thus increasing the string size.
        var encodedText = lzString.compressToEncodedURIComponent(text);
        console.debug('LargeMessageExtension: Compressed from ' + Math.round(text.length / 1024) + 'kb to ' + Math.round(encodedText.length / 1024) + 'kb (' + Math.round(encodedText.length / text.length * 100) + '%)');
        var chunks = [];
        var n = Math.floor(encodedText.length / maxChunkSize) + 1;
        var last = 0;
        for (var i = 0; i < n; i++) {
          chunks[i] = encodedText.substr(last, maxChunkSize);
          last += maxChunkSize;
        }
        return chunks;
      }, _chunksComplete = function (id, n) {
        var chunks = _chunkMap[id];
        for (var i = 0; i < n; i++) {
          if (!chunks[i]) {
            return false;
          }
        }
        return true;
      };
    var largeMessageExt = {
      COMPRESS_IF_LARGER: COMPRESS_IF_LARGER,
      registered: function (name, cometd) {
        // Store the cometd object reference
        _cometd = cometd;
      },
      outgoing: function (message) {
        if (!message.data || /^\/meta\//.test(message.channel)) {
          // Do not mess with meta messages
          return message;
        }
        if (message.data && message.data.type === 'chunk') {
          // Ignore messages that are already compressed
          return message;
        }
        var jsonMessage = JSON.stringify(message), currentTransport = _cometd.getTransport().toString();
        if (currentTransport === 'callback-polling') {
          jsonMessage = encodeURI(jsonMessage);
        }
        var size = jsonMessage.length, maxSizeForTransport = _getMaxMessageSize(currentTransport),
          /* substract 400 for the metadata we attach */
          maxSizeData = Math.min(maxSizeForTransport, COMPRESS_IF_LARGER), maxSizeChunk = maxSizeForTransport - 400;
        if (size >= maxSizeData) {
          // Log the long poll
          var chunkID = +new Date();
          console.info('LargeMessageExtension: Message "' + chunkID + ' is too large (' + size + '>' + maxSizeData + ') for transport ' + _cometd.getTransport().toString() + ' or exceeds defined threshold.');
          var timeStart = new Date().getTime(), splitted = _splitAndEncodeText(JSON.stringify(message), maxSizeChunk), timeTotal = new Date().getTime() - timeStart;
          if (timeTotal > 300) {
            console.warn('LargeMessageExtension: Detected slow parsing of a message. Took "' + timeTotal + 'ms\'');
          } else {
            console.debug('LargeMessageExtension: Parsing of a message. Took "' + timeTotal + 'ms\'');
          }
          timeStart = new Date().getTime();
          var cometdConfigCopy = _cometd.getConfiguration();
          // get a copy of the cometd config
          if (cometdConfigCopy.autoBatch) {
            _cometd.configure({ autoBatch: false });  // will be mixed into the existing config
          }
          var lastMessagesSent = function () {
            timeTotal = new Date().getTime() - timeStart;
            console.debug('LargeMessageExtension:  Sending of all chunks took "' + timeTotal + 'ms\'');
            // reset config autoBatch. timeout ensures that all messages have been sent.
            setTimeout(function () {
              if (cometdConfigCopy.autoBatch) {
                _cometd.configure({ autoBatch: true });  // will be mixed into the existing config
              }
            }, 1);
          };
          for (var index = 0; index < splitted.length; ++index) {
            var data = {
              type: 'chunk',
              i: index,
              n: splitted.length,
              id: chunkID,
              d: splitted[index]
            };
            if (!_cometd.isDisconnected()) {
              console.info('Sending \'' + chunkID + '\' chunk ' + (index + 1) + '/' + splitted.length + ' dataSize \'' + JSON.stringify(data).length + '\'');
              if (index == splitted.length - 1) {
                _cometd.publish(message.channel, data, lastMessagesSent);  // last message
              } else {
                _cometd.publish(message.channel, data);
              }
            }
          }
          // http://docs.cometd.org/reference/extensions.html#extensions_writing
          // If the extension method returns null, the processing should stop: other extensions do not process the
          // message, and CometD does not further process it. CometD does not send the message to the server,
          // nor notify listeners.
          return null;
        }
        return message;
      },
      incoming: function (message) {
        var data = message.data;
        if (data && data.type === 'chunk') {
          var id = data.id;
          var chunks = _chunkMap[id] || [];
          chunks[data.i] = data.d;
          _chunkMap[id] = chunks;
          if (_chunksComplete(id, data.n)) {
            var mergedChunks = chunks.join('');
            var largeMessage = JSON.parse(lzString.decompressFromEncodedURIComponent(mergedChunks));
            message.data = largeMessage.data;
            delete _chunkMap[id];
            return message;
          }
          return null;  // dismiss all chunk index messages
        }
      },
      getMaxMessageSize: _getMaxMessageSize
    };
    return largeMessageExt;
  }(dojo_has, dojo_sniff, synchronite_libs_lz_string);
  /*
   * Copyright (c) 2008-2017 the original author or authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  /* CometD Version 3.1.1 */
  (function (root, factory) {
    if (typeof exports === 'object') {
      // CommonJS.
      module.exports = factory();
    } else if (true) {
      org_cometd = function () {
        return typeof factory === 'function' ? factory() : factory;
      }();
    } else {
      // Globals.
      root.org = root.org || {};
      root.org.cometd = factory();
    }
  }(this, function () {
    /**
     * Utility functions.
     */
    var Utils = {
      isString: function (value) {
        if (value === undefined || value === null) {
          return false;
        }
        return typeof value === 'string' || value instanceof String;
      },
      isArray: function (value) {
        if (value === undefined || value === null) {
          return false;
        }
        return value instanceof Array;
      },
      /**
       * Returns whether the given element is contained into the given array.
       * @param element the element to check presence for
       * @param array the array to check for the element presence
       * @return the index of the element, if present, or a negative index if the element is not present
       */
      inArray: function (element, array) {
        for (var i = 0; i < array.length; ++i) {
          if (element === array[i]) {
            return i;
          }
        }
        return -1;
      },
      setTimeout: function (cometd, funktion, delay) {
        return window.setTimeout(function () {
          try {
            cometd._debug('Invoking timed function', funktion);
            funktion();
          } catch (x) {
            cometd._debug('Exception invoking timed function', funktion, x);
          }
        }, delay);
      },
      clearTimeout: function (timeoutHandle) {
        window.clearTimeout(timeoutHandle);
      }
    };
    /**
     * A registry for transports used by the CometD object.
     */
    var TransportRegistry = function () {
      var _types = [];
      var _transports = {};
      this.getTransportTypes = function () {
        return _types.slice(0);
      };
      this.findTransportTypes = function (version, crossDomain, url) {
        var result = [];
        for (var i = 0; i < _types.length; ++i) {
          var type = _types[i];
          if (_transports[type].accept(version, crossDomain, url) === true) {
            result.push(type);
          }
        }
        return result;
      };
      this.negotiateTransport = function (types, version, crossDomain, url) {
        for (var i = 0; i < _types.length; ++i) {
          var type = _types[i];
          for (var j = 0; j < types.length; ++j) {
            if (type === types[j]) {
              var transport = _transports[type];
              if (transport.accept(version, crossDomain, url) === true) {
                return transport;
              }
            }
          }
        }
        return null;
      };
      this.add = function (type, transport, index) {
        var existing = false;
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            existing = true;
            break;
          }
        }
        if (!existing) {
          if (typeof index !== 'number') {
            _types.push(type);
          } else {
            _types.splice(index, 0, type);
          }
          _transports[type] = transport;
        }
        return !existing;
      };
      this.find = function (type) {
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            return _transports[type];
          }
        }
        return null;
      };
      this.remove = function (type) {
        for (var i = 0; i < _types.length; ++i) {
          if (_types[i] === type) {
            _types.splice(i, 1);
            var transport = _transports[type];
            delete _transports[type];
            return transport;
          }
        }
        return null;
      };
      this.clear = function () {
        _types = [];
        _transports = {};
      };
      this.reset = function (init) {
        for (var i = 0; i < _types.length; ++i) {
          _transports[_types[i]].reset(init);
        }
      };
    };
    /**
     * Base object with the common functionality for transports.
     */
    var Transport = function () {
      var _type;
      var _cometd;
      var _url;
      /**
       * Function invoked just after a transport has been successfully registered.
       * @param type the type of transport (for example 'long-polling')
       * @param cometd the cometd object this transport has been registered to
       * @see #unregistered()
       */
      this.registered = function (type, cometd) {
        _type = type;
        _cometd = cometd;
      };
      /**
       * Function invoked just after a transport has been successfully unregistered.
       * @see #registered(type, cometd)
       */
      this.unregistered = function () {
        _type = null;
        _cometd = null;
      };
      this._debug = function () {
        _cometd._debug.apply(_cometd, arguments);
      };
      this._mixin = function () {
        return _cometd._mixin.apply(_cometd, arguments);
      };
      this.getConfiguration = function () {
        return _cometd.getConfiguration();
      };
      this.getAdvice = function () {
        return _cometd.getAdvice();
      };
      this.setTimeout = function (funktion, delay) {
        return Utils.setTimeout(_cometd, funktion, delay);
      };
      this.clearTimeout = function (handle) {
        Utils.clearTimeout(handle);
      };
      /**
       * Converts the given response into an array of bayeux messages
       * @param response the response to convert
       * @return an array of bayeux messages obtained by converting the response
       */
      this.convertToMessages = function (response) {
        if (Utils.isString(response)) {
          try {
            return JSON.parse(response);
          } catch (x) {
            this._debug('Could not convert to JSON the following string', '"' + response + '"');
            throw x;
          }
        }
        if (Utils.isArray(response)) {
          return response;
        }
        if (response === undefined || response === null) {
          return [];
        }
        if (response instanceof Object) {
          return [response];
        }
        throw 'Conversion Error ' + response + ', typeof ' + typeof response;
      };
      /**
       * Returns whether this transport can work for the given version and cross domain communication case.
       * @param version a string indicating the transport version
       * @param crossDomain a boolean indicating whether the communication is cross domain
       * @param url the URL to connect to
       * @return true if this transport can work for the given version and cross domain communication case,
       * false otherwise
       */
      this.accept = function (version, crossDomain, url) {
        throw 'Abstract';
      };
      /**
       * Returns the type of this transport.
       * @see #registered(type, cometd)
       */
      this.getType = function () {
        return _type;
      };
      this.getURL = function () {
        return _url;
      };
      this.setURL = function (url) {
        _url = url;
      };
      this.send = function (envelope, metaConnect) {
        throw 'Abstract';
      };
      this.reset = function (init) {
        this._debug('Transport', _type, 'reset', init ? 'initial' : 'retry');
      };
      this.abort = function () {
        this._debug('Transport', _type, 'aborted');
      };
      this.toString = function () {
        return this.getType();
      };
    };
    Transport.derive = function (baseObject) {
      function F() {
      }
      F.prototype = baseObject;
      return new F();
    };
    /**
     * Base object with the common functionality for transports based on requests.
     * The key responsibility is to allow at most 2 outstanding requests to the server,
     * to avoid that requests are sent behind a long poll.
     * To achieve this, we have one reserved request for the long poll, and all other
     * requests are serialized one after the other.
     */
    var RequestTransport = function () {
      var _super = new Transport();
      var _self = Transport.derive(_super);
      var _requestIds = 0;
      var _metaConnectRequest = null;
      var _requests = [];
      var _envelopes = [];
      function _coalesceEnvelopes(envelope) {
        while (_envelopes.length > 0) {
          var envelopeAndRequest = _envelopes[0];
          var newEnvelope = envelopeAndRequest[0];
          var newRequest = envelopeAndRequest[1];
          if (newEnvelope.url === envelope.url && newEnvelope.sync === envelope.sync) {
            _envelopes.shift();
            envelope.messages = envelope.messages.concat(newEnvelope.messages);
            this._debug('Coalesced', newEnvelope.messages.length, 'messages from request', newRequest.id);
            continue;
          }
          break;
        }
      }
      function _transportSend(envelope, request) {
        this.transportSend(envelope, request);
        request.expired = false;
        if (!envelope.sync) {
          var maxDelay = this.getConfiguration().maxNetworkDelay;
          var delay = maxDelay;
          if (request.metaConnect === true) {
            delay += this.getAdvice().timeout;
          }
          this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for the response, maxNetworkDelay', maxDelay);
          var self = this;
          request.timeout = this.setTimeout(function () {
            request.expired = true;
            var errorMessage = 'Request ' + request.id + ' of transport ' + self.getType() + ' exceeded ' + delay + ' ms max network delay';
            var failure = { reason: errorMessage };
            var xhr = request.xhr;
            failure.httpCode = self.xhrStatus(xhr);
            self.abortXHR(xhr);
            self._debug(errorMessage);
            self.complete(request, false, request.metaConnect);
            envelope.onFailure(xhr, envelope.messages, failure);
          }, delay);
        }
      }
      function _queueSend(envelope) {
        var requestId = ++_requestIds;
        var request = {
          id: requestId,
          metaConnect: false,
          envelope: envelope
        };
        // Consider the metaConnect requests which should always be present
        if (_requests.length < this.getConfiguration().maxConnections - 1) {
          _requests.push(request);
          _transportSend.call(this, envelope, request);
        } else {
          this._debug('Transport', this.getType(), 'queueing request', requestId, 'envelope', envelope);
          _envelopes.push([
            envelope,
            request
          ]);
        }
      }
      function _metaConnectComplete(request) {
        var requestId = request.id;
        this._debug('Transport', this.getType(), 'metaConnect complete, request', requestId);
        if (_metaConnectRequest !== null && _metaConnectRequest.id !== requestId) {
          throw 'Longpoll request mismatch, completing request ' + requestId;
        }
        // Reset metaConnect request
        _metaConnectRequest = null;
      }
      function _complete(request, success) {
        var index = Utils.inArray(request, _requests);
        // The index can be negative if the request has been aborted
        if (index >= 0) {
          _requests.splice(index, 1);
        }
        if (_envelopes.length > 0) {
          var envelopeAndRequest = _envelopes.shift();
          var nextEnvelope = envelopeAndRequest[0];
          var nextRequest = envelopeAndRequest[1];
          this._debug('Transport dequeued request', nextRequest.id);
          if (success) {
            if (this.getConfiguration().autoBatch) {
              _coalesceEnvelopes.call(this, nextEnvelope);
            }
            _queueSend.call(this, nextEnvelope);
            this._debug('Transport completed request', request.id, nextEnvelope);
          } else {
            // Keep the semantic of calling response callbacks asynchronously after the request
            var self = this;
            this.setTimeout(function () {
              self.complete(nextRequest, false, nextRequest.metaConnect);
              var failure = { reason: 'Previous request failed' };
              var xhr = nextRequest.xhr;
              failure.httpCode = self.xhrStatus(xhr);
              nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
            }, 0);
          }
        }
      }
      _self.complete = function (request, success, metaConnect) {
        if (metaConnect) {
          _metaConnectComplete.call(this, request);
        } else {
          _complete.call(this, request, success);
        }
      };
      /**
       * Performs the actual send depending on the transport type details.
       * @param envelope the envelope to send
       * @param request the request information
       */
      _self.transportSend = function (envelope, request) {
        throw 'Abstract';
      };
      _self.transportSuccess = function (envelope, request, responses) {
        if (!request.expired) {
          this.clearTimeout(request.timeout);
          this.complete(request, true, request.metaConnect);
          if (responses && responses.length > 0) {
            envelope.onSuccess(responses);
          } else {
            envelope.onFailure(request.xhr, envelope.messages, { httpCode: 204 });
          }
        }
      };
      _self.transportFailure = function (envelope, request, failure) {
        if (!request.expired) {
          this.clearTimeout(request.timeout);
          this.complete(request, false, request.metaConnect);
          envelope.onFailure(request.xhr, envelope.messages, failure);
        }
      };
      function _metaConnectSend(envelope) {
        if (_metaConnectRequest !== null) {
          throw 'Concurrent metaConnect requests not allowed, request id=' + _metaConnectRequest.id + ' not yet completed';
        }
        var requestId = ++_requestIds;
        this._debug('Transport', this.getType(), 'metaConnect send, request', requestId, 'envelope', envelope);
        var request = {
          id: requestId,
          metaConnect: true,
          envelope: envelope
        };
        _transportSend.call(this, envelope, request);
        _metaConnectRequest = request;
      }
      _self.send = function (envelope, metaConnect) {
        if (metaConnect) {
          _metaConnectSend.call(this, envelope);
        } else {
          _queueSend.call(this, envelope);
        }
      };
      _self.abort = function () {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i) {
          var request = _requests[i];
          if (request) {
            this._debug('Aborting request', request);
            if (!this.abortXHR(request.xhr)) {
              this.transportFailure(request.envelope, request, { reason: 'abort' });
            }
          }
        }
        var metaConnectRequest = _metaConnectRequest;
        if (metaConnectRequest) {
          this._debug('Aborting metaConnect request', metaConnectRequest);
          if (!this.abortXHR(metaConnectRequest.xhr)) {
            this.transportFailure(metaConnectRequest.envelope, metaConnectRequest, { reason: 'abort' });
          }
        }
        this.reset(true);
      };
      _self.reset = function (init) {
        _super.reset(init);
        _metaConnectRequest = null;
        _requests = [];
        _envelopes = [];
      };
      _self.abortXHR = function (xhr) {
        if (xhr) {
          try {
            var state = xhr.readyState;
            xhr.abort();
            return state !== XMLHttpRequest.UNSENT;
          } catch (x) {
            this._debug(x);
          }
        }
        return false;
      };
      _self.xhrStatus = function (xhr) {
        if (xhr) {
          try {
            return xhr.status;
          } catch (x) {
            this._debug(x);
          }
        }
        return -1;
      };
      return _self;
    };
    var LongPollingTransport = function () {
      var _super = new RequestTransport();
      var _self = Transport.derive(_super);
      // By default, support cross domain
      var _supportsCrossDomain = true;
      _self.accept = function (version, crossDomain, url) {
        return _supportsCrossDomain || !crossDomain;
      };
      _self.xhrSend = function (packet) {
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = true;
        xhr.open('POST', packet.url, packet.sync !== true);
        var headers = packet.headers;
        if (headers) {
          for (var headerName in headers) {
            if (headers.hasOwnProperty(headerName)) {
              xhr.setRequestHeader(headerName, headers[headerName]);
            }
          }
        }
        xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
        xhr.onload = function () {
          if (xhr.status === 200) {
            packet.onSuccess(xhr.responseText);
          } else {
            packet.onError(xhr.statusText);
          }
        };
        xhr.onerror = function () {
          packet.onError(xhr.statusText);
        };
        xhr.send(packet.body);
        return xhr;
      };
      _self.transportSend = function (envelope, request) {
        this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelope);
        var self = this;
        try {
          var sameStack = true;
          request.xhr = this.xhrSend({
            transport: this,
            url: envelope.url,
            sync: envelope.sync,
            headers: this.getConfiguration().requestHeaders,
            body: JSON.stringify(envelope.messages),
            onSuccess: function (response) {
              self._debug('Transport', self.getType(), 'received response', response);
              var success = false;
              try {
                var received = self.convertToMessages(response);
                if (received.length === 0) {
                  _supportsCrossDomain = false;
                  self.transportFailure(envelope, request, { httpCode: 204 });
                } else {
                  success = true;
                  self.transportSuccess(envelope, request, received);
                }
              } catch (x) {
                self._debug(x);
                if (!success) {
                  _supportsCrossDomain = false;
                  var failure = { exception: x };
                  failure.httpCode = self.xhrStatus(request.xhr);
                  self.transportFailure(envelope, request, failure);
                }
              }
            },
            onError: function (reason, exception) {
              self._debug('Transport', self.getType(), 'received error', reason, exception);
              _supportsCrossDomain = false;
              var failure = {
                reason: reason,
                exception: exception
              };
              failure.httpCode = self.xhrStatus(request.xhr);
              if (sameStack) {
                // Keep the semantic of calling response callbacks asynchronously after the request
                self.setTimeout(function () {
                  self.transportFailure(envelope, request, failure);
                }, 0);
              } else {
                self.transportFailure(envelope, request, failure);
              }
            }
          });
          sameStack = false;
        } catch (x) {
          _supportsCrossDomain = false;
          this.setTimeout(function () {
            self.transportFailure(envelope, request, { exception: x });
          }, 0);
        }
      };
      _self.reset = function (init) {
        _super.reset(init);
        _supportsCrossDomain = true;
      };
      return _self;
    };
    // var CallbackPollingTransport = function() {
    //     var _super = new RequestTransport();
    //     var _self = Transport.derive(_super);
    //     var _maxLength = 5000; //PATCHED
    //     var jsonp = 0;
    //
    //     _self.accept = function(version, crossDomain, url) {
    //         return true;
    //     };
    //
    //     _self.jsonpSend = function(packet) {
    //         var head = document.getElementsByTagName('head')[0];
    //         var script = document.createElement('script');
    //
    //         var callbackName = '_cometd_jsonp_' + jsonp++;
    //         window[callbackName] = function(responseText) {
    //             head.removeChild(script);
    //             delete window[callbackName];
    //             packet.onSuccess(responseText);
    //         };
    //
    //         var url = packet.url;
    //         url += url.indexOf('?') < 0 ? '?' : '&';
    //         url += 'jsonp=' + callbackName;
    //         url += '&message=' + packet.body;
    //         script.src = url;
    //         script.async = packet.sync !== true;
    //         script.type = 'application/javascript';
    //         script.onerror = function(e) {
    //             packet.onError('jsonp ' + e.type);
    //         };
    //         head.appendChild(script);
    //     };
    //
    //     function _failTransportFn(envelope, request, x) {
    //         var self = this;
    //         return function() {
    //             self.transportFailure(envelope, request, 'error', x);
    //         };
    //     }
    //
    //     _self.transportSend = function(envelope, request) {
    //         var self = this;
    //
    //         // Microsoft Internet Explorer has a 2083 URL max length
    //         // We must ensure that we stay within that length
    //         var start = 0;
    //         var length = envelope.messages.length;
    //         var lengths = [];
    //         while (length > 0) {
    //             // Encode the messages because all brackets, quotes, commas, colons, etc
    //             // present in the JSON will be URL encoded, taking many more characters
    //             var json = JSON.stringify(envelope.messages.slice(start, start + length));
    //             var urlLength = envelope.url.length + encodeURI(json).length;
    //
    //             if (urlLength > _maxLength) { // PATCHED
    //                 if (length === 1) {
    //                     var x = 'Bayeux message too big (' + urlLength + ' bytes, max is ' + maxLength + ') ' +
    //                         'for transport ' + this.getType();
    //                     // Keep the semantic of calling response callbacks asynchronously after the request
    //                     this.setTimeout(_failTransportFn.call(this, envelope, request, x), 0);
    //                     return;
    //                 }
    //
    //                 --length;
    //                 continue;
    //             }
    //
    //             lengths.push(length);
    //             start += length;
    //             length = envelope.messages.length - start;
    //         }
    //
    //         // Here we are sure that the messages can be sent within the URL limit
    //
    //         var envelopeToSend = envelope;
    //         if (lengths.length > 1) {
    //             var begin = 0;
    //             var end = lengths[0];
    //             this._debug('Transport', this.getType(), 'split', envelope.messages.length, 'messages into', lengths.join(' + '));
    //             envelopeToSend = this._mixin(false, {}, envelope);
    //             envelopeToSend.messages = envelope.messages.slice(begin, end);
    //             envelopeToSend.onSuccess = envelope.onSuccess;
    //             envelopeToSend.onFailure = envelope.onFailure;
    //
    //             for (var i = 1; i < lengths.length; ++i) {
    //                 var nextEnvelope = this._mixin(false, {}, envelope);
    //                 begin = end;
    //                 end += lengths[i];
    //                 nextEnvelope.messages = envelope.messages.slice(begin, end);
    //                 nextEnvelope.onSuccess = envelope.onSuccess;
    //                 nextEnvelope.onFailure = envelope.onFailure;
    //                 this.send(nextEnvelope, request.metaConnect);
    //             }
    //         }
    //
    //         this._debug('Transport', this.getType(), 'sending request', request.id, 'envelope', envelopeToSend);
    //
    //         try {
    //             var sameStack = true;
    //             this.jsonpSend({
    //                 transport: this,
    //                 url: envelopeToSend.url,
    //                 sync: envelopeToSend.sync,
    //                 headers: this.getConfiguration().requestHeaders,
    //                 body: JSON.stringify(envelopeToSend.messages),
    //                 onSuccess: function(responses) {
    //                     var success = false;
    //                     try {
    //                         var received = self.convertToMessages(responses);
    //                         if (received.length === 0) {
    //                             self.transportFailure(envelopeToSend, request, {
    //                                 httpCode: 204
    //                             });
    //                         } else {
    //                             success = true;
    //                             self.transportSuccess(envelopeToSend, request, received);
    //                         }
    //                     } catch (x) {
    //                         self._debug(x);
    //                         if (!success) {
    //                             self.transportFailure(envelopeToSend, request, {
    //                                 exception: x
    //                             });
    //                         }
    //                     }
    //                 },
    //                 onError: function(reason, exception) {
    //                     var failure = {
    //                         reason: reason,
    //                         exception: exception
    //                     };
    //                     if (sameStack) {
    //                         // Keep the semantic of calling response callbacks asynchronously after the request
    //                         self.setTimeout(function() {
    //                             self.transportFailure(envelopeToSend, request, failure);
    //                         }, 0);
    //                     } else {
    //                         self.transportFailure(envelopeToSend, request, failure);
    //                     }
    //                 }
    //             });
    //             sameStack = false;
    //         } catch (xx) {
    //             // Keep the semantic of calling response callbacks asynchronously after the request
    //             this.setTimeout(function() {
    //                 self.transportFailure(envelopeToSend, request, {
    //                     exception: xx
    //                 });
    //             }, 0);
    //         }
    //     };
    //
    //     return _self;
    // };
    var WebSocketTransport = function () {
      var _super = new Transport();
      var _self = Transport.derive(_super);
      var _cometd;
      // By default WebSocket is supported
      var _webSocketSupported = true;
      // Whether we were able to establish a WebSocket connection
      var _webSocketConnected = false;
      var _stickyReconnect = true;
      // The context contains the envelopes that have been sent
      // and the timeouts for the messages that have been sent.
      var _context = null;
      var _connecting = null;
      var _connected = false;
      var _successCallback = null;
      _self.reset = function (init) {
        _super.reset(init);
        _webSocketSupported = true;
        if (init) {
          _webSocketConnected = false;
        }
        _stickyReconnect = true;
        _context = null;
        _connecting = null;
        _connected = false;
      };
      function _forceClose(context, event) {
        if (context) {
          this.webSocketClose(context, event.code, event.reason);
          // Force immediate failure of pending messages to trigger reconnect.
          // This is needed because the server may not reply to our close()
          // and therefore the onclose function is never called.
          this.onClose(context, event);
        }
      }
      function _sameContext(context) {
        return context === _connecting || context === _context;
      }
      function _storeEnvelope(context, envelope, metaConnect) {
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
          var message = envelope.messages[i];
          if (message.id) {
            messageIds.push(message.id);
          }
        }
        context.envelopes[messageIds.join(',')] = [
          envelope,
          metaConnect
        ];
        this._debug('Transport', this.getType(), 'stored envelope, envelopes', context.envelopes);
      }
      function _websocketConnect(context) {
        // We may have multiple attempts to open a WebSocket
        // connection, for example a /meta/connect request that
        // may take time, along with a user-triggered publish.
        // Early return if we are already connecting.
        if (_connecting) {
          return;
        }
        // Mangle the URL, changing the scheme from 'http' to 'ws'.
        var url = _cometd.getURL().replace(/^http/, 'ws');
        this._debug('Transport', this.getType(), 'connecting to URL', url);
        try {
          var protocol = _cometd.getConfiguration().protocol;
          context.webSocket = protocol ? new window.WebSocket(url, protocol) : new window.WebSocket(url);
          _connecting = context;
        } catch (x) {
          _webSocketSupported = false;
          this._debug('Exception while creating WebSocket object', x);
          throw x;
        }
        // By default use sticky reconnects.
        _stickyReconnect = _cometd.getConfiguration().stickyReconnect !== false;
        var self = this;
        var connectTimeout = _cometd.getConfiguration().connectTimeout;
        if (connectTimeout > 0) {
          context.connectTimer = this.setTimeout(function () {
            _cometd._debug('Transport', self.getType(), 'timed out while connecting to URL', url, ':', connectTimeout, 'ms');
            // The connection was not opened, close anyway.
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Connect Timeout'
            });
          }, connectTimeout);
        }
        var onopen = function () {
          _cometd._debug('WebSocket onopen', context);
          if (context.connectTimer) {
            self.clearTimeout(context.connectTimer);
          }
          if (_sameContext(context)) {
            _connecting = null;
            _context = context;
            _webSocketConnected = true;
            self.onOpen(context);
          } else {
            // We have a valid connection already, close this one.
            _cometd._warn('Closing extra WebSocket connection', this, 'active connection', _context);
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Extra Connection'
            });
          }
        };
        // This callback is invoked when the server sends the close frame.
        // The close frame for a connection may arrive *after* another
        // connection has been opened, so we must make sure that actions
        // are performed only if it's the same connection.
        var onclose = function (event) {
          event = event || { code: 1000 };
          _cometd._debug('WebSocket onclose', context, event, 'connecting', _connecting, 'current', _context);
          if (context.connectTimer) {
            self.clearTimeout(context.connectTimer);
          }
          self.onClose(context, event);
        };
        var onmessage = function (wsMessage) {
          _cometd._debug('WebSocket onmessage', wsMessage, context);
          self.onMessage(context, wsMessage);
        };
        context.webSocket.onopen = onopen;
        context.webSocket.onclose = onclose;
        context.webSocket.onerror = function () {
          // Clients should call onclose(), but if they do not we do it here for safety.
          onclose({
            code: 1000,
            reason: 'Error'
          });
        };
        context.webSocket.onmessage = onmessage;
        this._debug('Transport', this.getType(), 'configured callbacks on', context);
      }
      function _webSocketSend(context, envelope, metaConnect) {
        var json = JSON.stringify(envelope.messages);
        context.webSocket.send(json);
        this._debug('Transport', this.getType(), 'sent', envelope, 'metaConnect =', metaConnect);
        // Manage the timeout waiting for the response.
        var maxDelay = this.getConfiguration().maxNetworkDelay;
        var delay = maxDelay;
        if (metaConnect) {
          delay += this.getAdvice().timeout;
          _connected = true;
        }
        var self = this;
        var messageIds = [];
        for (var i = 0; i < envelope.messages.length; ++i) {
          (function () {
            var message = envelope.messages[i];
            if (message.id) {
              messageIds.push(message.id);
              context.timeouts[message.id] = self.setTimeout(function () {
                _cometd._debug('Transport', self.getType(), 'timing out message', message.id, 'after', delay, 'on', context);
                _forceClose.call(self, context, {
                  code: 1000,
                  reason: 'Message Timeout'
                });
              }, delay);
            }
          }());
        }
        this._debug('Transport', this.getType(), 'waiting at most', delay, 'ms for messages', messageIds, 'maxNetworkDelay', maxDelay, ', timeouts:', context.timeouts);
      }
      _self._notifySuccess = function (fn, messages) {
        fn.call(this, messages);
      };
      _self._notifyFailure = function (fn, context, messages, failure) {
        fn.call(this, context, messages, failure);
      };
      function _send(context, envelope, metaConnect) {
        try {
          if (context === null) {
            context = _connecting || {
              envelopes: {},
              timeouts: {}
            };
            _storeEnvelope.call(this, context, envelope, metaConnect);
            _websocketConnect.call(this, context);
          } else {
            _storeEnvelope.call(this, context, envelope, metaConnect);
            _webSocketSend.call(this, context, envelope, metaConnect);
          }
        } catch (x) {
          var self = this;
          this.setTimeout(function () {
            _forceClose.call(self, context, {
              code: 1000,
              reason: 'Exception',
              exception: x
            });
          }, 0);
        }
      }
      _self.onOpen = function (context) {
        var envelopes = context.envelopes;
        this._debug('Transport', this.getType(), 'opened', context, 'pending messages', envelopes);
        for (var key in envelopes) {
          if (envelopes.hasOwnProperty(key)) {
            var element = envelopes[key];
            var envelope = element[0];
            var metaConnect = element[1];
            // Store the success callback, which is independent from the envelope,
            // so that it can be used to notify arrival of messages.
            _successCallback = envelope.onSuccess;
            _webSocketSend.call(this, context, envelope, metaConnect);
          }
        }
      };
      _self.onMessage = function (context, wsMessage) {
        this._debug('Transport', this.getType(), 'received websocket message', wsMessage, context);
        var close = false;
        var messages = this.convertToMessages(wsMessage.data);
        var messageIds = [];
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          // Detect if the message is a response to a request we made.
          // If it's a meta message, for sure it's a response; otherwise it's
          // a publish message and publish responses don't have the data field.
          if (/^\/meta\//.test(message.channel) || message.data === undefined) {
            if (message.id) {
              messageIds.push(message.id);
              var timeout = context.timeouts[message.id];
              if (timeout) {
                this.clearTimeout(timeout);
                delete context.timeouts[message.id];
                this._debug('Transport', this.getType(), 'removed timeout for message', message.id, ', timeouts', context.timeouts);
              }
            }
          }
          if ('/meta/connect' === message.channel) {
            _connected = false;
          }
          if ('/meta/disconnect' === message.channel && !_connected) {
            close = true;
          }
        }
        // Remove the envelope corresponding to the messages.
        var removed = false;
        var envelopes = context.envelopes;
        for (var j = 0; j < messageIds.length; ++j) {
          var id = messageIds[j];
          for (var key in envelopes) {
            if (envelopes.hasOwnProperty(key)) {
              var ids = key.split(',');
              var index = Utils.inArray(id, ids);
              if (index >= 0) {
                removed = true;
                ids.splice(index, 1);
                var envelope = envelopes[key][0];
                var metaConnect = envelopes[key][1];
                delete envelopes[key];
                if (ids.length > 0) {
                  envelopes[ids.join(',')] = [
                    envelope,
                    metaConnect
                  ];
                }
                break;
              }
            }
          }
        }
        if (removed) {
          this._debug('Transport', this.getType(), 'removed envelope, envelopes', envelopes);
        }
        this._notifySuccess(_successCallback, messages);
        if (close) {
          this.webSocketClose(context, 1000, 'Disconnect');
        }
      };
      _self.onClose = function (context, event) {
        this._debug('Transport', this.getType(), 'closed', context, event);
        if (_sameContext(context)) {
          // Remember if we were able to connect.
          // This close event could be due to server shutdown,
          // and if it restarts we want to try websocket again.
          _webSocketSupported = _stickyReconnect && _webSocketConnected;
          _connecting = null;
          _context = null;
        }
        var timeouts = context.timeouts;
        context.timeouts = {};
        for (var id in timeouts) {
          if (timeouts.hasOwnProperty(id)) {
            this.clearTimeout(timeouts[id]);
          }
        }
        var envelopes = context.envelopes;
        context.envelopes = {};
        for (var key in envelopes) {
          if (envelopes.hasOwnProperty(key)) {
            var envelope = envelopes[key][0];
            var metaConnect = envelopes[key][1];
            if (metaConnect) {
              _connected = false;
            }
            var failure = {
              websocketCode: event.code,
              reason: event.reason
            };
            if (event.exception) {
              failure.exception = event.exception;
            }
            this._notifyFailure(envelope.onFailure, context, envelope.messages, failure);
          }
        }
      };
      _self.registered = function (type, cometd) {
        _super.registered(type, cometd);
        _cometd = cometd;
      };
      _self.accept = function (version, crossDomain, url) {
        this._debug('Transport', this.getType(), 'accept, supported:', _webSocketSupported);
        // Using !! to return a boolean (and not the WebSocket object).
        return _webSocketSupported && !!window.WebSocket && _cometd.websocketEnabled !== false;
      };
      _self.send = function (envelope, metaConnect) {
        this._debug('Transport', this.getType(), 'sending', envelope, 'metaConnect =', metaConnect);
        _send.call(this, _context, envelope, metaConnect);
      };
      _self.webSocketClose = function (context, code, reason) {
        try {
          if (context.webSocket) {
            context.webSocket.close(code, reason);
          }
        } catch (x) {
          this._debug(x);
        }
      };
      _self.abort = function () {
        _super.abort();
        _forceClose.call(this, _context, {
          code: 1000,
          reason: 'Abort'
        });
        this.reset(true);
      };
      return _self;
    };
    /**
     * The constructor for a CometD object, identified by an optional name.
     * The default name is the string 'default'.
     * @param name the optional name of this cometd object
     */
    var CometD = function (name) {
      var _cometd = this;
      var _name = name || 'default';
      var _crossDomain = false;
      var _transports = new TransportRegistry();
      var _transport;
      var _status = 'disconnected';
      var _messageId = 0;
      var _clientId = null;
      var _batch = 0;
      var _messageQueue = [];
      var _internalBatch = false;
      var _listenerId = 0;
      var _listeners = {};
      var _backoff = 0;
      var _scheduledSend = null;
      var _extensions = [];
      var _advice = {};
      var _handshakeProps;
      var _handshakeCallback;
      var _callbacks = {};
      var _remoteCalls = {};
      var _reestablish = false;
      var _connected = false;
      var _unconnectTime = 0;
      var _handshakeMessages = 0;
      var _config = {
        protocol: null,
        stickyReconnect: true,
        connectTimeout: 0,
        maxConnections: 2,
        backoffIncrement: 1000,
        maxBackoff: 60000,
        logLevel: 'info',
        reverseIncomingExtensions: true,
        maxNetworkDelay: 10000,
        requestHeaders: {},
        appendMessageTypeToURL: true,
        autoBatch: false,
        urls: {},
        maxURILength: 2000,
        advice: {
          timeout: 60000,
          interval: 0,
          reconnect: undefined,
          maxInterval: 0
        }
      };
      function _fieldValue(object, name) {
        try {
          return object[name];
        } catch (x) {
          return undefined;
        }
      }
      /**
       * Mixes in the given objects into the target object by copying the properties.
       * @param deep if the copy must be deep
       * @param target the target object
       * @param objects the objects whose properties are copied into the target
       */
      this._mixin = function (deep, target, objects) {
        var result = target || {};
        // Skip first 2 parameters (deep and target), and loop over the others
        for (var i = 2; i < arguments.length; ++i) {
          var object = arguments[i];
          if (object === undefined || object === null) {
            continue;
          }
          for (var propName in object) {
            if (object.hasOwnProperty(propName)) {
              var prop = _fieldValue(object, propName);
              var targ = _fieldValue(result, propName);
              // Avoid infinite loops
              if (prop === target) {
                continue;
              }
              // Do not mixin undefined values
              if (prop === undefined) {
                continue;
              }
              if (deep && typeof prop === 'object' && prop !== null) {
                if (prop instanceof Array) {
                  result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop);
                } else {
                  var source = typeof targ === 'object' && !(targ instanceof Array) ? targ : {};
                  result[propName] = this._mixin(deep, source, prop);
                }
              } else {
                result[propName] = prop;
              }
            }
          }
        }
        return result;
      };
      function _isString(value) {
        return Utils.isString(value);
      }
      function _isFunction(value) {
        if (value === undefined || value === null) {
          return false;
        }
        return typeof value === 'function';
      }
      function _zeroPad(value, length) {
        var result = '';
        while (--length > 0) {
          if (value >= Math.pow(10, length)) {
            break;
          }
          result += '0';
        }
        result += value;
        return result;
      }
      function _log(level, args) {
        if (window.console) {
          var logger = window.console[level];
          if (_isFunction(logger)) {
            var now = new Date();
            [].splice.call(args, 0, 0, _zeroPad(now.getHours(), 2) + ':' + _zeroPad(now.getMinutes(), 2) + ':' + _zeroPad(now.getSeconds(), 2) + '.' + _zeroPad(now.getMilliseconds(), 3));
            logger.apply(window.console, args);
          }
        }
      }
      this._warn = function () {
        _log('warn', arguments);
      };
      this._info = function () {
        if (_config.logLevel !== 'warn') {
          _log('info', arguments);
        }
      };
      this._debug = function () {
        if (_config.logLevel === 'debug') {
          _log('debug', arguments);
        }
      };
      function _splitURL(url) {
        // [1] = protocol://,
        // [2] = host:port,
        // [3] = host,
        // [4] = IPv6_host,
        // [5] = IPv4_host,
        // [6] = :port,
        // [7] = port,
        // [8] = uri,
        // [9] = rest (query / fragment)
        return /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url);
      }
      /**
       * Returns whether the given hostAndPort is cross domain.
       * The default implementation checks against window.location.host
       * but this function can be overridden to make it work in non-browser
       * environments.
       *
       * @param hostAndPort the host and port in format host:port
       * @return whether the given hostAndPort is cross domain
       */
      this._isCrossDomain = function (hostAndPort) {
        return hostAndPort && hostAndPort !== window.location.host;
      };
      function _configure(configuration) {
        _cometd._debug('Configuring cometd object with', configuration);
        // Support old style param, where only the Bayeux server URL was passed
        if (_isString(configuration)) {
          configuration = { url: configuration };
        }
        if (!configuration) {
          configuration = {};
        }
        _config = _cometd._mixin(false, _config, configuration);
        var url = _cometd.getURL();
        if (!url) {
          throw 'Missing required configuration parameter \'url\' specifying the Bayeux server URL';
        }
        // Check if we're cross domain.
        var urlParts = _splitURL(url);
        var hostAndPort = urlParts[2];
        var uri = urlParts[8];
        var afterURI = urlParts[9];
        _crossDomain = _cometd._isCrossDomain(hostAndPort);
        // Check if appending extra path is supported
        if (_config.appendMessageTypeToURL) {
          if (afterURI !== undefined && afterURI.length > 0) {
            _cometd._info('Appending message type to URI ' + uri + afterURI + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
            _config.appendMessageTypeToURL = false;
          } else {
            var uriSegments = uri.split('/');
            var lastSegmentIndex = uriSegments.length - 1;
            if (uri.match(/\/$/)) {
              lastSegmentIndex -= 1;
            }
            if (uriSegments[lastSegmentIndex].indexOf('.') >= 0) {
              // Very likely the CometD servlet's URL pattern is mapped to an extension, such as *.cometd
              // It will be difficult to add the extra path in this case
              _cometd._info('Appending message type to URI ' + uri + ' is not supported, disabling \'appendMessageTypeToURL\' configuration');
              _config.appendMessageTypeToURL = false;
            }
          }
        }
      }
      function _removeListener(subscription) {
        if (subscription) {
          var subscriptions = _listeners[subscription.channel];
          if (subscriptions && subscriptions[subscription.id]) {
            delete subscriptions[subscription.id];
            _cometd._debug('Removed', subscription.listener ? 'listener' : 'subscription', subscription);
          }
        }
      }
      function _removeSubscription(subscription) {
        if (subscription && !subscription.listener) {
          _removeListener(subscription);
        }
      }
      function _clearSubscriptions() {
        for (var channel in _listeners) {
          if (_listeners.hasOwnProperty(channel)) {
            var subscriptions = _listeners[channel];
            if (subscriptions) {
              for (var id in subscriptions) {
                if (subscriptions.hasOwnProperty(id)) {
                  _removeSubscription(subscriptions[id]);
                }
              }
            }
          }
        }
      }
      function _setStatus(newStatus) {
        if (_status !== newStatus) {
          _cometd._debug('Status', _status, '->', newStatus);
          _status = newStatus;
        }
      }
      function _isDisconnected() {
        return _status === 'disconnecting' || _status === 'disconnected';
      }
      function _nextMessageId() {
        var result = ++_messageId;
        return '' + result;
      }
      function _applyExtension(scope, callback, name, message, outgoing) {
        try {
          return callback.call(scope, message);
        } catch (x) {
          var handler = _cometd.onExtensionException;
          if (_isFunction(handler)) {
            _cometd._debug('Invoking extension exception handler', name, x);
            try {
              handler.call(_cometd, x, name, outgoing, message);
            } catch (xx) {
              _cometd._info('Exception during execution of extension exception handler', name, xx);
            }
          } else {
            _cometd._info('Exception during execution of extension', name, x);
          }
          return message;
        }
      }
      function _applyIncomingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
          if (message === undefined || message === null) {
            break;
          }
          var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i;
          var extension = _extensions[index];
          var callback = extension.extension.incoming;
          if (_isFunction(callback)) {
            var result = _applyExtension(extension.extension, callback, extension.name, message, false);
            message = result === undefined ? message : result;
          }
        }
        return message;
      }
      function _applyOutgoingExtensions(message) {
        for (var i = 0; i < _extensions.length; ++i) {
          if (message === undefined || message === null) {
            break;
          }
          var extension = _extensions[i];
          var callback = extension.extension.outgoing;
          if (_isFunction(callback)) {
            var result = _applyExtension(extension.extension, callback, extension.name, message, true);
            message = result === undefined ? message : result;
          }
        }
        return message;
      }
      function _notify(channel, message) {
        var subscriptions = _listeners[channel];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              var subscription = subscriptions[id];
              // Subscriptions may come and go, so the array may have 'holes'
              if (subscription) {
                try {
                  subscription.callback.call(subscription.scope, message);
                } catch (x) {
                  var handler = _cometd.onListenerException;
                  if (_isFunction(handler)) {
                    _cometd._debug('Invoking listener exception handler', subscription, x);
                    try {
                      handler.call(_cometd, x, subscription, subscription.listener, message);
                    } catch (xx) {
                      _cometd._info('Exception during execution of listener exception handler', subscription, xx);
                    }
                  } else {
                    _cometd._info('Exception during execution of listener', subscription, message, x);
                  }
                }
              }
            }
          }
        }
      }
      function _notifyListeners(channel, message) {
        // Notify direct listeners
        _notify(channel, message);
        // Notify the globbing listeners
        var channelParts = channel.split('/');
        var last = channelParts.length - 1;
        for (var i = last; i > 0; --i) {
          var channelPart = channelParts.slice(0, i).join('/') + '/*';
          // We don't want to notify /foo/* if the channel is /foo/bar/baz,
          // so we stop at the first non recursive globbing
          if (i === last) {
            _notify(channelPart, message);
          }
          // Add the recursive globber and notify
          channelPart += '*';
          _notify(channelPart, message);
        }
      }
      function _cancelDelayedSend() {
        if (_scheduledSend !== null) {
          Utils.clearTimeout(_scheduledSend);
        }
        _scheduledSend = null;
      }
      function _delayedSend(operation, delay) {
        _cancelDelayedSend();
        var time = _advice.interval + delay;
        _cometd._debug('Function scheduled in', time, 'ms, interval =', _advice.interval, 'backoff =', _backoff, operation);
        _scheduledSend = Utils.setTimeout(_cometd, operation, time);
      }
      // Needed to break cyclic dependencies between function definitions
      var _handleMessages;
      var _handleFailure;
      /**
       * Delivers the messages to the CometD server
       * @param sync whether the send is synchronous
       * @param messages the array of messages to send
       * @param metaConnect true if this send is on /meta/connect
       * @param extraPath an extra path to append to the Bayeux server URL
       */
      function _send(sync, messages, metaConnect, extraPath) {
        // We must be sure that the messages have a clientId.
        // This is not guaranteed since the handshake may take time to return
        // (and hence the clientId is not known yet) and the application
        // may create other messages.
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          var messageId = message.id;
          if (_clientId) {
            message.clientId = _clientId;
          }
          message = _applyOutgoingExtensions(message);
          if (message !== undefined && message !== null) {
            // Extensions may have modified the message id, but we need to own it.
            message.id = messageId;
            messages[i] = message;
          } else {
            delete _callbacks[messageId];
            messages.splice(i--, 1);
          }
        }
        if (messages.length === 0) {
          return;
        }
        var url = _cometd.getURL();
        if (_config.appendMessageTypeToURL) {
          // If url does not end with '/', then append it
          if (!url.match(/\/$/)) {
            url = url + '/';
          }
          if (extraPath) {
            url = url + extraPath;
          }
        }
        var envelope = {
          url: url,
          sync: sync,
          messages: messages,
          onSuccess: function (rcvdMessages) {
            try {
              _handleMessages.call(_cometd, rcvdMessages);
            } catch (x) {
              _cometd._info('Exception during handling of messages', x);
            }
          },
          onFailure: function (conduit, messages, failure) {
            try {
              var transport = _cometd.getTransport();
              failure.connectionType = transport ? transport.getType() : 'unknown';
              _handleFailure.call(_cometd, conduit, messages, failure);
            } catch (x) {
              _cometd._info('Exception during handling of failure', x);
            }
          }
        };
        _cometd._debug('Send', envelope);
        _transport.send(envelope, metaConnect);
      }
      function _queueSend(message) {
        if (_batch > 0 || _internalBatch === true) {
          _messageQueue.push(message);
        } else {
          _send(false, [message], false);
        }
      }
      /**
       * Sends a complete bayeux message.
       * This method is exposed as a public so that extensions may use it
       * to send bayeux message directly, for example in case of re-sending
       * messages that have already been sent but that for some reason must
       * be resent.
       */
      this.send = _queueSend;
      function _resetBackoff() {
        _backoff = 0;
      }
      function _increaseBackoff() {
        if (_backoff < _config.maxBackoff) {
          _backoff += _config.backoffIncrement;
        }
        return _backoff;
      }
      /**
       * Starts a the batch of messages to be sent in a single request.
       * @see #_endBatch(sendMessages)
       */
      function _startBatch() {
        ++_batch;
        _cometd._debug('Starting batch, depth', _batch);
      }
      function _flushBatch() {
        var messages = _messageQueue;
        _messageQueue = [];
        if (messages.length > 0) {
          _send(false, messages, false);
        }
      }
      /**
       * Ends the batch of messages to be sent in a single request,
       * optionally sending messages present in the message queue depending
       * on the given argument.
       * @see #_startBatch()
       */
      function _endBatch() {
        --_batch;
        _cometd._debug('Ending batch, depth', _batch);
        if (_batch < 0) {
          throw 'Calls to startBatch() and endBatch() are not paired';
        }
        if (_batch === 0 && !_isDisconnected() && !_internalBatch) {
          _flushBatch();
        }
      }
      /**
       * Sends the connect message
       */
      function _connect() {
        if (!_isDisconnected()) {
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/connect',
            connectionType: _transport.getType()
          };
          // In case of reload or temporary loss of connection
          // we want the next successful connect to return immediately
          // instead of being held by the server, so that connect listeners
          // can be notified that the connection has been re-established
          if (!_connected) {
            bayeuxMessage.advice = { timeout: 0 };
          }
          _setStatus('connecting');
          _cometd._debug('Connect sent', bayeuxMessage);
          _send(false, [bayeuxMessage], true, 'connect');
          _setStatus('connected');
        }
      }
      function _delayedConnect(delay) {
        _setStatus('connecting');
        _delayedSend(function () {
          _connect();
        }, delay);
      }
      function _updateAdvice(newAdvice) {
        if (newAdvice) {
          _advice = _cometd._mixin(false, {}, _config.advice, newAdvice);
          _cometd._debug('New advice', _advice);
        }
      }
      function _disconnect(abort) {
        _cancelDelayedSend();
        if (abort && _transport) {
          _transport.abort();
        }
        _clientId = null;
        _setStatus('disconnected');
        _batch = 0;
        _resetBackoff();
        _transport = null;
        _reestablish = false;
        _connected = false;
        // Fail any existing queued message
        if (_messageQueue.length > 0) {
          var messages = _messageQueue;
          _messageQueue = [];
          _handleFailure.call(_cometd, undefined, messages, { reason: 'Disconnected' });
        }
      }
      function _notifyTransportException(oldTransport, newTransport, failure) {
        var handler = _cometd.onTransportException;
        if (_isFunction(handler)) {
          _cometd._debug('Invoking transport exception handler', oldTransport, newTransport, failure);
          try {
            handler.call(_cometd, failure, oldTransport, newTransport);
          } catch (x) {
            _cometd._info('Exception during execution of transport exception handler', x);
          }
        }
      }
      /**
       * Sends the initial handshake message
       */
      function _handshake(handshakeProps, handshakeCallback) {
        if (_isFunction(handshakeProps)) {
          handshakeCallback = handshakeProps;
          handshakeProps = undefined;
        }
        _clientId = null;
        _clearSubscriptions();
        // Reset the transports if we're not retrying the handshake
        if (_isDisconnected()) {
          _transports.reset(true);
          _updateAdvice(_config.advice);
        }
        _batch = 0;
        // Mark the start of an internal batch.
        // This is needed because handshake and connect are async.
        // It may happen that the application calls init() then subscribe()
        // and the subscribe message is sent before the connect message, if
        // the subscribe message is not held until the connect message is sent.
        // So here we start a batch to hold temporarily any message until
        // the connection is fully established.
        _internalBatch = true;
        // Save the properties provided by the user, so that
        // we can reuse them during automatic re-handshake
        _handshakeProps = handshakeProps;
        _handshakeCallback = handshakeCallback;
        var version = '1.0';
        // Figure out the transports to send to the server
        var url = _cometd.getURL();
        var transportTypes = _transports.findTransportTypes(version, _crossDomain, url);
        var bayeuxMessage = {
          id: _nextMessageId(),
          version: version,
          minimumVersion: version,
          channel: '/meta/handshake',
          supportedConnectionTypes: transportTypes,
          advice: {
            timeout: _advice.timeout,
            interval: _advice.interval
          }
        };
        // Do not allow the user to override important fields.
        var message = _cometd._mixin(false, {}, _handshakeProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, handshakeCallback);
        // Pick up the first available transport as initial transport
        // since we don't know if the server supports it
        if (!_transport) {
          _transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url);
          if (!_transport) {
            var failure = 'Could not find initial transport among: ' + _transports.getTransportTypes();
            _cometd._warn(failure);
            throw failure;
          }
        }
        _cometd._debug('Initial transport is', _transport.getType());
        // We started a batch to hold the application messages,
        // so here we must bypass it and send immediately.
        _setStatus('handshaking');
        _cometd._debug('Handshake sent', message);
        _send(false, [message], false, 'handshake');
      }
      function _delayedHandshake(delay) {
        _setStatus('handshaking');
        // We will call _handshake() which will reset _clientId, but we want to avoid
        // that between the end of this method and the call to _handshake() someone may
        // call publish() (or other methods that call _queueSend()).
        _internalBatch = true;
        _delayedSend(function () {
          _handshake(_handshakeProps, _handshakeCallback);
        }, delay);
      }
      function _notifyCallback(callback, message) {
        try {
          callback.call(_cometd, message);
        } catch (x) {
          var handler = _cometd.onCallbackException;
          if (_isFunction(handler)) {
            _cometd._debug('Invoking callback exception handler', x);
            try {
              handler.call(_cometd, x, message);
            } catch (xx) {
              _cometd._info('Exception during execution of callback exception handler', xx);
            }
          } else {
            _cometd._info('Exception during execution of message callback', x);
          }
        }
      }
      this._getCallback = function (messageId) {
        return _callbacks[messageId];
      };
      this._putCallback = function (messageId, callback) {
        var result = this._getCallback(messageId);
        if (_isFunction(callback)) {
          _callbacks[messageId] = callback;
        }
        return result;
      };
      function _handleCallback(message) {
        var callback = _cometd._getCallback([message.id]);
        if (_isFunction(callback)) {
          delete _callbacks[message.id];
          _notifyCallback(callback, message);
        }
      }
      function _handleRemoteCall(message) {
        var context = _remoteCalls[message.id];
        delete _remoteCalls[message.id];
        if (context) {
          _cometd._debug('Handling remote call response for', message, 'with context', context);
          // Clear the timeout, if present.
          var timeout = context.timeout;
          if (timeout) {
            Utils.clearTimeout(timeout);
          }
          var callback = context.callback;
          if (_isFunction(callback)) {
            _notifyCallback(callback, message);
            return true;
          }
        }
        return false;
      }
      this.onTransportFailure = function (message, failureInfo, failureHandler) {
        this._debug('Transport failure', failureInfo, 'for', message);
        var transports = this.getTransportRegistry();
        var url = this.getURL();
        var crossDomain = this._isCrossDomain(_splitURL(url)[2]);
        var version = '1.0';
        var transportTypes = transports.findTransportTypes(version, crossDomain, url);
        if (failureInfo.action === 'none') {
          if (message.channel === '/meta/handshake') {
            if (!failureInfo.transport) {
              var failure = 'Could not negotiate transport, client=[' + transportTypes + '], server=[' + message.supportedConnectionTypes + ']';
              this._warn(failure);
              _notifyTransportException(_transport.getType(), null, {
                reason: failure,
                connectionType: _transport.getType(),
                transport: _transport
              });
            }
          }
        } else {
          failureInfo.delay = this.getBackoffPeriod();
          // Different logic depending on whether we are handshaking or connecting.
          if (message.channel === '/meta/handshake') {
            if (!failureInfo.transport) {
              // The transport is invalid, try to negotiate again.
              var newTransport = transports.negotiateTransport(transportTypes, version, crossDomain, url);
              if (!newTransport) {
                this._warn('Could not negotiate transport, client=[' + transportTypes + ']');
                _notifyTransportException(_transport.getType(), null, message.failure);
                failureInfo.action = 'none';
              } else {
                this._debug('Transport', _transport.getType(), '->', newTransport.getType());
                _notifyTransportException(_transport.getType(), newTransport.getType(), message.failure);
                failureInfo.action = 'handshake';
                failureInfo.transport = newTransport;
              }
            }
            if (failureInfo.action !== 'none') {
              this.increaseBackoffPeriod();
            }
          } else {
            var now = new Date().getTime();
            if (_unconnectTime === 0) {
              _unconnectTime = now;
            }
            if (failureInfo.action === 'retry') {
              failureInfo.delay = this.increaseBackoffPeriod();
              // Check whether we may switch to handshaking.
              var maxInterval = _advice.maxInterval;
              if (maxInterval > 0) {
                var expiration = _advice.timeout + _advice.interval + maxInterval;
                var unconnected = now - _unconnectTime;
                if (unconnected + _backoff > expiration) {
                  failureInfo.action = 'handshake';
                }
              }
            }
            if (failureInfo.action === 'handshake') {
              failureInfo.delay = 0;
              transports.reset(false);
              this.resetBackoffPeriod();
            }
          }
        }
        failureHandler.call(_cometd, failureInfo);
      };
      function _handleTransportFailure(failureInfo) {
        _cometd._debug('Transport failure handling', failureInfo);
        if (failureInfo.transport) {
          _transport = failureInfo.transport;
        }
        if (failureInfo.url) {
          _transport.setURL(failureInfo.url);
        }
        var action = failureInfo.action;
        var delay = failureInfo.delay || 0;
        switch (action) {
        case 'handshake':
          _delayedHandshake(delay);
          break;
        case 'retry':
          _delayedConnect(delay);
          break;
        case 'none':
          _disconnect(true);
          break;
        default:
          throw 'Unknown action ' + action;
        }
      }
      function _failHandshake(message, failureInfo) {
        _handleCallback(message);
        _notifyListeners('/meta/handshake', message);
        _notifyListeners('/meta/unsuccessful', message);
        // The listeners may have disconnected.
        if (_isDisconnected()) {
          failureInfo.action = 'none';
        }
        _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
      }
      function _handshakeResponse(message) {
        var url = _cometd.getURL();
        if (message.successful) {
          var crossDomain = _cometd._isCrossDomain(_splitURL(url)[2]);
          var newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, crossDomain, url);
          if (newTransport === null) {
            message.successful = false;
            _failHandshake(message, {
              cause: 'negotiation',
              action: 'none',
              transport: null
            });
            return;
          } else if (_transport !== newTransport) {
            _cometd._debug('Transport', _transport.getType(), '->', newTransport.getType());
            _transport = newTransport;
          }
          _clientId = message.clientId;
          // End the internal batch and allow held messages from the application
          // to go to the server (see _handshake() where we start the internal batch).
          _internalBatch = false;
          _flushBatch();
          // Here the new transport is in place, as well as the clientId, so
          // the listeners can perform a publish() if they want.
          // Notify the listeners before the connect below.
          message.reestablish = _reestablish;
          _reestablish = true;
          _handleCallback(message);
          _notifyListeners('/meta/handshake', message);
          _handshakeMessages = message['x-messages'] || 0;
          var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
          switch (action) {
          case 'retry':
            _resetBackoff();
            if (_handshakeMessages === 0) {
              _delayedConnect(0);
            } else {
              _cometd._debug('Processing', _handshakeMessages, 'handshake-delivered messages');
            }
            break;
          case 'none':
            _disconnect(true);
            break;
          default:
            throw 'Unrecognized advice action ' + action;
          }
        } else {
          _failHandshake(message, {
            cause: 'unsuccessful',
            action: _advice.reconnect || 'handshake',
            transport: _transport
          });
        }
      }
      function _handshakeFailure(message) {
        _failHandshake(message, {
          cause: 'failure',
          action: 'handshake',
          transport: null
        });
      }
      function _failConnect(message, failureInfo) {
        // Notify the listeners after the status change but before the next action.
        _notifyListeners('/meta/connect', message);
        _notifyListeners('/meta/unsuccessful', message);
        // The listeners may have disconnected.
        if (_isDisconnected()) {
          failureInfo.action = 'none';
        }
        _cometd.onTransportFailure.call(_cometd, message, failureInfo, _handleTransportFailure);
      }
      function _connectResponse(message) {
        _connected = message.successful;
        if (_connected) {
          _notifyListeners('/meta/connect', message);
          // Normally, the advice will say "reconnect: 'retry', interval: 0"
          // and the server will hold the request, so when a response returns
          // we immediately call the server again (long polling).
          // Listeners can call disconnect(), so check the state after they run.
          var action = _isDisconnected() ? 'none' : _advice.reconnect || 'retry';
          switch (action) {
          case 'retry':
            _resetBackoff();
            _delayedConnect(_backoff);
            break;
          case 'none':
            _disconnect(false);
            break;
          default:
            throw 'Unrecognized advice action ' + action;
          }
        } else {
          _failConnect(message, {
            cause: 'unsuccessful',
            action: _advice.reconnect || 'retry',
            transport: _transport
          });
        }
      }
      function _connectFailure(message) {
        _connected = false;
        _failConnect(message, {
          cause: 'failure',
          action: 'retry',
          transport: null
        });
      }
      function _failDisconnect(message) {
        _disconnect(true);
        _handleCallback(message);
        _notifyListeners('/meta/disconnect', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _disconnectResponse(message) {
        if (message.successful) {
          // Wait for the /meta/connect to arrive.
          _disconnect(false);
          _handleCallback(message);
          _notifyListeners('/meta/disconnect', message);
        } else {
          _failDisconnect(message);
        }
      }
      function _disconnectFailure(message) {
        _failDisconnect(message);
      }
      function _failSubscribe(message) {
        var subscriptions = _listeners[message.subscription];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              var subscription = subscriptions[id];
              if (subscription && !subscription.listener) {
                delete subscriptions[id];
                _cometd._debug('Removed failed subscription', subscription);
              }
            }
          }
        }
        _handleCallback(message);
        _notifyListeners('/meta/subscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _subscribeResponse(message) {
        if (message.successful) {
          _handleCallback(message);
          _notifyListeners('/meta/subscribe', message);
        } else {
          _failSubscribe(message);
        }
      }
      function _subscribeFailure(message) {
        _failSubscribe(message);
      }
      function _failUnsubscribe(message) {
        _handleCallback(message);
        _notifyListeners('/meta/unsubscribe', message);
        _notifyListeners('/meta/unsuccessful', message);
      }
      function _unsubscribeResponse(message) {
        if (message.successful) {
          _handleCallback(message);
          _notifyListeners('/meta/unsubscribe', message);
        } else {
          _failUnsubscribe(message);
        }
      }
      function _unsubscribeFailure(message) {
        _failUnsubscribe(message);
      }
      function _failMessage(message) {
        if (!_handleRemoteCall(message)) {
          _handleCallback(message);
          _notifyListeners('/meta/publish', message);
          _notifyListeners('/meta/unsuccessful', message);
        }
      }
      function _messageResponse(message) {
        if (message.data !== undefined) {
          if (!_handleRemoteCall(message)) {
            _notifyListeners(message.channel, message);
            if (_handshakeMessages > 0) {
              --_handshakeMessages;
              if (_handshakeMessages === 0) {
                _cometd._debug('Processed last handshake-delivered message');
                _delayedConnect(0);
              }
            }
          }
        } else {
          if (message.successful === undefined) {
            _cometd._warn('Unknown Bayeux Message', message);
          } else {
            if (message.successful) {
              _handleCallback(message);
              _notifyListeners('/meta/publish', message);
            } else {
              _failMessage(message);
            }
          }
        }
      }
      function _messageFailure(failure) {
        _failMessage(failure);
      }
      function _receive(message) {
        _unconnectTime = 0;
        message = _applyIncomingExtensions(message);
        if (message === undefined || message === null) {
          return;
        }
        _updateAdvice(message.advice);
        var channel = message.channel;
        switch (channel) {
        case '/meta/handshake':
          _handshakeResponse(message);
          break;
        case '/meta/connect':
          _connectResponse(message);
          break;
        case '/meta/disconnect':
          _disconnectResponse(message);
          break;
        case '/meta/subscribe':
          _subscribeResponse(message);
          break;
        case '/meta/unsubscribe':
          _unsubscribeResponse(message);
          break;
        default:
          _messageResponse(message);
          break;
        }
      }
      /**
       * Receives a message.
       * This method is exposed as a public so that extensions may inject
       * messages simulating that they had been received.
       */
      this.receive = _receive;
      _handleMessages = function (rcvdMessages) {
        _cometd._debug('Received', rcvdMessages);
        for (var i = 0; i < rcvdMessages.length; ++i) {
          var message = rcvdMessages[i];
          _receive(message);
        }
      };
      _handleFailure = function (conduit, messages, failure) {
        _cometd._debug('handleFailure', conduit, messages, failure);
        failure.transport = conduit;
        for (var i = 0; i < messages.length; ++i) {
          var message = messages[i];
          var failureMessage = {
            id: message.id,
            successful: false,
            channel: message.channel,
            failure: failure
          };
          failure.message = message;
          switch (message.channel) {
          case '/meta/handshake':
            _handshakeFailure(failureMessage);
            break;
          case '/meta/connect':
            _connectFailure(failureMessage);
            break;
          case '/meta/disconnect':
            _disconnectFailure(failureMessage);
            break;
          case '/meta/subscribe':
            failureMessage.subscription = message.subscription;
            _subscribeFailure(failureMessage);
            break;
          case '/meta/unsubscribe':
            failureMessage.subscription = message.subscription;
            _unsubscribeFailure(failureMessage);
            break;
          default:
            _messageFailure(failureMessage);
            break;
          }
        }
      };
      function _hasSubscriptions(channel) {
        var subscriptions = _listeners[channel];
        if (subscriptions) {
          for (var id in subscriptions) {
            if (subscriptions.hasOwnProperty(id)) {
              if (subscriptions[id]) {
                return true;
              }
            }
          }
        }
        return false;
      }
      function _resolveScopedCallback(scope, callback) {
        var delegate = {
          scope: scope,
          method: callback
        };
        if (_isFunction(scope)) {
          delegate.scope = undefined;
          delegate.method = scope;
        } else {
          if (_isString(callback)) {
            if (!scope) {
              throw 'Invalid scope ' + scope;
            }
            delegate.method = scope[callback];
            if (!_isFunction(delegate.method)) {
              throw 'Invalid callback ' + callback + ' for scope ' + scope;
            }
          } else if (!_isFunction(callback)) {
            throw 'Invalid callback ' + callback;
          }
        }
        return delegate;
      }
      function _addListener(channel, scope, callback, isListener) {
        // The data structure is a map<channel, subscription[]>, where each subscription
        // holds the callback to be called and its scope.
        var delegate = _resolveScopedCallback(scope, callback);
        _cometd._debug('Adding', isListener ? 'listener' : 'subscription', 'on', channel, 'with scope', delegate.scope, 'and callback', delegate.method);
        var id = ++_listenerId;
        var subscription = {
          id: id,
          channel: channel,
          scope: delegate.scope,
          callback: delegate.method,
          listener: isListener
        };
        var subscriptions = _listeners[channel];
        if (!subscriptions) {
          subscriptions = {};
          _listeners[channel] = subscriptions;
        }
        subscriptions[id] = subscription;
        _cometd._debug('Added', isListener ? 'listener' : 'subscription', subscription);
        return subscription;
      }
      //
      // PUBLIC API
      //
      /**
       * Registers the given transport under the given transport type.
       * The optional index parameter specifies the "priority" at which the
       * transport is registered (where 0 is the max priority).
       * If a transport with the same type is already registered, this function
       * does nothing and returns false.
       * @param type the transport type
       * @param transport the transport object
       * @param index the index at which this transport is to be registered
       * @return true if the transport has been registered, false otherwise
       * @see #unregisterTransport(type)
       */
      this.registerTransport = function (type, transport, index) {
        var result = _transports.add(type, transport, index);
        if (result) {
          this._debug('Registered transport', type);
          if (_isFunction(transport.registered)) {
            transport.registered(type, this);
          }
        }
        return result;
      };
      /**
       * Unregisters the transport with the given transport type.
       * @param type the transport type to unregister
       * @return the transport that has been unregistered,
       * or null if no transport was previously registered under the given transport type
       */
      this.unregisterTransport = function (type) {
        var transport = _transports.remove(type);
        if (transport !== null) {
          this._debug('Unregistered transport', type);
          if (_isFunction(transport.unregistered)) {
            transport.unregistered();
          }
        }
        return transport;
      };
      this.unregisterTransports = function () {
        _transports.clear();
      };
      /**
       * @return an array of all registered transport types
       */
      this.getTransportTypes = function () {
        return _transports.getTransportTypes();
      };
      this.findTransport = function (name) {
        return _transports.find(name);
      };
      /**
       * @returns the TransportRegistry object
       */
      this.getTransportRegistry = function () {
        return _transports;
      };
      /**
       * Configures the initial Bayeux communication with the Bayeux server.
       * Configuration is passed via an object that must contain a mandatory field <code>url</code>
       * of type string containing the URL of the Bayeux server.
       * @param configuration the configuration object
       */
      this.configure = function (configuration) {
        _configure.call(this, configuration);
      };
      /**
       * Configures and establishes the Bayeux communication with the Bayeux server
       * via a handshake and a subsequent connect.
       * @param configuration the configuration object
       * @param handshakeProps an object to be merged with the handshake message
       * @see #configure(configuration)
       * @see #handshake(handshakeProps)
       */
      this.init = function (configuration, handshakeProps) {
        this.configure(configuration);
        this.handshake(handshakeProps);
      };
      /**
       * Establishes the Bayeux communication with the Bayeux server
       * via a handshake and a subsequent connect.
       * @param handshakeProps an object to be merged with the handshake message
       * @param handshakeCallback a function to be invoked when the handshake is acknowledged
       */
      this.handshake = function (handshakeProps, handshakeCallback) {
        if (_status !== 'disconnected') {
          throw 'Illegal state: handshaken';
        }
        _handshake(handshakeProps, handshakeCallback);
      };
      /**
       * Disconnects from the Bayeux server.
       * It is possible to suggest to attempt a synchronous disconnect, but this feature
       * may only be available in certain transports (for example, long-polling may support
       * it, callback-polling certainly does not).
       * @param sync whether attempt to perform a synchronous disconnect
       * @param disconnectProps an object to be merged with the disconnect message
       * @param disconnectCallback a function to be invoked when the disconnect is acknowledged
       */
      this.disconnect = function (sync, disconnectProps, disconnectCallback) {
        if (_isDisconnected()) {
          return;
        }
        if (typeof sync !== 'boolean') {
          disconnectCallback = disconnectProps;
          disconnectProps = sync;
          sync = false;
        }
        if (_isFunction(disconnectProps)) {
          disconnectCallback = disconnectProps;
          disconnectProps = undefined;
        }
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: '/meta/disconnect'
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, disconnectProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, disconnectCallback);
        _setStatus('disconnecting');
        _send(sync === true, [message], false, 'disconnect');
      };
      /**
       * Marks the start of a batch of application messages to be sent to the server
       * in a single request, obtaining a single response containing (possibly) many
       * application reply messages.
       * Messages are held in a queue and not sent until {@link #endBatch()} is called.
       * If startBatch() is called multiple times, then an equal number of endBatch()
       * calls must be made to close and send the batch of messages.
       * @see #endBatch()
       */
      this.startBatch = function () {
        _startBatch();
      };
      /**
       * Marks the end of a batch of application messages to be sent to the server
       * in a single request.
       * @see #startBatch()
       */
      this.endBatch = function () {
        _endBatch();
      };
      /**
       * Executes the given callback in the given scope, surrounded by a {@link #startBatch()}
       * and {@link #endBatch()} calls.
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to be executed within {@link #startBatch()} and {@link #endBatch()} calls
       */
      this.batch = function (scope, callback) {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try {
          delegate.method.call(delegate.scope);
          this.endBatch();
        } catch (x) {
          this._info('Exception during execution of batch', x);
          this.endBatch();
          throw x;
        }
      };
      /**
       * Adds a listener for bayeux messages, performing the given callback in the given scope
       * when a message for the given channel arrives.
       * @param channel the channel the listener is interested to
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to call when a message is sent to the channel
       * @returns the subscription handle to be passed to {@link #removeListener(object)}
       * @see #removeListener(subscription)
       */
      this.addListener = function (channel, scope, callback) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        return _addListener(channel, scope, callback, true);
      };
      /**
       * Removes the subscription obtained with a call to {@link #addListener(string, object, function)}.
       * @param subscription the subscription to unsubscribe.
       * @see #addListener(channel, scope, callback)
       */
      this.removeListener = function (subscription) {
        // Beware of subscription.id == 0, which is falsy => cannot use !subscription.id
        if (!subscription || !subscription.channel || !('id' in subscription)) {
          throw 'Invalid argument: expected subscription, not ' + subscription;
        }
        _removeListener(subscription);
      };
      /**
       * Removes all listeners registered with {@link #addListener(channel, scope, callback)} or
       * {@link #subscribe(channel, scope, callback)}.
       */
      this.clearListeners = function () {
        _listeners = {};
      };
      /**
       * Subscribes to the given channel, performing the given callback in the given scope
       * when a message for the channel arrives.
       * @param channel the channel to subscribe to
       * @param scope the scope of the callback, may be omitted
       * @param callback the callback to call when a message is sent to the channel
       * @param subscribeProps an object to be merged with the subscribe message
       * @param subscribeCallback a function to be invoked when the subscription is acknowledged
       * @return the subscription handle to be passed to {@link #unsubscribe(object)}
       */
      this.subscribe = function (channel, scope, callback, subscribeProps, subscribeCallback) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        // Normalize arguments
        if (_isFunction(scope)) {
          subscribeCallback = subscribeProps;
          subscribeProps = callback;
          callback = scope;
          scope = undefined;
        }
        if (_isFunction(subscribeProps)) {
          subscribeCallback = subscribeProps;
          subscribeProps = undefined;
        }
        // Only send the message to the server if this client has not yet subscribed to the channel
        var send = !_hasSubscriptions(channel);
        var subscription = _addListener(channel, scope, callback, false);
        if (send) {
          // Send the subscription message after the subscription registration to avoid
          // races where the server would send a message to the subscribers, but here
          // on the client the subscription has not been added yet to the data structures
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/subscribe',
            subscription: channel
          };
          // Do not allow the user to override important fields.
          var message = this._mixin(false, {}, subscribeProps, bayeuxMessage);
          // Save the callback.
          _cometd._putCallback(message.id, subscribeCallback);
          _queueSend(message);
        }
        return subscription;
      };
      /**
       * Unsubscribes the subscription obtained with a call to {@link #subscribe(string, object, function)}.
       * @param subscription the subscription to unsubscribe.
       * @param unsubscribeProps an object to be merged with the unsubscribe message
       * @param unsubscribeCallback a function to be invoked when the unsubscription is acknowledged
       */
      this.unsubscribe = function (subscription, unsubscribeProps, unsubscribeCallback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(unsubscribeProps)) {
          unsubscribeCallback = unsubscribeProps;
          unsubscribeProps = undefined;
        }
        // Remove the local listener before sending the message
        // This ensures that if the server fails, this client does not get notifications
        this.removeListener(subscription);
        var channel = subscription.channel;
        // Only send the message to the server if this client unsubscribes the last subscription
        if (!_hasSubscriptions(channel)) {
          var bayeuxMessage = {
            id: _nextMessageId(),
            channel: '/meta/unsubscribe',
            subscription: channel
          };
          // Do not allow the user to override important fields.
          var message = this._mixin(false, {}, unsubscribeProps, bayeuxMessage);
          // Save the callback.
          _cometd._putCallback(message.id, unsubscribeCallback);
          _queueSend(message);
        }
      };
      this.resubscribe = function (subscription, subscribeProps) {
        _removeSubscription(subscription);
        if (subscription) {
          return this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps);
        }
        return undefined;
      };
      /**
       * Removes all subscriptions added via {@link #subscribe(channel, scope, callback, subscribeProps)},
       * but does not remove the listeners added via {@link addListener(channel, scope, callback)}.
       */
      this.clearSubscriptions = function () {
        _clearSubscriptions();
      };
      /**
       * Publishes a message on the given channel, containing the given content.
       * @param channel the channel to publish the message to
       * @param content the content of the message
       * @param publishProps an object to be merged with the publish message
       * @param publishCallback a function to be invoked when the publish is acknowledged by the server
       */
      this.publish = function (channel, content, publishProps, publishCallback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(channel)) {
          throw 'Illegal argument type: channel must be a string';
        }
        if (/^\/meta\//.test(channel)) {
          throw 'Illegal argument: cannot publish to meta channels';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(content)) {
          publishCallback = content;
          content = {};
          publishProps = undefined;
        } else if (_isFunction(publishProps)) {
          publishCallback = publishProps;
          publishProps = undefined;
        }
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: channel,
          data: content
        };
        // Do not allow the user to override important fields.
        var message = this._mixin(false, {}, publishProps, bayeuxMessage);
        // Save the callback.
        _cometd._putCallback(message.id, publishCallback);
        _queueSend(message);
      };
      /**
       * Publishes a message with binary data on the given channel.
       * The binary data chunk may be an ArrayBuffer, a DataView, a TypedArray
       * (such as Uint8Array) or a plain integer array.
       * The meta data object may contain additional application data such as
       * a file name, a mime type, etc.
       * @param channel the channel to publish the message to
       * @param data the binary data to publish
       * @param last whether the binary data chunk is the last
       * @param meta an object containing meta data associated to the binary chunk
       * @param callback a function to be invoked when the publish is acknowledged by the server
       */
      this.publishBinary = function (channel, data, last, meta, callback) {
        if (_isFunction(data)) {
          callback = data;
          data = new ArrayBuffer(0);
          last = true;
          meta = undefined;
        } else if (_isFunction(last)) {
          callback = last;
          last = true;
          meta = undefined;
        } else if (_isFunction(meta)) {
          callback = meta;
          meta = undefined;
        }
        var content = {
          meta: meta,
          data: data,
          last: last
        };
        var ext = { ext: { binary: {} } };
        this.publish(channel, content, ext, callback);
      };
      this.remoteCall = function (target, content, timeout, callProps, callback) {
        if (arguments.length < 1) {
          throw 'Illegal arguments number: required 1, got ' + arguments.length;
        }
        if (!_isString(target)) {
          throw 'Illegal argument type: target must be a string';
        }
        if (_isDisconnected()) {
          throw 'Illegal state: disconnected';
        }
        if (_isFunction(content)) {
          callback = content;
          content = {};
          timeout = _config.maxNetworkDelay;
          callProps = undefined;
        } else if (_isFunction(timeout)) {
          callback = timeout;
          timeout = _config.maxNetworkDelay;
          callProps = undefined;
        } else if (_isFunction(callProps)) {
          callback = callProps;
          callProps = undefined;
        }
        if (typeof timeout !== 'number') {
          throw 'Illegal argument type: timeout must be a number';
        }
        if (!target.match(/^\//)) {
          target = '/' + target;
        }
        var channel = '/service' + target;
        var bayeuxMessage = {
          id: _nextMessageId(),
          channel: channel,
          data: content
        };
        var message = this._mixin(false, {}, callProps, bayeuxMessage);
        var context = { callback: callback };
        if (timeout > 0) {
          context.timeout = Utils.setTimeout(_cometd, function () {
            _cometd._debug('Timing out remote call', message, 'after', timeout, 'ms');
            _failMessage({
              id: message.id,
              error: '406::timeout',
              successful: false,
              failure: {
                message: message,
                reason: 'Remote Call Timeout'
              }
            });
          }, timeout);
          _cometd._debug('Scheduled remote call timeout', message, 'in', timeout, 'ms');
        }
        _remoteCalls[message.id] = context;
        _queueSend(message);
      };
      this.remoteCallBinary = function (target, data, last, meta, timeout, callback) {
        if (_isFunction(data)) {
          callback = data;
          data = new ArrayBuffer(0);
          last = true;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(last)) {
          callback = last;
          last = true;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(meta)) {
          callback = meta;
          meta = undefined;
          timeout = _config.maxNetworkDelay;
        } else if (_isFunction(timeout)) {
          callback = timeout;
          timeout = _config.maxNetworkDelay;
        }
        var content = {
          meta: meta,
          data: data,
          last: last
        };
        var ext = { ext: { binary: {} } };
        this.remoteCall(target, content, timeout, ext, callback);
      };
      /**
       * Returns a string representing the status of the bayeux communication with the Bayeux server.
       */
      this.getStatus = function () {
        return _status;
      };
      /**
       * Returns whether this instance has been disconnected.
       */
      this.isDisconnected = _isDisconnected;
      /**
       * Sets the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
       * Default value is 1 second, which means if there is a persistent failure the retries will happen
       * after 1 second, then after 2 seconds, then after 3 seconds, etc. So for example with 15 seconds of
       * elapsed time, there will be 5 retries (at 1, 3, 6, 10 and 15 seconds elapsed).
       * @param period the backoff period to set
       * @see #getBackoffIncrement()
       */
      this.setBackoffIncrement = function (period) {
        _config.backoffIncrement = period;
      };
      /**
       * Returns the backoff period used to increase the backoff time when retrying an unsuccessful or failed message.
       * @see #setBackoffIncrement(period)
       */
      this.getBackoffIncrement = function () {
        return _config.backoffIncrement;
      };
      /**
       * Returns the backoff period to wait before retrying an unsuccessful or failed message.
       */
      this.getBackoffPeriod = function () {
        return _backoff;
      };
      /**
       * Increases the backoff period up to the maximum value configured.
       * @returns the backoff period after increment
       * @see getBackoffIncrement
       */
      this.increaseBackoffPeriod = function () {
        return _increaseBackoff();
      };
      /**
       * Resets the backoff period to zero.
       */
      this.resetBackoffPeriod = function () {
        _resetBackoff();
      };
      /**
       * Sets the log level for console logging.
       * Valid values are the strings 'error', 'warn', 'info' and 'debug', from
       * less verbose to more verbose.
       * @param level the log level string
       */
      this.setLogLevel = function (level) {
        _config.logLevel = level;
      };
      /**
           * Registers an extension whose callbacks are called for every incoming message
           * (that comes from the server to this client implementation) and for every
           * outgoing message (that originates from this client implementation for the
           * server).
           * The format of the extension object is the following:
           * <pre>
           * {
       *     incoming: function(message) { ... },
       *     outgoing: function(message) { ... }
       * }
           * </pre>
           * Both properties are optional, but if they are present they will be called
           * respectively for each incoming message and for each outgoing message.
           * @param name the name of the extension
           * @param extension the extension to register
           * @return true if the extension was registered, false otherwise
           * @see #unregisterExtension(name)
           */
      this.registerExtension = function (name, extension) {
        if (arguments.length < 2) {
          throw 'Illegal arguments number: required 2, got ' + arguments.length;
        }
        if (!_isString(name)) {
          throw 'Illegal argument type: extension name must be a string';
        }
        var existing = false;
        for (var i = 0; i < _extensions.length; ++i) {
          var existingExtension = _extensions[i];
          if (existingExtension.name === name) {
            existing = true;
            break;
          }
        }
        if (!existing) {
          _extensions.push({
            name: name,
            extension: extension
          });
          this._debug('Registered extension', name);
          // Callback for extensions
          if (_isFunction(extension.registered)) {
            extension.registered(name, this);
          }
          return true;
        } else {
          this._info('Could not register extension with name', name, 'since another extension with the same name already exists');
          return false;
        }
      };
      /**
       * Unregister an extension previously registered with
       * {@link #registerExtension(name, extension)}.
       * @param name the name of the extension to unregister.
       * @return true if the extension was unregistered, false otherwise
       */
      this.unregisterExtension = function (name) {
        if (!_isString(name)) {
          throw 'Illegal argument type: extension name must be a string';
        }
        var unregistered = false;
        for (var i = 0; i < _extensions.length; ++i) {
          var extension = _extensions[i];
          if (extension.name === name) {
            _extensions.splice(i, 1);
            unregistered = true;
            this._debug('Unregistered extension', name);
            // Callback for extensions
            var ext = extension.extension;
            if (_isFunction(ext.unregistered)) {
              ext.unregistered();
            }
            break;
          }
        }
        return unregistered;
      };
      /**
       * Find the extension registered with the given name.
       * @param name the name of the extension to find
       * @return the extension found or null if no extension with the given name has been registered
       */
      this.getExtension = function (name) {
        for (var i = 0; i < _extensions.length; ++i) {
          var extension = _extensions[i];
          if (extension.name === name) {
            return extension.extension;
          }
        }
        return null;
      };
      /**
       * Returns the name assigned to this CometD object, or the string 'default'
       * if no name has been explicitly passed as parameter to the constructor.
       */
      this.getName = function () {
        return _name;
      };
      /**
       * Returns the clientId assigned by the Bayeux server during handshake.
       */
      this.getClientId = function () {
        return _clientId;
      };
      /**
       * Returns the URL of the Bayeux server.
       */
      this.getURL = function () {
        if (_transport) {
          var url = _transport.getURL();
          if (url) {
            return url;
          }
          url = _config.urls[_transport.getType()];
          if (url) {
            return url;
          }
        }
        return _config.url;
      };
      this.getTransport = function () {
        return _transport;
      };
      this.getConfiguration = function () {
        return this._mixin(true, {}, _config);
      };
      this.getAdvice = function () {
        return this._mixin(true, {}, _advice);
      };
      // Initialize transports.
      if (window.WebSocket) {
        this.registerTransport('websocket', new WebSocketTransport());
      }
      this.registerTransport('long-polling', new LongPollingTransport());  // this.registerTransport('callback-polling', new CallbackPollingTransport());
    };
    var _z85EncodeTable = [
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z',
      'A',
      'B',
      'C',
      'D',
      'E',
      'F',
      'G',
      'H',
      'I',
      'J',
      'K',
      'L',
      'M',
      'N',
      'O',
      'P',
      'Q',
      'R',
      'S',
      'T',
      'U',
      'V',
      'W',
      'X',
      'Y',
      'Z',
      '.',
      '-',
      ':',
      '+',
      '=',
      '^',
      '!',
      '/',
      '*',
      '?',
      '&',
      '<',
      '>',
      '(',
      ')',
      '[',
      ']',
      '{',
      '}',
      '@',
      '%',
      '$',
      '#'
    ];
    var _z85DecodeTable = [
      0,
      68,
      0,
      84,
      83,
      82,
      72,
      0,
      75,
      76,
      70,
      65,
      0,
      63,
      62,
      69,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      64,
      0,
      73,
      66,
      74,
      71,
      81,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      77,
      0,
      78,
      67,
      0,
      0,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      79,
      0,
      80,
      0,
      0
    ];
    var Z85 = {
      encode: function (bytes) {
        var buffer = null;
        if (bytes instanceof ArrayBuffer) {
          buffer = bytes;
        } else if (bytes.buffer instanceof ArrayBuffer) {
          buffer = bytes.buffer;
        } else if (Array.isArray(bytes)) {
          buffer = new Uint8Array(bytes).buffer;
        }
        if (buffer == null) {
          throw 'Cannot Z85 encode ' + bytes;
        }
        var length = buffer.byteLength;
        var remainder = length % 4;
        var padding = 4 - (remainder === 0 ? 4 : remainder);
        var view = new DataView(buffer);
        var result = '';
        var value = 0;
        for (var i = 0; i < length + padding; ++i) {
          var isPadding = i >= length;
          value = value * 256 + (isPadding ? 0 : view.getUint8(i));
          if ((i + 1) % 4 === 0) {
            var divisor = 85 * 85 * 85 * 85;
            for (var j = 5; j > 0; --j) {
              if (!isPadding || j > padding) {
                var code = Math.floor(value / divisor) % 85;
                result += _z85EncodeTable[code];
              }
              divisor /= 85;
            }
            value = 0;
          }
        }
        return result;
      },
      decode: function (string) {
        var remainder = string.length % 5;
        var padding = 5 - (remainder === 0 ? 5 : remainder);
        for (var p = 0; p < padding; ++p) {
          string += _z85EncodeTable[_z85EncodeTable.length - 1];
        }
        var length = string.length;
        var buffer = new ArrayBuffer(length * 4 / 5 - padding);
        var view = new DataView(buffer);
        var value = 0;
        var charIdx = 0;
        var byteIdx = 0;
        for (var i = 0; i < length; ++i) {
          var code = string.charCodeAt(charIdx++) - 32;
          value = value * 85 + _z85DecodeTable[code];
          if (charIdx % 5 === 0) {
            var divisor = 256 * 256 * 256;
            while (divisor >= 1) {
              if (byteIdx < view.byteLength) {
                view.setUint8(byteIdx++, Math.floor(value / divisor) % 256);
              }
              divisor /= 256;
            }
            value = 0;
          }
        }
        return buffer;
      }
    };
    return {
      CometD: CometD,
      Transport: Transport,
      RequestTransport: RequestTransport,
      LongPollingTransport: LongPollingTransport,
      // CallbackPollingTransport: CallbackPollingTransport,
      WebSocketTransport: WebSocketTransport,
      Utils: Utils,
      Z85: Z85
    };
  }));
  dojo_json = function (has) {
    var hasJSON = typeof JSON != 'undefined';
    has.add('json-parse', hasJSON);
    // all the parsers work fine
    // Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184
    // PATCHED improved detection of JSON.stringify manipulation
    has.add('json-stringify', hasJSON && JSON.stringify([{ a: 0 }], function (k, v) {
      return v || 1;
    }) == '[{"a":1}]');
    // END PATCH
    /*=====
    	return {
    		// summary:
    		//		Functions to parse and serialize JSON
    
    		parse: function(str, strict){
    			// summary:
    			//		Parses a [JSON](http://json.org) string to return a JavaScript object.
    			// description:
    			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
    			//		Throws for invalid JSON strings. This delegates to eval() if native JSON
    			//		support is not available. By default this will evaluate any valid JS expression.
    			//		With the strict parameter set to true, the parser will ensure that only
    			//		valid JSON strings are parsed (otherwise throwing an error). Without the strict
    			//		parameter, the content passed to this method must come
    			//		from a trusted source.
    			// str:
    			//		a string literal of a JSON item, for instance:
    			//		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
    			// strict:
    			//		When set to true, this will ensure that only valid, secure JSON is ever parsed.
    			//		Make sure this is set to true for untrusted content. Note that on browsers/engines
    			//		without native JSON support, setting this to true will run slower.
    		},
    		stringify: function(value, replacer, spacer){
    			// summary:
    			//		Returns a [JSON](http://json.org) serialization of an object.
    			// description:
    			//		Returns a [JSON](http://json.org) serialization of an object.
    			//		This function follows [native JSON API](https://developer.mozilla.org/en/JSON)
    			//		Note that this doesn't check for infinite recursion, so don't do that!
    			// value:
    			//		A value to be serialized.
    			// replacer:
    			//		A replacer function that is called for each value and can return a replacement
    			// spacer:
    			//		A spacer string to be used for pretty printing of JSON
    			// example:
    			//		simple serialization of a trivial object
    			//	|	define(["dojo/json"], function(JSON){
    			// 	|		var jsonStr = JSON.stringify({ howdy: "stranger!", isStrange: true });
    			//	|		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
    		}
    	};
    	=====*/
    if (has('json-stringify')) {
      return JSON;
    } else {
      var escapeString = function (str) {
        // summary:
        //		Adds escape sequences for non-visual characters, double quote and
        //		backslash and surrounds with double quotes to form a valid string
        //		literal.
        return ('"' + str.replace(/(["\\])/g, '\\$1') + '"').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r');  // string
      };
      return {
        parse: has('json-parse') ? JSON.parse : function (str, strict) {
          if (strict && !/^([\s\[\{]*(?:"(?:\\.|[^"])*"|-?\d[\d\.]*(?:[Ee][+-]?\d+)?|null|true|false|)[\s\]\}]*(?:,|:|$))+$/.test(str)) {
            throw new SyntaxError('Invalid characters in JSON');
          }
          return eval('(' + str + ')');
        },
        stringify: function (value, replacer, spacer) {
          var undef;
          if (typeof replacer == 'string') {
            spacer = replacer;
            replacer = null;
          }
          function stringify(it, indent, key) {
            if (replacer) {
              it = replacer(key, it);
            }
            var val, objtype = typeof it;
            if (objtype == 'number') {
              return isFinite(it) ? it + '' : 'null';
            }
            if (objtype == 'boolean') {
              return it + '';
            }
            if (it === null) {
              return 'null';
            }
            if (typeof it == 'string') {
              return escapeString(it);
            }
            if (objtype == 'function' || objtype == 'undefined') {
              return undef;  // undefined
            }
            // short-circuit for objects that support "json" serialization
            // if they return "self" then just pass-through...
            //PATCHED Sometimes Object.toJSON is overwritten (e.g. by prototype.js) and should not be used because the returned JSON is not valid
            //					if(typeof it.toJSON == "function"){
            //						return stringify(it.toJSON(key), indent, key);
            //					}
            // END PATCH
            if (it instanceof Date) {
              return '"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z"'.replace(/\{(\w+)(\+)?\}/g, function (t, prop, plus) {
                var num = it['getUTC' + prop]() + (plus ? 1 : 0);
                return num < 10 ? '0' + num : num;
              });
            }
            if (it.valueOf() !== it) {
              // primitive wrapper, try again unwrapped:
              return stringify(it.valueOf(), indent, key);
            }
            var nextIndent = spacer ? indent + spacer : '';
            /* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */
            var sep = spacer ? ' ' : '';
            var newLine = spacer ? '\n' : '';
            // array
            if (it instanceof Array) {
              var itl = it.length, res = [];
              for (key = 0; key < itl; key++) {
                var obj = it[key];
                val = stringify(obj, nextIndent, key);
                if (typeof val != 'string') {
                  val = 'null';
                }
                res.push(newLine + nextIndent + val);
              }
              return '[' + res.join(',') + newLine + indent + ']';
            }
            // generic object code path
            var output = [];
            for (key in it) {
              var keyStr;
              if (it.hasOwnProperty(key)) {
                if (typeof key == 'number') {
                  keyStr = '"' + key + '"';
                } else if (typeof key == 'string') {
                  keyStr = escapeString(key);
                } else {
                  // skip non-string or number keys
                  continue;
                }
                val = stringify(it[key], nextIndent, key);
                if (typeof val != 'string') {
                  // skip non-serializable values
                  continue;
                }
                // At this point, the most non-IE browsers don't get in this branch
                // (they have native JSON), so push is definitely the way to
                output.push(newLine + nextIndent + keyStr + ':' + sep + val);
              }
            }
            return '{' + output.join(',') + newLine + indent + '}';  // String
          }
          return stringify(value, '', '');
        }
      };
    }
  }(dojo_has);
  dojox_main = function (dojo) {
    // module:
    //		dojox/main
    /*=====
    	return {
    		// summary:
    		//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.
    		//		Apps should require modules from the dojox packages directly, rather than loading this module.
    	};
    	=====*/
    return dojo.dojox;
  }(dojo__base_kernel);
  dojox = function (main) {
    return main;
  }(dojox_main);
  dojo__base_sniff = function (dojo, lang, has) {
    // module:
    //		dojo/_base/sniff
    /*=====
    	return {
    		// summary:
    		//		Deprecated.   New code should use dojo/sniff.
    		//		This module populates the dojo browser version sniffing properties like dojo.isIE.
    	};
    	=====*/
    if (!has('host-browser')) {
      return has;
    }
    // no idea what this is for, or if it's used
    dojo._name = 'browser';
    lang.mixin(dojo, {
      // isBrowser: Boolean
      //		True if the client is a web-browser
      isBrowser: true,
      // isFF: Number|undefined
      //		Version as a Number if client is FireFox. undefined otherwise. Corresponds to
      //		major detected FireFox version (1.5, 2, 3, etc.)
      isFF: has('ff'),
      // isIE: Number|undefined
      //		Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
      //		major detected IE version (6, 7, 8, etc.)
      isIE: has('ie'),
      // isKhtml: Number|undefined
      //		Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
      //		detected version.
      isKhtml: has('khtml'),
      // isWebKit: Number|undefined
      //		Version as a Number if client is a WebKit-derived browser (Konqueror,
      //		Safari, Chrome, etc.). undefined otherwise.
      isWebKit: has('webkit'),
      // isMozilla: Number|undefined
      //		Version as a Number if client is a Mozilla-based browser (Firefox,
      //		SeaMonkey). undefined otherwise. Corresponds to major detected version.
      isMozilla: has('mozilla'),
      // isMoz: Number|undefined
      //		Version as a Number if client is a Mozilla-based browser (Firefox,
      //		SeaMonkey). undefined otherwise. Corresponds to major detected version.
      isMoz: has('mozilla'),
      // isOpera: Number|undefined
      //		Version as a Number if client is Opera. undefined otherwise. Corresponds to
      //		major detected version.
      isOpera: has('opera'),
      // isSafari: Number|undefined
      //		Version as a Number if client is Safari or iPhone. undefined otherwise.
      isSafari: has('safari'),
      // isChrome: Number|undefined
      //		Version as a Number if client is Chrome browser. undefined otherwise.
      isChrome: has('chrome'),
      // isMac: Boolean
      //		True if the client runs on Mac
      isMac: has('mac'),
      // isIos: Number|undefined
      //		Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.
      isIos: has('ios'),
      // isAndroid: Number|undefined
      //		Version as a Number if client is android browser. undefined otherwise.
      isAndroid: has('android'),
      // isWii: Boolean
      //		True if client is Wii
      isWii: has('wii'),
      // isQuirks: Boolean
      //		Page is in quirks mode.
      isQuirks: has('quirks'),
      // isAir: Boolean
      //		True if client is Adobe Air
      isAir: has('air')
    });
    return has;
  }(dojo__base_kernel, dojo__base_lang, dojo_sniff);
  dojo_io_query = function (lang) {
    // module:
    //		dojo/io-query
    var backstop = {};
    return {
      // summary:
      //		This module defines query string processing functions.
      objectToQuery: function objectToQuery(map) {
        // summary:
        //		takes a name/value mapping object and returns a string representing
        //		a URL-encoded version of that object.
        // example:
        //		this object:
        //
        //	|	{
        //	|		blah: "blah",
        //	|		multi: [
        //	|			"thud",
        //	|			"thonk"
        //	|		]
        //	|	};
        //
        //		yields the following query string:
        //
        //	|	"blah=blah&multi=thud&multi=thonk"
        // FIXME: need to implement encodeAscii!!
        var enc = encodeURIComponent, pairs = [];
        for (var name in map) {
          var value = map[name];
          if (value != backstop[name]) {
            var assign = enc(name) + '=';
            if (lang.isArray(value)) {
              for (var i = 0, l = value.length; i < l; ++i) {
                pairs.push(assign + enc(value[i]));
              }
            } else {
              pairs.push(assign + enc(value));
            }
          }
        }
        return pairs.join('&');  // String
      },
      queryToObject: function queryToObject(str) {
        // summary:
        //		Create an object representing a de-serialized query section of a
        //		URL. Query keys with multiple values are returned in an array.
        //
        // example:
        //		This string:
        //
        //	|		"foo=bar&foo=baz&thinger=%20spaces%20=blah&zonk=blarg&"
        //
        //		results in this object structure:
        //
        //	|		{
        //	|			foo: [ "bar", "baz" ],
        //	|			thinger: " spaces =blah",
        //	|			zonk: "blarg"
        //	|		}
        //
        //		Note that spaces and other urlencoded entities are correctly
        //		handled.
        // FIXME: should we grab the URL string if we're not passed one?
        var dec = decodeURIComponent, qp = str.split('&'), ret = {}, name, val;
        for (var i = 0, l = qp.length, item; i < l; ++i) {
          item = qp[i];
          if (item.length) {
            var s = item.indexOf('=');
            if (s < 0) {
              name = dec(item);
              val = '';
            } else {
              name = dec(item.slice(0, s));
              val = dec(item.slice(s + 1));
            }
            if (typeof ret[name] == 'string') {
              // inline'd type check
              ret[name] = [ret[name]];
            }
            if (lang.isArray(ret[name])) {
              ret[name].push(val);
            } else {
              ret[name] = val;
            }
          }
        }
        return ret;  // Object
      }
    };
  }(dojo__base_lang);
  dojo_dom_form = function (lang, dom, ioq, json) {
    // module:
    //		dojo/dom-form
    function setValue(obj, name, value) {
      // summary:
      //		For the named property in object, set the value. If a value
      //		already exists and it is a string, convert the value to be an
      //		array of values.
      // Skip it if there is no value
      if (value === null) {
        return;
      }
      var val = obj[name];
      if (typeof val == 'string') {
        // inline'd type check
        obj[name] = [
          val,
          value
        ];
      } else if (lang.isArray(val)) {
        val.push(value);
      } else {
        obj[name] = value;
      }
    }
    var exclude = 'file|submit|image|reset|button';
    var form = {
      // summary:
      //		This module defines form-processing functions.
      fieldToObject: function fieldToObject(inputNode) {
        // summary:
        //		Serialize a form field to a JavaScript object.
        // description:
        //		Returns the value encoded in a form field as
        //		as a string or an array of strings. Disabled form elements
        //		and unchecked radio and checkboxes are skipped.	Multi-select
        //		elements are returned as an array of string values.
        // inputNode: DOMNode|String
        // returns: Object
        var ret = null;
        inputNode = dom.byId(inputNode);
        if (inputNode) {
          var _in = inputNode.name, type = (inputNode.type || '').toLowerCase();
          if (_in && type && !inputNode.disabled) {
            if (type == 'radio' || type == 'checkbox') {
              if (inputNode.checked) {
                ret = inputNode.value;
              }
            } else if (inputNode.multiple) {
              ret = [];
              var nodes = [inputNode.firstChild];
              while (nodes.length) {
                for (var node = nodes.pop(); node; node = node.nextSibling) {
                  if (node.nodeType == 1 && node.tagName.toLowerCase() == 'option') {
                    if (node.selected) {
                      ret.push(node.value);
                    }
                  } else {
                    if (node.nextSibling) {
                      nodes.push(node.nextSibling);
                    }
                    if (node.firstChild) {
                      nodes.push(node.firstChild);
                    }
                    break;
                  }
                }
              }
            } else {
              ret = inputNode.value;
            }
          }
        }
        return ret;  // Object
      },
      toObject: function formToObject(formNode) {
        // summary:
        //		Serialize a form node to a JavaScript object.
        // description:
        //		Returns the values encoded in an HTML form as
        //		string properties in an object which it then returns. Disabled form
        //		elements, buttons, and other non-value form elements are skipped.
        //		Multi-select elements are returned as an array of string values.
        // formNode: DOMNode|String
        // example:
        //		This form:
        //		|	<form id="test_form">
        //		|		<input type="text" name="blah" value="blah">
        //		|		<input type="text" name="no_value" value="blah" disabled>
        //		|		<input type="button" name="no_value2" value="blah">
        //		|		<select type="select" multiple name="multi" size="5">
        //		|			<option value="blah">blah</option>
        //		|			<option value="thud" selected>thud</option>
        //		|			<option value="thonk" selected>thonk</option>
        //		|		</select>
        //		|	</form>
        //
        //		yields this object structure as the result of a call to
        //		formToObject():
        //
        //		|	{
        //		|		blah: "blah",
        //		|		multi: [
        //		|			"thud",
        //		|			"thonk"
        //		|		]
        //		|	};
        var ret = {}, elems = dom.byId(formNode).elements;
        for (var i = 0, l = elems.length; i < l; ++i) {
          var item = elems[i], _in = item.name, type = (item.type || '').toLowerCase();
          if (_in && type && exclude.indexOf(type) < 0 && !item.disabled) {
            setValue(ret, _in, form.fieldToObject(item));
            if (type == 'image') {
              ret[_in + '.x'] = ret[_in + '.y'] = ret[_in].x = ret[_in].y = 0;
            }
          }
        }
        return ret;  // Object
      },
      toQuery: function formToQuery(formNode) {
        // summary:
        //		Returns a URL-encoded string representing the form passed as either a
        //		node or string ID identifying the form to serialize
        // formNode: DOMNode|String
        // returns: String
        return ioq.objectToQuery(form.toObject(formNode));  // String
      },
      toJson: function formToJson(formNode, prettyPrint) {
        // summary:
        //		Create a serialized JSON string from a form node or string
        //		ID identifying the form to serialize
        // formNode: DOMNode|String
        // prettyPrint: Boolean?
        // returns: String
        return json.stringify(form.toObject(formNode), null, prettyPrint ? 4 : 0);  // String
      }
    };
    return form;
  }(dojo__base_lang, dojo_dom, dojo_io_query, dojo_json);
  dojo_when = function (Deferred, Promise) {
    // module:
    //		dojo/when
    return function when(valueOrPromise, callback, errback, progback) {
      // summary:
      //		Transparently applies callbacks to values and/or promises.
      // description:
      //		Accepts promises but also transparently handles non-promises. If no
      //		callbacks are provided returns a promise, regardless of the initial
      //		value. Foreign promises are converted.
      //
      //		If callbacks are provided and the initial value is not a promise,
      //		the callback is executed immediately with no error handling. Returns
      //		a promise if the initial value is a promise, or the result of the
      //		callback otherwise.
      // valueOrPromise:
      //		Either a regular value or an object with a `then()` method that
      //		follows the Promises/A specification.
      // callback: Function?
      //		Callback to be invoked when the promise is resolved, or a non-promise
      //		is received.
      // errback: Function?
      //		Callback to be invoked when the promise is rejected.
      // progback: Function?
      //		Callback to be invoked when the promise emits a progress update.
      // returns: dojo/promise/Promise
      //		Promise, or if a callback is provided, the result of the callback.
      var receivedPromise = valueOrPromise && typeof valueOrPromise.then === 'function';
      var nativePromise = receivedPromise && valueOrPromise instanceof Promise;
      if (!receivedPromise) {
        if (arguments.length > 1) {
          return callback ? callback(valueOrPromise) : valueOrPromise;
        } else {
          return new Deferred().resolve(valueOrPromise);
        }
      } else if (!nativePromise) {
        var deferred = new Deferred(valueOrPromise.cancel);
        valueOrPromise.then(deferred.resolve, deferred.reject, deferred.progress);
        valueOrPromise = deferred.promise;
      }
      if (callback || errback || progback) {
        return valueOrPromise.then(callback, errback, progback);
      }
      return valueOrPromise;
    };
  }(dojo_Deferred, dojo_promise_Promise);
  dojo__base_Deferred = function (dojo, NewDeferred, Promise, CancelError, has, lang, when) {
    // module:
    //		dojo/_base/Deferred
    var mutator = function () {
    };
    var freeze = Object.freeze || function () {
    };
    // A deferred provides an API for creating and resolving a promise.
    var Deferred = dojo.Deferred = function (canceller) {
      // summary:
      //		Deprecated.   This module defines the legacy dojo/_base/Deferred API.
      //		New code should use dojo/Deferred instead.
      // description:
      //		The Deferred API is based on the concept of promises that provide a
      //		generic interface into the eventual completion of an asynchronous action.
      //		The motivation for promises fundamentally is about creating a
      //		separation of concerns that allows one to achieve the same type of
      //		call patterns and logical data flow in asynchronous code as can be
      //		achieved in synchronous code. Promises allows one
      //		to be able to call a function purely with arguments needed for
      //		execution, without conflating the call with concerns of whether it is
      //		sync or async. One shouldn't need to alter a call's arguments if the
      //		implementation switches from sync to async (or vice versa). By having
      //		async functions return promises, the concerns of making the call are
      //		separated from the concerns of asynchronous interaction (which are
      //		handled by the promise).
      //
      //		The Deferred is a type of promise that provides methods for fulfilling the
      //		promise with a successful result or an error. The most important method for
      //		working with Dojo's promises is the then() method, which follows the
      //		CommonJS proposed promise API. An example of using a Dojo promise:
      //
      //		|	var resultingPromise = someAsyncOperation.then(function(result){
      //		|		... handle result ...
      //		|	},
      //		|	function(error){
      //		|		... handle error ...
      //		|	});
      //
      //		The .then() call returns a new promise that represents the result of the
      //		execution of the callback. The callbacks will never affect the original promises value.
      //
      //		The Deferred instances also provide the following functions for backwards compatibility:
      //
      //		- addCallback(handler)
      //		- addErrback(handler)
      //		- callback(result)
      //		- errback(result)
      //
      //		Callbacks are allowed to return promises themselves, so
      //		you can build complicated sequences of events with ease.
      //
      //		The creator of the Deferred may specify a canceller.  The canceller
      //		is a function that will be called if Deferred.cancel is called
      //		before the Deferred fires. You can use this to implement clean
      //		aborting of an XMLHttpRequest, etc. Note that cancel will fire the
      //		deferred with a CancelledError (unless your canceller returns
      //		another kind of error), so the errbacks should be prepared to
      //		handle that error for cancellable Deferreds.
      // example:
      //	|	var deferred = new Deferred();
      //	|	setTimeout(function(){ deferred.callback({success: true}); }, 1000);
      //	|	return deferred;
      // example:
      //		Deferred objects are often used when making code asynchronous. It
      //		may be easiest to write functions in a synchronous manner and then
      //		split code using a deferred to trigger a response to a long-lived
      //		operation. For example, instead of register a callback function to
      //		denote when a rendering operation completes, the function can
      //		simply return a deferred:
      //
      //		|	// callback style:
      //		|	function renderLotsOfData(data, callback){
      //		|		var success = false
      //		|		try{
      //		|			for(var x in data){
      //		|				renderDataitem(data[x]);
      //		|			}
      //		|			success = true;
      //		|		}catch(e){ }
      //		|		if(callback){
      //		|			callback(success);
      //		|		}
      //		|	}
      //
      //		|	// using callback style
      //		|	renderLotsOfData(someDataObj, function(success){
      //		|		// handles success or failure
      //		|		if(!success){
      //		|			promptUserToRecover();
      //		|		}
      //		|	});
      //		|	// NOTE: no way to add another callback here!!
      // example:
      //		Using a Deferred doesn't simplify the sending code any, but it
      //		provides a standard interface for callers and senders alike,
      //		providing both with a simple way to service multiple callbacks for
      //		an operation and freeing both sides from worrying about details
      //		such as "did this get called already?". With Deferreds, new
      //		callbacks can be added at any time.
      //
      //		|	// Deferred style:
      //		|	function renderLotsOfData(data){
      //		|		var d = new Deferred();
      //		|		try{
      //		|			for(var x in data){
      //		|				renderDataitem(data[x]);
      //		|			}
      //		|			d.callback(true);
      //		|		}catch(e){
      //		|			d.errback(new Error("rendering failed"));
      //		|		}
      //		|		return d;
      //		|	}
      //
      //		|	// using Deferred style
      //		|	renderLotsOfData(someDataObj).then(null, function(){
      //		|		promptUserToRecover();
      //		|	});
      //		|	// NOTE: addErrback and addCallback both return the Deferred
      //		|	// again, so we could chain adding callbacks or save the
      //		|	// deferred for later should we need to be notified again.
      // example:
      //		In this example, renderLotsOfData is synchronous and so both
      //		versions are pretty artificial. Putting the data display on a
      //		timeout helps show why Deferreds rock:
      //
      //		|	// Deferred style and async func
      //		|	function renderLotsOfData(data){
      //		|		var d = new Deferred();
      //		|		setTimeout(function(){
      //		|			try{
      //		|				for(var x in data){
      //		|					renderDataitem(data[x]);
      //		|				}
      //		|				d.callback(true);
      //		|			}catch(e){
      //		|				d.errback(new Error("rendering failed"));
      //		|			}
      //		|		}, 100);
      //		|		return d;
      //		|	}
      //
      //		|	// using Deferred style
      //		|	renderLotsOfData(someDataObj).then(null, function(){
      //		|		promptUserToRecover();
      //		|	});
      //
      //		Note that the caller doesn't have to change his code at all to
      //		handle the asynchronous case.
      var result, finished, canceled, fired, isError, head, nextListener;
      var promise = this.promise = new Promise();
      function complete(value) {
        if (finished) {
          throw new Error('This deferred has already been resolved');
        }
        result = value;
        finished = true;
        notify();
      }
      function notify() {
        var mutated;
        while (!mutated && nextListener) {
          var listener = nextListener;
          nextListener = nextListener.next;
          if (mutated = listener.progress == mutator) {
            // assignment and check
            finished = false;
          }
          var func = isError ? listener.error : listener.resolved;
          if (has('config-useDeferredInstrumentation')) {
            if (isError && NewDeferred.instrumentRejected) {
              NewDeferred.instrumentRejected(result, !!func);
            }
          }
          if (func) {
            try {
              var newResult = func(result);
              if (newResult && typeof newResult.then === 'function') {
                newResult.then(lang.hitch(listener.deferred, 'resolve'), lang.hitch(listener.deferred, 'reject'), lang.hitch(listener.deferred, 'progress'));
                continue;
              }
              var unchanged = mutated && newResult === undefined;
              if (mutated && !unchanged) {
                isError = newResult instanceof Error;
              }
              listener.deferred[unchanged && isError ? 'reject' : 'resolve'](unchanged ? result : newResult);
            } catch (e) {
              listener.deferred.reject(e);
            }
          } else {
            if (isError) {
              listener.deferred.reject(result);
            } else {
              listener.deferred.resolve(result);
            }
          }
        }
      }
      this.isResolved = promise.isResolved = function () {
        // summary:
        //		Checks whether the deferred has been resolved.
        // returns: Boolean
        return fired == 0;
      };
      this.isRejected = promise.isRejected = function () {
        // summary:
        //		Checks whether the deferred has been rejected.
        // returns: Boolean
        return fired == 1;
      };
      this.isFulfilled = promise.isFulfilled = function () {
        // summary:
        //		Checks whether the deferred has been resolved or rejected.
        // returns: Boolean
        return fired >= 0;
      };
      this.isCanceled = promise.isCanceled = function () {
        // summary:
        //		Checks whether the deferred has been canceled.
        // returns: Boolean
        return canceled;
      };
      // calling resolve will resolve the promise
      this.resolve = this.callback = function (value) {
        // summary:
        //		Fulfills the Deferred instance successfully with the provide value
        this.fired = fired = 0;
        this.results = [
          value,
          null
        ];
        complete(value);
      };
      // calling error will indicate that the promise failed
      this.reject = this.errback = function (error) {
        // summary:
        //		Fulfills the Deferred instance as an error with the provided error
        isError = true;
        this.fired = fired = 1;
        if (has('config-useDeferredInstrumentation')) {
          if (NewDeferred.instrumentRejected) {
            NewDeferred.instrumentRejected(error, !!nextListener);
          }
        }
        complete(error);
        this.results = [
          null,
          error
        ];
      };
      // call progress to provide updates on the progress on the completion of the promise
      this.progress = function (update) {
        // summary:
        //		Send progress events to all listeners
        var listener = nextListener;
        while (listener) {
          var progress = listener.progress;
          progress && progress(update);
          listener = listener.next;
        }
      };
      this.addCallbacks = function (callback, errback) {
        // summary:
        //		Adds callback and error callback for this deferred instance.
        // callback: Function?
        //		The callback attached to this deferred object.
        // errback: Function?
        //		The error callback attached to this deferred object.
        // returns:
        //		Returns this deferred object.
        this.then(callback, errback, mutator);
        return this;  // Deferred
      };
      // provide the implementation of the promise
      promise.then = this.then = function (resolvedCallback, errorCallback, progressCallback) {
        // summary:
        //		Adds a fulfilledHandler, errorHandler, and progressHandler to be called for
        //		completion of a promise. The fulfilledHandler is called when the promise
        //		is fulfilled. The errorHandler is called when a promise fails. The
        //		progressHandler is called for progress events. All arguments are optional
        //		and non-function values are ignored. The progressHandler is not only an
        //		optional argument, but progress events are purely optional. Promise
        //		providers are not required to ever create progress events.
        //
        //		This function will return a new promise that is fulfilled when the given
        //		fulfilledHandler or errorHandler callback is finished. This allows promise
        //		operations to be chained together. The value returned from the callback
        //		handler is the fulfillment value for the returned promise. If the callback
        //		throws an error, the returned promise will be moved to failed state.
        //
        // returns:
        //		Returns a new promise that represents the result of the
        //		execution of the callback. The callbacks will never affect the original promises value.
        // example:
        //		An example of using a CommonJS compliant promise:
        //		|	asyncComputeTheAnswerToEverything().
        //		|		then(addTwo).
        //		|		then(printResult, onError);
        //		|	>44
        //
        var returnDeferred = progressCallback == mutator ? this : new Deferred(promise.cancel);
        var listener = {
          resolved: resolvedCallback,
          error: errorCallback,
          progress: progressCallback,
          deferred: returnDeferred
        };
        if (nextListener) {
          head = head.next = listener;
        } else {
          nextListener = head = listener;
        }
        if (finished) {
          notify();
        }
        return returnDeferred.promise;  // Promise
      };
      var deferred = this;
      promise.cancel = this.cancel = function () {
        // summary:
        //		Cancels the asynchronous operation
        if (!finished) {
          var error = canceller && canceller(deferred);
          if (!finished) {
            if (!(error instanceof Error)) {
              error = new CancelError(error);
            }
            error.log = false;
            deferred.reject(error);
          }
        }
        canceled = true;
      };
      freeze(promise);
    };
    lang.extend(Deferred, {
      addCallback: function (callback) {
        // summary:
        //		Adds successful callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        return this.addCallbacks(lang.hitch.apply(dojo, arguments));  // Deferred
      },
      addErrback: function (errback) {
        // summary:
        //		Adds error callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        return this.addCallbacks(null, lang.hitch.apply(dojo, arguments));  // Deferred
      },
      addBoth: function (callback) {
        // summary:
        //		Add handler as both successful callback and error callback for this deferred instance.
        // returns:
        //		Returns this deferred object.
        var enclosed = lang.hitch.apply(dojo, arguments);
        return this.addCallbacks(enclosed, enclosed);  // Deferred
      },
      fired: -1
    });
    Deferred.when = dojo.when = when;
    return Deferred;
  }(dojo__base_kernel, dojo_Deferred, dojo_promise_Promise, dojo_errors_CancelError, dojo_has, dojo__base_lang, dojo_when);
  dojo__base_json = function (dojo, json) {
    // module:
    //		dojo/_base/json
    /*=====
    return {
    	// summary:
    	//		This module defines the dojo JSON API.
    };
    =====*/
    dojo.fromJson = function (js) {
      // summary:
      //		Parses a JavaScript expression and returns a JavaScript value.
      // description:
      //		Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It
      //		always delegates to eval(). The content passed to this method must therefore come
      //		from a trusted source.
      //		It is recommend that you use dojo/json's parse function for an
      //		implementation uses the (faster) native JSON parse when available.
      // js:
      //		a string literal of a JavaScript expression, for instance:
      //		`'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'`
      return JSON.parse(js);  // Object PATCHED use JSON parse instean of eval
    };
    /*=====
    dojo._escapeString = function(){
    	// summary:
    	//		Adds escape sequences for non-visual characters, double quote and
    	//		backslash and surrounds with double quotes to form a valid string
    	//		literal.
    };
    =====*/
    dojo._escapeString = json.stringify;
    // just delegate to json.stringify
    dojo.toJsonIndentStr = '\t';
    dojo.toJson = function (it, prettyPrint) {
      // summary:
      //		Returns a [JSON](http://json.org) serialization of an object.
      // description:
      //		Returns a [JSON](http://json.org) serialization of an object.
      //		Note that this doesn't check for infinite recursion, so don't do that!
      //		It is recommend that you use dojo/json's stringify function for an lighter
      //		and faster implementation that matches the native JSON API and uses the
      //		native JSON serializer when available.
      // it:
      //		an object to be serialized. Objects may define their own
      //		serialization via a special "__json__" or "json" function
      //		property. If a specialized serializer has been defined, it will
      //		be used as a fallback.
      //		Note that in 1.6, toJson would serialize undefined, but this no longer supported
      //		since it is not supported by native JSON serializer.
      // prettyPrint:
      //		if true, we indent objects and arrays to make the output prettier.
      //		The variable `dojo.toJsonIndentStr` is used as the indent string --
      //		to use something other than the default (tab), change that variable
      //		before calling dojo.toJson().
      //		Note that if native JSON support is available, it will be used for serialization,
      //		and native implementations vary on the exact spacing used in pretty printing.
      // returns:
      //		A JSON string serialization of the passed-in object.
      // example:
      //		simple serialization of a trivial object
      //		|	var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
      //		|	doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);
      // example:
      //		a custom serializer for an objects of a particular class:
      //		|	dojo.declare("Furby", null, {
      //		|		furbies: "are strange",
      //		|		furbyCount: 10,
      //		|		__json__: function(){
      //		|		},
      //		|	});
      // use dojo/json
      return json.stringify(it, function (key, value) {
        if (value) {
          var tf = value.__json__ || value.json;
          if (typeof tf == 'function') {
            return tf.call(value);
          }
        }
        return value;
      }, prettyPrint && dojo.toJsonIndentStr);  // String
    };
    return dojo;
  }(dojo__base_kernel, dojo_json);
  dojo_errors_RequestError = function (create) {
    // module:
    //		dojo/errors/RequestError
    /*=====
    return function(){
     // summary:
     //		TODOC
    };
    =====*/
    return create('RequestError', function (message, response) {
      this.response = response;
    });
  }(dojo_errors_create);
  dojo_request_util = function (exports, RequestError, CancelError, Deferred, ioQuery, array, lang, Promise) {
    exports.deepCopy = function deepCopy(target, source) {
      for (var name in source) {
        var tval = target[name], sval = source[name];
        if (tval !== sval) {
          if (tval && typeof tval === 'object' && sval && typeof sval === 'object') {
            exports.deepCopy(tval, sval);
          } else {
            target[name] = sval;
          }
        }
      }
      return target;
    };
    exports.deepCreate = function deepCreate(source, properties) {
      properties = properties || {};
      var target = lang.delegate(source), name, value;
      for (name in source) {
        value = source[name];
        if (value && typeof value === 'object') {
          target[name] = exports.deepCreate(value, properties[name]);
        }
      }
      return exports.deepCopy(target, properties);
    };
    var freeze = Object.freeze || function (obj) {
      return obj;
    };
    function okHandler(response) {
      return freeze(response);
    }
    function dataHandler(response) {
      return response.data || response.text;
    }
    exports.deferred = function deferred(response, cancel, isValid, isReady, handleResponse, last) {
      var def = new Deferred(function (reason) {
        cancel && cancel(def, response);
        if (!reason || !(reason instanceof RequestError) && !(reason instanceof CancelError)) {
          return new CancelError('Request canceled', response);
        }
        return reason;
      });
      def.response = response;
      def.isValid = isValid;
      def.isReady = isReady;
      def.handleResponse = handleResponse;
      function errHandler(error) {
        error.response = response;
        throw error;
      }
      var responsePromise = def.then(okHandler).otherwise(errHandler);
      if (exports.notify) {
        responsePromise.then(lang.hitch(exports.notify, 'emit', 'load'), lang.hitch(exports.notify, 'emit', 'error'));
      }
      var dataPromise = responsePromise.then(dataHandler);
      // http://bugs.dojotoolkit.org/ticket/16794
      // The following works around a leak in IE9 through the
      // prototype using lang.delegate on dataPromise and
      // assigning the result a property with a reference to
      // responsePromise.
      var promise = new Promise();
      for (var prop in dataPromise) {
        if (dataPromise.hasOwnProperty(prop)) {
          promise[prop] = dataPromise[prop];
        }
      }
      promise.response = responsePromise;
      freeze(promise);
      // End leak fix
      if (last) {
        def.then(function (response) {
          last.call(def, response);
        }, function (error) {
          last.call(def, response, error);
        });
      }
      def.promise = promise;
      def.then = promise.then;
      return def;
    };
    exports.addCommonMethods = function addCommonMethods(provider, methods) {
      array.forEach(methods || [
        'GET',
        'POST',
        'PUT',
        'DELETE'
      ], function (method) {
        provider[(method === 'DELETE' ? 'DEL' : method).toLowerCase()] = function (url, options) {
          options = lang.delegate(options || {});
          options.method = method;
          return provider(url, options);
        };
      });
    };
    exports.parseArgs = function parseArgs(url, options, skipData) {
      var data = options.data, query = options.query;
      if (data && !skipData) {
        if (typeof data === 'object') {
          options.data = ioQuery.objectToQuery(data);
        }
      }
      if (query) {
        if (typeof query === 'object') {
          query = ioQuery.objectToQuery(query);
        }
        if (options.preventCache) {
          query += (query ? '&' : '') + 'request.preventCache=' + +new Date();
        }
      } else if (options.preventCache) {
        query = 'request.preventCache=' + +new Date();
      }
      if (url && query) {
        url += (~url.indexOf('?') ? '&' : '?') + query;
      }
      return {
        url: url,
        options: options,
        getHeader: function (headerName) {
          return null;
        }
      };
    };
    exports.checkStatus = function (stat) {
      stat = stat || 0;
      return stat >= 200 && stat < 300 || // allow any 2XX response code
      stat === 304 || // or, get it out of the cache
      stat === 1223 || // or, Internet Explorer mangled the status code
      !stat;  // or, we're Titanium/browser chrome/chrome extension requesting a local file
    };
    return exports;
  }(dojo_request_util, dojo_errors_RequestError, dojo_errors_CancelError, dojo_Deferred, dojo_io_query, dojo__base_array, dojo__base_lang, dojo_promise_Promise);
  dojo_errors_RequestTimeoutError = function (create, RequestError) {
    // module:
    //		dojo/errors/RequestTimeoutError
    /*=====
    return function(){
     // summary:
     //		TODOC
    };
    =====*/
    return create('RequestTimeoutError', null, RequestError, { dojoType: 'timeout' });
  }(dojo_errors_create, dojo_errors_RequestError);
  dojo_request_watch = function (util, RequestTimeoutError, CancelError, array, win, on) {
    // avoid setting a timer per request. It degrades performance on IE
    // something fierece if we don't use unified loops.
    var _inFlightIntvl = null, _inFlight = [];
    function watchInFlight() {
      // summary:
      //		internal method that checks each inflight XMLHttpRequest to see
      //		if it has completed or if the timeout situation applies.
      var now = +new Date();
      // we need manual loop because we often modify _inFlight (and therefore 'i') while iterating
      for (var i = 0, dfd; i < _inFlight.length && (dfd = _inFlight[i]); i++) {
        var response = dfd.response, options = response.options;
        if (dfd.isCanceled && dfd.isCanceled() || dfd.isValid && !dfd.isValid(response)) {
          _inFlight.splice(i--, 1);
          watch._onAction && watch._onAction();
        } else if (dfd.isReady && dfd.isReady(response)) {
          _inFlight.splice(i--, 1);
          dfd.handleResponse(response);
          watch._onAction && watch._onAction();
        } else if (dfd.startTime) {
          // did we timeout?
          if (dfd.startTime + (options.timeout || 0) < now) {
            _inFlight.splice(i--, 1);
            // Cancel the request so the io module can do appropriate cleanup.
            dfd.cancel(new RequestTimeoutError('Timeout exceeded', response));
            watch._onAction && watch._onAction();
          }
        }
      }
      watch._onInFlight && watch._onInFlight(dfd);
      if (!_inFlight.length) {
        clearInterval(_inFlightIntvl);
        _inFlightIntvl = null;
      }
    }
    function watch(dfd) {
      // summary:
      //		Watches the io request represented by dfd to see if it completes.
      // dfd: Deferred
      //		The Deferred object to watch.
      // response: Object
      //		The object used as the value of the request promise.
      // validCheck: Function
      //		Function used to check if the IO request is still valid. Gets the dfd
      //		object as its only argument.
      // ioCheck: Function
      //		Function used to check if basic IO call worked. Gets the dfd
      //		object as its only argument.
      // resHandle: Function
      //		Function used to process response. Gets the dfd
      //		object as its only argument.
      if (dfd.response.options.timeout) {
        dfd.startTime = +new Date();
      }
      if (dfd.isFulfilled()) {
        // bail out if the deferred is already fulfilled
        return;
      }
      _inFlight.push(dfd);
      if (!_inFlightIntvl) {
        _inFlightIntvl = setInterval(watchInFlight, 50);
      }
      // handle sync requests separately from async:
      // http://bugs.dojotoolkit.org/ticket/8467
      if (dfd.response.options.sync) {
        watchInFlight();
      }
    }
    watch.cancelAll = function cancelAll() {
      // summary:
      //		Cancels all pending IO requests, regardless of IO type
      try {
        array.forEach(_inFlight, function (dfd) {
          try {
            dfd.cancel(new CancelError('All requests canceled.'));
          } catch (e) {
          }
        });
      } catch (e) {
      }
    };
    if (win && on && win.doc.attachEvent) {
      // Automatically call cancel all io calls on unload in IE
      // http://bugs.dojotoolkit.org/ticket/2357
      on(win.global, 'unload', function () {
        watch.cancelAll();
      });
    }
    return watch;
  }(dojo_request_util, dojo_errors_RequestTimeoutError, dojo_errors_CancelError, dojo__base_array, dojo__base_window, dojo_on);
  dojo_request_handlers = function (JSON, kernel, array, has) {
    has.add('activex', typeof ActiveXObject !== 'undefined');
    has.add('dom-parser', function (global) {
      return 'DOMParser' in global;
    });
    var handleXML;
    if (has('activex')) {
      // GUIDs obtained from http://msdn.microsoft.com/en-us/library/ms757837(VS.85).aspx
      var dp = [
        'Msxml2.DOMDocument.6.0',
        'Msxml2.DOMDocument.4.0',
        'MSXML2.DOMDocument.3.0',
        'MSXML.DOMDocument'  // 2.0
      ];
      var lastParser;
      handleXML = function (response) {
        var result = response.data;
        var text = response.text;
        if (result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')) {
          // http://bugs.dojotoolkit.org/ticket/15631
          // IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation
          // returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain
          // the fuller-featured implementation and avoid bugs caused by the inconsistency
          result = new DOMParser().parseFromString(text, 'application/xml');
        }
        function createDocument(p) {
          try {
            var dom = new ActiveXObject(p);
            dom.async = false;
            dom.loadXML(text);
            result = dom;
            lastParser = p;
          } catch (e) {
            return false;
          }
          return true;
        }
        if (!result || !result.documentElement) {
          // The creation of an ActiveX object is expensive, so we cache the
          // parser type to avoid trying all parser types each time we handle a
          // document. There is some concern that some parser types might fail
          // depending on the document being parsed. If parsing using the cached
          // parser type fails, we do the more expensive operation of finding one
          // that works for the given document.
          // https://bugs.dojotoolkit.org/ticket/15246
          if (!lastParser || !createDocument(lastParser)) {
            array.some(dp, createDocument);
          }
        }
        return result;
      };
    }
    var handleNativeResponse = function (response) {
      if (!has('native-xhr2-blob') && response.options.handleAs === 'blob' && typeof Blob !== 'undefined') {
        return new Blob([response.xhr.response], { type: response.xhr.getResponseHeader('Content-Type') });
      }
      return response.xhr.response;
    };
    var handlers = {
      'javascript': function (response) {
        return kernel.eval(response.text || '');
      },
      'json': function (response) {
        return JSON.parse(response.text || null);
      },
      'xml': handleXML,
      'blob': handleNativeResponse,
      'arraybuffer': handleNativeResponse,
      'document': handleNativeResponse
    };
    function handle(response) {
      var handler = handlers[response.options.handleAs];
      response.data = handler ? handler(response) : response.data || response.text;
      return response;
    }
    handle.register = function (name, handler) {
      handlers[name] = handler;
    };
    return handle;
  }(dojo_json, dojo__base_kernel, dojo__base_array, dojo_has);
  dojo_request_xhr = function (RequestError, watch, handlers, util, has) {
    has.add('native-xhr', function () {
      // if true, the environment has a native XHR implementation
      return typeof XMLHttpRequest !== 'undefined';
    });
    has.add('dojo-force-activex-xhr', function () {
      return has('activex') && !document.addEventListener && window.location.protocol === 'file:';
    });
    has.add('native-xhr2', function () {
      if (!has('native-xhr')) {
        return;
      }
      var x = new XMLHttpRequest();
      return typeof x['addEventListener'] !== 'undefined' && (typeof opera === 'undefined' || typeof x['upload'] !== 'undefined');
    });
    has.add('native-formdata', function () {
      // if true, the environment has a native FormData implementation
      return typeof FormData !== 'undefined';
    });
    has.add('native-response-type', function () {
      return has('native-xhr') && typeof new XMLHttpRequest().responseType !== 'undefined';
    });
    has.add('native-xhr2-blob', function () {
      if (!has('native-response-type')) {
        return;
      }
      var responseType;
      try {
        var x = new XMLHttpRequest();
        x.open('GET', '/', true);
        x.responseType = 'blob';
        // will not be set if unsupported
        responseType = x.responseType;
        x.abort();
      } catch (e) {
      }
      return responseType === 'blob';
    });
    // Google Chrome doesn't support "json" response type
    // up to version 30, so it's intentionally not included here
    var nativeResponseTypes = {
      'blob': has('native-xhr2-blob') ? 'blob' : 'arraybuffer',
      'document': 'document',
      'arraybuffer': 'arraybuffer'
    };
    function handleResponse(response, error) {
      var _xhr = response.xhr;
      response.status = response.xhr.status;
      try {
        // Firefox throws an error when trying to access
        // xhr.responseText if response isn't text
        response.text = _xhr.responseText;
      } catch (e) {
      }
      if (response.options.handleAs === 'xml') {
        response.data = _xhr.responseXML;
      }
      if (!error) {
        try {
          handlers(response);
        } catch (e) {
          error = e;
        }
      }
      if (error) {
        this.reject(error);
      } else if (util.checkStatus(_xhr.status)) {
        this.resolve(response);
      } else {
        error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
        this.reject(error);
      }
    }
    var isValid, isReady, addListeners, cancel;
    if (has('native-xhr2')) {
      // Any platform with XHR2 will only use the watch mechanism for timeout.
      isValid = function (response) {
        // summary:
        //		Check to see if the request should be taken out of the watch queue
        return !this.isFulfilled();
      };
      cancel = function (dfd, response) {
        // summary:
        //		Canceler for deferred
        response.xhr.abort();
      };
      addListeners = function (_xhr, dfd, response) {
        // summary:
        //		Adds event listeners to the XMLHttpRequest object
        function onLoad(evt) {
          dfd.handleResponse(response);
        }
        function onError(evt) {
          var _xhr = evt.target;
          var error = new RequestError('Unable to load ' + response.url + ' status: ' + _xhr.status, response);
          dfd.handleResponse(response, error);
        }
        function onProgress(evt) {
          if (evt.lengthComputable) {
            response.loaded = evt.loaded;
            response.total = evt.total;
            dfd.progress(response);
          } else if (response.xhr.readyState === 3) {
            response.loaded = 'loaded' in evt ? evt.loaded : evt.position;
            //PATCHED https://github.com/dojo/dojo/commit/d400e28ad88aca5a3244710ad2ac1d341868d3d7
            dfd.progress(response);
          }
        }
        _xhr.addEventListener('load', onLoad, false);
        _xhr.addEventListener('error', onError, false);
        _xhr.addEventListener('progress', onProgress, false);
        return function () {
          _xhr.removeEventListener('load', onLoad, false);
          _xhr.removeEventListener('error', onError, false);
          _xhr.removeEventListener('progress', onProgress, false);
          _xhr = null;
        };
      };
    } else {
      isValid = function (response) {
        return response.xhr.readyState;  //boolean
      };
      isReady = function (response) {
        return 4 === response.xhr.readyState;  //boolean
      };
      cancel = function (dfd, response) {
        // summary:
        //		canceller function for util.deferred call.
        var xhr = response.xhr;
        var _at = typeof xhr.abort;
        if (_at === 'function' || _at === 'object' || _at === 'unknown') {
          xhr.abort();
        }
      };
    }
    function getHeader(headerName) {
      return this.xhr.getResponseHeader(headerName);
    }
    var undefined, defaultOptions = {
        data: null,
        query: null,
        sync: false,
        method: 'GET'
      };
    function xhr(url, options, returnDeferred) {
      var isFormData = has('native-formdata') && options && options.data && options.data instanceof FormData;
      var response = util.parseArgs(url, util.deepCreate(defaultOptions, options), isFormData);
      url = response.url;
      options = response.options;
      var remover, last = function () {
          remover && remover();
        };
      //Make the Deferred object for this xhr request.
      var dfd = util.deferred(response, cancel, isValid, isReady, handleResponse, last);
      var _xhr = response.xhr = xhr._create();
      if (!_xhr) {
        // If XHR factory somehow returns nothings,
        // cancel the deferred.
        dfd.cancel(new RequestError('XHR was not created'));
        return returnDeferred ? dfd : dfd.promise;
      }
      response.getHeader = getHeader;
      if (addListeners) {
        remover = addListeners(_xhr, dfd, response);
      }
      var data = options.data, async = !options.sync, method = options.method;
      try {
        // IE6 won't let you call apply() on the native function.
        _xhr.open(method, url, async, options.user || undefined, options.password || undefined);
        if (options.withCredentials) {
          _xhr.withCredentials = options.withCredentials;
        }
        if (has('native-response-type') && options.handleAs in nativeResponseTypes) {
          _xhr.responseType = nativeResponseTypes[options.handleAs];
        }
        var headers = options.headers, contentType = isFormData ? false : 'application/x-www-form-urlencoded';
        if (headers) {
          for (var hdr in headers) {
            if (hdr.toLowerCase() === 'content-type') {
              contentType = headers[hdr];
            } else if (headers[hdr]) {
              //Only add header if it has a value. This allows for instance, skipping
              //insertion of X-Requested-With by specifying empty value.
              _xhr.setRequestHeader(hdr, headers[hdr]);
            }
          }
        }
        if (contentType && contentType !== false) {
          _xhr.setRequestHeader('Content-Type', contentType);
        }
        if (!headers || !('X-Requested-With' in headers)) {
          _xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
        }
        if (util.notify) {
          util.notify.emit('send', response, dfd.promise.cancel);
        }
        _xhr.send(data);
      } catch (e) {
        dfd.reject(e);
      }
      watch(dfd);
      _xhr = null;
      return returnDeferred ? dfd : dfd.promise;
    }
    /*=====
    	xhr = function(url, options){
    		// summary:
    		//		Sends a request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__Options?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.__BaseOptions = declare(request.__BaseOptions, {
    		// sync: Boolean?
    		//		Whether to make a synchronous request or not. Default
    		//		is `false` (asynchronous).
    		// data: String|Object|FormData?
    		//		Data to transfer. This is ignored for GET and DELETE
    		//		requests.
    		// headers: Object?
    		//		Headers to use for the request.
    		// user: String?
    		//		Username to use during the request.
    		// password: String?
    		//		Password to use during the request.
    		// withCredentials: Boolean?
    		//		For cross-site requests, whether to send credentials
    		//		or not.
    	});
    	xhr.__MethodOptions = declare(null, {
    		// method: String?
    		//		The HTTP method to use to make the request. Must be
    		//		uppercase. Default is `"GET"`.
    	});
    	xhr.__Options = declare([xhr.__BaseOptions, xhr.__MethodOptions]);
    
    	xhr.get = function(url, options){
    		// summary:
    		//		Send an HTTP GET request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.post = function(url, options){
    		// summary:
    		//		Send an HTTP POST request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.put = function(url, options){
    		// summary:
    		//		Send an HTTP PUT request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	xhr.del = function(url, options){
    		// summary:
    		//		Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/xhr.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	=====*/
    xhr._create = function () {
      // summary:
      //		does the work of portably generating a new XMLHTTPRequest object.
      throw new Error('XMLHTTP not available');
    };
    if (has('native-xhr') && !has('dojo-force-activex-xhr')) {
      xhr._create = function () {
        return new XMLHttpRequest();
      };
    } else if (has('activex')) {
      try {
        new ActiveXObject('Msxml2.XMLHTTP');
        xhr._create = function () {
          return new ActiveXObject('Msxml2.XMLHTTP');
        };
      } catch (e) {
        try {
          new ActiveXObject('Microsoft.XMLHTTP');
          xhr._create = function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
          };
        } catch (e) {
        }
      }
    }
    util.addCommonMethods(xhr);
    return xhr;
  }(dojo_errors_RequestError, dojo_request_watch, dojo_request_handlers, dojo_request_util, dojo_has);
  dojo__base_xhr = function (dojo, has, require, ioq, dom, domForm, Deferred, config, json, lang, array, on, aspect, watch, _xhr, util) {
    // module:
    //		dojo/_base/xhr
    /*=====
    	dojo._xhrObj = function(){
    		// summary:
    		//		does the work of portably generating a new XMLHTTPRequest object.
    	};
    	=====*/
    dojo._xhrObj = _xhr._create;
    var cfg = dojo.config;
    // mix in io-query and dom-form
    dojo.objectToQuery = ioq.objectToQuery;
    dojo.queryToObject = ioq.queryToObject;
    dojo.fieldToObject = domForm.fieldToObject;
    dojo.formToObject = domForm.toObject;
    dojo.formToQuery = domForm.toQuery;
    dojo.formToJson = domForm.toJson;
    // need to block async callbacks from snatching this thread as the result
    // of an async callback might call another sync XHR, this hangs khtml forever
    // must checked by watchInFlight()
    dojo._blockAsync = false;
    // MOW: remove dojo._contentHandlers alias in 2.0
    var handlers = dojo._contentHandlers = dojo.contentHandlers = {
      // summary:
      //		A map of available XHR transport handle types. Name matches the
      //		`handleAs` attribute passed to XHR calls.
      // description:
      //		A map of available XHR transport handle types. Name matches the
      //		`handleAs` attribute passed to XHR calls. Each contentHandler is
      //		called, passing the xhr object for manipulation. The return value
      //		from the contentHandler will be passed to the `load` or `handle`
      //		functions defined in the original xhr call.
      // example:
      //		Creating a custom content-handler:
      //	|	xhr.contentHandlers.makeCaps = function(xhr){
      //	|		return xhr.responseText.toUpperCase();
      //	|	}
      //	|	// and later:
      //	|	dojo.xhrGet({
      //	|		url:"foo.txt",
      //	|		handleAs:"makeCaps",
      //	|		load: function(data){ /* data is a toUpper version of foo.txt */ }
      //	|	});
      'text': function (xhr) {
        // summary:
        //		A contentHandler which simply returns the plaintext response data
        return xhr.responseText;
      },
      'json': function (xhr) {
        // summary:
        //		A contentHandler which returns a JavaScript object created from the response data
        return json.fromJson(xhr.responseText || null);
      },
      'json-comment-filtered': function (xhr) {
        // summary:
        //		A contentHandler which expects comment-filtered JSON.
        // description:
        //		A contentHandler which expects comment-filtered JSON.
        //		the json-comment-filtered option was implemented to prevent
        //		"JavaScript Hijacking", but it is less secure than standard JSON. Use
        //		standard JSON instead. JSON prefixing can be used to subvert hijacking.
        //
        //		Will throw a notice suggesting to use application/json mimetype, as
        //		json-commenting can introduce security issues. To decrease the chances of hijacking,
        //		use the standard `json` contentHandler, and prefix your "JSON" with: {}&&
        //
        //		use djConfig.useCommentedJson = true to turn off the notice
        if (!config.useCommentedJson) {
          console.warn('Consider using the standard mimetype:application/json.' + ' json-commenting can introduce security issues. To' + ' decrease the chances of hijacking, use the standard the \'json\' handler and' + ' prefix your json with: {}&&\n' + 'Use djConfig.useCommentedJson=true to turn off this message.');
        }
        var value = xhr.responseText;
        var cStartIdx = value.indexOf('/*');
        var cEndIdx = value.lastIndexOf('*/');
        if (cStartIdx == -1 || cEndIdx == -1) {
          throw new Error('JSON was not comment filtered');
        }
        return json.fromJson(value.substring(cStartIdx + 2, cEndIdx));
      },
      'javascript': function (xhr) {
        // summary:
        //		A contentHandler which evaluates the response data, expecting it to be valid JavaScript
        // FIXME: try Moz and IE specific eval variants?
        return dojo.eval(xhr.responseText);
      },
      'xml': function (xhr) {
        // summary:
        //		A contentHandler returning an XML Document parsed from the response data
        var result = xhr.responseXML;
        if (result && has('dom-qsa2.1') && !result.querySelectorAll && has('dom-parser')) {
          // http://bugs.dojotoolkit.org/ticket/15631
          // IE9 supports a CSS3 querySelectorAll implementation, but the DOM implementation 
          // returned by IE9 xhr.responseXML does not. Manually create the XML DOM to gain 
          // the fuller-featured implementation and avoid bugs caused by the inconsistency
          result = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
        if (has('ie')) {
          if (!result || !result.documentElement) {
            //WARNING: this branch used by the xml handling in dojo.io.iframe,
            //so be sure to test dojo.io.iframe if making changes below.
            var ms = function (n) {
              return 'MSXML' + n + '.DOMDocument';
            };
            var dp = [
              'Microsoft.XMLDOM',
              ms(6),
              ms(4),
              ms(3),
              ms(2)
            ];
            array.some(dp, function (p) {
              try {
                var dom = new ActiveXObject(p);
                dom.async = false;
                dom.loadXML(xhr.responseText);
                result = dom;
              } catch (e) {
                return false;
              }
              return true;
            });
          }
        }
        return result;  // DOMDocument
      },
      'json-comment-optional': function (xhr) {
        // summary:
        //		A contentHandler which checks the presence of comment-filtered JSON and
        //		alternates between the `json` and `json-comment-filtered` contentHandlers.
        if (xhr.responseText && /^[^{\[]*\/\*/.test(xhr.responseText)) {
          return handlers['json-comment-filtered'](xhr);
        } else {
          return handlers['json'](xhr);
        }
      }
    };
    /*=====
    
    	// kwargs function parameter definitions.   Assigning to dojo namespace rather than making them local variables
    	// because they are used by dojo/io modules too
    
    	dojo.__IoArgs = declare(null, {
    		// url: String
    		//		URL to server endpoint.
    		// content: Object?
    		//		Contains properties with string values. These
    		//		properties will be serialized as name1=value2 and
    		//		passed in the request.
    		// timeout: Integer?
    		//		Milliseconds to wait for the response. If this time
    		//		passes, the then error callbacks are called.
    		// form: DOMNode?
    		//		DOM node for a form. Used to extract the form values
    		//		and send to the server.
    		// preventCache: Boolean?
    		//		Default is false. If true, then a
    		//		"dojo.preventCache" parameter is sent in the request
    		//		with a value that changes with each request
    		//		(timestamp). Useful only with GET-type requests.
    		// handleAs: String?
    		//		Acceptable values depend on the type of IO
    		//		transport (see specific IO calls for more information).
    		// rawBody: String?
    		//		Sets the raw body for an HTTP request. If this is used, then the content
    		//		property is ignored. This is mostly useful for HTTP methods that have
    		//		a body to their requests, like PUT or POST. This property can be used instead
    		//		of postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.
    		// ioPublish: Boolean?
    		//		Set this explicitly to false to prevent publishing of topics related to
    		//		IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
    		//		will be published via dojo/topic.publish() for different phases of an IO operation.
    		//		See dojo/main.__IoPublish for a list of topics that are published.
    
    		load: function(response, ioArgs){
    			// summary:
    			//		This function will be
    			//		called on a successful HTTP response code.
    	 		// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    			// response: Object
    			//		The response in the format as defined with handleAs.
    		},
    
    		error: function(response, ioArgs){
    			// summary:
    			//		This function will
    			//		be called when the request fails due to a network or server error, the url
    			//		is invalid, etc. It will also be called if the load or handle callback throws an
    			//		exception, unless djConfig.debugAtAllCosts is true.	 This allows deployed applications
    			//		to continue to run even when a logic error happens in the callback, while making
    			//		it easier to troubleshoot while in debug mode.
    			// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    			// response: Object
    			//		The response in the format as defined with handleAs.
    		},
    
    		handle: function(loadOrError, response, ioArgs){
    			// summary:
    	 		//		This function will
    	 		//		be called at the end of every request, whether or not an error occurs.
    			// loadOrError: String
    			//		Provides a string that tells you whether this function
    			//		was called because of success (load) or failure (error).
    			// response: Object
    			//		The response in the format as defined with handleAs.
    			// ioArgs: dojo/main.__IoCallbackArgs
    			//		Provides additional information about the request.
    		}
    	});
    
    	dojo.__IoCallbackArgs = declare(null, {
    		// args: Object
    		//		the original object argument to the IO call.
    		// xhr: XMLHttpRequest
    		//		For XMLHttpRequest calls only, the
    		//		XMLHttpRequest object that was used for the
    		//		request.
    		// url: String
    		//		The final URL used for the call. Many times it
    		//		will be different than the original args.url
    		//		value.
    		// query: String
    		//		For non-GET requests, the
    		//		name1=value1&name2=value2 parameters sent up in
    		//		the request.
    		// handleAs: String
    		//		The final indicator on how the response will be
    		//		handled.
    		// id: String
    		//		For dojo/io/script calls only, the internal
    		//		script ID used for the request.
    		// canDelete: Boolean
    		//		For dojo/io/script calls only, indicates
    		//		whether the script tag that represents the
    		//		request can be deleted after callbacks have
    		//		been called. Used internally to know when
    		//		cleanup can happen on JSONP-type requests.
    		// json: Object
    		//		For dojo/io/script calls only: holds the JSON
    		//		response for JSONP-type requests. Used
    		//		internally to hold on to the JSON responses.
    		//		You should not need to access it directly --
    		//		the same object should be passed to the success
    		//		callbacks directly.
    	});
    
    	dojo.__IoPublish = declare(null, {
    		// summary:
    		//		This is a list of IO topics that can be published
    		//		if djConfig.ioPublish is set to true. IO topics can be
    		//		published for any Input/Output, network operation. So,
    		//		dojo.xhr, dojo.io.script and dojo.io.iframe can all
    		//		trigger these topics to be published.
    		// start: String
    		//		"/dojo/io/start" is sent when there are no outstanding IO
    		//		requests, and a new IO request is started. No arguments
    		//		are passed with this topic.
    		// send: String
    		//		"/dojo/io/send" is sent whenever a new IO request is started.
    		//		It passes the dojo.Deferred for the request with the topic.
    		// load: String
    		//		"/dojo/io/load" is sent whenever an IO request has loaded
    		//		successfully. It passes the response and the dojo.Deferred
    		//		for the request with the topic.
    		// error: String
    		//		"/dojo/io/error" is sent whenever an IO request has errored.
    		//		It passes the error and the dojo.Deferred
    		//		for the request with the topic.
    		// done: String
    		//		"/dojo/io/done" is sent whenever an IO request has completed,
    		//		either by loading or by erroring. It passes the error and
    		//		the dojo.Deferred for the request with the topic.
    		// stop: String
    		//		"/dojo/io/stop" is sent when all outstanding IO requests have
    		//		finished. No arguments are passed with this topic.
    	});
    	=====*/
    dojo._ioSetArgs = function (args, canceller, okHandler, errHandler) {
      // summary:
      //		sets up the Deferred and ioArgs property on the Deferred so it
      //		can be used in an io call.
      // args:
      //		The args object passed into the public io call. Recognized properties on
      //		the args object are:
      // canceller:
      //		The canceller function used for the Deferred object. The function
      //		will receive one argument, the Deferred object that is related to the
      //		canceller.
      // okHandler:
      //		The first OK callback to be registered with Deferred. It has the opportunity
      //		to transform the OK response. It will receive one argument -- the Deferred
      //		object returned from this function.
      // errHandler:
      //		The first error callback to be registered with Deferred. It has the opportunity
      //		to do cleanup on an error. It will receive two arguments: error (the
      //		Error object) and dfd, the Deferred object returned from this function.
      var ioArgs = {
        args: args,
        url: args.url
      };
      //Get values from form if requested.
      var formObject = null;
      if (args.form) {
        var form = dom.byId(args.form);
        //IE requires going through getAttributeNode instead of just getAttribute in some form cases,
        //so use it for all. See #2844
        var actnNode = form.getAttributeNode('action');
        ioArgs.url = ioArgs.url || (actnNode ? actnNode.value : null);
        formObject = domForm.toObject(form);
      }
      // set up the query params
      var miArgs = [{}];
      if (formObject) {
        // potentially over-ride url-provided params w/ form values
        miArgs.push(formObject);
      }
      if (args.content) {
        // stuff in content over-rides what's set by form
        miArgs.push(args.content);
      }
      if (args.preventCache) {
        miArgs.push({ 'dojo.preventCache': new Date().valueOf() });
      }
      ioArgs.query = ioq.objectToQuery(lang.mixin.apply(null, miArgs));
      // .. and the real work of getting the deferred in order, etc.
      ioArgs.handleAs = args.handleAs || 'text';
      var d = new Deferred(function (dfd) {
        dfd.canceled = true;
        canceller && canceller(dfd);
        var err = dfd.ioArgs.error;
        if (!err) {
          err = new Error('request cancelled');
          err.dojoType = 'cancel';
          dfd.ioArgs.error = err;
        }
        return err;
      });
      d.addCallback(okHandler);
      //Support specifying load, error and handle callback functions from the args.
      //For those callbacks, the "this" object will be the args object.
      //The callbacks will get the deferred result value as the
      //first argument and the ioArgs object as the second argument.
      var ld = args.load;
      if (ld && lang.isFunction(ld)) {
        d.addCallback(function (value) {
          return ld.call(args, value, ioArgs);
        });
      }
      var err = args.error;
      if (err && lang.isFunction(err)) {
        d.addErrback(function (value) {
          return err.call(args, value, ioArgs);
        });
      }
      var handle = args.handle;
      if (handle && lang.isFunction(handle)) {
        d.addBoth(function (value) {
          return handle.call(args, value, ioArgs);
        });
      }
      // Attach error handler last (not including topic publishing)
      // to catch any errors that may have been generated from load
      // or handle functions.
      d.addErrback(function (error) {
        return errHandler(error, d);
      });
      //Plug in topic publishing, if dojo.publish is loaded.
      if (cfg.ioPublish && dojo.publish && ioArgs.args.ioPublish !== false) {
        d.addCallbacks(function (res) {
          dojo.publish('/dojo/io/load', [
            d,
            res
          ]);
          return res;
        }, function (res) {
          dojo.publish('/dojo/io/error', [
            d,
            res
          ]);
          return res;
        });
        d.addBoth(function (res) {
          dojo.publish('/dojo/io/done', [
            d,
            res
          ]);
          return res;
        });
      }
      d.ioArgs = ioArgs;
      // FIXME: need to wire up the xhr object's abort method to something
      // analogous in the Deferred
      return d;
    };
    var _deferredOk = function (dfd) {
      // summary:
      //		okHandler function for dojo._ioSetArgs call.
      var ret = handlers[dfd.ioArgs.handleAs](dfd.ioArgs.xhr);
      return ret === undefined ? null : ret;
    };
    var _deferError = function (error, dfd) {
      // summary:
      //		errHandler function for dojo._ioSetArgs call.
      if (!dfd.ioArgs.args.failOk) {
        console.error(error);
      }
      return error;
    };
    //Use a separate count for knowing if we are starting/stopping io calls.
    var _checkPubCount = function (dfd) {
      if (_pubCount <= 0) {
        _pubCount = 0;
        if (cfg.ioPublish && dojo.publish && (!dfd || dfd && dfd.ioArgs.args.ioPublish !== false)) {
          dojo.publish('/dojo/io/stop');
        }
      }
    };
    var _pubCount = 0;
    aspect.after(watch, '_onAction', function () {
      _pubCount -= 1;
    });
    aspect.after(watch, '_onInFlight', _checkPubCount);
    dojo._ioCancelAll = watch.cancelAll;
    /*=====
    	dojo._ioCancelAll = function(){
    		// summary:
    		//		Cancels all pending IO requests, regardless of IO type
    		//		(xhr, script, iframe).
    	};
    	=====*/
    dojo._ioNotifyStart = function (dfd) {
      // summary:
      //		If dojo.publish is available, publish topics
      //		about the start of a request queue and/or the
      //		the beginning of request.
      //
      //		Used by IO transports. An IO transport should
      //		call this method before making the network connection.
      if (cfg.ioPublish && dojo.publish && dfd.ioArgs.args.ioPublish !== false) {
        if (!_pubCount) {
          dojo.publish('/dojo/io/start');
        }
        _pubCount += 1;
        dojo.publish('/dojo/io/send', [dfd]);
      }
    };
    dojo._ioWatch = function (dfd, validCheck, ioCheck, resHandle) {
      // summary:
      //		Watches the io request represented by dfd to see if it completes.
      // dfd: Deferred
      //		The Deferred object to watch.
      // validCheck: Function
      //		Function used to check if the IO request is still valid. Gets the dfd
      //		object as its only argument.
      // ioCheck: Function
      //		Function used to check if basic IO call worked. Gets the dfd
      //		object as its only argument.
      // resHandle: Function
      //		Function used to process response. Gets the dfd
      //		object as its only argument.
      var args = dfd.ioArgs.options = dfd.ioArgs.args;
      lang.mixin(dfd, {
        response: dfd.ioArgs,
        isValid: function (response) {
          return validCheck(dfd);
        },
        isReady: function (response) {
          return ioCheck(dfd);
        },
        handleResponse: function (response) {
          return resHandle(dfd);
        }
      });
      watch(dfd);
      _checkPubCount(dfd);
    };
    var _defaultContentType = 'application/x-www-form-urlencoded';
    dojo._ioAddQueryToUrl = function (ioArgs) {
      // summary:
      //		Adds query params discovered by the io deferred construction to the URL.
      //		Only use this for operations which are fundamentally GET-type operations.
      if (ioArgs.query.length) {
        ioArgs.url += (ioArgs.url.indexOf('?') == -1 ? '?' : '&') + ioArgs.query;
        ioArgs.query = null;
      }
    };
    /*=====
    	dojo.__XhrArgs = declare(dojo.__IoArgs, {
    		// summary:
    		//		In addition to the properties listed for the dojo._IoArgs type,
    		//		the following properties are allowed for dojo.xhr* methods.
    		// handleAs: String?
    		//		Acceptable values are: text (default), json, json-comment-optional,
    		//		json-comment-filtered, javascript, xml. See `dojo/_base/xhr.contentHandlers`
    	 	// sync: Boolean?
    		//		false is default. Indicates whether the request should
    		//		be a synchronous (blocking) request.
    		// headers: Object?
    		//		Additional HTTP headers to send in the request.
    		// failOk: Boolean?
    		//		false is default. Indicates whether a request should be
    		//		allowed to fail (and therefore no console error message in
    		//		the event of a failure)
    		// contentType: String|Boolean
    		//		"application/x-www-form-urlencoded" is default. Set to false to
    		//		prevent a Content-Type header from being sent, or to a string
    		//		to send a different Content-Type.
    	 });
    	=====*/
    dojo.xhr = function (method, args, hasBody) {
      // summary:
      //		Deprecated.   Use dojo/request instead.
      // description:
      //		Sends an HTTP request with the given method.
      //		See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
      //		for those HTTP methods. There are also methods for "raw" PUT and POST methods
      //		via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.
      // method:
      //		HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.
      // hasBody:
      //		If the request has an HTTP body, then pass true for hasBody.
      var rDfd;
      //Make the Deferred object for this xhr request.
      var dfd = dojo._ioSetArgs(args, function (dfd) {
        rDfd && rDfd.cancel();
      }, _deferredOk, _deferError);
      var ioArgs = dfd.ioArgs;
      //Allow for specifying the HTTP body completely.
      if ('postData' in args) {
        ioArgs.query = args.postData;
      } else if ('putData' in args) {
        ioArgs.query = args.putData;
      } else if ('rawBody' in args) {
        ioArgs.query = args.rawBody;
      } else if (arguments.length > 2 && !hasBody || 'POST|PUT'.indexOf(method.toUpperCase()) === -1) {
        //Check for hasBody being passed. If no hasBody,
        //then only append query string if not a POST or PUT request.
        dojo._ioAddQueryToUrl(ioArgs);
      }
      var options = {
        method: method,
        handleAs: 'text',
        timeout: args.timeout,
        withCredentials: args.withCredentials,
        ioArgs: ioArgs
      };
      if (typeof args.headers !== 'undefined') {
        options.headers = args.headers;
      }
      if (typeof args.contentType !== 'undefined') {
        if (!options.headers) {
          options.headers = {};
        }
        options.headers['Content-Type'] = args.contentType;
      }
      if (typeof ioArgs.query !== 'undefined') {
        options.data = ioArgs.query;
      }
      if (typeof args.sync !== 'undefined') {
        options.sync = args.sync;
      }
      dojo._ioNotifyStart(dfd);
      try {
        rDfd = _xhr(ioArgs.url, options, true);
      } catch (e) {
        dfd.cancel();
        return dfd;
      }
      // sync ioArgs
      dfd.ioArgs.xhr = rDfd.response.xhr;
      rDfd.then(function () {
        dfd.resolve(dfd);
      }).otherwise(function (error) {
        ioArgs.error = error;
        if (error.response) {
          error.status = error.response.status;
          error.responseText = error.response.text;
          error.xhr = error.response.xhr;
        }
        dfd.reject(error);
      });
      return dfd;  // dojo/_base/Deferred
    };
    dojo.xhrGet = function (args) {
      // summary:
      //		Sends an HTTP GET request to the server.
      return dojo.xhr('GET', args);  // dojo/_base/Deferred
    };
    dojo.rawXhrPost = dojo.xhrPost = function (args) {
      // summary:
      //		Sends an HTTP POST request to the server. In addition to the properties
      //		listed for the dojo.__XhrArgs type, the following property is allowed:
      // postData:
      //		String. Send raw data in the body of the POST request.
      return dojo.xhr('POST', args, true);  // dojo/_base/Deferred
    };
    dojo.rawXhrPut = dojo.xhrPut = function (args) {
      // summary:
      //		Sends an HTTP PUT request to the server. In addition to the properties
      //		listed for the dojo.__XhrArgs type, the following property is allowed:
      // putData:
      //		String. Send raw data in the body of the PUT request.
      return dojo.xhr('PUT', args, true);  // dojo/_base/Deferred
    };
    dojo.xhrDelete = function (args) {
      // summary:
      //		Sends an HTTP DELETE request to the server.
      return dojo.xhr('DELETE', args);  // dojo/_base/Deferred
    };
    /*
    	dojo.wrapForm = function(formNode){
    		// summary:
    		//		A replacement for FormBind, but not implemented yet.
    
    		// FIXME: need to think harder about what extensions to this we might
    		// want. What should we allow folks to do w/ this? What events to
    		// set/send?
    		throw new Error("dojo.wrapForm not yet implemented");
    	}
    	*/
    dojo._isDocumentOk = function (x) {
      return util.checkStatus(x.status);
    };
    dojo._getText = function (url) {
      var result;
      dojo.xhrGet({
        url: url,
        sync: true,
        load: function (text) {
          result = text;
        }
      });
      return result;
    };
    // Add aliases for static functions to dojo.xhr since dojo.xhr is what's returned from this module
    lang.mixin(dojo.xhr, {
      _xhrObj: dojo._xhrObj,
      fieldToObject: domForm.fieldToObject,
      formToObject: domForm.toObject,
      objectToQuery: ioq.objectToQuery,
      formToQuery: domForm.toQuery,
      formToJson: domForm.toJson,
      queryToObject: ioq.queryToObject,
      contentHandlers: handlers,
      _ioSetArgs: dojo._ioSetArgs,
      _ioCancelAll: dojo._ioCancelAll,
      _ioNotifyStart: dojo._ioNotifyStart,
      _ioWatch: dojo._ioWatch,
      _ioAddQueryToUrl: dojo._ioAddQueryToUrl,
      _isDocumentOk: dojo._isDocumentOk,
      _getText: dojo._getText,
      get: dojo.xhrGet,
      post: dojo.xhrPost,
      put: dojo.xhrPut,
      del: dojo.xhrDelete
    });
    return dojo.xhr;
  }(dojo__base_kernel, dojo__base_sniff, {}, dojo_io_query, dojo_dom, dojo_dom_form, dojo__base_Deferred, dojo__base_config, dojo__base_json, dojo__base_lang, dojo__base_array, dojo_on, dojo_aspect, dojo_request_watch, dojo_request_xhr, dojo_request_util);
  dojo_request_script = function (watch, util, kernel, array, lang, on, dom, has, win) {
    has.add('script-readystatechange', function (global, document) {
      var script = document.createElement('script');
      return typeof script['onreadystatechange'] !== 'undefined' && (typeof global['opera'] === 'undefined' || global['opera'].toString() !== '[object Opera]');
    });
    var mid = 'rqst_cobr' + ~~(Math.random() * 10000000),
      //module.id.replace(/[\/\.\-]/g, '_'), //PATCHED TO SUPPORT AMD CLEAN
      counter = 0, loadEvent = has('script-readystatechange') ? 'readystatechange' : 'load', readyRegExp = /complete|loaded/, callbacks = kernel.global[mid + '_callbacks'] = {}, deadScripts = [];
    function attach(id, url, frameDoc) {
      var doc = frameDoc || win.doc, element = doc.createElement('script');
      element.type = 'text/javascript';
      element.src = url;
      element.id = id;
      element.async = true;
      element.charset = 'utf-8';
      return doc.getElementsByTagName('head')[0].appendChild(element);
    }
    function remove(id, frameDoc, cleanup) {
      var node = dom.byId(id, frameDoc);
      node.parentNode.removeChild(node);
      // domConstruct.destroy
      if (callbacks[id]) {
        if (cleanup) {
          // set callback to a function that deletes itself so requests that
          // are in-flight don't error out when returning and also
          // clean up after themselves
          callbacks[id] = function () {
            delete callbacks[id];
          };
        } else {
          delete callbacks[id];
        }
      }
    }
    function _addDeadScript(dfd) {
      // Be sure to check ioArgs because it can dynamically change in the dojox/io plugins.
      // See http://bugs.dojotoolkit.org/ticket/15890.
      var options = dfd.response.options, frameDoc = options.ioArgs ? options.ioArgs.frameDoc : options.frameDoc;
      deadScripts.push({
        id: dfd.id,
        frameDoc: frameDoc
      });
      if (options.ioArgs) {
        options.ioArgs.frameDoc = null;
      }
      options.frameDoc = null;
    }
    function canceler(dfd, response) {
      if (dfd.canDelete) {
        //For timeouts and cancels, remove the script element immediately to
        //avoid a response from it coming back later and causing trouble.
        script._remove(dfd.id, response.options.frameDoc, true);
      }
    }
    function isValid(response) {
      //Do script cleanup here. We wait for one inflight pass
      //to make sure we don't get any weird things by trying to remove a script
      //tag that is part of the call chain (IE 6 has been known to
      //crash in that case).
      if (deadScripts && deadScripts.length) {
        array.forEach(deadScripts, function (_script) {
          script._remove(_script.id, _script.frameDoc);
          _script.frameDoc = null;
        });
        deadScripts = [];
      }
      return response.options.jsonp ? !response.data : true;
    }
    function isReadyScript(response) {
      return !!this.scriptLoaded;
    }
    function isReadyCheckString(response) {
      var checkString = response.options.checkString;
      return checkString && eval('typeof(' + checkString + ') !== "undefined"');
    }
    function handleResponse(response, error) {
      if (this.canDelete) {
        _addDeadScript(this);
      }
      if (error) {
        this.reject(error);
      } else {
        this.resolve(response);
      }
    }
    function script(url, options, returnDeferred) {
      var response = util.parseArgs(url, util.deepCopy({}, options));
      url = response.url;
      options = response.options;
      var dfd = util.deferred(response, canceler, isValid, options.jsonp ? null : options.checkString ? isReadyCheckString : isReadyScript, handleResponse);
      lang.mixin(dfd, {
        id: mid + counter++,
        canDelete: false
      });
      if (options.jsonp) {
        var queryParameter = new RegExp('[?&]' + options.jsonp + '=');
        if (!queryParameter.test(url)) {
          url += (~url.indexOf('?') ? '&' : '?') + options.jsonp + '=' + (options.frameDoc ? 'parent.' : '') + mid + '_callbacks.' + dfd.id;
        }
        dfd.canDelete = true;
        callbacks[dfd.id] = function (json) {
          response.data = json;
          dfd.handleResponse(response);
        };
      }
      if (util.notify) {
        util.notify.emit('send', response, dfd.promise.cancel);
      }
      if (!options.canAttach || options.canAttach(dfd)) {
        var node = script._attach(dfd.id, url, options.frameDoc);
        if (!options.jsonp && !options.checkString) {
          var handle = on(node, loadEvent, function (evt) {
            if (evt.type === 'load' || readyRegExp.test(node.readyState)) {
              handle.remove();
              dfd.scriptLoaded = evt;
            }
          });
        }
      }
      watch(dfd);
      return returnDeferred ? dfd : dfd.promise;
    }
    script.get = script;
    /*=====
    	script = function(url, options){
    		// summary:
    		//		Sends a request using a script element with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/script.__Options?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	script.__BaseOptions = declare(request.__BaseOptions, {
    		// jsonp: String?
    		//		The URL parameter name that indicates the JSONP callback string.
    		//		For instance, when using Yahoo JSONP calls it is normally,
    		//		jsonp: "callback". For AOL JSONP calls it is normally
    		//		jsonp: "c".
    		// checkString: String?
    		//		A string of JavaScript that when evaluated like so:
    		//		"typeof(" + checkString + ") != 'undefined'"
    		//		being true means that the script fetched has been loaded.
    		//		Do not use this if doing a JSONP type of call (use `jsonp` instead).
    		// frameDoc: Document?
    		//		The Document object of a child iframe. If this is passed in, the script
    		//		will be attached to that document. This can be helpful in some comet long-polling
    		//		scenarios with Firefox and Opera.
    	});
    	script.__MethodOptions = declare(null, {
    		// method: String?
    		//		This option is ignored. All requests using this transport are
    		//		GET requests.
    	});
    	script.__Options = declare([script.__BaseOptions, script.__MethodOptions]);
    
    	script.get = function(url, options){
    		// summary:
    		//		Send an HTTP GET request using a script element with the given URL and options.
    		// url: String
    		//		URL to request
    		// options: dojo/request/script.__BaseOptions?
    		//		Options for the request.
    		// returns: dojo/request.__Promise
    	};
    	=====*/
    // TODO: Remove in 2.0
    script._attach = attach;
    script._remove = remove;
    script._callbacksProperty = mid + '_callbacks';
    return script;
  }(dojo_request_watch, dojo_request_util, dojo__base_kernel, dojo__base_array, dojo__base_lang, dojo_on, dojo_dom, dojo_has, dojo__base_window);
  dojox_cometd = function (cometdModule, JSON, dojox, dojoXHR, dojoSCRIPT) {
    function LongPollingTransport() {
      var _super = new cometdModule.LongPollingTransport();
      var that = cometdModule.Transport.derive(_super);
      that.xhrSend = function (packet) {
        var deferred = dojoXHR.post({
          url: packet.url,
          sync: packet.sync === true,
          contentType: 'application/json;charset=UTF-8',
          headers: packet.headers,
          postData: packet.body,
          withCredentials: true,
          handleAs: 'json',
          load: packet.onSuccess,
          error: function (error) {
            packet.onError(error.message, deferred ? deferred.ioArgs.error : error);
          }
        });
        return deferred.ioArgs.xhr;
      };
      return that;
    }
    // function CallbackPollingTransport() {
    //     var _super = new cometdModule.CallbackPollingTransport();
    //     var that = cometdModule.Transport.derive(_super);
    //
    //     that.jsonpSend = function(packet) {
    //         dojoSCRIPT.get(packet.url, {
    //             jsonp: 'jsonp',
    //             query: {
    //                 // In callback-polling, the content must be sent via the 'message' parameter
    //                 message: packet.body
    //             },
    //             sync: packet.sync === true
    //         }).then(packet.onSuccess, function(error) {
    //             // Actually never called by Dojo, perhaps a Dojo bug.
    //             packet.onError(error);
    //         });
    //         return undefined;
    //     };
    //
    //     return that;
    // }
    dojox.CometD = function (name) {
      var cometd = new cometdModule.CometD(name);
      cometd.unregisterTransports();
      // Registration order is important.
      if (window.WebSocket) {
        cometd.registerTransport('websocket', new cometdModule.WebSocketTransport());
      }
      cometd.registerTransport('long-polling', new LongPollingTransport());
      // cometd.registerTransport('callback-polling', new CallbackPollingTransport()); PATCHED
      return cometd;
    };
    // The default cometd instance
    var cometd = new dojox.CometD();
    dojox.cometd = cometd;
    return cometd;
  }(org_cometd, dojo_json, dojox, dojo__base_xhr, dojo_request_script);
  /*
   * Copyright (c) 2008-2017 the original author or authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (function () {
    function bind(org_cometd) {
      if (!org_cometd.COOKIE) {
        org_cometd.COOKIE = {};
        org_cometd.COOKIE.set = function (name, value, options) {
          throw 'Abstract';
        };
        org_cometd.COOKIE.get = function (name) {
          throw 'Abstract';
        };
      }
      /**
       * The reload extension allows a page to be loaded (or reloaded)
       * without having to re-handshake in the new (or reloaded) page,
       * therefore resuming the existing CometD connection.
       *
       * When the reload() method is called, the state of the CometD
       * connection is stored in the window.sessionStorage object.
       * The reload() method must therefore be called by page unload
       * handlers, often provided by JavaScript toolkits.
       *
       * When the page is (re)loaded, this extension checks the
       * window.sessionStorage and restores the CometD connection,
       * maintaining the same CometD clientId.
       */
      return org_cometd.ReloadExtension = function (configuration) {
        var _cometd;
        var _debug;
        var _state = {};
        var _cookieName = 'org.cometd.reload';
        var _cookiePath = '/';
        var _cookieMaxAge = 5;
        var _cookieDomain = window.location.host;
        var _batch = false;
        var _reloading = false;
        var _cookie;
        this.setCookie = function (cookie) {
          _cookie = cookie;
        };
        function _reload(config) {
          if (_state.handshakeResponse) {
            // _reloading = true; //PATCHED
            // var transport = _cometd.getTransport();
            // if (transport) {
            //     transport.abort();
            // }
            _configure(config);
            var cookie = JSON.stringify(_state);
            _debug('Reload extension saving state', cookie);
            org_cometd.COOKIE.set(_cookieName, cookie, {
              'max-age': _cookieMaxAge,
              path: _cookiePath,
              domain: _cookieDomain,
              expires: 1800000
            });
          }
        }
        function _setReloadCookie() {
          _state.cookiePath = _cookiePath;
          var cookie = JSON.stringify(_state);
          org_cometd.COOKIE.set(_cookieName, cookie);
        }
        function _similarState(oldState) {
          // We want to check here that the CometD object
          // did not change much between reloads.
          // We just check the URL for now, but in future
          // further checks may involve the transport type
          // and other configuration parameters.
          return _state.url == oldState.url;
        }
        function _configure(config) {
          if (config) {
            if (typeof config.cookieMaxAge === 'number') {
              _cookieMaxAge = config.cookieMaxAge;
            }
            if (typeof config.cookieName === 'string') {
              _cookieName = config.cookieName;
            }
            if (typeof config.cookiePath === 'string') {
              _cookiePath = config.cookiePath;
            }
            if (typeof config.cookieDomain === 'string') {
              _cookieDomain = config.cookieDomain;
            }
          }
        }
        function _receive(response) {
          _cometd.receive(response);
        }
        this.configure = _configure;
        this._receive = _receive;
        this.registered = function (name, cometd) {
          _cometd = cometd;
          _cometd.reload = _reload;
          _cometd.setReloadCookie = _setReloadCookie;
          _debug = _cometd._debug;
        };
        this.unregistered = function () {
          delete _cometd.reload;
          _cometd = null;
        };
        this.outgoing = function (message) {
          switch (message.channel) {
          case '/meta/handshake': {
              _state = {};
              _state.url = _cometd.getURL();
              _debug('Reload extension found state', _cookie);
              // Is there a saved handshake response from a prior load ?
              if (_cookie) {
                try {
                  var oldState = JSON.parse(_cookie);
                  _cookie = null;
                  if (oldState.handshakeResponse && _similarState(oldState)) {
                    _debug('Reload extension restoring state', oldState);
                    // Since we are going to abort this message,
                    // we must save an eventual callback to restore
                    // it when we replay the handshake response.
                    var callback = _cometd._getCallback(message.id);
                    var self = this;
                    setTimeout(function () {
                      _debug('Reload extension replaying handshake response', oldState.handshakeResponse);
                      _state.handshakeResponse = oldState.handshakeResponse;
                      _state.transportType = oldState.transportType;
                      // Restore the callback.
                      _cometd._putCallback(message.id, callback);
                      var response = _cometd._mixin(true, {}, _state.handshakeResponse, {
                        // Keep the response message id the same as the request.
                        id: message.id,
                        // Tells applications this is a handshake replayed by the reload extension.
                        ext: { reload: true }
                      });
                      // Use the same transport as before.
                      if (!_state.transportType) {
                        _state.transportType = 'websocket';
                      }
                      response.supportedConnectionTypes = [_state.transportType];
                      self._receive(response);
                      _debug('Reload extension replayed handshake response', response);
                    }, 0);
                    // Delay any sends until first connect is complete.
                    // This avoids that there is an old /meta/connect pending on server
                    // that will be resumed to send messages to the client, when the
                    // client has already closed the connection, thereby losing the messages.
                    // if (!_batch) {
                    //     _batch = true;
                    //     _cometd.startBatch();
                    // }
                    // This handshake is aborted, as we will replay the prior handshake response
                    return null;
                  } else {
                    _debug('Reload extension could not restore state', oldState);
                  }
                } catch (x) {
                  _debug('Reload extension error while trying to restore state', x);
                }
              }
              break;
            }
          case '/meta/connect': {
              if (_reloading === true) {
                // The reload causes the failure of the outstanding /meta/connect,
                // which CometD will react to by sending another. Here we avoid
                // that /meta/connect messages are sent between the reload and
                // the destruction of the JavaScript context, so that we are sure
                // that the first /meta/connect is the one triggered after the
                // replay of the /meta/handshake by this extension.
                _debug('Reload extension aborting /meta/connect during reload');
                return null;
              }
              if (!_state.transportType) {
                _state.transportType = message.connectionType;
                _debug('Reload extension tracked transport type', _state.transportType);
              }
              break;
            }
          case '/meta/disconnect': {
              _state = {};
              break;
            }
          default: {
              break;
            }
          }
          return message;
        };
        this.incoming = function (message) {
          if (message.successful) {
            switch (message.channel) {
            case '/meta/handshake': {
                // If the handshake response is already present, then we're replaying it.
                // Since the replay may have modified the handshake response, do not record it here.
                if (!_state.handshakeResponse) {
                  // Save successful handshake response
                  _state.handshakeResponse = message;
                  _debug('Reload extension tracked handshake response', message);
                }
                break;
              }
            case '/meta/connect': {
                // if (_batch) {
                //     _batch = false;
                //     _cometd.endBatch();
                // }
                break;
              }
            case '/meta/disconnect': {
                _state = {};
                break;
              }
            default: {
                break;
              }
            }
          }
          return message;
        };
        _configure(configuration);
      };
    }
    if (true) {
      org_cometd_ReloadExtensionLP = function (org_cometd) {
        return typeof bind === 'function' ? bind(org_cometd) : bind;
      }(org_cometd);
    } else {
      bind(org.cometd);
    }
  }());
  dojox_cometd_reloadLP = function (org_cometd, domReady, lang, storage, ReloadExtensionLP, cometd, constants) {
    var reloadExtension = new ReloadExtensionLP();
    cometd.registerExtension('reload', reloadExtension);
    domReady(function () {
      storage.init({
        site: synchroniteConfig.tenantId,
        cobrowseBaseUrl: synchroniteConfig.serverUrl || window.location.protocol + '//' + synchroniteConfig.tenantHost
      });
      storage.getValue(constants.cometReloadKey, function (cookie) {
        if (cookie) {
          console.log('got cookie, set it in reload extension');
          reloadExtension.setCookie(cookie);
        } else {
          console.log('no valid reload cookie found');
        }
      });
    });
    // Remap cometd COOKIE functions to dojo cookie functions
    org_cometd.COOKIE.set = lang.hitch(storage, storage.setValue);
    org_cometd.COOKIE.get = lang.hitch(storage, storage.getValue);
    org_cometd.COOKIE.remove = lang.hitch(storage, storage.removeValue);
    return reloadExtension;
  }(org_cometd, dojo_domReady, dojo__base_lang, synchronite_proxyless_storage, org_cometd_ReloadExtensionLP, dojox_cometd, synchronite_constants_constants);
  dojo_request = function (xhr) {
    return xhr;
  }(dojo_request_xhr);
  synchronite_proxyless_datachannel = function (strings, constants, utils, storage, participantNotification, reconnectNotification, LargeMessageExtension, baseUrl, microDom, dojoxCometd, cometdReloadLP, on, has, request, lang, Evented) {
    var win = window, config = synchroniteConfig, events = new Evented();
    window.stopSignal = false;
    // _handlePageHide function is needed to remove the active cobrowse flag status from local storage
    // when the user navigates to different page from the session's history [back button].
    var _handlePageHide = function () {
      if (window.stopSignal === true) {
        return;
      }
      console.debug('datachannel _handlePageHide pagehide');
      storage.removeValueInLocalStorage(constants.cobrowseActive);
      if (!config.isSlave) {
        window.stopSignal = true;
        DataChannel.send(constants.EVENT.LOADING, { begin: true });
      }
      try {
        // http://bugs.cometd.org/browse/COMETD-388
        var transport = dojoxCometd.getTransport();
        if (transport && transport.abort) {
          console.debug('datachannel.js _handlePageHide inside try if block');
          transport.abort();
        }
      } catch (e) {
        console.log('datachannel.js _handlePageHide inside catch block: ', e);
      }
    };
    //_handleBeforeUnload function is needed to remove the active cobrowse flag status from local storage.
    var _handleBeforeUnload = function () {
      if (window.stopSignal === true) {
        console.debug('datachannel _handleBeforeUnload beforeunload stopSignal', window.stopSignal);
        return;
      }
      console.debug('datachannel _handleBeforeUnload');
      storage.removeValueInLocalStorage(constants.cobrowseActive);
      if (!config.isSlave) {
        window.stopSignal = true;
        DataChannel.send(constants.EVENT.LOADING, { begin: true });
      }
      try {
        // http://bugs.cometd.org/browse/COMETD-388
        var transport = dojoxCometd.getTransport();
        if (transport && transport.abort) {
          console.debug('datachannel.js _handleBeforeUnload inside try if block');
          transport.abort();
        }
      } catch (e) {
        console.log('datachannel.js _handleBeforeUnload inside catch block: ', e);
      }
    };
    var DataChannel = {
      registeredHandlers: [],
      _disconnecting: false,
      _connected: false,
      userId: null,
      subscriptions: [],
      ticket: null,
      handshakeListener: null,
      connectListener: null,
      unsuccessfulListener: null,
      heartbeatInterval: null,
      sendingDom: false,
      sid: null,
      endSessionTimeoutRef: null,
      retryCount: 5,
      init: function (ticketid, sid) {
        console.debug('datachannel.js init()');
        if (this._connected) {
          return;
        }
        this.ticket = ticketid;
        this.sendingDom = false;
        this.sid = sid;
        var that = this;
        // if (has("ios") || !!(navigator.userAgent.match(/Mac/) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2)) {
        //     console.log("Touch device detected");
        //     console.log("datachannel.js")
        //     microDom.addEvent(win, "pagehide", _handleWinUnload);
        // } else {
        //     microDom.addEvent(win, "beforeunload", _handleWinUnload);
        // }
        microDom.addEvent(win, 'pagehide', _handlePageHide);
        microDom.addEvent(win, 'beforeunload', _handleBeforeUnload);
        this.getOrCreateUserId(function () {
          var cfg = window.proxylessConfig || window.callConfig;
          var existingComet = cfg && cfg.comet;
          if (existingComet && !existingComet.isDisconnected()) {
            dojoxCometd = existingComet;
            that._connected = true;
            that._disconnecting = false;
            that.configureComet();
            that._connectionEstablished();
          } else {
            that.configureComet();
            that.initializeComet();
          }
        });
      },
      on: function (type, cb) {
        return events.on(type, cb);
      },
      once: function (type, cb) {
        var signal = events.on(type, function () {
          signal.remove();
          return cb.apply(this, arguments);
        });
        return signal;
      },
      getOrCreateUserId: function (callback) {
        var that = this;
        storage.getValue(constants.userIdKey, function (userid) {
          if (userid) {
            console.debug('dataChannel.js getOrCreateUserId if userid', userid);
            that.userId = userid;
            callback(userid);
          } else {
            that.userId = ~~(Math.random() * 1000000);
            console.debug('no userid found, create new id:' + that.userId);
            storage.setValue({
              key: constants.userIdKey,
              value: that.userId
            });
            callback(that.userid);
          }
        }, function (err) {
          if (that.retryCount > 1) {
            that.init();
            that.retryCount = that.retryCount - 1;
          }
          console.debug('dataChannel.js getOrCreateUserId error', err);
        });
      },
      configureComet: function () {
        this.handshakeListener = dojoxCometd.addListener('/meta/handshake', lang.hitch(this, this._metaHandshake));
        this.connectListener = dojoxCometd.addListener('/meta/connect', lang.hitch(this, this._metaConnect));
        this.unsuccessfulListener = dojoxCometd.addListener('/meta/unsuccessful', lang.hitch(this, this._metaUnsuccessful));
      },
      removeListeners: function () {
        dojoxCometd.removeListener(this.handshakeListener);
        dojoxCometd.removeListener(this.unsuccessfulListener);
        dojoxCometd.removeListener(this.connectListener);
        this.removeSubscriptions();
      },
      removeSubscriptions: function () {
        for (var i = 0; i < this.subscriptions.length; i++) {
          dojoxCometd.unsubscribe(this.subscriptions[i]);
        }
        this.subscriptions = [];
      },
      initializeComet: function () {
        var cometdUrl = 'https://' + config.cometUrl + '/sync';
        dojoxCometd.configure({
          url: cometdUrl,
          logLevel: 'info',
          autoBatch: true,
          maxNetworkDelay: 15000,
          maxBackoff: 30000
        });
        // comet reload is needed to detect comet sessions across page loads.
        cometdReloadLP.configure({
          cookieName: 's.connect',
          cookieMaxAge: 40,
          cookieDomain: baseUrl.getHostWithoutSubdomains()
        });
        var isSafari13 = has('safari') === 13;
        // see CC-1775. Remove once safari bug is fixed.
        if (synchroniteConfig.disableWebsockets || isSafari13) {
          console.debug('dataChannel.js if (synchroniteConfig.disableWebsockets || isSafari13) {', synchroniteConfig.disableWebsockets, isSafari13);
          dojoxCometd.unregisterTransport('websocket');
          dojoxCometd.websocketEnabled = false;
        }
        dojoxCometd.ackEnabled = false;
        dojoxCometd.onListenerException = function (exception, subscriptionHandle, isListener, cometdMessage) {
          console.error('Exception', exception);
          console.error('stack', exception.stack);
          console.error('subscriptionHandle', subscriptionHandle);
          console.error('isListener', isListener);
          console.error('ListenerException', cometdMessage);
        };
        dojoxCometd.registerExtension('largeMessage', LargeMessageExtension);
        dojoxCometd.handshake();
      },
      send: function (type, msg, callback) {
        var message = {
          type: type,
          senderId: +this.userId,
          msg: msg
        };
        if (this._connected) {
          dojoxCometd.publish(constants.defaultChannel + '/' + config.tenantId + '/' + this.ticket, message, this.getSubscribeProps(), callback);
        }
      },
      handleMessage: function (message) {
        reconnectNotification.connectionHealthy();
        var msg = message.data;
        // eslint-disable-next-line eqeqeq
        if (msg && msg.senderId != this.userId) {
          if (!msg.type) {
            console.error('Unexpected message: ' + JSON.stringify(message));
            return;
          }
          for (var i = 0; i < this.registeredHandlers.length; i++) {
            var handler = this.registeredHandlers[i];
            if (handler.type === msg.type) {
              handler.handleMessage(msg.msg);
            }
          }
        }
      },
      getUserId: function () {
        return this.userId;
      },
      addHandler: function (handler) {
        this.registeredHandlers.push(handler);
      },
      isConnected: function () {
        return this._connected;
      },
      handleService: function (message) {
        console.log('handleService.message', message);
        if (message.data.iceServers) {
          events.emit(constants.EVENT.TURNCONFIG, message.data);
          return;
        }
        if (message.data.endSession) {
          this.disconnect(message.data);
          return;
        }
        if (!message.data.members) {
          console.log('handleService - message.data.members is missing.', { message: message });
          return;
        }
        participantNotification.addParticipantInfo(message.data);
      },
      onParticipantConnected: function () {
        events.emit('connected');
        this._startHeartbeat();
        participantNotification.startObserving(this.userId);
      },
      endSession: function () {
        console.log('endSession called');
        var msg = {
          senderId: +this.userId,
          isAgent: config.isAgent,
          endSession: true
        };
        dojoxCometd.publish(constants.serviceChannel + '/' + config.tenantId + '/' + this.ticket, msg, this.getSubscribeProps());
        var that = this;
        this.endSessionTimeoutRef = setTimeout(function () {
          var info = {
            endedBy: {
              userId: +that.userId,
              isAgent: config.isAgent
            }
          };
          events.emit(constants.EVENT.ENDSESSION, info);
        }, 2000);
      },
      disconnect: function (message) {
        this._stopHeartbeat();
        participantNotification.stopObserving();
        if (!this._connected) {
          console.log('disconnect called, but already disconnected');
          return;
        }
        this.removeListeners();
        console.log('disconnect called');
        this._connected = false;
        setTimeout(function () {
          console.log('disconnect cometd');
          try {
            var transport = dojoxCometd.getTransport();
            if (transport && transport.abort) {
              console.debug('datachannel.js disconnect inside try if block');
              transport.abort();
            }
          } catch (e) {
            console.log('datachannel.js disconnect inside catch block: ', e);
          }
          dojoxCometd.disconnect();
        }, 0);
        clearTimeout(this.endSessionTimeoutRef);
        if (message) {
          events.emit(constants.EVENT.ENDSESSION, {
            endedBy: {
              userId: message.senderId,
              isAgent: message.isAgent
            }
          });
        } else {
          events.emit(constants.EVENT.ENDSESSION);
        }
      },
      abandonSession: function () {
        this._stopHeartbeat();
        participantNotification.stopObserving();
        if (!this._connected) {
          console.log('abandonSession called, but already disconnected');
          return;
        }
        this.removeListeners();
        console.log('abandonSession called');
        this._connected = false;
      },
      _metaConnect: function (message) {
        console.log('dataChannel.js _metaConnect');
        if (this._disconnecting) {
          this._connected = false;
          this._connectionClosed();
        } else {
          var wasConnected = this._connected;
          this._connected = message.successful === true;
          if (!wasConnected && this._connected) {
            this._connectionEstablished();
          } else if (wasConnected && !this._connected) {
            this._connectionBroken();
          }
        }
      },
      _metaUnsuccessful: function (msg) {
        dojoxCometd._connected = false;
        if (msg.error) {
          console.warn('Unsuccessful comet operation - error: ' + msg.error);
          if (window.proxyless && window.proxyless.debug) {
            window.console.warn.call(null, 'Unsuccessful comet operation - error: ' + msg.error);
          }
          if (/402/i.test(msg.error)) {
            // Unknown Client (This client did perform a handshake)
            // see: https://groups.google.com/forum/#!topic/cometd-users/liSeYB3KH7E
            //
            // The most common case is when the client has network problems, and the
            // server does not see a connect arriving from the client.
            // The server being busy is a less frequent case, because the server
            // would have to find the time to execute the timeout and expire the
            // client, but not to answer to client's connect, which is possible but
            // would lead to casual expirations and not to consistent ones.
            //
            console.warn('Unknown Client (This client did perform a handshake)');
            console.warn('Comet Reloading... Cause: ' + msg.error);
            storage.removeValue(constants.cometReloadKey);
            dojoxCometd.handshake();
          } else if (/403/i.test(msg.error)) {
            //not allowed. Probably the session has ended.
            this.disconnect();
          }
        } else if (msg.failure) {
          console.warn('Failed cometd operation: ', msg.failure.reason);
          if (window.navigator && window.navigator.onLine !== undefined && !window.navigator.onLine) {
            console.warn('No network connection.');
          }
          reconnectNotification.connectionUnhealthy();
        }
      },
      _metaHandshake: function (message) {
        if (message.successful) {
          console.log('Handshake successful');
        }
      },
      sendService: function (message) {
        dojoxCometd.publish('/service/ticket', message, this.getSubscribeProps());
      },
      joinSession: function (url) {
        console.debug('dataChannel.js joinSession', url);
        var publishMsg = {
          action: 'join',
          tenant: config.tenantId,
          user: config.userName,
          senderId: +this.userId,
          ticket: this.ticket,
          isAgent: !!config.isAgent,
          url: url || window.location.href
        };
        this.sendService(publishMsg);
      },
      _connectionEstablished: function () {
        console.log('Connection established. Joining session with user ' + config.userName + ' and user id: ' + this.userId);
        // Connection might be re-established after being broken. In
        // this case existing subscriptions must be cleaned up before
        // new subscriptions are added.
        this.removeSubscriptions();
        this.subscriptions.push(dojoxCometd.subscribe(constants.defaultChannel + '/' + config.tenantId + '/' + this.ticket, lang.hitch(this, this.handleMessage), this.getSubscribeProps()));
        this.subscriptions.push(dojoxCometd.subscribe(constants.serviceChannel + '/' + config.tenantId + '/' + this.ticket, lang.hitch(this, this.handleService), this.getSubscribeProps()));
        this.joinSession();
        dojoxCometd.setReloadCookie();
        this.onParticipantConnected();
      },
      getSubscribeProps: function () {
        if (this.sid) {
          return { ext: { 'com.liveperson.authz': { sid: this.sid } } };
        }
      },
      _startHeartbeat: function () {
        var that = this;
        this.send(constants.EVENT.HEARTBEAT, { userId: that.userId });
        this.heartbeatInterval = setInterval(function () {
          that.send(constants.EVENT.HEARTBEAT, { userId: that.userId });
        }, 5000);
      },
      _stopHeartbeat: function () {
        clearInterval(this.heartbeatInterval);
      },
      _connectionBroken: function () {
        console.log('Connection broken');
      },
      _connectionClosed: function () {
        console.log('Connection closed');
      },
      sendCustomerSatisfaction: function (rating) {
        var requestUrl = config.serverUrl + strings.AJAX_PATH;
        return request.post(requestUrl, {
          preventCache: true,
          handleAs: 'json',
          timeout: 4000,
          data: {
            action: constants.EVENT.CSAT,
            rating: rating,
            ticketId: config.ticketId
          }
        });
      }
    };
    return DataChannel;
  }(synchronite_constants_strings, synchronite_constants_constants, synchronite_proxyless_utils, synchronite_proxyless_storage, synchronite_proxyless_participantNotification, synchronite_proxyless_reconnectNotification, synchronite_cometd_LargeMessageExtension, synchronite__base_url, synchronite_micro_dom, dojox_cometd, dojox_cometd_reloadLP, dojo_on, dojo_has, dojo_request, dojo__base_lang, dojo_Evented);
  synchronite_proxyless_accessibility = function (dom, query, dojoString) {
    var screenreaderUpdatesId = 'cobrowse-screenreader-updates';
    function toDom(html) {
      html = dojoString.trim(html);
      var div = document.createElement('div');
      div.innerHTML = html;
      return div.firstChild;
    }
    return {
      init: function () {
        var doc = document, body = doc.body || doc.getElementsByTagName('body')[0];
        // eslint-disable-next-line
        var cobrowseAccessibilityUpdates = toDom('<div aria-live="assertive" role="region" id="' + screenreaderUpdatesId + '" class="ignoreDOM" style="height: 0px; position: absolute; top: -1000px; left: -1000px; margin-left: -9999; opactity: 0"><p></p></div>');
        body.appendChild(cobrowseAccessibilityUpdates);
      },
      announce: function (text) {
        // using setTimeout to make sure it's announced by all screen readers
        // (might not be the case if the element has just been added in 'init')
        setTimeout(function () {
          query('#cobrowse-screenreader-updates p')[0].innerHTML = text;
        }, 500);
      },
      cleanup: function () {
        setTimeout(function () {
          var node = dom.byId(screenreaderUpdatesId);
          if (node) {
            node.parentNode.removeChild(node);
          }
        }, 3000);
      }
    };
  }(dojo_dom, dojo_query, dojo_string);
  dojo_text = function (module) {
    var text, fs, Cc, Ci, xpcIsWindows, progIds = [
        'Msxml2.XMLHTTP',
        'Microsoft.XMLHTTP',
        'Msxml2.XMLHTTP.4.0'
      ], xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im, hasLocation = typeof location !== 'undefined' && location.href, defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''), defaultHostName = hasLocation && location.hostname, defaultPort = hasLocation && (location.port || undefined), buildMap = {}, masterConfig = module.config && module.config() || {};
    text = {
      version: '2.0.14',
      strip: function (content) {
        //Strips <?xml ...?> declarations so that external SVG and XML
        //documents can be added to a document without worry. Also, if the string
        //is an HTML document, only the part inside the body tag is returned.
        if (content) {
          content = content.replace(xmlRegExp, '');
          var matches = content.match(bodyRegExp);
          if (matches) {
            content = matches[1];
          }
        } else {
          content = '';
        }
        return content;
      },
      jsEscape: function (content) {
        return content.replace(/(['\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029');
      },
      createXhr: masterConfig.createXhr || function () {
        //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
        var xhr, i, progId;
        if (typeof XDomainRequest !== 'undefined') {
          // PATCHED IE9
          return new XDomainRequest();
        } else if (typeof XMLHttpRequest !== 'undefined') {
          return new XMLHttpRequest();
        } else if (typeof ActiveXObject !== 'undefined') {
          for (i = 0; i < 3; i += 1) {
            progId = progIds[i];
            try {
              xhr = new ActiveXObject(progId);
            } catch (e) {
            }
            if (xhr) {
              progIds = [progId];
              // so faster next time
              break;
            }
          }
        }
        return xhr;
      },
      /**
       * Parses a resource name into its component parts. Resource names
       * look like: module/name.ext!strip, where the !strip part is
       * optional.
       * @param {String} name the resource name
       * @returns {Object} with properties "moduleName", "ext" and "strip"
       * where strip is a boolean.
       */
      parseName: function (name) {
        var modName, ext, temp, strip = false, index = name.lastIndexOf('.'), isRelative = name.indexOf('./') === 0 || name.indexOf('../') === 0;
        if (index !== -1 && (!isRelative || index > 1)) {
          modName = name.substring(0, index);
          ext = name.substring(index + 1);
        } else {
          modName = name;
        }
        temp = ext || modName;
        index = temp.indexOf('!');
        if (index !== -1) {
          //Pull off the strip arg.
          strip = temp.substring(index + 1) === 'strip';
          temp = temp.substring(0, index);
          if (ext) {
            ext = temp;
          } else {
            modName = temp;
          }
        }
        return {
          moduleName: modName,
          ext: ext,
          strip: strip
        };
      },
      xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,
      /**
       * Is an URL on another domain. Only works for browser use, returns
       * false in non-browser environments. Only used to know if an
       * optimized .js version of a text resource should be loaded
       * instead.
       * @param {String} url
       * @returns Boolean
       */
      useXhr: function (url, protocol, hostname, port) {
        // PATCHED: ALLOW ALL CORS BROWSERS
        // Adapted from: https://raw.github.com/Modernizr/Modernizr/master/feature-detects/cors.js
        if (typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest()) {
          return true;
        }
        if (typeof XDomainRequest !== 'undefined') {
          return true;
        }
        // PATCHED: ALLOW ALL CORS BROWSERS END
        var uProtocol, uHostName, uPort, match = text.xdRegExp.exec(url);
        if (!match) {
          return true;
        }
        uProtocol = match[2];
        uHostName = match[3];
        uHostName = uHostName.split(':');
        uPort = uHostName[1];
        uHostName = uHostName[0];
        return (!uProtocol || uProtocol === protocol) && (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) && (!uPort && !uHostName || uPort === port);
      },
      finishLoad: function (name, strip, content, onLoad) {
        content = strip ? text.strip(content) : content;
        if (masterConfig.isBuild) {
          buildMap[name] = content;
        }
        onLoad(content);
      },
      load: function (name, req, onLoad, config) {
        //Name has format: some.module.filext!strip
        //The strip part is optional.
        //if strip is present, then that means only get the string contents
        //inside a body tag in an HTML string. For XML/SVG content it means
        //removing the <?xml ...?> declarations so the content can be inserted
        //into the current doc without problems.
        // Do not bother with the work if a build and text will
        // not be inlined.
        if (config && config.isBuild && !config.inlineText) {
          onLoad();
          return;
        }
        masterConfig.isBuild = config && config.isBuild;
        var parsed = text.parseName(name), nonStripName = parsed.moduleName + (parsed.ext ? '.' + parsed.ext : ''), url = req.toUrl(nonStripName), useXhr = masterConfig.useXhr || text.useXhr;
        // Do not load if it is an empty: url
        if (url.indexOf('empty:') === 0) {
          onLoad();
          return;
        }
        //Load the text. Use XHR if possible and in a browser.
        if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
          text.get(url, function (content) {
            text.finishLoad(name, parsed.strip, content, onLoad);
          }, function (err) {
            if (onLoad.error) {
              onLoad.error(err);
            }
          });
        } else {
          //Need to fetch the resource across domains. Assume
          //the resource has been optimized into a JS module. Fetch
          //by the module name + extension, but do not include the
          //!strip part to avoid file system issues.
          req([nonStripName], function (content) {
            text.finishLoad(parsed.moduleName + '.' + parsed.ext, parsed.strip, content, onLoad);
          });
        }
      },
      write: function (pluginName, moduleName, write, config) {
        if (buildMap.hasOwnProperty(moduleName)) {
          var content = text.jsEscape(buildMap[moduleName]);
          write.asModule(pluginName + '!' + moduleName, 'define(function () { return \'' + content + '\';});\n');
        }
      },
      writeFile: function (pluginName, moduleName, req, write, config) {
        var parsed = text.parseName(moduleName), extPart = parsed.ext ? '.' + parsed.ext : '', nonStripName = parsed.moduleName + extPart,
          //Use a '.js' file name so that it indicates it is a
          //script that can be loaded across domains.
          fileName = req.toUrl(parsed.moduleName + extPart) + '.js';
        //Leverage own load() method to load plugin value, but only
        //write out values that do not have the strip argument,
        //to avoid any potential issues with ! in file names.
        text.load(nonStripName, req, function (value) {
          //Use own write() method to construct full module value.
          //But need to create shell that translates writeFile's
          //write() to the right interface.
          var textWrite = function (contents) {
            return write(fileName, contents);
          };
          textWrite.asModule = function (moduleName, contents) {
            return write.asModule(moduleName, fileName, contents);
          };
          text.write(pluginName, nonStripName, textWrite, config);
        }, config);
      }
    };
    if (masterConfig.env === 'node' || !masterConfig.env && typeof process !== 'undefined' && process.versions && !!process.versions.node && !process.versions['node-webkit'] && !process.versions['atom-shell']) {
      //Using special require.nodeRequire, something added by r.js.
      fs = require.nodeRequire('fs');
      text.get = function (url, callback, errback) {
        try {
          var file = fs.readFileSync(url, 'utf8');
          //Remove BOM (Byte Mark Order) from utf8 files if it is there.
          if (file[0] === '\uFEFF') {
            file = file.substring(1);
          }
          callback(file);
        } catch (e) {
          if (errback) {
            errback(e);
          }
        }
      };
    } else if (masterConfig.env === 'xhr' || !masterConfig.env && text.createXhr()) {
      text.get = function (url, callback, errback, headers) {
        var xhr = text.createXhr(), header;
        // PATCH START: XDomainRequest support for IE
        if (typeof XDomainRequest !== 'undefined' && xhr instanceof XDomainRequest) {
          // Requests must be targeted to the same scheme as the hosting page
          // http://stackoverflow.com/questions/8464262/access-is-denied-error-on-xdomainrequest
          var pageProtocol = window.location.protocol;
          if (url.indexOf(pageProtocol) == -1) {
            url = pageProtocol + url.substring(url.indexOf('//'));
          }
        }
        // PATCHED END
        xhr.open('GET', url, true);
        //Allow plugins direct access to xhr headers
        if (headers) {
          for (header in headers) {
            if (headers.hasOwnProperty(header)) {
              xhr.setRequestHeader(header.toLowerCase(), headers[header]);
            }
          }
        }
        //Allow overrides specified in config
        if (masterConfig.onXhr) {
          masterConfig.onXhr(xhr, url);
        }
        xhr.onreadystatechange = function (evt) {
          var status, err;
          //Do not explicitly handle errors, those should be
          //visible via console output in the browser.
          if (xhr.readyState === 4) {
            status = xhr.status || 0;
            if (status > 399 && status < 600) {
              //An http 4xx or 5xx error. Signal an error.
              err = new Error(url + ' HTTP status: ' + status);
              err.xhr = xhr;
              if (errback) {
                errback(err);
              }
            } else {
              callback(xhr.responseText);
            }
            if (masterConfig.onXhrComplete) {
              masterConfig.onXhrComplete(xhr, url);
            }
          }
        };
        // PATCH START: XDomainRequest support for IE
        if (typeof XDomainRequest !== 'undefined' && xhr instanceof XDomainRequest) {
          xhr.onload = function () {
            callback(xhr.responseText);
          };
          xhr.onerror = function () {
            err = new Error(url);
            err.xhr = xhr;
            errback(err);
          };
          // Empty event handlers needs to be there, because IE9 is flawed: http://rudovsky.blogspot.dk/2012/09/microsoft-shit-xdomainrequest.html
          xhr.ontimeout = function () {
          };
          xhr.onprogress = function () {
          };
          xhr.send();
        } else {
          // PATCHED END
          xhr.send(null);
        }
      };
    } else if (masterConfig.env === 'rhino' || !masterConfig.env && typeof Packages !== 'undefined' && typeof java !== 'undefined') {
      //Why Java, why is this so awkward?
      text.get = function (url, callback) {
        var stringBuffer, line, encoding = 'utf-8', file = new java.io.File(url), lineSeparator = java.lang.System.getProperty('line.separator'), input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)), content = '';
        try {
          stringBuffer = new java.lang.StringBuffer();
          line = input.readLine();
          // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
          // http://www.unicode.org/faq/utf_bom.html
          // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
          // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
          if (line && line.length() && line.charAt(0) === 65279) {
            // Eat the BOM, since we've already found the encoding on this file,
            // and we plan to concatenating this buffer with others; the BOM should
            // only appear at the top of a file.
            line = line.substring(1);
          }
          if (line !== null) {
            stringBuffer.append(line);
          }
          while ((line = input.readLine()) !== null) {
            stringBuffer.append(lineSeparator);
            stringBuffer.append(line);
          }
          //Make sure we return a JavaScript string and not a Java string.
          content = String(stringBuffer.toString());  //String
        } finally {
          input.close();
        }
        callback(content);
      };
    } else if (masterConfig.env === 'xpconnect' || !masterConfig.env && typeof Components !== 'undefined' && Components.classes && Components.interfaces) {
      //Avert your gaze!
      Cc = Components.classes;
      Ci = Components.interfaces;
      Components.utils['import']('resource://gre/modules/FileUtils.jsm');
      xpcIsWindows = '@mozilla.org/windows-registry-key;1' in Cc;
      text.get = function (url, callback) {
        var inStream, convertStream, fileObj, readData = {};
        if (xpcIsWindows) {
          url = url.replace(/\//g, '\\');
        }
        fileObj = new FileUtils.File(url);
        //XPCOM, you so crazy
        try {
          inStream = Cc['@mozilla.org/network/file-input-stream;1'].createInstance(Ci.nsIFileInputStream);
          inStream.init(fileObj, 1, 0, false);
          convertStream = Cc['@mozilla.org/intl/converter-input-stream;1'].createInstance(Ci.nsIConverterInputStream);
          convertStream.init(inStream, 'utf-8', inStream.available(), Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);
          convertStream.readString(inStream.available(), readData);
          convertStream.close();
          inStream.close();
          callback(readData.value);
        } catch (e) {
          throw new Error((fileObj && fileObj.path || '') + ': ' + e);
        }
      };
    }
    return text;
  }({});
  dojo_text_synchronite_proxyless_templates_errorhtml = '<div id="cobrowse-error-container" data-noclick="true" class="ignoreDOM cobrowse-reset cobrowse-noDomError-cont">\n\t<div id="cobrowse-error" data-noclick="true" class="ignoreDOM cobrowse-reset cobrowse-noDomError">\n\t\t<div class="cobrowse-errorIcon" style="background:url(${proxyUrl}/images/warning.png)"></div>\n\t\t<div class="cobrowse-errorHeading">${heading}</div>\n\t\t<div class="cobrowse-errorText">${msg}</div>\n\t</div>\n</div>\n';
  dojo_text_synchronite_proxyless_templates_statushtml = '<div id="cobrowsingstatus" data-noclick="true" class="ignoreDOM cobrowse-reset cobrowse-status">\n\t<div data-noclick="true" class="cobrowse-reset cobrowsing-status-text" role="heading" aria-level="2" aria-label="${session.cobrowseSession}">${session.cobrowseSession}</div>\n\t<div class="cobrowse-status-button-container">\n\t\t<button aria-label="Restricted page tooltip" style="background:url(${proxyUrl}/images/secure.png) no-repeat center center; display: none"\n\t\t\t\tdata-noclick="true" id="cobrowse-restricted-page" aria-describedby="cobrowse-status-tooltip-text"\n\t\t\t\tclass="cobrowse-status-button cobrowse-status-tooltip-trigger">\n\t\t\t<span class="cobrowse-status-tooltip">\n\t\t\t\t<div style="background:url(${proxyUrl}/images/tooltip_notice.png) no-repeat center center;" class="cobrowse-status-tooltip-icon"></div>\n\t\t\t\t<div role="tooltip" id="cobrowse-status-tooltip-text" class="cobrowse-status-tooltip-text">${session.restrictedPageVisitor}\n\t\t\t\t</div>\n\t\t\t</span>\n\t\t</button>\n\t\t<button style="background:url(${proxyUrl}/images/close.png) no-repeat center center;"\n\t\t\t\taria-label="End CoBrowse Session" data-noclick="true" id="cobrowse-end-button" class="cobrowse-status-button"></button>\n\t</div>\n</div>\n';
  dojo_text_synchronite_proxyless_templates_notificationhtml = '<div id="cobrowse-notification" data-noclick="true" class="ignoreDOM cobrowse-reset cobrowse-notification">\n\t<div role="alert" id="cobrowse-notification-text" data-noclick="true" class="ignoreDOM cobrowse-reset cobrowse-notification-text">${msg}</div>\n\t<button style="background:url(${proxyUrl}/images/close.png) no-repeat center center; margin-top: 5px"\n\t\t\taria-label="Close CoBrowse notification" data-noclick="true" id="cobrowse-close-button" class="cobrowse-close-button"></button>\n</div>\n';
  synchronite_proxyless_ui = function (lang, query, i18next, strings, datachannel, constants, utils, accessibility, baseArray, dojoString, fx, dom, domStyle, on, has, request, errorTemplate, statusTemplate, notificationTemplate) {
    var config = synchroniteConfig;
    var currentInterval, noDomErrorTimeout, timer = 1, mousemoveHandler, focusHandler, scrollHandler, endSessionHandler;
    var borderIds = [
      'cobrowsing-border-top',
      'cobrowsing-border-left',
      'cobrowsing-border-right',
      'cobrowsing-border-bottom'
    ];
    var statusId = 'cobrowsingstatus';
    var notificationId = 'cobrowse-notification';
    var preloadImages = ['/images/close.png'];
    statusTemplate = dojoString.trim(statusTemplate);
    errorTemplate = dojoString.trim(errorTemplate);
    notificationTemplate = dojoString.trim(notificationTemplate);
    function toDom(html) {
      html = dojoString.trim(html);
      var div = document.createElement('div');
      div.innerHTML = html;
      return div.firstChild;
    }
    function addStatus() {
      var attachTo = getBodyOrRoot();
      attachTo.insertBefore(toDom(i18next.replace(statusTemplate, config)), attachTo.firstChild);
      if (has('touch') && !config.stickyMenubar) {
        showStatus();
        addEndButtonListener(window);
        setTimeout(function () {
          hideStatus();
          removeEndButtonListener();
          scrollHandler = on(document, 'scroll', function () {
            if (window.scrollY === 0) {
              hideStatus();
              removeEndButtonListener();
            } else if (window.scrollY > 40) {
              showStatus();
              addEndButtonListener(window);
            }
          });
        }, 4000);
        var showAndHide = function () {
          showStatus();
          addEndButtonListener(window);
          setTimeout(function () {
            hideStatus();
            removeEndButtonListener();
          }, 4000);
        };
        query('#cobrowsingstatus').on('click', showAndHide);
        focusHandler = query('#cobrowse-end-button').on('focus', showAndHide);
      } else {
        if (!config.stickyMenubar) {
          addHideStatusInterval();
        }
        addEndButtonListener(window);
      }
    }
    function addEndButtonListener(win) {
      if (win) {
        removeEndButtonListener();
        try {
          endSessionHandler = query('#cobrowse-end-button', win.document).on('click', function (event) {
            datachannel.endSession();
            event.preventDefault();
          });
        } catch (e) {
          console.log('Unable to add listener to End-Session-Button. This is ok if running inside the WebAgent');
        }
      }
    }
    function removeEndButtonListener() {
      if (endSessionHandler && endSessionHandler.remove) {
        endSessionHandler.remove();
      }
    }
    function hideStatus() {
      fx.animateProperty({
        node: 'cobrowsingstatus',
        properties: { top: -29 }
      }).play();
    }
    function showStatus() {
      fx.animateProperty({
        node: 'cobrowsingstatus',
        properties: { top: 0 }
      }).play();
    }
    function addHideStatusInterval() {
      clearInterval(currentInterval);
      currentInterval = setInterval(function () {
        if (timer === 2) {
          hideStatus();
          timer = 1;
        }
        timer++;
      }, 3000);
      var doc = config.isSlave ? document.getElementById(constants.cobrowsingFrameName).contentDocument : document;
      mousemoveHandler = on(doc, 'mousemove', function (e) {
        if (e.clientY < 7) {
          showStatus();
        }
        timer = 1;
      });
      focusHandler = query('#cobrowse-end-button').on('focus', function () {
        showStatus();
        timer = 1;
      });
    }
    function getBodyOrRoot() {
      var attachTo;
      if (query('body').length === 0) {
        attachTo = document.documentElement;
      } else {
        attachTo = query('body')[0];
      }
      return attachTo;
    }
    function showNotification(msg, fadeOut) {
      if (query('#' + notificationId).length !== 0) {
        dom.byId('cobrowse-notification-text').innerHTML = msg;
      } else {
        var attachTo = getBodyOrRoot();
        attachTo.appendChild(toDom(dojoString.substitute(notificationTemplate, lang.mixin({ msg: msg }, config))));
      }
      var notificationElement = dom.byId(notificationId);
      notificationElement.style.display = 'block';
      fx.animateProperty({
        node: notificationElement,
        properties: { left: 30 }
      }).play();
      var closeButton = query('#cobrowse-close-button');
      closeButton.on('click', function () {
        fx.animateProperty({
          node: notificationElement,
          properties: { left: -1000 },
          onEnd: function () {
            notificationElement.style.display = 'none';
          }
        }).play();
      });
      if (fadeOut) {
        setTimeout(function () {
          fx.animateProperty({
            node: notificationElement,
            properties: { left: -1000 },
            onEnd: function () {
              notificationElement.style.display = 'none';
            }
          }).play();
        }, 3000);
      }
    }
    //currently Agent only
    function showError(msg, heading) {
      heading = heading || 'Error';
      var cobrowseLoading = dom.byId('cobrowseLoading'), synchroniteWidgets = dom.byId('synchronite-widgets');
      if (cobrowseLoading) {
        cobrowseLoading.style.display = 'none';
      }
      if (synchroniteWidgets) {
        synchroniteWidgets.parentNode.removeChild(synchroniteWidgets);
      }
      // Use document.open/write/close functions in order to clear the content and initialize the frame
      var doc = document.getElementById(constants.cobrowsingFrameName).contentDocument;
      doc.open();
      doc.write('<!DOCTYPE html>');
      doc.close();
      _loadCss(config.proxyUrl + '/css/proxyless.css', doc);
      var attachTo = doc.body || doc.getElementsByTagName('body')[0];
      attachTo.innerHTML = dojoString.substitute(errorTemplate, {
        proxyUrl: config.proxyUrl,
        heading: heading,
        msg: msg
      });
    }
    function _prepareDocument() {
      //first clear the body
      var body = query('body')[0];
      while (body.firstChild) {
        body.removeChild(body.firstChild);
      }
      // add iframe (safe to use innerHTML because body is empty)
      // eslint-disable-next-line
      body.innerHTML = '<div id="cobrowse-overlay-container"><iframe class="iframeShadow" src="about:blank" name="' + constants.cobrowsingFrameName + '" id="' + constants.cobrowsingFrameName + '" style="position: absolute; top:0px; left:0px; bottom:0px; right:0px; width:100%; height:100%; border:none; margin: auto;" sandbox="allow-scripts allow-same-origin"></iframe></div>';
    }
    function _loadCss(file, rootDoc) {
      var doc = rootDoc || document;
      var link = doc.createElement('link');
      link.href = file;
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.media = 'screen,print';
      link.className = 'ignoreDOM';
      var head = doc.getElementsByTagName('head')[0];
      head.insertBefore(link, head.firstChild);
    }
    function _updateBlockedContentWarning() {
      var doc = document.getElementById(constants.cobrowsingFrameName).contentDocument;
      query('.cobrowse-blocked', doc).forEach(function (el) {
        el.style.backgroundImage = 'url(' + config.proxyUrl + '/images/warning.png)';
        el.style.backgroundColor = 'lightgray';
        el.style.backgroundRepeat = 'no-repeat';
        el.style.backgroundPosition = '50% 50%';
        el.setAttribute('title', i18next.t('blockedContent', { ns: ['session'] }));
      });
    }
    /*
     Preloads images that might be used later (when we might have no network connection)
     */
    function _preloadImages() {
      var images = [];
      for (var i = 0; i < preloadImages.length; i++) {
        images[i] = new Image();
        images[i].src = preloadImages[i];
      }
    }
    function showRestrictedPageMessage(isVisitor) {
      if (isVisitor) {
        var node = query('#cobrowse-restricted-page')[0];
        node.style.display = 'inline';
        showStatus();
      } else {
        showError(i18next.t('restrictedPage', { ns: ['session'] }), 'Notification');
      }
    }
    function hideRestrictedPageMessage(isVisitor) {
      if (isVisitor) {
        var node = query('#cobrowse-restricted-page')[0];
        node.style.display = 'none';
        showStatus();
      }
    }
    var Ui = {
      createSlaveUI: function () {
        //add loading indicator
        var win = window, doc = win.document, body = doc.body || doc.getElementsByTagName('body')[0];
        // eslint-disable-next-line
        var cobrowseLoadingHtml = toDom('<div id="cobrowseLoading" class="ignoreDOM" style="position: fixed; top:0px; left:0px; width:100%; height: 100%; z-index:99999; background-color:white; opacity:0.7"><div style="width: 100%;height: 100%; background:url(' + config.proxyUrl + '/images/cobrowse_loading.gif) no-repeat center center;"></div></div>');
        var cobrowseLoading = body.appendChild(cobrowseLoadingHtml);
        on(cobrowseLoading, 'click', function (event) {
          cobrowseLoading.style.display = 'none';
          event.preventDefault();
        });
        addEndButtonListener(win.parent);
        _preloadImages();
      },
      createMasterUI: function (firstStart) {
        var attachTo = getBodyOrRoot(), doc = document, border;
        baseArray.forEach(borderIds, function (borderId) {
          border = doc.createElement('div');
          border.id = borderId;
          border.className = 'ignoreDOM cobrowse-reset';
          attachTo.appendChild(border);
        });
        accessibility.init();
        if (firstStart) {
          accessibility.announce(i18next.t('sessionStarted', { ns: ['session'] }));
        } else {
          accessibility.announce(i18next.t('sessionActive', { ns: ['session'] }));
        }
        addStatus();
      },
      cleanup: function () {
        accessibility.announce(i18next.t('sessionEnded', { ns: ['session'] }));
        accessibility.cleanup();
        clearInterval(currentInterval);
        var allIds = borderIds.concat(statusId).concat(notificationId);
        baseArray.forEach(allIds, function (id) {
          var node = dom.byId(id);
          if (node) {
            node.parentNode.removeChild(node);
          }
        });
        if (mousemoveHandler) {
          mousemoveHandler.remove();
        }
        if (focusHandler) {
          focusHandler.remove();
        }
        if (scrollHandler) {
          scrollHandler.remove();
        }
      },
      removeNoDomErrorTimeout: function () {
        clearInterval(noDomErrorTimeout);
      },
      addNoDomErrorTimeout: function () {
        noDomErrorTimeout = setTimeout(function () {
          showError(i18next.t('noDataError', { ns: ['session'] }));
        }, 30000);
      },
      showError: showError,
      showNotification: showNotification,
      showRestrictedPageMessage: showRestrictedPageMessage,
      hideRestrictedPageMessage: hideRestrictedPageMessage,
      loadCSS: function (file) {
        _loadCss(file);
      },
      prepareDocument: _prepareDocument,
      updateBlockedContentWarning: _updateBlockedContentWarning,
      showLoadingOverlay: function () {
        var loading = dom.byId('cobrowseLoading');
        if (loading) {
          loading.style.display = 'inline';
        }
      },
      hideLoadingOverlay: function () {
        var loading = dom.byId('cobrowseLoading');
        if (loading) {
          loading.style.display = 'none';
        }
      }
    };
    return Ui;
  }(dojo__base_lang, dojo_query, i18next_loader, synchronite_constants_strings, synchronite_proxyless_datachannel, synchronite_constants_constants, synchronite_proxyless_utils, synchronite_proxyless_accessibility, dojo__base_array, dojo_string, dojo__base_fx, dojo_dom, dojo_dom_style, dojo_on, dojo_has, dojo_request, dojo_text_synchronite_proxyless_templates_errorhtml, dojo_text_synchronite_proxyless_templates_statushtml, dojo_text_synchronite_proxyless_templates_notificationhtml);
  synchronite_proxyless_lib_tree_mirror = function () {
    var TreeMirror = function () {
      window.Node = window.Node || {
        ELEMENT_NODE: 1,
        ATTRIBUTE_NODE: 2,
        TEXT_NODE: 3,
        CDATA_SECTION_NODE: 4,
        ENTITY_REFERENCE_NODE: 5,
        ENTITY_NODE: 6,
        PROCESSING_INSTRUCTION_NODE: 7,
        COMMENT_NODE: 8,
        DOCUMENT_NODE: 9,
        DOCUMENT_TYPE_NODE: 10,
        DOCUMENT_FRAGMENT_NODE: 11,
        NOTATION_NODE: 12
      };
      function TreeMirror(root, delegate) {
        this.root = root;
        this.delegate = delegate;
        this.idMap = {};
      }
      TreeMirror.prototype.initialize = function (rootId, children) {
        this.idMap[rootId] = this.root;
        for (var i = 0; i < children.length; i++)
          this.deserializeNode(children[i], this.root);
        if (this.root.close)
          this.root.close();
        if (this.root.nodeType === window.Node.DOCUMENT_NODE && this.root.getElementsByTagName('html').length === 2) {
          // document.close() may add a second html element to the doc that should better be removed
          this.root.removeChild(this.root.getElementsByTagName('html')[1]);
        }
      };
      TreeMirror.prototype.applyChanged = function (removed, addedOrMoved, attributes, text) {
        var _this = this;
        // NOTE: Applying the changes can result in an attempting to add a child
        // to a parent which is presently an ancestor of the parent. This can occur
        // based on random ordering of moves. The way we handle this is to first
        // remove all changed nodes from their parents, then apply.
        addedOrMoved.forEach(function (data) {
          var node = _this.deserializeNode(data);
          if (node && node.parentNode)
            node.parentNode.removeChild(node);
        });
        removed.forEach(function (data) {
          var node = _this.deserializeNode(data);
          if (node && node.parentNode)
            node.parentNode.removeChild(node);
        });
        addedOrMoved.forEach(function (data) {
          var node = _this.deserializeNode(data);
          var parent = _this.deserializeNode(data.parentNode);
          var previous = _this.deserializeNode(data.previousSibling);
          if (node && node.nodeType === 3 && parent && parent.tagName === 'STYLE') {
            node.textContent = _this.delegate.getSanitizedCssTextNodeVal(node.textContent);
          }
          if (!parent) {
            //cannot insert this node because parent is not know. This is is the case if the parent element is
            // ignored and therefore not know on the slave
            return;
          }
          try {
            parent.insertBefore(node, previous ? previous.nextSibling : parent.firstChild);
          } catch (e) {
            console.warn('Failed to insert DOM node ' + e);
          }
        });
        attributes.forEach(function (data) {
          var node = _this.deserializeNode(data);
          if (typeof node === 'undefined') {
            return;
          }
          Object.keys(data.attributes).forEach(function (attrName) {
            var newVal = data.attributes[attrName];
            if (typeof node.removeAttribute !== 'function') {
              return;
            }
            if (newVal === null) {
              node.removeAttribute(attrName);
            } else {
              if (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, attrName, newVal) && typeof node != 'boolean') {
                try {
                  node.setAttribute(attrName, newVal);
                } catch (e) {
                  console.warn('Could not set Attribute ' + attrName + ' on element ' + node);
                }
              }
            }
          });
        });
        text.forEach(function (data) {
          var node = _this.deserializeNode(data);
          if (node) {
            node.textContent = data.textContent;
          }
        });
        removed.forEach(function (node) {
          delete _this.idMap[node.id];
        });
      };
      TreeMirror.prototype.deserializeNode = function (nodeData, parent, inStyle, inSVG) {
        var _this = this;
        if (nodeData === null)
          return null;
        var node = this.idMap[nodeData.id];
        if (node)
          return node;
        var doc = this.root.ownerDocument;
        if (doc === null)
          doc = this.root;
        switch (nodeData.nodeType) {
        case Node.COMMENT_NODE:
          var content = nodeData.textContent;
          if (content) {
            content = content.replace(/\bscript\b/gi, function (x) {
              return 'no-script';
            });
            node = doc.createComment(content);
          } else if (content === '') {
            // to support empty comments ...
            node = doc.createComment('');
          }
          break;
        case Node.TEXT_NODE:
          if (this.delegate && this.delegate.createTextNode) {
            node = this.delegate.createTextNode(nodeData.textContent, inStyle);
          }
          if (!node) {
            doc.createTextNode(nodeData.textContent);
          }
          break;
        case Node.DOCUMENT_TYPE_NODE:
          try {
            parent.close();
          } catch (e) {
            console.log(e);
          }
          parent.open();
          var dt = '<' + nodeData.doctype + '>';
          parent.write(dt);
          node = parent.firstChild;
          break;
        case Node.ELEMENT_NODE:
          if (this.delegate && this.delegate.createElement)
            node = this.delegate.createElement(nodeData.tagName, nodeData, inSVG);
          if (!node) {
            try {
              node = doc.createElement(nodeData.tagName);
            } catch (e) {
            }
          }
          //if (node && node.tagName === 'HEAD') {
          //    var cspNode = {
          //        id: "cspNode",
          //        nodeType: Node.ELEMENT_NODE,
          //        tagName: "meta",
          //        attributes: {
          //            "http-equiv":"Content-Security-Policy",
          //            "script-src": "https://global.my.synchronite.de:443"
          //        }
          //    }
          //    nodeData.childNodes.push(cspNode);
          //}
          //if (node && node.tagName === 'HEAD') {
          //    var noScript = {
          //        id: "headNoScript",
          //        nodeType: Node.ELEMENT_NODE,
          //        tagName: "noscript",
          //        childNodes: nodeData.childNodes,
          //        attributes: {}
          //    }
          //    nodeData.childNodes = [noScript];
          //}
          if (node && node.tagName === 'STYLE') {
            inStyle = true;
          } else if (node && node.tagName === 'svg' || inSVG) {
            inSVG = true;
          } else {
            inStyle = false;
            inSVG = false;
          }
          Object.keys(nodeData.attributes).forEach(function (name) {
            if (node && node.setAttribute && (!_this.delegate || !_this.delegate.setAttribute || !_this.delegate.setAttribute(node, name, nodeData.attributes[name], nodeData.attributes, inSVG))) {
              try {
                node.setAttribute(name, nodeData.attributes[name]);
              } catch (e) {
                console.warn('Failed to set attribute ' + e);
              }
            }
          });
          break;
        }
        if (!node) {
          //this is not so bad, because sometimes the master changes attributes on a node that does not exist on the slave (because it
          // is not created/filtered there)
          return;
        }
        this.idMap[nodeData.id] = node;
        if (parent && parent.appendChild && node.nodeType && node.nodeType !== Node.DOCUMENT_TYPE_NODE) {
          if ((document.documentMode || 100) === 8  /*IE8*/ && parent.tagName === 'STYLE' && node.nodeType === Node.TEXT_NODE) {
            parent.styleSheet.cssText = node.nodeValue;
          } else if ((document.documentMode || 100) === 8  /*IE8*/ && parent.tagName === 'NOSCRIPT' && node.nodeType === Node.TEXT_NODE) {
          } else {
            parent.appendChild(node);
          }
        }
        if (nodeData.childNodes) {
          for (var i = 0; i < nodeData.childNodes.length; i++)
            this.deserializeNode(nodeData.childNodes[i], node, inStyle, inSVG);
        }
        return node;
      };
      return TreeMirror;
    }();
    window.TreeMirror = TreeMirror;
    var TreeMirrorClient = function () {
      window.Node = window.Node || {
        ELEMENT_NODE: 1,
        ATTRIBUTE_NODE: 2,
        TEXT_NODE: 3,
        CDATA_SECTION_NODE: 4,
        ENTITY_REFERENCE_NODE: 5,
        ENTITY_NODE: 6,
        PROCESSING_INSTRUCTION_NODE: 7,
        COMMENT_NODE: 8,
        DOCUMENT_NODE: 9,
        DOCUMENT_TYPE_NODE: 10,
        DOCUMENT_FRAGMENT_NODE: 11,
        NOTATION_NODE: 12
      };
      var shadowRootCssShimClassName = 'lp-cobrowse-shadowroot-shim-styles';
      function TreeMirrorClient(target, mirror, queries) {
        var _this = this;
        this.target = target;
        this.mirror = mirror;
        this.nextId = 1;
        this.knownNodes = new LpCoBrowseMutationSummary.NodeMap();
        if (target.shadowRoot)
          target = target.shadowRoot;
        var rootId = this.serializeNode(target).id;
        var children = [];
        for (var child = target.firstChild; child; child = child.nextSibling)
          children.push(this.serializeNode(child, true));
        this.mirror.initialize(rootId, children);
        this.mutationSummary = new LpCoBrowseMutationSummary({
          rootNode: target,
          callback: function (summaries) {
            _this.applyChanged(summaries);
          },
          queries: queries,
          observeOwnChanges: true
        });
      }
      TreeMirrorClient.prototype.disconnect = function () {
        if (this.target && this.target.nodeName && this.target.nodeName === '#document') {
          Array.prototype.forEach.call(document.getElementsByTagName('*'), function (allElement) {
            this.TreeMirrorClient.prototype.removeShadowRootCssShim(allElement);
          });
        }
        if (this.mutationSummary) {
          this.mutationSummary.disconnect();
          this.mutationSummary = undefined;
        }
      };
      // Remove styles placed in DOM by CoBrowse session for shadowRoot where styles are in shadowRoot.adoptedStyleSheets
      TreeMirrorClient.prototype.removeShadowRootCssShim = function (allElement) {
        if (allElement.shadowRoot) {
          var shadowRootElements = allElement.shadowRoot.querySelectorAll('*');
          Array.prototype.forEach.call(shadowRootElements, function (shadowRootElement) {
            if (shadowRootElement.classList.contains(shadowRootCssShimClassName)) {
              shadowRootElement.parentNode.removeChild(shadowRootElement);
            }
            this.TreeMirrorClient.prototype.removeShadowRootCssShim(shadowRootElement);
          });
        }
      };
      TreeMirrorClient.prototype.rememberNode = function (node) {
        var id = this.nextId++;
        this.knownNodes.set(node, id);
        return id;
      };
      TreeMirrorClient.prototype.forgetNode = function (node) {
        this.knownNodes['delete'](node);
      };
      TreeMirrorClient.prototype.serializeNode = function (node, recursive, forceSerialization, willBeRemoved) {
        // PATCHED
        if (node === null)
          return null;
        var id = this.knownNodes.get(node);
        if (id !== undefined && !forceSerialization) {
          // PATCHED
          return {
            id: id,
            isShadowRoot: !!node.shadowRoot
          };
        }
        if (willBeRemoved && !id) {
          //PATCHED will be removed but is not known to the mirror
          return null;
        }
        var data = {
          nodeType: node.nodeType,
          id: id || this.rememberNode(node)  //PATCHED
        };
        switch (data.nodeType) {
        case Node.DOCUMENT_TYPE_NODE:
          data.doctype = this.getDoctype(node);
          break;
        case Node.COMMENT_NODE:
        case Node.TEXT_NODE:
          if (node.innerHTML !== '<!-->' && typeof node.textContent !== 'undefined') {
            data.textContent = node.textContent || node.nodeValue;
          }
          if (this.mirror.isIgnored(node)) {
            data.textContent = '';
            data.ignored = true;
          }
          break;
        case Node.ELEMENT_NODE:
          var elm = node;
          data.tagName = elm.tagName;
          data.attributes = {};
          for (var i = 0; i < elm.attributes.length; i++) {
            if (!this.mirror.isAttributeIgnored(elm.attributes[i], elm)) {
              var attr = elm.attributes[i];
              data.attributes[attr.name] = attr.value;
            }
          }
          if (node instanceof SVGElement) {
            data.isSVG = true;
          }
          if (node.tagName === 'STYLE' || node.tagName === 'style') {
            //support IE stylesheet property
            if (node.innerHTML === '' && node.styleSheet && node.styleSheet.cssText) {
              var textNode = {
                nodeType: Node.TEXT_NODE,
                id: this.rememberNode('IEStyleSheetNode'),
                textContent: node.styleSheet.cssText
              };
              data.childNodes = [];
              data.childNodes.push(textNode);
              return data;
            }
            // support for CSSOM styles (styled components)
            if (node.innerHTML === '' && node.sheet && node.sheet.cssRules && node.sheet.cssRules.length) {
              var styledCssText = '';
              var cssRules = node.sheet.cssRules;
              Array.prototype.forEach.call(cssRules, function (cssRule) {
                styledCssText += cssRule.cssText;
              });
              var textNode = {
                nodeType: Node.TEXT_NODE,
                id: this.rememberNode('CSSOMStyleSheetNode'),
                textContent: styledCssText
              };
              data.childNodes = [];
              data.childNodes.push(textNode);
              return data;
            }
          }
          if (node.shadowRoot) {
            data.isShadowRoot = true;
            // support for browsers where shadowRoot uses adoptedStyleSheets instead of stylesheets (Chromium-based browsers)
            if (node.shadowRoot.adoptedStyleSheets && node.shadowRoot.adoptedStyleSheets.length && (!node.shadowRoot.styleSheets || node.shadowRoot.styleSheets.length === 0)) {
              // Reset
              TreeMirrorClient.prototype.removeShadowRootCssShim(node);
              var styledCssText = '';
              var style = document.createElement('style');
              style.className = shadowRootCssShimClassName;
              Array.prototype.forEach.call(node.shadowRoot.adoptedStyleSheets, function (adoptedStyleSheet) {
                Array.prototype.forEach.call(adoptedStyleSheet.cssRules, function (cssRule) {
                  styledCssText += cssRule.cssText;
                });
              });
              style.innerHTML = styledCssText;
              node.shadowRoot.appendChild(style);
            }
          }
          if (this.mirror.isIgnored(node)) {
            data.attributes = [];
            data.ignored = true;
          }
          if (recursive && elm.childNodes.length) {
            data.childNodes = [];
            for (var child = elm.firstChild; child; child = child.nextSibling)
              data.childNodes.push(this.serializeNode(child, true, forceSerialization));
          }
          break;
        }
        return data;
      };
      TreeMirrorClient.prototype.getDoctype = function (node) {
        return doctype = '!DOCTYPE ' + node.name + (node.publicId ? ' PUBLIC \'' + node.publicId + '\'' : '') + (!node.publicId && node.systemId ? ' SYSTEM' : '') + (node.systemId ? ' \'' + node.systemId + '\'' : '');  // PATCHED: Removed <> because of XSS
      };
      TreeMirrorClient.prototype.serializeAddedAndMoved = function (added, reparented, reordered) {
        var _this = this;
        var all = added.concat(reparented).concat(reordered);
        var parentMap = new LpCoBrowseMutationSummary.NodeMap();
        all.forEach(function (node) {
          if (_this.mirror.isIgnored(node)) {
            return;
          }
          var parent = node.parentNode;
          var children = parentMap.get(parent);
          if (!children) {
            children = new LpCoBrowseMutationSummary.NodeMap();
            parentMap.set(parent, children);
          }
          children.set(node, true);
        });
        var moved = [];
        parentMap.keys().forEach(function (parent) {
          var children = parentMap.get(parent);
          var keys = children.keys();
          while (keys.length) {
            var node = keys[0];
            while (node.previousSibling && children.has(node.previousSibling))
              node = node.previousSibling;
            while (node && children.has(node)) {
              if (_this.mirror.isIgnored(node)) {
                return;
              }
              var data = _this.serializeNode(node);
              if (data) {
                var possiblePreviousSibling = node.previousSibling;
                while (possiblePreviousSibling && _this.mirror.isIgnored(possiblePreviousSibling, true)) {
                  possiblePreviousSibling = possiblePreviousSibling.previousSibling;
                }
                data.previousSibling = _this.serializeNode(possiblePreviousSibling);
                data.parentNode = _this.serializeNode(node.parentNode);
                moved.push(data);
                children['delete'](node);
                node = node.nextSibling;
              } else {
                break;
              }
            }
            var keys = children.keys();
          }
        });
        return moved;
      };
      TreeMirrorClient.prototype.serializeAttributeChanges = function (attributeChanged) {
        //if(attributeChanged.style && attributeChanged.style.length >0 && attributeChanged.style[0].className===ignore){
        //}
        var _this = this;
        var map = new LpCoBrowseMutationSummary.NodeMap();
        Object.keys(attributeChanged).forEach(function (attrName) {
          attributeChanged[attrName].forEach(function (element) {
            if (_this.mirror.isIgnored(element) || _this.mirror.isAttributeIgnored({ name: attrName }, element)) {
              return;
            }
            var record = map.get(element);
            if (!record) {
              record = _this.serializeNode(element);
              record.attributes = {};
              map.set(element, record);
            }
            record.attributes[attrName] = element.getAttribute(attrName);
          });
        });
        return map.keys().map(function (node) {
          return map.get(node);
        });
      };
      TreeMirrorClient.prototype.applyChanged = function (summaries) {
        var _this = this;
        var summary = summaries[0];
        var removed = summary.removed.map(function (node) {
          if (_this.mirror.isIgnored(node)) {
            return;
          }
          return _this.serializeNode(node, false, false, true);
        });
        var moved = this.serializeAddedAndMoved(summary.added, summary.reparented, summary.reordered);
        var attributes = this.serializeAttributeChanges(summary.attributeChanged);
        var text = summary.characterDataChanged.map(function (node) {
          if (_this.mirror.isIgnored(node) || node.nodeType === Node.COMMENT_NODE) {
            return;
          }
          var parent = node.parentNode;
          var data = _this.serializeNode(parent);
          if (data) {
            data.textContent = node.textContent;
            return data;
          }
        });
        if (removed.length || moved.length || attributes.length || text.length)
          this.mirror.applyChanged(removed, moved, attributes, text);
        summary.removed.forEach(function (node) {
          _this.forgetNode(node);
        });
      };
      return TreeMirrorClient;
    }();
    window.TreeMirrorClient = TreeMirrorClient;
  }();
  synchronite_proxyless_lib_mutation_summary = function (has) {
    var __extends = this.__extends || function (d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
      function __() {
        this.constructor = d;
      }
      __.prototype = b.prototype;
      d.prototype = new __();
    };
    var MutationObserverCtor;
    // PATCHED  Angular overrides MutationObserver and stores the original one in a global variable, see https://github.com/angular/angular/issues/26948
    if (window.Zone && typeof window[window.Zone.__symbol__('MutationObserver')] !== 'undefined') {
      MutationObserverCtor = window[window.Zone.__symbol__('MutationObserver')];
    } else if (window.Zone && typeof window[window.Zone.__symbol__('WebKitMutationObserver')] !== 'undefined') {
      MutationObserverCtor = window[window.Zone.__symbol__('WebKitMutationObserver')];
    } else if (typeof WebKitMutationObserver !== 'undefined')
      MutationObserverCtor = WebKitMutationObserver;
    else if (typeof MutationObserver != 'undefined') {
      MutationObserverCtor = MutationObserver;
    }
    var origInsertRule;
    if (typeof CSSStyleSheet === 'function' && CSSStyleSheet.prototype && CSSStyleSheet.prototype.insertRule) {
      var origInsertRule = CSSStyleSheet.prototype.insertRule;
    }
    function observeCSSOM(callback) {
      if (origInsertRule && !CSSStyleSheet.prototype.insertRule.lpOverriden && typeof callback === 'function') {
        CSSStyleSheet.prototype.insertRule = function () {
          try {
            var styledCssText = '';
            var cssRules = this.cssRules;
            Array.prototype.forEach.call(cssRules, function (cssRule) {
              styledCssText += cssRule.cssText;
            });
            var newStyledCssText = styledCssText + arguments[0];
            var removed = document.createTextNode(styledCssText);
            var added = document.createTextNode(newStyledCssText);
            var ownerNode = this.ownerNode;
            Object.defineProperty(added, 'parentNode', {
              get: function () {
                return ownerNode;
              }
            });
            var summaries = [{
                added: [added],
                removed: [removed],
                reordered: [],
                reparented: [],
                attributeChanged: [],
                characterDataChanged: []
              }];
            callback(summaries);
          } catch (e) {
            console.error('CSSOM insetRule override error, manipulation skipped', e);
          }
          return origInsertRule.apply(this, arguments);
        };
        CSSStyleSheet.prototype.insertRule.lpOverriden = true;
      }
    }
    function resetCSSOM() {
      if (origInsertRule && CSSStyleSheet.prototype.insertRule.lpOverriden) {
        CSSStyleSheet.prototype.insertRule = origInsertRule;
      }
    }
    var hasWindow = typeof window != 'undefined' || window;
    if (MutationObserverCtor === undefined && /* ignore this error situation when there is no window object during build time -> */
      !hasWindow) {
      console.error('DOM Mutation Observers are required.');
      console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');
      throw Error('DOM Mutation Observers are required');
    }
    var NodeMap = function () {
      function NodeMap() {
        this.nodes = [];
        this.values = [];
      }
      NodeMap.prototype.isIndex = function (s) {
        return +s === s >>> 0;
      };
      NodeMap.prototype.nodeId = function (node) {
        var id = node[NodeMap.ID_PROP];
        if (!id) {
          id = NodeMap.nextId_++;
          try {
            node[NodeMap.ID_PROP] = id;
          } catch (e) {
          }
        }
        return id;
      };
      NodeMap.prototype.set = function (node, value) {
        var id = this.nodeId(node);
        this.nodes[id] = node;
        this.values[id] = value;
      };
      NodeMap.prototype.get = function (node) {
        var id = this.nodeId(node);
        return this.values[id];
      };
      NodeMap.prototype.has = function (node) {
        return this.nodeId(node) in this.nodes;
      };
      NodeMap.prototype['delete'] = function (node) {
        var id = this.nodeId(node);
        delete this.nodes[id];
        this.values[id] = undefined;
      };
      NodeMap.prototype.keys = function () {
        var nodes = [];
        for (var id in this.nodes) {
          if (!this.isIndex(id))
            continue;
          nodes.push(this.nodes[id]);
        }
        return nodes;
      };
      NodeMap.ID_PROP = '__nodeId' + ~~(Math.random() * 10000) + '__';
      NodeMap.nextId_ = 1;
      return NodeMap;
    }();
    //window.NodeMap = NodeMap;
    /**
     *  var reachableMatchableProduct = [
     *  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED
     *    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT
     *    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED
     *    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN
     *    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED
     *  ];
     */
    var Movement;
    (function (Movement) {
      Movement[Movement['STAYED_OUT'] = 0] = 'STAYED_OUT';
      Movement[Movement['ENTERED'] = 1] = 'ENTERED';
      Movement[Movement['STAYED_IN'] = 2] = 'STAYED_IN';
      Movement[Movement['REPARENTED'] = 3] = 'REPARENTED';
      Movement[Movement['REORDERED'] = 4] = 'REORDERED';
      Movement[Movement['EXITED'] = 5] = 'EXITED';
    }(Movement || (Movement = {})));
    function enteredOrExited(changeType) {
      return changeType === 1  /* ENTERED */ || changeType === 5  /* EXITED */;
    }
    var NodeChange = function () {
      function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {
        if (typeof childList === 'undefined') {
          childList = false;
        }
        if (typeof attributes === 'undefined') {
          attributes = false;
        }
        if (typeof characterData === 'undefined') {
          characterData = false;
        }
        if (typeof oldParentNode === 'undefined') {
          oldParentNode = null;
        }
        if (typeof added === 'undefined') {
          added = false;
        }
        if (typeof attributeOldValues === 'undefined') {
          attributeOldValues = null;
        }
        if (typeof characterDataOldValue === 'undefined') {
          characterDataOldValue = null;
        }
        this.node = node;
        this.childList = childList;
        this.attributes = attributes;
        this.characterData = characterData;
        this.oldParentNode = oldParentNode;
        this.added = added;
        this.attributeOldValues = attributeOldValues;
        this.characterDataOldValue = characterDataOldValue;
        this.isCaseInsensitive = this.node.nodeType === Node.ELEMENT_NODE && this.node.nodeType === 1 && Object.prototype.toString.call(this.node.ownerDocument) == '[object HTMLDocument]';
      }
      NodeChange.prototype.getAttributeOldValue = function (name) {
        if (!this.attributeOldValues)
          return undefined;
        if (this.isCaseInsensitive)
          name = name.toLowerCase();
        return this.attributeOldValues[name];
      };
      NodeChange.prototype.getAttributeNamesMutated = function () {
        var names = [];
        if (!this.attributeOldValues)
          return names;
        for (var name in this.attributeOldValues) {
          names.push(name);
        }
        return names;
      };
      NodeChange.prototype.attributeMutated = function (name, oldValue) {
        this.attributes = true;
        this.attributeOldValues = this.attributeOldValues || {};
        if (name in this.attributeOldValues)
          return;
        this.attributeOldValues[name] = oldValue;
      };
      NodeChange.prototype.characterDataMutated = function (oldValue) {
        if (this.characterData)
          return;
        this.characterData = true;
        this.characterDataOldValue = oldValue;
      };
      // Note: is it possible to receive a removal followed by a removal. This
      // can occur if the removed node is added to an non-observed node, that
      // node is added to the observed area, and then the node removed from
      // it.
      NodeChange.prototype.removedFromParent = function (parent) {
        this.childList = true;
        if (this.added || this.oldParentNode)
          this.added = false;
        else
          this.oldParentNode = parent;
      };
      NodeChange.prototype.insertedIntoParent = function () {
        this.childList = true;
        this.added = true;
      };
      // An node's oldParent is
      //   -its present parent, if its parentNode was not changed.
      //   -null if the first thing that happened to it was an add.
      //   -the node it was removed from if the first thing that happened to it
      //      was a remove.
      NodeChange.prototype.getOldParent = function () {
        if (this.childList) {
          if (this.oldParentNode)
            return this.oldParentNode;
          if (this.added)
            return null;
        }
        return this.node.parentNode;
      };
      return NodeChange;
    }();
    //  window.NodeChange = NodeChange;
    var ChildListChange = function () {
      function ChildListChange() {
        this.added = new NodeMap();
        this.removed = new NodeMap();
        this.maybeMoved = new NodeMap();
        this.oldPrevious = new NodeMap();
        this.moved = undefined;
      }
      return ChildListChange;
    }();
    // window.ChildListChange = ChildListChange;
    var TreeChanges = function (_super) {
      __extends(TreeChanges, _super);
      function TreeChanges(rootNode, mutations) {
        _super.call(this);
        this.rootNode = rootNode;
        this.reachableCache = undefined;
        this.wasReachableCache = undefined;
        this.anyParentsChanged = false;
        this.anyAttributesChanged = false;
        this.anyCharacterDataChanged = false;
        for (var m = 0; m < mutations.length; m++) {
          var mutation = mutations[m];
          switch (mutation.type) {
          case 'childList':
            this.anyParentsChanged = true;
            for (var i = 0; i < mutation.removedNodes.length; i++) {
              var node = mutation.removedNodes[i];
              this.getChange(node).removedFromParent(mutation.target);
            }
            for (var i = 0; i < mutation.addedNodes.length; i++) {
              var node = mutation.addedNodes[i];
              this.getChange(node).insertedIntoParent();
            }
            break;
          case 'attributes':
            this.anyAttributesChanged = true;
            var change = this.getChange(mutation.target);
            change.attributeMutated(mutation.attributeName, mutation.oldValue);
            break;
          case 'characterData':
            this.anyCharacterDataChanged = true;
            var change = this.getChange(mutation.target);
            change.characterDataMutated(mutation.oldValue);
            break;
          }
        }
      }
      TreeChanges.prototype.getChange = function (node) {
        var change = this.get(node);
        if (!change) {
          change = new NodeChange(node);
          this.set(node, change);
        }
        return change;
      };
      TreeChanges.prototype.getOldParent = function (node) {
        var change = this.get(node);
        return change ? change.getOldParent() : node.parentNode;
      };
      TreeChanges.prototype.getIsReachable = function (node) {
        if (node === this.rootNode)
          return true;
        if (!node)
          return false;
        this.reachableCache = this.reachableCache || new NodeMap();
        var isReachable = this.reachableCache.get(node);
        if (isReachable === undefined) {
          isReachable = this.getIsReachable(node.parentNode);
          this.reachableCache.set(node, isReachable);
        }
        return isReachable;
      };
      // A node wasReachable if its oldParent wasReachable.
      TreeChanges.prototype.getWasReachable = function (node) {
        if (node === this.rootNode)
          return true;
        if (!node)
          return false;
        this.wasReachableCache = this.wasReachableCache || new NodeMap();
        var wasReachable = this.wasReachableCache.get(node);
        if (wasReachable === undefined) {
          wasReachable = this.getWasReachable(this.getOldParent(node));
          this.wasReachableCache.set(node, wasReachable);
        }
        return wasReachable;
      };
      TreeChanges.prototype.reachabilityChange = function (node) {
        if (this.getIsReachable(node)) {
          return this.getWasReachable(node) ? 2  /* STAYED_IN */ : 1  /* ENTERED */;
        }
        return this.getWasReachable(node) ? 5  /* EXITED */ : 0  /* STAYED_OUT */;
      };
      return TreeChanges;
    }(NodeMap);
    //  window.TreeChanges = TreeChanges;
    var MutationProjection = function () {
      // TOOD(any)
      function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {
        this.rootNode = rootNode;
        this.mutations = mutations;
        this.selectors = selectors;
        this.calcReordered = calcReordered;
        this.calcOldPreviousSibling = calcOldPreviousSibling;
        this.treeChanges = new TreeChanges(rootNode, mutations);
        this.entered = [];
        this.exited = [];
        this.stayedIn = new NodeMap();
        this.visited = new NodeMap();
        this.childListChangeMap = undefined;
        this.characterDataOnly = undefined;
        this.matchCache = undefined;
        this.processMutations();
      }
      MutationProjection.prototype.processMutations = function () {
        if (!this.treeChanges.anyParentsChanged && !this.treeChanges.anyAttributesChanged)
          return;
        var changedNodes = this.treeChanges.keys();
        for (var i = 0; i < changedNodes.length; i++) {
          this.visitNode(changedNodes[i], undefined);
        }
      };
      MutationProjection.prototype.visitNode = function (node, parentReachable) {
        if (this.visited.has(node))
          return;
        this.visited.set(node, true);
        var change = this.treeChanges.get(node);
        var reachable = parentReachable;
        // node inherits its parent's reachability change unless
        // its parentNode was mutated.
        if (change && change.childList || reachable == undefined)
          reachable = this.treeChanges.reachabilityChange(node);
        if (reachable === 0  /* STAYED_OUT */)
          return;
        // Cache match results for sub-patterns.
        this.matchabilityChange(node);
        if (reachable === 1  /* ENTERED */) {
          this.entered.push(node);
        } else if (reachable === 5  /* EXITED */) {
          this.exited.push(node);
          this.ensureHasOldPreviousSiblingIfNeeded(node);
        } else if (reachable === 2  /* STAYED_IN */) {
          var movement = 2  /* STAYED_IN */;
          if (change && change.childList) {
            if (change.oldParentNode !== node.parentNode) {
              movement = 3  /* REPARENTED */;
              this.ensureHasOldPreviousSiblingIfNeeded(node);
            } else if (this.calcReordered && this.wasReordered(node)) {
              movement = 4  /* REORDERED */;
            }
          }
          this.stayedIn.set(node, movement);
        }
        if (reachable === 2  /* STAYED_IN */)
          return;
        for (var child = node.firstChild; child; child = child.nextSibling) {
          this.visitNode(child, reachable);
        }
      };
      MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {
        if (!this.calcOldPreviousSibling)
          return;
        this.processChildlistChanges();
        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
          parentNode = nodeChange.oldParentNode;
        var change = this.childListChangeMap.get(parentNode);
        if (!change) {
          change = new ChildListChange();
          this.childListChangeMap.set(parentNode, change);
        }
        if (!change.oldPrevious.has(node)) {
          change.oldPrevious.set(node, node.previousSibling);
        }
      };
      MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {
        this.selectors = selectors;
        this.characterDataOnly = characterDataOnly;
        for (var i = 0; i < this.entered.length; i++) {
          var node = this.entered[i];
          var matchable = this.matchabilityChange(node);
          if (matchable === 1  /* ENTERED */ || matchable === 2  /* STAYED_IN */)
            summary.added.push(node);
        }
        var stayedInNodes = this.stayedIn.keys();
        for (var i = 0; i < stayedInNodes.length; i++) {
          var node = stayedInNodes[i];
          var matchable = this.matchabilityChange(node);
          if (matchable === 1  /* ENTERED */) {
            summary.added.push(node);
          } else if (matchable === 5  /* EXITED */) {
            summary.removed.push(node);
          } else if (matchable === 2  /* STAYED_IN */ && (summary.reparented || summary.reordered)) {
            var movement = this.stayedIn.get(node);
            if (summary.reparented && movement === 3  /* REPARENTED */)
              summary.reparented.push(node);
            else if (summary.reordered && movement === 4  /* REORDERED */)
              summary.reordered.push(node);
          }
        }
        for (var i = 0; i < this.exited.length; i++) {
          var node = this.exited[i];
          var matchable = this.matchabilityChange(node);
          if (matchable === 5  /* EXITED */ || matchable === 2  /* STAYED_IN */)
            summary.removed.push(node);
        }
      };
      MutationProjection.prototype.getOldParentNode = function (node) {
        var change = this.treeChanges.get(node);
        if (change && change.childList)
          return change.oldParentNode ? change.oldParentNode : null;
        var reachabilityChange = this.treeChanges.reachabilityChange(node);
        if (reachabilityChange === 0  /* STAYED_OUT */ || reachabilityChange === 1  /* ENTERED */)
          throw Error('getOldParentNode requested on invalid node.');
        return node.parentNode;
      };
      MutationProjection.prototype.getOldPreviousSibling = function (node) {
        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
          parentNode = nodeChange.oldParentNode;
        var change = this.childListChangeMap.get(parentNode);
        if (!change)
          throw Error('getOldPreviousSibling requested on invalid node.');
        return change.oldPrevious.get(node);
      };
      MutationProjection.prototype.getOldAttribute = function (element, attrName) {
        var change = this.treeChanges.get(element);
        if (!change || !change.attributes)
          throw Error('getOldAttribute requested on invalid node.');
        var value = change.getAttributeOldValue(attrName);
        if (value === undefined)
          throw Error('getOldAttribute requested for unchanged attribute name.');
        return value;
      };
      MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {
        if (!this.treeChanges.anyAttributesChanged)
          return {};
        var attributeFilter;
        var caseInsensitiveFilter;
        if (includeAttributes) {
          attributeFilter = {};
          caseInsensitiveFilter = {};
          for (var i = 0; i < includeAttributes.length; i++) {
            var attrName = includeAttributes[i];
            attributeFilter[attrName] = true;
            caseInsensitiveFilter[attrName.toLowerCase()] = attrName;
          }
        }
        var result = {};
        var nodes = this.treeChanges.keys();
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          var change = this.treeChanges.get(node);
          if (!change.attributes)
            continue;
          if (2  /* STAYED_IN */ !== this.treeChanges.reachabilityChange(node) || 2  /* STAYED_IN */ !== this.matchabilityChange(node)) {
            continue;
          }
          var element = node;
          var changedAttrNames = change.getAttributeNamesMutated();
          for (var j = 0; j < changedAttrNames.length; j++) {
            var attrName = changedAttrNames[j];
            if (attributeFilter && !attributeFilter[attrName] && !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {
              continue;
            }
            var isIE11 = !!window.MSInputMethodContext && !!document.documentMode;
            /* need to add IE11 specific code here because when removing the attribute 'disabled'
               the old Value is not an empty string as it should be but null and therefore this change is not
               part of the summary of changed attributes (oldValue is equal to new value)
            */
            var oldValue = change.getAttributeOldValue(attrName);
            if (oldValue === element.getAttribute(attrName) && !(isIE11 && attrName === 'disabled'))
              continue;
            if (caseInsensitiveFilter && change.isCaseInsensitive)
              attrName = caseInsensitiveFilter[attrName];
            result[attrName] = result[attrName] || [];
            result[attrName].push(element);
          }
        }
        return result;
      };
      MutationProjection.prototype.getOldCharacterData = function (node) {
        var change = this.treeChanges.get(node);
        if (!change || !change.characterData)
          throw Error('getOldCharacterData requested on invalid node.');
        return change.characterDataOldValue;
      };
      MutationProjection.prototype.getCharacterDataChanged = function () {
        if (!this.treeChanges.anyCharacterDataChanged)
          return [];
        var nodes = this.treeChanges.keys();
        var result = [];
        for (var i = 0; i < nodes.length; i++) {
          var target = nodes[i];
          if (2  /* STAYED_IN */ !== this.treeChanges.reachabilityChange(target))
            continue;
          var change = this.treeChanges.get(target);
          if (!change.characterData || target.textContent == change.characterDataOldValue)
            continue;
          result.push(target);
        }
        return result;
      };
      MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {
        if (!this.matchCache)
          this.matchCache = [];
        if (!this.matchCache[selector.uid])
          this.matchCache[selector.uid] = new NodeMap();
        var cache = this.matchCache[selector.uid];
        var result = cache.get(el);
        if (result === undefined) {
          result = selector.matchabilityChange(el, this.treeChanges.get(el));
          cache.set(el, result);
        }
        return result;
      };
      MutationProjection.prototype.matchabilityChange = function (node) {
        var _this = this;
        // TODO(rafaelw): Include PI, CDATA?
        // Only include text nodes.
        if (this.characterDataOnly) {
          switch (node.nodeType) {
          case Node.COMMENT_NODE:
          case Node.TEXT_NODE:
            return 2  /* STAYED_IN */;
          default:
            return 0  /* STAYED_OUT */;
          }
        }
        // No element filter. Include all nodes.
        if (!this.selectors)
          return 2  /* STAYED_IN */;
        // Element filter. Exclude non-elements.
        if (node.nodeType !== Node.ELEMENT_NODE)
          return 0  /* STAYED_OUT */;
        var el = node;
        var matchChanges = this.selectors.map(function (selector) {
          return _this.computeMatchabilityChange(selector, el);
        });
        var accum = 0  /* STAYED_OUT */;
        var i = 0;
        while (accum !== 2  /* STAYED_IN */ && i < matchChanges.length) {
          switch (matchChanges[i]) {
          case 2  /* STAYED_IN */:
            accum = 2  /* STAYED_IN */;
            break;
          case 1  /* ENTERED */:
            if (accum === 5  /* EXITED */)
              accum = 2  /* STAYED_IN */;
            else
              accum = 1  /* ENTERED */;
            break;
          case 5  /* EXITED */:
            if (accum === 1  /* ENTERED */)
              accum = 2  /* STAYED_IN */;
            else
              accum = 5  /* EXITED */;
            break;
          }
          i++;
        }
        return accum;
      };
      MutationProjection.prototype.getChildlistChange = function (el) {
        var change = this.childListChangeMap.get(el);
        if (!change) {
          change = new ChildListChange();
          this.childListChangeMap.set(el, change);
        }
        return change;
      };
      MutationProjection.prototype.processChildlistChanges = function () {
        if (this.childListChangeMap)
          return;
        this.childListChangeMap = new NodeMap();
        for (var i = 0; i < this.mutations.length; i++) {
          var mutation = this.mutations[i];
          if (mutation.type != 'childList')
            continue;
          if (this.treeChanges.reachabilityChange(mutation.target) !== 2  /* STAYED_IN */ && !this.calcOldPreviousSibling)
            continue;
          var change = this.getChildlistChange(mutation.target);
          var oldPrevious = mutation.previousSibling;
          function recordOldPrevious(node, previous) {
            if (!node || change.oldPrevious.has(node) || change.added.has(node) || change.maybeMoved.has(node))
              return;
            if (previous && (change.added.has(previous) || change.maybeMoved.has(previous)))
              return;
            change.oldPrevious.set(node, previous);
          }
          for (var j = 0; j < mutation.removedNodes.length; j++) {
            var node = mutation.removedNodes[j];
            recordOldPrevious(node, oldPrevious);
            if (change.added.has(node)) {
              change.added['delete'](node);
            } else {
              change.removed.set(node, true);
              change.maybeMoved['delete'](node);
            }
            oldPrevious = node;
          }
          recordOldPrevious(mutation.nextSibling, oldPrevious);
          for (var j = 0; j < mutation.addedNodes.length; j++) {
            var node = mutation.addedNodes[j];
            if (change.removed.has(node)) {
              change.removed['delete'](node);
              change.maybeMoved.set(node, true);
            } else {
              change.added.set(node, true);
            }
          }
        }
      };
      MutationProjection.prototype.wasReordered = function (node) {
        if (!this.treeChanges.anyParentsChanged)
          return false;
        this.processChildlistChanges();
        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
          parentNode = nodeChange.oldParentNode;
        var change = this.childListChangeMap.get(parentNode);
        if (!change)
          return false;
        if (change.moved)
          return change.moved.get(node);
        change.moved = new NodeMap();
        var pendingMoveDecision = new NodeMap();
        function isMoved(node) {
          if (!node)
            return false;
          if (!change.maybeMoved.has(node))
            return false;
          var didMove = change.moved.get(node);
          if (didMove !== undefined)
            return didMove;
          if (pendingMoveDecision.has(node)) {
            didMove = true;
          } else {
            pendingMoveDecision.set(node, true);
            didMove = getPrevious(node) !== getOldPrevious(node);
          }
          if (pendingMoveDecision.has(node)) {
            pendingMoveDecision['delete'](node);
            change.moved.set(node, didMove);
          } else {
            didMove = change.moved.get(node);
          }
          return didMove;
        }
        var oldPreviousCache = new NodeMap();
        function getOldPrevious(node) {
          var oldPrevious = oldPreviousCache.get(node);
          if (oldPrevious !== undefined)
            return oldPrevious;
          oldPrevious = change.oldPrevious.get(node);
          while (oldPrevious && (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {
            oldPrevious = getOldPrevious(oldPrevious);
          }
          if (oldPrevious === undefined)
            oldPrevious = node.previousSibling;
          oldPreviousCache.set(node, oldPrevious);
          return oldPrevious;
        }
        var previousCache = new NodeMap();
        function getPrevious(node) {
          if (previousCache.has(node))
            return previousCache.get(node);
          var previous = node.previousSibling;
          while (previous && (change.added.has(previous) || isMoved(previous)))
            previous = previous.previousSibling;
          previousCache.set(node, previous);
          return previous;
        }
        change.maybeMoved.keys().forEach(isMoved);
        return change.moved.get(node);
      };
      return MutationProjection;
    }();
    //window.MutationProjection = MutationProjection;
    var Summary = function () {
      function Summary(projection, query) {
        var _this = this;
        this.projection = projection;
        this.added = [];
        this.removed = [];
        this.reparented = query.all || query.element ? [] : undefined;
        this.reordered = query.all ? [] : undefined;
        projection.getChanged(this, query.elementFilter, query.characterData);
        if (query.all || query.attribute || query.attributeList) {
          var filter = query.attribute ? [query.attribute] : query.attributeList;
          var attributeChanged = projection.attributeChangedNodes(filter);
          if (query.attribute) {
            this.valueChanged = attributeChanged[query.attribute] || [];
          } else {
            this.attributeChanged = attributeChanged;
            if (query.attributeList) {
              query.attributeList.forEach(function (attrName) {
                if (!_this.attributeChanged.hasOwnProperty(attrName))
                  _this.attributeChanged[attrName] = [];
              });
            }
          }
        }
        if (query.all || query.characterData) {
          var characterDataChanged = projection.getCharacterDataChanged();
          if (query.characterData)
            this.valueChanged = characterDataChanged;
          else
            this.characterDataChanged = characterDataChanged;
        }
        if (this.reordered)
          this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);
      }
      Summary.prototype.getOldParentNode = function (node) {
        return this.projection.getOldParentNode(node);
      };
      Summary.prototype.getOldAttribute = function (node, name) {
        return this.projection.getOldAttribute(node, name);
      };
      Summary.prototype.getOldCharacterData = function (node) {
        return this.projection.getOldCharacterData(node);
      };
      Summary.prototype.getOldPreviousSibling = function (node) {
        return this.projection.getOldPreviousSibling(node);
      };
      return Summary;
    }();
    // window.Summary = Summary;
    // TODO(rafaelw): Allow ':' and '.' as valid name characters.
    var validNameInitialChar = /[a-zA-Z_]+/;
    var validNameNonInitialChar = /[a-zA-Z0-9_\-]+/;
    // TODO(rafaelw): Consider allowing backslash in the attrValue.
    // TODO(rafaelw): There's got a to be way to represent this state machine
    // more compactly???
    function escapeQuotes(value) {
      return '"' + value.replace(/"/, '\\"') + '"';
    }
    var Qualifier = function () {
      function Qualifier() {
      }
      Qualifier.prototype.matches = function (oldValue) {
        if (oldValue === null)
          return false;
        if (this.attrValue === undefined)
          return true;
        if (!this.contains)
          return this.attrValue == oldValue;
        var tokens = oldValue.split(' ');
        for (var i = 0; i < tokens.length; i++) {
          if (this.attrValue === tokens[i])
            return true;
        }
        return false;
      };
      Qualifier.prototype.toString = function () {
        if (this.attrName === 'class' && this.contains)
          return '.' + this.attrValue;
        if (this.attrName === 'id' && !this.contains)
          return '#' + this.attrValue;
        if (this.contains)
          return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';
        if ('attrValue' in this)
          return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';
        return '[' + this.attrName + ']';
      };
      return Qualifier;
    }();
    // window.Qualifier = Qualifier;
    var Selector = function () {
      function Selector() {
        this.uid = Selector.nextUid++;
        this.qualifiers = [];
      }
      Selector.prototype.caseInsensitiveTagName = function () {
        return this.tagName.toUpperCase();
      };
      Selector.prototype.selectorString = function () {
        return this.tagName + qualifiers.join('');
      };
      Selector.prototype.isMatching = function (el) {
        return el[Selector.matchesSelector](this.selectorString);
      };
      Selector.prototype.wasMatching = function (el, change, isMatching) {
        if (!change || !change.attributes)
          return isMatching;
        var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;
        if (tagName !== '*' && tagName !== el.tagName)
          return false;
        var attributeOldValues = [];
        var anyChanged = false;
        for (var i = 0; i < this.qualifiers.length; i++) {
          var qualifier = this.qualifiers[i];
          var oldValue = change.getAttributeOldValue(qualifier.attrName);
          attributeOldValues.push(oldValue);
          anyChanged = anyChanged || oldValue !== undefined;
        }
        if (!anyChanged)
          return isMatching;
        for (var i = 0; i < this.qualifiers.length; i++) {
          var qualifier = this.qualifiers[i];
          var oldValue = attributeOldValues[i];
          if (oldValue === undefined)
            oldValue = el.getAttribute(qualifier.attrName);
          if (!qualifier.matches(oldValue))
            return false;
        }
        return true;
      };
      Selector.prototype.matchabilityChange = function (el, change) {
        var isMatching = this.isMatching(el);
        if (isMatching)
          return this.wasMatching(el, change, isMatching) ? 2  /* STAYED_IN */ : 1  /* ENTERED */;
        else
          return this.wasMatching(el, change, isMatching) ? 5  /* EXITED */ : 0  /* STAYED_OUT */;
      };
      Selector.parseSelectors = function (input) {
        var selectors = [];
        var currentSelector;
        var currentQualifier;
        function newSelector() {
          if (currentSelector) {
            if (currentQualifier) {
              currentSelector.qualifiers.push(currentQualifier);
              currentQualifier = undefined;
            }
            selectors.push(currentSelector);
          }
          currentSelector = new Selector();
        }
        function newQualifier() {
          if (currentQualifier)
            currentSelector.qualifiers.push(currentQualifier);
          currentQualifier = new Qualifier();
        }
        var WHITESPACE = /\s/;
        var valueQuoteChar;
        var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';
        var SELECTOR = 1;
        var TAG_NAME = 2;
        var QUALIFIER = 3;
        var QUALIFIER_NAME_FIRST_CHAR = 4;
        var QUALIFIER_NAME = 5;
        var ATTR_NAME_FIRST_CHAR = 6;
        var ATTR_NAME = 7;
        var EQUIV_OR_ATTR_QUAL_END = 8;
        var EQUAL = 9;
        var ATTR_QUAL_END = 10;
        var VALUE_FIRST_CHAR = 11;
        var VALUE = 12;
        var QUOTED_VALUE = 13;
        var SELECTOR_SEPARATOR = 14;
        var state = SELECTOR;
        var i = 0;
        while (i < input.length) {
          var c = input[i++];
          switch (state) {
          case SELECTOR:
            if (c.match(validNameInitialChar)) {
              newSelector();
              currentSelector.tagName = c;
              state = TAG_NAME;
              break;
            }
            if (c == '*') {
              newSelector();
              currentSelector.tagName = '*';
              state = QUALIFIER;
              break;
            }
            if (c == '.') {
              newSelector();
              newQualifier();
              currentSelector.tagName = '*';
              currentQualifier.attrName = 'class';
              currentQualifier.contains = true;
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '#') {
              newSelector();
              newQualifier();
              currentSelector.tagName = '*';
              currentQualifier.attrName = 'id';
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '[') {
              newSelector();
              newQualifier();
              currentSelector.tagName = '*';
              currentQualifier.attrName = '';
              state = ATTR_NAME_FIRST_CHAR;
              break;
            }
            if (c.match(WHITESPACE))
              break;
            throw Error(SYNTAX_ERROR);
          case TAG_NAME:
            if (c.match(validNameNonInitialChar)) {
              currentSelector.tagName += c;
              break;
            }
            if (c == '.') {
              newQualifier();
              currentQualifier.attrName = 'class';
              currentQualifier.contains = true;
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '#') {
              newQualifier();
              currentQualifier.attrName = 'id';
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '[') {
              newQualifier();
              currentQualifier.attrName = '';
              state = ATTR_NAME_FIRST_CHAR;
              break;
            }
            if (c.match(WHITESPACE)) {
              state = SELECTOR_SEPARATOR;
              break;
            }
            if (c == ',') {
              state = SELECTOR;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case QUALIFIER:
            if (c == '.') {
              newQualifier();
              currentQualifier.attrName = 'class';
              currentQualifier.contains = true;
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '#') {
              newQualifier();
              currentQualifier.attrName = 'id';
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '[') {
              newQualifier();
              currentQualifier.attrName = '';
              state = ATTR_NAME_FIRST_CHAR;
              break;
            }
            if (c.match(WHITESPACE)) {
              state = SELECTOR_SEPARATOR;
              break;
            }
            if (c == ',') {
              state = SELECTOR;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case QUALIFIER_NAME_FIRST_CHAR:
            if (c.match(validNameInitialChar)) {
              currentQualifier.attrValue = c;
              state = QUALIFIER_NAME;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case QUALIFIER_NAME:
            if (c.match(validNameNonInitialChar)) {
              currentQualifier.attrValue += c;
              break;
            }
            if (c == '.') {
              newQualifier();
              currentQualifier.attrName = 'class';
              currentQualifier.contains = true;
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '#') {
              newQualifier();
              currentQualifier.attrName = 'id';
              state = QUALIFIER_NAME_FIRST_CHAR;
              break;
            }
            if (c == '[') {
              newQualifier();
              state = ATTR_NAME_FIRST_CHAR;
              break;
            }
            if (c.match(WHITESPACE)) {
              state = SELECTOR_SEPARATOR;
              break;
            }
            if (c == ',') {
              state = SELECTOR;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case ATTR_NAME_FIRST_CHAR:
            if (c.match(validNameInitialChar)) {
              currentQualifier.attrName = c;
              state = ATTR_NAME;
              break;
            }
            if (c.match(WHITESPACE))
              break;
            throw Error(SYNTAX_ERROR);
          case ATTR_NAME:
            if (c.match(validNameNonInitialChar)) {
              currentQualifier.attrName += c;
              break;
            }
            if (c.match(WHITESPACE)) {
              state = EQUIV_OR_ATTR_QUAL_END;
              break;
            }
            if (c == '~') {
              currentQualifier.contains = true;
              state = EQUAL;
              break;
            }
            if (c == '=') {
              currentQualifier.attrValue = '';
              state = VALUE_FIRST_CHAR;
              break;
            }
            if (c == ']') {
              state = QUALIFIER;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case EQUIV_OR_ATTR_QUAL_END:
            if (c == '~') {
              currentQualifier.contains = true;
              state = EQUAL;
              break;
            }
            if (c == '=') {
              currentQualifier.attrValue = '';
              state = VALUE_FIRST_CHAR;
              break;
            }
            if (c == ']') {
              state = QUALIFIER;
              break;
            }
            if (c.match(WHITESPACE))
              break;
            throw Error(SYNTAX_ERROR);
          case EQUAL:
            if (c == '=') {
              currentQualifier.attrValue = '';
              state = VALUE_FIRST_CHAR;
              break;
            }
            throw Error(SYNTAX_ERROR);
          case ATTR_QUAL_END:
            if (c == ']') {
              state = QUALIFIER;
              break;
            }
            if (c.match(WHITESPACE))
              break;
            throw Error(SYNTAX_ERROR);
          case VALUE_FIRST_CHAR:
            if (c.match(WHITESPACE))
              break;
            if (c == '"' || c == '\'') {
              valueQuoteChar = c;
              state = QUOTED_VALUE;
              break;
            }
            currentQualifier.attrValue += c;
            state = VALUE;
            break;
          case VALUE:
            if (c.match(WHITESPACE)) {
              state = ATTR_QUAL_END;
              break;
            }
            if (c == ']') {
              state = QUALIFIER;
              break;
            }
            if (c == '\'' || c == '"')
              throw Error(SYNTAX_ERROR);
            currentQualifier.attrValue += c;
            break;
          case QUOTED_VALUE:
            if (c == valueQuoteChar) {
              state = ATTR_QUAL_END;
              break;
            }
            currentQualifier.attrValue += c;
            break;
          case SELECTOR_SEPARATOR:
            if (c.match(WHITESPACE))
              break;
            if (c == ',') {
              state = SELECTOR;
              break;
            }
            throw Error(SYNTAX_ERROR);
          }
        }
        switch (state) {
        case SELECTOR:
        case TAG_NAME:
        case QUALIFIER:
        case QUALIFIER_NAME:
        case SELECTOR_SEPARATOR:
          // Valid end states.
          newSelector();
          break;
        default:
          throw Error(SYNTAX_ERROR);
        }
        if (!selectors.length)
          throw Error(SYNTAX_ERROR);
        return selectors;
      };
      Selector.nextUid = 1;
      Selector.matchesSelector = function () {
        var element = document.createElement('div');
        if (typeof element['webkitMatchesSelector'] === 'function')
          return 'webkitMatchesSelector';
        if (typeof element['mozMatchesSelector'] === 'function')
          return 'mozMatchesSelector';
        if (typeof element['msMatchesSelector'] === 'function')
          return 'msMatchesSelector';
        return 'matchesSelector';
      }();
      return Selector;
    }();
    // window.Selector = Selector;
    var attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\-:\.]*)$/;
    function validateAttribute(attribute) {
      if (typeof attribute != 'string')
        throw Error('Invalid request opion. attribute must be a non-zero length string.');
      attribute = attribute.trim();
      if (!attribute)
        throw Error('Invalid request opion. attribute must be a non-zero length string.');
      if (!attribute.match(attributeFilterPattern))
        throw Error('Invalid request option. invalid attribute name: ' + attribute);
      return attribute;
    }
    function validateElementAttributes(attribs) {
      if (!attribs.trim().length)
        throw Error('Invalid request option: elementAttributes must contain at least one attribute.');
      var lowerAttributes = {};
      var attributes = {};
      var tokens = attribs.split(/\s+/);
      for (var i = 0; i < tokens.length; i++) {
        var name = tokens[i];
        if (!name)
          continue;
        var name = validateAttribute(name);
        var nameLower = name.toLowerCase();
        if (lowerAttributes[nameLower])
          throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');
        attributes[name] = true;
        lowerAttributes[nameLower] = true;
      }
      return Object.keys(attributes);
    }
    function elementFilterAttributes(selectors) {
      var attributes = {};
      selectors.forEach(function (selector) {
        selector.qualifiers.forEach(function (qualifier) {
          attributes[qualifier.attrName] = true;
        });
      });
      return Object.keys(attributes);
    }
    var MutationSummary = function () {
      if (!Object.keys) {
        Object.keys = function (obj) {
          var keys = [];
          for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              keys.push(i);
            }
          }
          return keys;
        };
      }
      if (!('forEach' in Array.prototype)) {
        Array.prototype.forEach = function (action, that) {
          for (var i = 0, n = this.length; i < n; i++)
            if (i in this)
              action.call(that, this[i], i, this);
        };
      }
      if (!('map' in Array.prototype)) {
        Array.prototype.map = function (mapper, that) {
          var other = new Array(this.length);
          for (var i = 0, n = this.length; i < n; i++)
            if (i in this)
              other[i] = mapper.call(that, this[i], i, this);
          return other;
        };
      }
      if (!('some' in Array.prototype)) {
        Array.prototype.some = function (tester, that) {
          for (var i = 0, n = this.length; i < n; i++)
            if (i in this && tester.call(that, this[i], i, this))
              return true;
          return false;
        };
      }
      function MutationSummary(opts) {
        var _this = this;
        this.connected = false;
        this.options = MutationSummary.validateOptions(opts);
        this.observerOptions = MutationSummary.createObserverOptions(this.options.queries);
        this.root = this.options.rootNode;
        this.callback = this.options.callback;
        this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {
          return query.elementFilter ? query.elementFilter : [];
        }));
        if (!this.elementFilter.length)
          this.elementFilter = undefined;
        this.calcReordered = this.options.queries.some(function (query) {
          return query.all;
        });
        this.queryValidators = [];
        // TODO(rafaelw): Shouldn't always define this.
        if (MutationSummary.createQueryValidator) {
          this.queryValidators = this.options.queries.map(function (query) {
            return MutationSummary.createQueryValidator(_this.root, query);
          });
        }
        this.observer = new MutationObserverCtor(function (mutations) {
          _this.observerCallback(mutations);
        });
        observeCSSOM(this.callback);
        this.reconnect();
      }
      MutationSummary.createObserverOptions = function (queries) {
        var observerOptions = {
          childList: true,
          subtree: true
        };
        var attributeFilter;
        function observeAttributes(attributes) {
          if (observerOptions.attributes && !attributeFilter)
            return;
          observerOptions.attributes = true;
          observerOptions.attributeOldValue = true;
          if (!attributes) {
            // observe all.
            attributeFilter = undefined;
            return;
          }
          // add to observed.
          attributeFilter = attributeFilter || {};
          attributes.forEach(function (attribute) {
            attributeFilter[attribute] = true;
            attributeFilter[attribute.toLowerCase()] = true;
          });
        }
        queries.forEach(function (query) {
          if (query.characterData) {
            observerOptions.characterData = true;
            observerOptions.characterDataOldValue = true;
            return;
          }
          if (query.all) {
            observeAttributes();
            observerOptions.characterData = true;
            observerOptions.characterDataOldValue = true;
            return;
          }
          if (query.attribute) {
            observeAttributes([query.attribute.trim()]);
            return;
          }
          var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);
          if (attributes.length)
            observeAttributes(attributes);
        });
        if (attributeFilter)
          observerOptions.attributeFilter = Object.keys(attributeFilter);
        return observerOptions;
      };
      MutationSummary.validateOptions = function (options) {
        for (var prop in options) {
          if (!(prop in MutationSummary.optionKeys))
            throw Error('Invalid option: ' + prop);
        }
        if (typeof options.callback !== 'function')
          throw Error('Invalid options: callback is required and must be a function');
        if (!options.queries || !options.queries.length)
          throw Error('Invalid options: queries must contain at least one query request object.');
        var opts = {
          callback: options.callback,
          rootNode: options.rootNode || document,
          observeOwnChanges: !!options.observeOwnChanges,
          oldPreviousSibling: !!options.oldPreviousSibling,
          queries: []
        };
        for (var i = 0; i < options.queries.length; i++) {
          var request = options.queries[i];
          // all
          if (request.all) {
            if (Object.keys(request).length > 1)
              throw Error('Invalid request option. all has no options.');
            opts.queries.push({ all: true });
            continue;
          }
          // attribute
          if ('attribute' in request) {
            var query = { attribute: validateAttribute(request.attribute) };
            query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');
            if (Object.keys(request).length > 1)
              throw Error('Invalid request option. attribute has no options.');
            opts.queries.push(query);
            continue;
          }
          // element
          if ('element' in request) {
            var requestOptionCount = Object.keys(request).length;
            var query = {
              element: request.element,
              elementFilter: Selector.parseSelectors(request.element)
            };
            if (request.hasOwnProperty('elementAttributes')) {
              query.attributeList = validateElementAttributes(request.elementAttributes);
              requestOptionCount--;
            }
            if (requestOptionCount > 1)
              throw Error('Invalid request option. element only allows elementAttributes option.');
            opts.queries.push(query);
            continue;
          }
          // characterData
          if (request.characterData) {
            if (Object.keys(request).length > 1)
              throw Error('Invalid request option. characterData has no options.');
            opts.queries.push({ characterData: true });
            continue;
          }
          throw Error('Invalid request option. Unknown query request.');
        }
        return opts;
      };
      MutationSummary.prototype.createSummaries = function (mutations) {
        if (!mutations || !mutations.length)
          return [];
        var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);
        var summaries = [];
        for (var i = 0; i < this.options.queries.length; i++) {
          summaries.push(new Summary(projection, this.options.queries[i]));
        }
        return summaries;
      };
      MutationSummary.prototype.checkpointQueryValidators = function () {
        this.queryValidators.forEach(function (validator) {
          if (validator)
            validator.recordPreviousState();
        });
      };
      MutationSummary.prototype.runQueryValidators = function (summaries) {
        this.queryValidators.forEach(function (validator, index) {
          if (validator)
            validator.validate(summaries[index]);
        });
      };
      MutationSummary.prototype.changesToReport = function (summaries) {
        return summaries.some(function (summary) {
          var summaryProps = [
            'added',
            'removed',
            'reordered',
            'reparented',
            'valueChanged',
            'characterDataChanged'
          ];
          if (summaryProps.some(function (prop) {
              return summary[prop] && summary[prop].length;
            }))
            return true;
          if (summary.attributeChanged) {
            var attrNames = Object.keys(summary.attributeChanged);
            var attrsChanged = attrNames.some(function (attrName) {
              return !!summary.attributeChanged[attrName].length;
            });
            if (attrsChanged)
              return true;
          }
          return false;
        });
      };
      MutationSummary.prototype.observerCallback = function (mutations) {
        if (!this.options.observeOwnChanges)
          this.observer.disconnect();
        var summaries = this.createSummaries(mutations);
        this.runQueryValidators(summaries);
        if (this.options.observeOwnChanges)
          this.checkpointQueryValidators();
        if (this.changesToReport(summaries))
          this.callback(summaries);
        // disconnect() may have been called during the callback.
        if (!this.options.observeOwnChanges && this.connected) {
          this.checkpointQueryValidators();
          this.observer.observe(this.root, this.observerOptions);
        }
      };
      MutationSummary.prototype.reconnect = function () {
        if (this.connected)
          throw Error('Already connected');
        this.observer.observe(this.root, this.observerOptions);
        observeCSSOM(this.callback);
        this.connected = true;
        this.checkpointQueryValidators();
      };
      MutationSummary.prototype.takeSummaries = function () {
        if (!this.connected)
          throw Error('Not connected');
        var summaries = this.createSummaries(this.observer.takeRecords());
        return this.changesToReport(summaries) ? summaries : undefined;
      };
      MutationSummary.prototype.disconnect = function () {
        var summaries = this.takeSummaries();
        this.observer.disconnect();
        resetCSSOM();
        this.connected = false;
        return summaries;
      };
      MutationSummary.NodeMap = NodeMap;
      MutationSummary.parseElementFilter = Selector.parseSelectors;
      MutationSummary.optionKeys = {
        'callback': true,
        'queries': true,
        'rootNode': true,
        'oldPreviousSibling': true,
        'observeOwnChanges': true
      };
      return MutationSummary;
    }();
    window.LpCoBrowseMutationSummary = MutationSummary;
  }(dojo_has);
  synchronite_proxyless_dom_TreeListener = function (_TreeMirror, _MutationSummary) {
    return window.TreeMirrorClient;
  }(synchronite_proxyless_lib_tree_mirror, synchronite_proxyless_lib_mutation_summary);
  synchronite_proxyless_dom_common = {
    NAMESPACE: 'dom',
    DOM_SHADOW_INITIALIZE: 'dom:shadow:initialize',
    DOM_FRAME_INITIALIZE: 'dom:frame:initialize',
    DOM_INITIALIZE: 'dom:initialize',
    DOM_CHANGE: 'dom:change',
    DOM_IFRAME_CHANGE: 'dom:iframe:change',
    DOM_SHADOW_CHANGE: 'dom:shadow:change',
    frameSelectorToId: function (selector) {
      if (selector) {
        return selector.join('');
      }
      if (selector == null) {
        return 'root';
      }
      console.error('frameSelectorToId selector is undefined');
      return 'root';
    },
    getNodeFromEvent: function (event, mirror) {
      if (event.target.nodeId) {
        return mirror.knownNodes.nodes[event.target.nodeId];
      } else {
        var index = mirror.knownNodes.values.indexOf(event.target.id);
        return mirror.knownNodes.nodes[index];
      }
    },
    getShadowId: function (selector) {
      return selector.element + JSON.stringify(selector.shadow);
    }
  };
  synchronite_proxyless_dom_listener = function (lang, domClass, baseArray, TreeMirrorClient, common, shadowHosts, synchDom, Evented, has, query, on, synchQuery) {
    // Private variables
    var iframeMirrors = {};
    var shadowDomMirrors = {};
    var localDomEvents = new Evented();
    var MARKED_IGNORED = '__COBROWSE_IGNORED__';
    var filterElementsByClass = synchroniteConfig.protectAreasByClassName || [];
    var filterElementsById = synchroniteConfig.protectAreasById || [];
    // add default values
    filterElementsByClass = filterElementsByClass.concat([
      'ignoreDOM',
      'lp_desktop',
      'LPMcontainer',
      'lp_mobile',
      'lp_main_ltr',
      'lp_tablet',
      'lp_android',
      'chat-tab-wrapper'
    ]);
    filterElementsById = filterElementsById.concat([
      'lpChatStyle',
      'LP_CHAT_DIALOG'
    ]);
    var sendAttrChangeTimeouts = {};
    var isAnimation = function (attrChange) {
      return attrChange.attributes.style && /width|opacity|transform|margin-left/i.test(attrChange.attributes.style);
    };
    var delayDomChange = function (attributes) {
      console.debug('Delay DOM change ' + JSON.stringify(attributes));
      if (sendAttrChangeTimeouts[attributes[0].id]) {
        clearTimeout(sendAttrChangeTimeouts[attributes[0].id]);
      }
      sendAttrChangeTimeouts[attributes[0].id] = setTimeout(function () {
        if (iframeMirrors.root && iframeMirrors.root.mirror) {
          iframeMirrors.root.mirror.applyChanged([], [], attributes, [], true);
        }
      }, 100);
    };
    var getMirrorId = function (node) {
      var iframeWindow = node.contentWindow;
      var frameSelector = synchQuery.getFrameSelector(iframeWindow);
      return common.frameSelectorToId(frameSelector);
    };
    var getShadowIdFromNode = function (shadowNode) {
      var selector = synchQuery.getNodeSelector(shadowNode);
      return common.getShadowId(selector);
    };
    //stores functions that customize the tree mirror
    var createListeningDelegate = function (winOrNode, events, mirrorId, baseUrl, isShadowDom) {
      var mirrorDelegates = {};
      var selector = isShadowDom ? synchQuery.getNodeSelector(winOrNode) : synchQuery.getFrameSelector(winOrNode);
      var filterPseudoHover = function (serializedNodes) {
        return baseArray.filter(serializedNodes, function (serializedNode) {
          if (!serializedNode) {
            return false;
          }
          if (serializedNode && serializedNode.nodeType === 1) {
            var cls = serializedNode.attributes && serializedNode.attributes.class;
            if (cls === 'sn_ps_hover'  /* exactly equals pseudo hover */) {
              return false;
            }
          }
          return true;
        });
      };
      mirrorDelegates.isAttributeIgnored = function (attr, node) {
        // Ignore value attribute changes as they are synced using the utils.sendState() function and the field may be protected
        if (attr && attr.name === 'value') {
          // check which input type it is. We should only ignore "value" attributes if type is one of
          // ^text$|password|hidden|search|number|^tel$|url|color|datetime-local|^date$|week|month|^time$|email
          // Issue on orange website: Visitor enters something in to masked field.
          // Input is then validated and stored in the 'value' attribute of the element that'd then be sent to the agent
          for (var i = 0; i < node.attributes.length; i++) {
            if (node.attributes[i].name === 'type') {
              return /^text$|password|hidden|search|number|^tel$|url|color|datetime-local|^date$|week|month|^time$|email/i.test(node.attributes[i].value);
            }
          }
        }
        // ignore encoded svg
        if (attr && /^src$/i.test(attr.name) && /^img$/i.test(node.tagName) && /(^\s*javascript:.*|^\s*data:image\/svg\+xml.*)/i.test(attr.value)) {
          return true;
        }
        // ignore URLs on script tags
        if (attr && /^src$/i.test(attr.name) && /^script$/i.test(node.tagName)) {
          return true;
        }
        // ignore ng-reflect-model which contains the value of the input field in angular apps
        if (attr && /ng-reflect-model/i.test(attr.name)) {
          return true;
        }
      };
      /**
       * Check and mark a node when needs to be ignored by CoBrowse
       * @param {Node} node DOM Node
       * @param {Boolean=} excludeDynamic if true, it will ignore the current mark and will run the check again, this to exclude dynamic props - for example: `data-lp-cobrowse-animated` attribute (see effects.js)
       * @returns {Boolean}
       */
      mirrorDelegates.isIgnored = function (node, excludeDynamic) {
        if (node[MARKED_IGNORED] && !excludeDynamic) {
          return true;
        }
        //also ignore children of ignored elements
        if (node.parentNode && node.parentNode[MARKED_IGNORED]) {
          node[MARKED_IGNORED] = true;
          return true;
        }
        if (node && typeof node.id === 'string' && node.id.indexOf('rqst_cobr') === 0) {
          // filter our own JSONP requests
          node[MARKED_IGNORED] = true;
          return true;
        }
        if (node && typeof node.src === 'string' && node.src.indexOf('.dev.lprnd.net/api/') > 0) {
          // filter liveperson JSONP requests
          node[MARKED_IGNORED] = true;
          return true;
        }
        if (node && typeof node.src === 'string' && node.src.indexOf('.liveperson.net/api/') > 0) {
          // filter liveperson JSONP requests
          node[MARKED_IGNORED] = true;
          return true;
        }
        // For all other scripts tags, don't ignore the tag itself, just don't send the content.
        // Otherwise inserting other elements using insertBefore won't work anymore if they are located next to a script tag.
        if (node && node.parentNode && node.parentNode.tagName && node.parentNode.tagName.toLowerCase() === 'script') {
          node[MARKED_IGNORED] = true;
          return true;
        }
        for (var i = 0; i < filterElementsById.length; i++) {
          if (node.id && node.id === filterElementsById[i]) {
            node[MARKED_IGNORED] = true;
            return true;
          }
        }
        for (var i = 0; i < filterElementsByClass.length; i++) {
          if (domClass.contains(node, filterElementsByClass[i])) {
            node[MARKED_IGNORED] = true;
            return true;
          }
        }
      };
      mirrorDelegates.initialize = function (rootId, children) {
        console.log('send initial domtree for winOrNode:', {
          tagName: winOrNode.tagName,
          id: winOrNode.id,
          classList: winOrNode.classList
        });
        this.initState = {
          type: isShadowDom ? common.DOM_SHADOW_INITIALIZE : common.DOM_FRAME_INITIALIZE,
          target: selector,
          args: [
            rootId,
            children
          ],
          loc: { href: baseUrl }
        };
        events.emit(common.DOM_INITIALIZE, this.initState);
      };
      mirrorDelegates.applyChanged = function (removed, addedOrMoved, attributes, text, forceSend) {
        addedOrMoved = filterPseudoHover(addedOrMoved);
        attributes = filterPseudoHover(attributes);
        removed = filterPseudoHover(removed);
        if (addedOrMoved.length === 0 && removed.length === 0 && attributes.length === 0 && text.length === 0) {
          return;
        }
        // In case of DOM changes triggered by animations we discard the small animation steps and only send the last DOM change
        // Only used for animations that change the opacitity, transform or width of an object
        if (!forceSend && mirrorId === 'root' && attributes.length > 0) {
          var onlyAnimations = true;
          for (var i = 0; i < attributes.length; i++) {
            var attrId = attributes[i].id;
            if (addedOrMoved.length > 0 || removed.length > 0 || text.length > 0 || !isAnimation(attributes[i])) {
              // if there are more changes than just attribute changes or if it is not an animation, clear possible queued changes
              // Example: Increasing opacity animation is delayed, but last animation step is not changing the opactity but setting display:block
              // We would send the display block change and shortly after that the delayed opacity change.
              onlyAnimations = false;
              clearTimeout(sendAttrChangeTimeouts[attrId]);
            }
          }
          if (onlyAnimations) {
            // delay changes if it's only animations
            delayDomChange(attributes);
            return;
          }
        }
        //detect if iframe or shadow dom has been added
        if (addedOrMoved.length > 0) {
          for (var j = 0; j < addedOrMoved.length; ++j) {
            if (/frame|iframe/i.test(addedOrMoved[j].tagName)) {
              console.log('localDomEvents - iframe was changed ' + JSON.stringify(addedOrMoved[j]));
              events.emit(common.DOM_IFRAME_CHANGE, {
                type: common.DOM_IFRAME_CHANGE,
                target: addedOrMoved[j],
                mirror: mirrorId
              });
            } else if (addedOrMoved[j].isShadowRoot) {
              events.emit(common.DOM_SHADOW_CHANGE, {
                type: common.DOM_SHADOW_CHANGE,
                target: addedOrMoved[j],
                mirror: mirrorId
              });
            }
          }
        }
        var changeEvent = {
          type: common.DOM_CHANGE,
          args: [
            removed,
            addedOrMoved,
            attributes,
            text
          ]
        };
        if (isShadowDom) {
          changeEvent.shadowDom = selector;
        } else {
          changeEvent.frame = selector;
        }
        // console.debug(common.DOM_CHANGE + " -> " + JSON.stringify(changeEvent));
        events.emit(common.DOM_CHANGE, changeEvent, iframeMirrors[mirrorId]);
      };
      return mirrorDelegates;
    };
    var listenToShadowDom = function (node) {
      var shadowDomId = getShadowIdFromNode(node);
      var baseUrl = getBaseUrl(node.ownerDocument);
      if (shadowDomMirrors[shadowDomId]) {
        shadowDomMirrors[shadowDomId].disconnect();
      }
      shadowDomMirrors[shadowDomId] = new TreeMirrorClient(node, createListeningDelegate(node, localDomEvents, shadowDomId, baseUrl, true), [{ all: true }]);
    };
    var listenToFrame = function (node, parentMirror) {
      parentMirror = parentMirror || 'root';
      var iframeWindow = node.contentWindow;
      var iframeDocument = iframeWindow.document;
      var mirrorId = getMirrorId(node);
      var baseUrl = getBaseUrl(iframeDocument);
      var iframeLoadListener;
      iframeMirrors[mirrorId] = new TreeMirrorClient(iframeDocument, createListeningDelegate(iframeWindow, localDomEvents, mirrorId, baseUrl), [{ all: true }]);
      iframeLoadListener = on(node, 'load', function () {
        console.log('load - iframe has loaded ' + node.src);
        iframeLoadListener.remove();
        localDomEvents.emit(common.DOM_IFRAME_CHANGE, {
          type: common.DOM_IFRAME_CHANGE,
          target: { nodeId: node[LpCoBrowseMutationSummary.NodeMap.ID_PROP] },
          mirror: parentMirror
        });
      });
      if (synchroniteConfig.rewriteTargets) {
        if (synchDom.isNative(iframeWindow.open)) {
          iframeWindow.open = function (url, targetWindowName, features) {
            console.log('Overriding window.open(' + url + ', ' + targetWindowName + ', ' + features + ')');
            window.location = url;  // Lesson learned: Always open in main window to avoid mixed content.
          };
        }
      }
    };
    // returns the base url that should be used on the slave to resolve relative URLs
    var getBaseUrl = function (doc) {
      var baseUrl = doc.location.origin + doc.location.pathname + doc.location.search;
      var baseTags = doc.getElementsByTagName('base');
      if (baseTags.length && baseTags[0].href) {
        baseUrl = baseTags[0].href;
      }
      return baseUrl;
    };
    var attachIframeMirrors = function (win, events, parentMirror) {
      var contextDoc = win.document;
      var frameSelector = synchQuery.getFrameSelector(win);
      var mirrorId = common.frameSelectorToId(frameSelector);
      parentMirror = parentMirror || mirrorId;
      query('iframe,frame', contextDoc).forEach(function (node) {
        try {
          if (node.contentDocument) {
            listenToFrame(node, parentMirror);
            attachIframeMirrors(node.contentWindow, events, getMirrorId(node));
          } else {
            // third party iframe
            domClass.add(node, 'cobrowse-blocked');
          }
        } catch (e) {
          console.log('Failed to sync iframe with src ' + node.src + '. Encountered error ' + e);
          domClass.add(node, 'cobrowse-blocked');
        }
      });
    };
    var attachShadowDomMirrors = function (root, events, parentMirror) {
      var shadowDoms = shadowHosts.queryShadowHosts(root);
      for (var i = 0; i < shadowDoms.length; i++) {
        listenToShadowDom(shadowDoms[i], parentMirror);
        attachShadowDomMirrors(shadowDoms[i].shadowRoot, events, getShadowIdFromNode(shadowDoms[i]));
      }
    };
    var eventHandles = [];
    var stopListening = function () {
      baseArray.forEach(eventHandles, function (handle) {
        handle.remove();
      });
      for (var mirrorId in iframeMirrors) {
        if (iframeMirrors.hasOwnProperty(mirrorId)) {
          iframeMirrors[mirrorId].disconnect();
        }
      }
      for (var shadowMirrorId in shadowDomMirrors) {
        if (shadowDomMirrors.hasOwnProperty(shadowMirrorId)) {
          shadowDomMirrors[shadowMirrorId].disconnect();
        }
      }
      iframeMirrors = {};
      shadowDomMirrors = {};
    };
    var startListening = function (rootWindow) {
      stopListening();
      console.info('STARTLISTENING ' + rootWindow.location.href);
      //remove the nodeId param that is used by mutation summary from all elements
      var all = document.getElementsByTagName('*');
      for (var i = 0, max = all.length; i < max; i++) {
        if (all[i][LpCoBrowseMutationSummary.NodeMap.ID_PROP]) {
          delete all[i][LpCoBrowseMutationSummary.NodeMap.ID_PROP];
        }
      }
      var rootDocument = rootWindow.document, frameSelector = synchQuery.getFrameSelector(rootWindow), mirrorId = common.frameSelectorToId(frameSelector);
      // @cbikar What the purpose of scrolling here?
      // cbikar: on some websites some browsers scroll to the bottom once we capture the DOM
      rootWindow.scrollTo(0, 0);
      // Listen to main window
      iframeMirrors[mirrorId] = new TreeMirrorClient(rootDocument, createListeningDelegate(rootWindow, localDomEvents, mirrorId, getBaseUrl(rootDocument)), [{ all: true }]);
      if (synchroniteConfig.rewriteTargets) {
        if (synchDom.isNative(rootWindow.open)) {
          var nativeWinOpen = rootWindow.open;
          rootWindow.open = function (url, targetWindowName, features) {
            // allow chat window to be popped out (opened in a new browser window)
            if (/le_unified_window/i.test(url)) {
              nativeWinOpen(url, targetWindowName, features);
            } else {
              console.log('Overriding window.open(' + url + ', ' + targetWindowName + ', ' + features + ')');
              window.location = url;
              // Lesson learned: Always open in main window to avoid mixed content.
              return window;
            }
          };
        }
        if (synchDom.isNative(rootWindow.close)) {
          rootWindow.close = function () {
            history.go(-1);
          };
        }
      }
      // Listen to iframe windows (only works for same domain)
      attachIframeMirrors(rootWindow, localDomEvents, 'root');
      attachShadowDomMirrors(rootWindow.document.body, localDomEvents, 'root');
      eventHandles.push(localDomEvents.on(common.DOM_IFRAME_CHANGE, function (event) {
        if (event.mirror && event.target && (event.target.id || event.target.nodeId)) {
          setTimeout(function () {
            var mirror = iframeMirrors[event.mirror] || shadowDomMirrors[event.mirror];
            var node = common.getNodeFromEvent(event, mirror);
            if (node) {
              try {
                listenToFrame(node, event.mirror);
                attachIframeMirrors(node.contentWindow, localDomEvents, getMirrorId(node));
              } catch (e) {
                console.log('Failed to sync iframe with src ' + node.src + '. Encountered error ' + e);
                domClass.add(node, 'cobrowse-blocked');
              }
            }
          }, 1000);
        }
      }));
      eventHandles.push(localDomEvents.on(common.DOM_SHADOW_CHANGE, function (event) {
        if (event.mirror && event.target && (event.target.id || event.target.nodeId)) {
          setTimeout(function () {
            var mirror = shadowDomMirrors[event.mirror] || iframeMirrors[event.mirror];
            var node = common.getNodeFromEvent(event, mirror);
            if (node && node.shadowRoot) {
              try {
                listenToShadowDom(node);
                attachShadowDomMirrors(node.shadowRoot, localDomEvents, getShadowIdFromNode(node));
              } catch (e) {
                console.log('Failed to sync shadow dom with src ' + node.src + '. Encountered error ' + e);
              }
            }
          }, 1000);
        }
      }));
    };
    var getState = function (rootWin) {
      var frameSelector = synchQuery.getFrameSelector(rootWin);
      var mirrorId = common.frameSelectorToId(frameSelector);
      var treemirror = iframeMirrors[mirrorId];
      if (treemirror) {
        return treemirror.mirror.initState;  //                var target = rootWin.document;
                                             //                var rootId = treemirror.knownNodes.get(rootWin.document); //treemirror.serializeNode(rootWin.document).id;
                                             //                var children = [];
                                             //                for (var child = target.firstChild; child; child = child.nextSibling)
                                             //                    children.push(treemirror.serializeNode(child, true, true));
                                             //
                                             //                return {
                                             //                    type: common.DOM_INITIALIZE,
                                             //                    frame: frameSelector,
                                             //                    args: [rootId, children],
                                             //                    loc: {
                                             //                        href: rootWin.location.href
                                             //                    }
                                             //                };
      }
      console.error('Unable to provide state for mirrorId ' + mirrorId);
      return null;
    };
    // EXPORTS
    /////////////////
    localDomEvents.getState = getState;
    localDomEvents.startListening = startListening;
    // function (rootWindow)
    localDomEvents.stopListening = stopListening;
    return localDomEvents;
  }(dojo__base_lang, dojo_dom_class, dojo__base_array, synchronite_proxyless_dom_TreeListener, synchronite_proxyless_dom_common, synchronite_proxyless_dom_shadowHosts, synchronite_micro_dom, dojo_Evented, dojo_has, dojo_query, dojo_on, synchronite__base_query);
  synchronite_proxyless_unifiedWindowState_common = {
    NAMESPACE: 'unifiedWindow',
    MAXIMIZED: 'uw:maximized',
    MINIMIZED: 'uw:minimized'
  };
  synchronite_proxyless_unifiedWindowState_listener = function (has, Evented, common) {
    var localWindowEvents = new Evented();
    var currentState = common.MINIMIZED;
    function onMaximized() {
      localWindowEvents.emit(common.NAMESPACE, common.MAXIMIZED);
      currentState = common.MAXIMIZED;
    }
    function onMinimized() {
      localWindowEvents.emit(common.NAMESPACE, common.MINIMIZED);
      currentState = common.MINIMIZED;
    }
    //EXPORTS
    localWindowEvents.startListening = function () {
      if (lpTag && lpTag.events && has('touch')) {
        lpTag.events.bind({
          appName: 'lpUnifiedWindow',
          eventName: 'maximized',
          func: onMaximized
        });
        lpTag.events.bind({
          appName: 'lpUnifiedWindow',
          eventName: 'minimized',
          func: onMinimized
        });
      }
    };
    localWindowEvents.getCurrentState = function () {
      return currentState;
    };
    return localWindowEvents;
  }(dojo_has, dojo_Evented, synchronite_proxyless_unifiedWindowState_common);
  synchronite__base_trackingEvents = function (Evented) {
    //PRIVATE
    var _eventHandler = new Evented();
    //PUBLIC
    return _eventHandler;
  }(dojo_Evented);
  synchronite_integration_tracking_ga = function (query) {
    //API: https://developers.google.com/analytics/devguides/collection/gajs/eventTrackerGuide#SettingUpEventTracking
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    //API: _trackEvent(category, action, opt_label, opt_value, opt_noninteraction)
    var googleTrack = function (action, opt_label, opt_value, opt_noninteraction) {
      //parameters
      //
      //String   category The general event category (e.g. "Videos").
      //
      //String   action The action for the event (e.g. "Play").
      //
      //String   opt_label An optional descriptor for the event.
      //
      //Int      opt_value An optional value associated with the event. You can see your event values in the Overview, Categories, and Actions reports, where they are listed by event or aggregated across events, depending upon your report view.
      //
      //Boolean  opt_noninteraction Default value is false. By default, the event hit sent by _trackEvent() will impact a visitor's bounce rate. By setting this parameter to true, this event hit will not be used in bounce rate calculations.
      //returns
      //
      //Boolean whether the event was successfully sent.
      var gaq = trackingWindow._gaq;
      if (typeof gaq !== 'undefined') {
        // category = "synchronite"
        var payload = [
          '_trackEvent',
          'cobrowse'
        ];
        payload.push(action);
        opt_label && payload.push(opt_label);
        opt_value && payload.push(opt_value);
        return gaq.push(payload);
      } else if (typeof ga !== 'undefined') {
        return ga('send', 'event', 'cobrowse', action, opt_label, opt_value);
      } else {
        console.warn('Google Analytics Tracking API not found. \'_gaq\' does not exist.');
        return null;
      }
    };
    // Google Analytics
    var sessionOffered = function (evt) {
        return googleTrack('sessionOffered', 'Visitor_Id_' + evt.visitorId);
      }, sessionStart = function (evt) {
        return googleTrack('sessionStarted', 'Visitor_Id_' + evt.visitorId);
      }, sessionRequested = function (evt) {
        return googleTrack('sessionRequested', 'Visitor_Id_' + evt.visitorId);
      }, sessionAccepted = function (evt) {
        return googleTrack('sessionAccepted', 'Visitor_Id_' + evt.visitorId);
      }, sessionDeclined = function (evt) {
        return googleTrack('sessionDeclined', 'Visitor_Id_' + evt.visitorId);
      }, sessionEnd = function (evt) {
        googleTrack('sessionDuration', 'Visitor_Id_' + evt.visitorId, evt.duration);
        return googleTrack('sessionEnd', 'Visitor_Id_' + evt.visitorId);
      }, liveSupportButtonClicked = function (evt) {
        return googleTrack('liveSupportButtonClicked', 'Visitor_Id_' + evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionAccepted', sessionAccepted);
      trackingEvents.on('sessionDeclined', sessionDeclined);
      trackingEvents.on('sessionStart', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_piwik = function (query) {
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var piwikTrack = function (index, name, value, scope) {
      // http://piwik.org/docs/javascript-tracking/#toc-custom-variables
      // Example:
      //  ASYNC CALL: _paq.push(['setCustomVariable','1','VisitorType','Member']);
      //  SYNC  CALL: setCustomVariable (index, name, value, scope = "page")
      var paq = trackingWindow._paq;
      if (typeof paq !== 'undefined') {
        var payload = ['setCustomVariable'];
        payload.push(index);
        payload.push(name);
        payload.push(value);
        //payload.push(eventName);
        if (scope) {
          payload.push(scope);
        } else {
          payload.push('page');
        }
        return paq.push(payload);
      } else {
        console.warn('Piwik Web Analytics Tracking API not found. \'_paq\' does not exist.');
        return null;
      }
    };
    // Piwik Web Analytics
    var liveSupportButtonClicked = function (evt) {
        return piwikTrack('1', 'liveSupportButtonClicked', 'Visitor_Id_' + evt.visitorId);
      }, sessionRequested = function (evt) {
        return piwikTrack('2', 'sessionRequested', 'Visitor_Id_' + evt.visitorId);
      }, sessionOffered = function (evt) {
        return piwikTrack('3', 'sessionOffered', 'Visitor_Id_' + evt.visitorId);
      }, sessionStart = function (evt) {
        return piwikTrack('4', 'sessionStarted', 'Visitor_Id_' + evt.visitorId);
      }, sessionEnd = function (evt) {
        return piwikTrack('5', 'sessionEnd', 'Visitor_Id_' + evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionStart', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_wt = function (query) {
    //API: if(typeof wt!="undefined"){_wt.sendinfo({linkId:a,customClickParameter:b}
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var PARAM_ORDER = [
      /* 0 */
      false,
      /* 1 */
      false,
      /* 2 */
      false,
      /* 3 */
      false,
      /* 4 */
      false,
      /* 5 */
      false,
      /* 6 */
      'duration',
      /* 7 */
      'visitorId'
    ];
    var wtTrack = function (linkId, evt, sendOnUnload) {
      // wtParams:
      //  contentId
      //  linkId - STRING - standard parameter (e.g. tracks facebook_like)
      //  customClickParameter - JSON ARRAY - { "1" : "HomePage" }
      //  sendOnUnload
      var customClickParameter = {};
      var trackAnonymous = typeof synchroniteConfig !== 'undefined' && synchroniteConfig.trackingAnonymous;
      var param, strKey, strValue;
      for (var i = 0; i < PARAM_ORDER.length; i++) {
        param = PARAM_ORDER[i];
        if (param && evt && evt[param]) {
          // We must pass the index/key AND value as a string, because webtrekk expects
          // an object. When the index is set as a number, the customClickParameter object
          // is converted to an array.
          strKey = i + '';
          strValue = evt[param] + '';
          if (param == 'visitorId') {
            strValue = 'Visitor_Id_' + (trackAnonymous ? 'anonymous' : strValue);
          }
          customClickParameter[strKey] = strValue;
        }
      }
      var _wt = trackingWindow.wt;
      if (typeof _wt !== 'undefined') {
        var wtParams = {
          linkId: 'synchronite_' + linkId,
          customClickParameter: customClickParameter
        };
        if (sendOnUnload) {
          // sendOnUnload: Beim Verlassen einer Seite knnen einige Browser das Pixel nicht
          //               mehr rechtzeitig versenden, falls der Parameter sendOnUnload
          //               weggelassen wird. (S. 28 - Integration und Konfiguration des
          //               Webtrekk Tracking-Pixels
          // sendOnUnload = !!sendOnUnload; // convert to boolean
          wtParams.sendOnUnload = sendOnUnload;
        }
        console.info('_wt.sendinfo(' + JSON.stringify(wtParams) + ')');
        // this.sendinfo = function(c, p, $V, ep) {
        _wt.sendinfo(wtParams);
      } else {
        console.warn('Webtrekk Tracking API not found. \'wt\' does not exist.');
        return null;
      }
    };
    // web trekk
    var sessionOffered = function (evt) {
        return wtTrack('sessionOffered', evt);
      }, sessionStart = function (evt) {
        return wtTrack('sessionStarted', evt, 1);
      }, sessionRequested = function (evt) {
        return wtTrack('sessionRequested', evt);
      }, sessionAccepted = function (evt) {
        return wtTrack('sessionAccepted', evt, 1);
      }, sessionDeclined = function (evt) {
        return wtTrack('sessionDeclined', evt);
      }, sessionEnd = function (evt) {
        return wtTrack('sessionEnd', evt);
      }, liveSupportButtonClicked = function (evt) {
        return wtTrack('liveSupportButtonClicked', evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      _trackingEvents.on('sessionOffered', sessionOffered);
      _trackingEvents.on('sessionRequested', sessionRequested);
      _trackingEvents.on('sessionAccepted', sessionAccepted);
      _trackingEvents.on('sessionDeclined', sessionDeclined);
      _trackingEvents.on('sessionStart', sessionStart);
      _trackingEvents.on('sessionEnd', sessionEnd);
      _trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_lpEvents = function (query) {
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var appName = 'cobrowse';
    var lpEventsTrack = function (eventName, data) {
      var lpEvents = trackingWindow.lpTag.events;
      lpEvents.trigger({
        appName: appName,
        eventName: eventName,
        data: data
      });
    };
    var sessionOffered = function (evt) {
        return lpEventsTrack('sessionOffered', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionStart = function (evt) {
        return lpEventsTrack('sessionStarted', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionRequested = function (evt) {
        return lpEventsTrack('sessionRequested', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionAccepted = function (evt) {
        return lpEventsTrack('sessionAccepted', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionDeclined = function (evt) {
        return lpEventsTrack('sessionDeclined', { visitorId: 'Visitor_Id_' + evt.visitorId });
      }, sessionResume = function (evt) {
        return lpEventsTrack('sessionResume', evt);
      }, sessionError = function (evt) {
        return lpEventsTrack('sessionError', evt);
      }, sessionEnd = function (evt) {
        lpEventsTrack('sessionDuration', {
          visitorId: 'Visitor_Id_' + evt.visitorId,
          duration: evt.duration
        });
        return lpEventsTrack('sessionEnd', {
          visitorId: 'Visitor_Id_' + evt.visitorId,
          ticketId: evt.ticketId,
          endedBy: evt.endedBy
        });
      }, liveSupportButtonClicked = function (evt) {
        return lpEventsTrack('liveSupportButtonClicked', { visitorId: 'Visitor_Id_' + evt.visitorId });
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      trackingEvents.on('sessionOffered', sessionOffered);
      trackingEvents.on('sessionRequested', sessionRequested);
      trackingEvents.on('sessionAccepted', sessionAccepted);
      trackingEvents.on('sessionDeclined', sessionDeclined);
      trackingEvents.on('sessionResume', sessionResume);
      trackingEvents.on('sessionError', sessionError);
      trackingEvents.on('sessionStarted', sessionStart);
      trackingEvents.on('sessionEnd', sessionEnd);
      trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(synchronite__base_query);
  synchronite_integration_tracking_tealium = function (string, lang) {
    //API: if(typeof wt!="undefined"){_wt.sendinfo({linkId:a,customClickParameter:b}
    //PRIVATE
    var trackingEvents, visitorInfo, trackingWindow;
    var track = function (type, originalData) {
      var _utag = trackingWindow.utag;
      if (!_utag) {
        if (trackingWindow.frames.length) {
          try {
            _utag = trackingWindow.frames[0].utag;
          } catch (e) {
            console.warn('Unable to find utag window.');
            console.warn(e);
          }
        }
      }
      if (typeof _utag !== 'undefined') {
        //utag.link({
        //
        //    'wt_link_id' :'liveperson_cobrowsing', // statischer Wert, der immer so mit in das Objekt geschrieben wird
        //    'cb_offers' : 'cobrowsing.angebot',   // Anzahl Angebote - statischer Wert, der bergeben wird bei der Eingabe in die Webcode-Lasche
        //    'cb_session' : 'TEAMID',               // Anzahl der tatschlich durchgefhrten Sessions inkl. Aufsplitung nach dem Team-Namen/der TeamID (Anzahl Sessions pro Team)
        //    'cb_cancel' : 'cobrowsing.abbruch',   // Daraus ergibt sich die Anzahl der durch Kunden abgebrochenen Session - statischer Wert
        //    'cb_sessiondauer' : '125',             // Dauer Session nach der Beendigung in Sekunden
        //    'cb_kundenbefragung' : 'ja'            // Wenn Die Kundenbefragung nach Beendigung der Session stattfinden soll wird der Wert 'ja' eingetragen
        //});
        var data = JSON.parse(JSON.stringify(originalData));
        // create copy of data
        // CUSTOM TELEKOM START
        addAgentTeam(data);
        if (data.agentAlias) {
          delete data.agentAlias;
        }
        if (data.agentId) {
          delete data.agentId;
        }
        for (var key in data) {
          if (data.hasOwnProperty(key)) {
            data['cb_' + key] = data[key] + '';
            // convert to String
            delete data[key];
          }
        }
        if (type == 'sessionEnd') {
          data.cb_kundenbefragung = 'ja';
        }
        // CUSTOM TELEKOM END
        var trackAnonymous = typeof synchroniteConfig !== 'undefined' && synchroniteConfig.trackingAnonymous;
        if (trackAnonymous && data.visitorId) {
          data.visitorId = 'anonymous';
        }
        var event = {
          'wt_link_id': 'liveperson_cobrowsing',
          'cb_type': type  // changed for telekom
        };
        event = lang.mixin(data, event);
        console.info('utag.link(' + JSON.stringify(event) + ')');
        _utag.link(event);
      } else {
        console.warn('Tealium UTag Tracking API not found. \'utag\' does not exist.');
        return null;
      }
    };
    var addAgentTeam = function (event) {
      var agentAlias = event.agentAlias;
      if (agentAlias) {
        var agentInfo = agentAlias.split(',');
        if (agentInfo.length > 1) {
          event.agentAlias = string.trim(agentInfo[0]);
          event.agentTeam = string.trim(agentInfo[1]);
        }
      }
      return event;
    };
    // web trekk
    var sessionOffered = function (evt) {
        return track('sessionOffered', evt);
      }, sessionStart = function (evt) {
        return track('sessionStarted', evt);
      }, sessionRequested = function (evt) {
        return track('sessionRequested', evt);
      }, sessionAccepted = function (evt) {
        return track('sessionAccepted', evt);
      }, sessionDeclined = function (evt) {
        return track('sessionDeclined', evt);
      }, sessionEnd = function (evt) {
        return track('sessionEnd', evt);
      }, liveSupportButtonClicked = function (evt) {
        return track('liveSupportButtonClicked', evt.visitorId);
      };
    // PUBLIC
    var setupTracking = function (_trackingWindow, _trackingEvents) {
      if (_trackingEvents.listening) {
        console.info('Already Tracking Event. Skipped setupTracking to prevent duplicate requests.');
        return;
      }
      trackingWindow = _trackingWindow;
      trackingEvents = _trackingEvents;
      if (_trackingEvents.visitorInfo) {
        visitorInfo = _trackingEvents.visitorInfo;
      }
      _trackingEvents.on('sessionOffered', sessionOffered);
      _trackingEvents.on('sessionRequested', sessionRequested);
      _trackingEvents.on('sessionAccepted', sessionAccepted);
      _trackingEvents.on('sessionDeclined', sessionDeclined);
      _trackingEvents.on('sessionStart', sessionStart);
      _trackingEvents.on('sessionEnd', sessionEnd);
      _trackingEvents.on('liveSupportButtonClicked', liveSupportButtonClicked);
      _trackingEvents.listening = true;
    };
    return setupTracking;
  }(dojo_string, dojo__base_lang);
  synchronite_integration_tracking_loader = function (trackingGA, trackingPiwik, trackingWT, trackingLpEvents, trackingTealium) {
    var trackingLoader = {
      setupTracker: function (trackingWindow, trackingAPI, trackingEvents) {
        // publish events to lpTag.events if it's defined
        var lpEvents = trackingWindow.lpTag && trackingWindow.lpTag.events;
        if (lpEvents) {
          trackingLpEvents(trackingWindow, trackingEvents);
        }
        // check if additional tracking is configured, e.g. to Google Analytics
        if (trackingAPI && trackingAPI != 'disabled') {
          console.debug('trackingLoader: Initialize tracking API \'' + trackingAPI + '\' in window ' + trackingWindow.location.href);
          if (trackingAPI == 'ga' && (trackingWindow._gaq || trackingWindow.ga)) {
            trackingGA(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'piwik' && trackingWindow._paq) {
            trackingPiwik(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'wt' && trackingWindow.wt) {
            trackingWT(trackingWindow, trackingEvents);
          } else if (trackingAPI == 'tealium'  /* && trackingWindow.utag*/) {
            // lazy loaded
            trackingTealium(trackingWindow, trackingEvents);
          }
        } else {
          console.debug('trackingLoader: trackingAPI is disabled');
        }
      }
    };
    return trackingLoader;
  }(synchronite_integration_tracking_ga, synchronite_integration_tracking_piwik, synchronite_integration_tracking_wt, synchronite_integration_tracking_lpEvents, synchronite_integration_tracking_tealium);
  dojo_mouse = function (dojo, on, has, dom, win) {
    // module:
    //		dojo/mouse
    has.add('dom-quirks', win.doc && win.doc.compatMode == 'BackCompat');
    has.add('events-mouseenter', win.doc && 'onmouseenter' in win.doc.createElement('div'));
    has.add('events-mousewheel', win.doc && 'onmousewheel' in win.doc);
    var mouseButtons;
    if (has('dom-quirks') && has('ie') || !has('dom-addeventlistener')) {
      mouseButtons = {
        LEFT: 1,
        MIDDLE: 4,
        RIGHT: 2,
        // helper functions
        isButton: function (e, button) {
          return e.button & button;
        },
        isLeft: function (e) {
          return e.button & 1;
        },
        isMiddle: function (e) {
          return e.button & 4;
        },
        isRight: function (e) {
          return e.button & 2;
        }
      };
    } else {
      mouseButtons = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        // helper functions
        isButton: function (e, button) {
          return e.button == button;
        },
        isLeft: function (e) {
          return e.button == 0;
        },
        isMiddle: function (e) {
          return e.button == 1;
        },
        isRight: function (e) {
          return e.button == 2;
        }
      };
    }
    dojo.mouseButtons = mouseButtons;
    /*=====
    	dojo.mouseButtons = {
    		// LEFT: Number
    		//		Numeric value of the left mouse button for the platform.
    		LEFT:   0,
    		// MIDDLE: Number
    		//		Numeric value of the middle mouse button for the platform.
    		MIDDLE: 1,
    		// RIGHT: Number
    		//		Numeric value of the right mouse button for the platform.
    		RIGHT:  2,
    
    		isButton: function(e, button){
    			// summary:
    			//		Checks an event object for a pressed button
    			// e: Event
    			//		Event object to examine
    			// button: Number
    			//		The button value (example: dojo.mouseButton.LEFT)
    			return e.button == button; // Boolean
    		},
    		isLeft: function(e){
    			// summary:
    			//		Checks an event object for the pressed left button
    			// e: Event
    			//		Event object to examine
    			return e.button == 0; // Boolean
    		},
    		isMiddle: function(e){
    			// summary:
    			//		Checks an event object for the pressed middle button
    			// e: Event
    			//		Event object to examine
    			return e.button == 1; // Boolean
    		},
    		isRight: function(e){
    			// summary:
    			//		Checks an event object for the pressed right button
    			// e: Event
    			//		Event object to examine
    			return e.button == 2; // Boolean
    		}
    	};
    =====*/
    function eventHandler(type, selectHandler) {
      // emulation of mouseenter/leave with mouseover/out using descendant checking
      var handler = function (node, listener) {
        return on(node, type, function (evt) {
          if (selectHandler) {
            return selectHandler(evt, listener);
          }
          if (!dom.isDescendant(evt.relatedTarget, node)) {
            return listener.call(this, evt);
          }
        });
      };
      handler.bubble = function (select) {
        return eventHandler(type, function (evt, listener) {
          // using a selector, use the select function to determine if the mouse moved inside the selector and was previously outside the selector
          var target = select(evt.target);
          var relatedTarget = evt.relatedTarget;
          if (target && target != (relatedTarget && relatedTarget.nodeType == 1 && select(relatedTarget))) {
            return listener.call(target, evt);
          }
        });
      };
      return handler;
    }
    var wheel;
    if (has('events-mousewheel')) {
      wheel = 'mousewheel';
    } else {
      //firefox
      wheel = function (node, listener) {
        return on(node, 'DOMMouseScroll', function (evt) {
          evt.wheelDelta = -evt.detail;
          listener.call(this, evt);
        });
      };
    }
    return {
      // summary:
      //		This module provide mouse event handling utility functions and exports
      //		mouseenter and mouseleave event emulation.
      // example:
      //		To use these events, you register a mouseenter like this:
      //		|	define(["dojo/on", "dojo/mouse"], function(on, mouse){
      //		|		on(targetNode, mouse.enter, function(event){
      //		|			dojo.addClass(targetNode, "highlighted");
      //		|		});
      //		|		on(targetNode, mouse.leave, function(event){
      //		|			dojo.removeClass(targetNode, "highlighted");
      //		|		});
      _eventHandler: eventHandler,
      // for dojo/touch
      // enter: Synthetic Event
      //		This is an extension event for the mouseenter that IE provides, emulating the
      //		behavior on other browsers.
      enter: eventHandler('mouseover'),
      // leave: Synthetic Event
      //		This is an extension event for the mouseleave that IE provides, emulating the
      //		behavior on other browsers.
      leave: eventHandler('mouseout'),
      // wheel: Normalized Mouse Wheel Event
      //		This is an extension event for the mousewheel that non-Mozilla browsers provide,
      //		emulating the behavior on Mozilla based browsers.
      wheel: wheel,
      isLeft: mouseButtons.isLeft,
      /*=====
      isLeft: function(){
      	// summary:
      	//		Test an event object (from a mousedown event) to see if the left button was pressed.
      },
      =====*/
      isMiddle: mouseButtons.isMiddle,
      /*=====
       isMiddle: function(){
      	 // summary:
      	 //		Test an event object (from a mousedown event) to see if the middle button was pressed.
       },
       =====*/
      isRight: mouseButtons.isRight
    };
  }(dojo__base_kernel, dojo_on, dojo_has, dojo_dom, dojo__base_window);
  dojo_touch = function (dojo, aspect, dom, domClass, lang, on, has, mouse, domReady, win) {
    // module:
    //		dojo/touch
    var ios4 = has('ios') < 5;
    // Detect if platform supports Pointer Events, and if so, the names of the events (pointerdown vs. MSPointerDown).
    var hasPointer = has('pointer-events') || has('MSPointer'), pointer = function () {
        var pointer = {};
        for (var type in {
            down: 1,
            move: 1,
            up: 1,
            cancel: 1,
            over: 1,
            out: 1
          }) {
          pointer[type] = has('MSPointer') ? 'MSPointer' + type.charAt(0).toUpperCase() + type.slice(1) : 'pointer' + type;
        }
        return pointer;
      }();
    // Detect if platform supports the webkit touchstart/touchend/... events
    var hasTouch = has('touch-events');
    // Click generation variables
    var clicksInited, clickTracker, useTarget = false, clickTarget, clickX, clickY, clickDx, clickDy, clickTime;
    // Time of most recent touchstart, touchmove, or touchend event
    var lastTouch;
    function dualEvent(mouseType, touchType, pointerType) {
      // Returns synthetic event that listens for both the specified mouse event and specified touch event.
      // But ignore fake mouse events that were generated due to the user touching the screen.
      if (hasPointer && pointerType) {
        // IE10+: MSPointer* events are designed to handle both mouse and touch in a uniform way,
        // so just use that regardless of hasTouch.
        return function (node, listener) {
          return on(node, pointerType, listener);
        };
      } else if (hasTouch) {
        return function (node, listener) {
          var handle1 = on(node, touchType, function (evt) {
              listener.call(this, evt);
              // On slow mobile browsers (see https://bugs.dojotoolkit.org/ticket/17634),
              // a handler for a touch event may take >1s to run.  That time shouldn't
              // be included in the calculation for lastTouch.
              lastTouch = new Date().getTime();
            }), handle2 = on(node, mouseType, function (evt) {
              if (!lastTouch || new Date().getTime() > lastTouch + 1000) {
                listener.call(this, evt);
              }
            });
          return {
            remove: function () {
              handle1.remove();
              handle2.remove();
            }
          };
        };
      } else {
        // Avoid creating listeners for touch events on performance sensitive older browsers like IE6
        return function (node, listener) {
          return on(node, mouseType, listener);
        };
      }
    }
    // PATCHED removed below code as it's not needed and causes issues (duplicate clicks) on websites that use dojo (HSBC)
    // function marked(/*DOMNode*/ node){
    // // Search for node ancestor has been marked with the dojoClick property to indicate special processing.
    // // Returns marked ancestor.
    // do{
    // 	if(node.dojoClick !== undefined){ return node; }
    // }while(node = node.parentNode);
    // }
    //
    // function doClicks(e, moveType, endType){
    // // summary:
    // //		Setup touch listeners to generate synthetic clicks immediately (rather than waiting for the browser
    // //		to generate clicks after the double-tap delay) and consistently (regardless of whether event.preventDefault()
    // //		was called in an event listener. Synthetic clicks are generated only if a node or one of its ancestors has
    // //		its dojoClick property set to truthy. If a node receives synthetic clicks because one of its ancestors has its
    // //      dojoClick property set to truthy, you can disable synthetic clicks on this node by setting its own dojoClick property
    // //      to falsy.
    //
    // var markedNode = marked(e.target);
    // clickTracker  = !e.target.disabled && markedNode && markedNode.dojoClick; // click threshold = true, number, x/y object, or "useTarget"
    // if(clickTracker){
    // 	useTarget = (clickTracker == "useTarget");
    // 	clickTarget = (useTarget?markedNode:e.target);
    // 	if(useTarget){
    // 		// We expect a click, so prevent any other
    // 		// default action on "touchpress"
    // 		e.preventDefault();
    // 	}
    // 	clickX = e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX;
    // 	clickY = e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY;
    // 	clickDx = (typeof clickTracker == "object" ? clickTracker.x : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
    // 	clickDy = (typeof clickTracker == "object" ? clickTracker.y : (typeof clickTracker == "number" ? clickTracker : 0)) || 4;
    //
    // 	// add move/end handlers only the first time a node with dojoClick is seen,
    // 	// so we don't add too much overhead when dojoClick is never set.
    // 	if(!clicksInited){
    // 		clicksInited = true;
    //
    // 		function updateClickTracker(e){
    // 			if(useTarget){
    // 				clickTracker = dom.isDescendant(
    // 					win.doc.elementFromPoint(
    // 						(e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX),
    // 						(e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY)),
    // 					clickTarget);
    // 			}else{
    // 				clickTracker = clickTracker &&
    // 					(e.changedTouches ? e.changedTouches[0].target : e.target) == clickTarget &&
    // 					Math.abs((e.changedTouches ? e.changedTouches[0].pageX - win.global.pageXOffset : e.clientX) - clickX) <= clickDx &&
    // 					Math.abs((e.changedTouches ? e.changedTouches[0].pageY - win.global.pageYOffset : e.clientY) - clickY) <= clickDy;
    // 			}
    // 		}
    //
    // 		win.doc.addEventListener(moveType, function(e){
    // 			updateClickTracker(e);
    // 			if(useTarget){
    // 				// prevent native scroll event and ensure touchend is
    // 				// fire after touch moves between press and release.
    // 				e.preventDefault();
    // 			}
    // 		}, true);
    //
    // 		win.doc.addEventListener(endType, function(e){
    // 			updateClickTracker(e);
    // 			if(clickTracker){
    // 				clickTime = (new Date()).getTime();
    // 				var target = (useTarget?clickTarget:e.target);
    // 				if(target.tagName === "LABEL"){
    // 					// when clicking on a label, forward click to its associated input if any
    // 					target = dom.byId(target.getAttribute("for")) || target;
    // 				}
    // 				//some attributes can be on the Touch object, not on the Event:
    // 				//http://www.w3.org/TR/touch-events/#touch-interface
    // 				var src = (e.changedTouches) ? e.changedTouches[0] : e;
    // 				//create the synthetic event.
    // 				//http://www.w3.org/TR/DOM-Level-3-Events/#widl-MouseEvent-initMouseEvent
    // 				var clickEvt = document.createEvent("MouseEvents");
    // 				clickEvt._dojo_click = true;
    // 				clickEvt.initMouseEvent("click",
    // 					true, //bubbles
    // 					true, //cancelable
    // 					e.view,
    // 					e.detail,
    // 					src.screenX,
    // 					src.screenY,
    // 					src.clientX,
    // 					src.clientY,
    // 					e.ctrlKey,
    // 					e.altKey,
    // 					e.shiftKey,
    // 					e.metaKey,
    // 					0, //button
    // 					null //related target
    // 				);
    // 				setTimeout(function(){
    // 					on.emit(target, "click", clickEvt);
    //
    // 					// refresh clickTime in case app-defined click handler took a long time to run
    // 					clickTime = (new Date()).getTime();
    // 				}, 0);
    // 			}
    // 		}, true);
    //
    // 		function stopNativeEvents(type){
    // 			win.doc.addEventListener(type, function(e){
    // 				// Stop native events when we emitted our own click event.  Note that the native click may occur
    // 				// on a different node than the synthetic click event was generated on.  For example,
    // 				// click on a menu item, causing the menu to disappear, and then (~300ms later) the browser
    // 				// sends a click event to the node that was *underneath* the menu.  So stop all native events
    // 				// sent shortly after ours, similar to what is done in dualEvent.
    // 				// The INPUT.dijitOffScreen test is for offscreen inputs used in dijit/form/Button, on which
    // 				// we call click() explicitly, we don't want to stop this event.
    // 					if(!e._dojo_click &&
    // 						(new Date()).getTime() <= clickTime + 1000 &&
    // 						!(e.target.tagName == "INPUT" && domClass.contains(e.target, "dijitOffScreen"))){
    // 					e.stopPropagation();
    // 					e.stopImmediatePropagation && e.stopImmediatePropagation();
    // 					if(type == "click" && (e.target.tagName != "INPUT" || e.target.type == "radio" || e.target.type == "checkbox")
    // 						&& e.target.tagName != "TEXTAREA" && e.target.tagName != "AUDIO" && e.target.tagName != "VIDEO"){
    // 						 // preventDefault() breaks textual <input>s on android, keyboard doesn't popup,
    // 						 // but it is still needed for checkboxes and radio buttons, otherwise in some cases
    // 						 // the checked state becomes inconsistent with the widget's state
    // 						e.preventDefault();
    // 					}
    // 				}
    // 			}, true);
    // 		}
    //
    // 		stopNativeEvents("click");
    //
    // 		// We also stop mousedown/up since these would be sent well after with our "fast" click (300ms),
    // 		// which can confuse some dijit widgets.
    // 		stopNativeEvents("mousedown");
    // 		stopNativeEvents("mouseup");
    // 	}
    // }
    // }
    //
    // var hoveredNode;
    //
    // if(has("touch")){
    //     if(hasPointer){
    //         // MSPointer (IE10+) already has support for over and out, so we just need to init click support
    //         domReady(function(){
    //             win.doc.addEventListener(pointer.down, function(evt){
    //                 doClicks(evt, pointer.move, pointer.up);
    //             }, true);
    //         });
    //     }else if(hasTouch){
    //         domReady(function(){
    //             // Keep track of currently hovered node
    //             hoveredNode = win.body();	// currently hovered node
    //
    //             win.doc.addEventListener("touchstart", function(evt){
    //                 lastTouch = (new Date()).getTime();
    //
    //                 // Precede touchstart event with touch.over event.  DnD depends on this.
    //                 // Use addEventListener(cb, true) to run cb before any touchstart handlers on node run,
    //                 // and to ensure this code runs even if the listener on the node does event.stop().
    //                 var oldNode = hoveredNode;
    //                 hoveredNode = evt.target;
    //                 on.emit(oldNode, "dojotouchout", {
    //                     relatedTarget: hoveredNode,
    //                     bubbles: true
    //                 });
    //                 on.emit(hoveredNode, "dojotouchover", {
    //                     relatedTarget: oldNode,
    //                     bubbles: true
    //                 });
    //
    //                 doClicks(evt, "touchmove", "touchend"); // init click generation
    //             }, true);
    //
    //             function copyEventProps(evt){
    //                 // Make copy of event object and also set bubbles:true.  Used when calling on.emit().
    //                 var props = lang.delegate(evt, {
    //                     bubbles: true
    //                 });
    //
    //                 if(has("ios") >= 6){
    //                     // On iOS6 "touches" became a non-enumerable property, which
    //                     // is not hit by for...in.  Ditto for the other properties below.
    //                     props.touches = evt.touches;
    //                     props.altKey = evt.altKey;
    //                     props.changedTouches = evt.changedTouches;
    //                     props.ctrlKey = evt.ctrlKey;
    //                     props.metaKey = evt.metaKey;
    //                     props.shiftKey = evt.shiftKey;
    //                     props.targetTouches = evt.targetTouches;
    //                 }
    //
    //                 return props;
    //             }
    //
    //             on(win.doc, "touchmove", function(evt){
    //                 lastTouch = (new Date()).getTime();
    //
    //                 var newNode = win.doc.elementFromPoint(
    //                     evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
    //                     evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
    //                 );
    //
    //                 if(newNode){
    //                     // Fire synthetic touchover and touchout events on nodes since the browser won't do it natively.
    //                     if(hoveredNode !== newNode){
    //                         // touch out on the old node
    //                         on.emit(hoveredNode, "dojotouchout", {
    //                             relatedTarget: newNode,
    //                             bubbles: true
    //                         });
    //
    //                         // touchover on the new node
    //                         on.emit(newNode, "dojotouchover", {
    //                             relatedTarget: hoveredNode,
    //                             bubbles: true
    //                         });
    //
    //                         hoveredNode = newNode;
    //                     }
    //
    //                     // Unlike a listener on "touchmove", on(node, "dojotouchmove", listener) fires when the finger
    //                     // drags over the specified node, regardless of which node the touch started on.
    //                     if(!on.emit(newNode, "dojotouchmove", copyEventProps(evt))){
    //                         // emit returns false when synthetic event "dojotouchmove" is cancelled, so we prevent the
    //                         // default behavior of the underlying native event "touchmove".
    //                         evt.preventDefault();
    //                     }
    //                 }
    //             });
    //
    //             // Fire a dojotouchend event on the node where the finger was before it was removed from the screen.
    //             // This is different than the native touchend, which fires on the node where the drag started.
    //             on(win.doc, "touchend", function(evt){
    //                 lastTouch = (new Date()).getTime();
    //                 var node = win.doc.elementFromPoint(
    //                         evt.pageX - (ios4 ? 0 : win.global.pageXOffset), // iOS 4 expects page coords
    //                         evt.pageY - (ios4 ? 0 : win.global.pageYOffset)
    //                     ) || win.body(); // if out of the screen
    //
    //                 on.emit(node, "dojotouchend", copyEventProps(evt));
    //             });
    //         });
    //     }
    // }
    //device neutral events - touch.press|move|release|cancel/over/out
    var touch = {
      press: dualEvent('mousedown', 'touchstart', pointer.down),
      move: dualEvent('mousemove', 'dojotouchmove', pointer.move),
      release: dualEvent('mouseup', 'dojotouchend', pointer.up),
      cancel: dualEvent(mouse.leave, 'touchcancel', hasPointer ? pointer.cancel : null),
      over: dualEvent('mouseover', 'dojotouchover', pointer.over),
      out: dualEvent('mouseout', 'dojotouchout', pointer.out),
      enter: mouse._eventHandler(dualEvent('mouseover', 'dojotouchover', pointer.over)),
      leave: mouse._eventHandler(dualEvent('mouseout', 'dojotouchout', pointer.out))
    };
    /*=====
    	touch = {
    		// summary:
    		//		This module provides unified touch event handlers by exporting
    		//		press, move, release and cancel which can also run well on desktop.
    		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
    		//      Also, if the dojoClick property is set to truthy on a DOM node, dojo/touch generates
    		//      click events immediately for this node and its descendants (except for descendants that
    		//      have a dojoClick property set to falsy), to avoid the delay before native browser click events,
    		//      and regardless of whether evt.preventDefault() was called in a touch.press event listener.
    		//
    		// example:
    		//		Used with dojo/on
    		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
    		//		|		on(node, touch.press, function(e){});
    		//		|		on(node, touch.move, function(e){});
    		//		|		on(node, touch.release, function(e){});
    		//		|		on(node, touch.cancel, function(e){});
    		// example:
    		//		Used with touch.* directly
    		//		|	touch.press(node, function(e){});
    		//		|	touch.move(node, function(e){});
    		//		|	touch.release(node, function(e){});
    		//		|	touch.cancel(node, function(e){});
    		// example:
    		//		Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels
    		//		|	node.dojoClick = true;
    		// example:
    		//		Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically
    		//		|	node.dojoClick = 10;
    		// example:
    		//		Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically
    		//		|	node.dojoClick = {x:50, y:5};
    		// example:
    		//		Disable clicks without delay generated by dojo/touch on a node that has an ancestor with property dojoClick set to truthy
    		//		|  node.dojoClick = false;
    
    		press: function(node, listener){
    			// summary:
    			//		Register a listener to 'touchstart'|'mousedown' for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		move: function(node, listener){
    			// summary:
    			//		Register a listener that fires when the mouse cursor or a finger is dragged over the given node.
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		release: function(node, listener){
    			// summary:
    			//		Register a listener to releasing the mouse button while the cursor is over the given node
    			//		(i.e. "mouseup") or for removing the finger from the screen while touching the given node.
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		cancel: function(node, listener){
    			// summary:
    			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		over: function(node, listener){
    			// summary:
    			//		Register a listener to 'mouseover' or touch equivalent for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		out: function(node, listener){
    			// summary:
    			//		Register a listener to 'mouseout' or touch equivalent for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		enter: function(node, listener){
    			// summary:
    			//		Register a listener to mouse.enter or touch equivalent for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		},
    		leave: function(node, listener){
    			// summary:
    			//		Register a listener to mouse.leave or touch equivalent for the given node
    			// node: Dom
    			//		Target node to listen to
    			// listener: Function
    			//		Callback function
    			// returns:
    			//		A handle which will be used to remove the listener by handle.remove()
    		}
    	};
    	=====*/
    has('extend-dojo') && (dojo.touch = touch);
    return touch;
  }(dojo__base_kernel, dojo_aspect, dojo_dom, dojo_dom_class, dojo__base_lang, dojo_on, dojo_has, dojo_mouse, dojo_domReady, dojo__base_window);
  dojo__base_declare = function (dojo, has, lang) {
    // module:
    //		dojo/_base/declare
    var mix = lang.mixin, op = Object.prototype, opts = op.toString, counter = 0, cname = 'constructor';
    function err(msg, cls) {
      throw new Error('declare' + (cls ? ' ' + cls : '') + ': ' + msg);
    }
    // C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)
    function c3mro(bases, className) {
      var result = [], roots = [{
            cls: 0,
            refs: []
          }], nameMap = {}, clsCount = 1, l = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;
      // build a list of bases naming them if needed
      for (; i < l; ++i) {
        base = bases[i];
        if (!base) {
          err('mixin #' + i + ' is unknown. Did you use dojo.require to pull it in?', className);
        } else if (opts.call(base) != '[object Function]') {
          err('mixin #' + i + ' is not a callable constructor.', className);
        }
        lin = base._meta ? base._meta.bases : [base];
        top = 0;
        // add bases to the name map
        for (j = lin.length - 1; j >= 0; --j) {
          proto = lin[j].prototype;
          if (!proto.hasOwnProperty('declaredClass')) {
            proto.declaredClass = 'uniqName_' + counter++;
          }
          name = proto.declaredClass;
          if (!nameMap.hasOwnProperty(name)) {
            nameMap[name] = {
              count: 0,
              refs: [],
              cls: lin[j]
            };
            ++clsCount;
          }
          rec = nameMap[name];
          if (top && top !== rec) {
            rec.refs.push(top);
            ++top.count;
          }
          top = rec;
        }
        ++top.count;
        roots[0].refs.push(top);
      }
      // remove classes without external references recursively
      while (roots.length) {
        top = roots.pop();
        result.push(top.cls);
        --clsCount;
        // optimization: follow a single-linked chain
        while (refs = top.refs, refs.length == 1) {
          top = refs[0];
          if (!top || --top.count) {
            // branch or end of chain => do not end to roots
            top = 0;
            break;
          }
          result.push(top.cls);
          --clsCount;
        }
        if (top) {
          // branch
          for (i = 0, l = refs.length; i < l; ++i) {
            top = refs[i];
            if (!--top.count) {
              roots.push(top);
            }
          }
        }
      }
      if (clsCount) {
        err('can\'t build consistent linearization', className);
      }
      // calculate the superclass offset
      base = bases[0];
      result[0] = base ? base._meta && base === result[result.length - base._meta.bases.length] ? base._meta.bases.length : 1 : 0;
      return result;
    }
    function inherited(args, a, f) {
      var name, chains, bases, caller, meta, base, proto, opf, pos, cache = this._inherited = this._inherited || {};
      // crack arguments
      if (typeof args == 'string') {
        name = args;
        args = a;
        a = f;
      }
      f = 0;
      caller = args.callee;
      name = name || caller.nom;
      if (!name) {
        err('can\'t deduce a name to call inherited()', this.declaredClass);
      }
      meta = this.constructor._meta;
      bases = meta.bases;
      pos = cache.p;
      if (name != cname) {
        // method
        if (cache.c !== caller) {
          // cache bust
          pos = 0;
          base = bases[0];
          meta = base._meta;
          if (meta.hidden[name] !== caller) {
            // error detection
            chains = meta.chains;
            if (chains && typeof chains[name] == 'string') {
              err('calling chained method with inherited: ' + name, this.declaredClass);
            }
            // find caller
            do {
              meta = base._meta;
              proto = base.prototype;
              if (meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)) {
                break;
              }
            } while (base = bases[++pos]);
            // intentional assignment
            pos = base ? pos : -1;
          }
        }
        // find next
        base = bases[++pos];
        if (base) {
          proto = base.prototype;
          if (base._meta && proto.hasOwnProperty(name)) {
            f = proto[name];
          } else {
            opf = op[name];
            do {
              proto = base.prototype;
              f = proto[name];
              if (f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)) {
                break;
              }
            } while (base = bases[++pos]);  // intentional assignment
          }
        }
        f = base && f || op[name];
      } else {
        // constructor
        if (cache.c !== caller) {
          // cache bust
          pos = 0;
          meta = bases[0]._meta;
          if (meta && meta.ctor !== caller) {
            // error detection
            chains = meta.chains;
            if (!chains || chains.constructor !== 'manual') {
              err('calling chained constructor with inherited', this.declaredClass);
            }
            // find caller
            while (base = bases[++pos]) {
              // intentional assignment
              meta = base._meta;
              if (meta && meta.ctor === caller) {
                break;
              }
            }
            pos = base ? pos : -1;
          }
        }
        // find next
        while (base = bases[++pos]) {
          // intentional assignment
          meta = base._meta;
          f = meta ? meta.ctor : base;
          if (f) {
            break;
          }
        }
        f = base && f;
      }
      // cache the found super method
      cache.c = f;
      cache.p = pos;
      // now we have the result
      if (f) {
        return a === true ? f : f.apply(this, a || args);
      }  // intentionally no return if a super method was not found
    }
    function getInherited(name, args) {
      if (typeof name == 'string') {
        return this.__inherited(name, args, true);
      }
      return this.__inherited(name, true);
    }
    function inherited__debug(args, a1, a2) {
      var f = this.getInherited(args, a1);
      if (f) {
        return f.apply(this, a2 || a1 || args);
      }  // intentionally no return if a super method was not found
    }
    var inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;
    // emulation of "instanceof"
    function isInstanceOf(cls) {
      var bases = this.constructor._meta.bases;
      for (var i = 0, l = bases.length; i < l; ++i) {
        if (bases[i] === cls) {
          return true;
        }
      }
      return this instanceof cls;
    }
    function mixOwn(target, source) {
      // add props adding metadata for incoming functions skipping a constructor
      for (var name in source) {
        if (name != cname && source.hasOwnProperty(name)) {
          target[name] = source[name];
        }
      }
      if (has('bug-for-in-skips-shadowed')) {
        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
          name = extraNames[--i];
          if (name != cname && source.hasOwnProperty(name)) {
            target[name] = source[name];
          }
        }
      }
    }
    // implementation of safe mixin function
    function safeMixin(target, source) {
      // summary:
      //		Mix in properties skipping a constructor and decorating functions
      //		like it is done by declare().
      // target: Object
      //		Target object to accept new properties.
      // source: Object
      //		Source object for new properties.
      // description:
      //		This function is used to mix in properties like lang.mixin does,
      //		but it skips a constructor property and decorates functions like
      //		declare() does.
      //
      //		It is meant to be used with classes and objects produced with
      //		declare. Functions mixed in with dojo.safeMixin can use
      //		this.inherited() like normal methods.
      //
      //		This function is used to implement extend() method of a constructor
      //		produced with declare().
      //
      // example:
      //	|	var A = declare(null, {
      //	|		m1: function(){
      //	|			console.log("A.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("A.m2");
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		m1: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("B.m1");
      //	|		}
      //	|	});
      //	|	B.extend({
      //	|		m2: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("B.m2");
      //	|		}
      //	|	});
      //	|	var x = new B();
      //	|	dojo.safeMixin(x, {
      //	|		m1: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("X.m1");
      //	|		},
      //	|		m2: function(){
      //	|			this.inherited(arguments);
      //	|			console.log("X.m2");
      //	|		}
      //	|	});
      //	|	x.m2();
      //	|	// prints:
      //	|	// A.m1
      //	|	// B.m1
      //	|	// X.m1
      var name, t;
      // add props adding metadata for incoming functions skipping a constructor
      for (name in source) {
        t = source[name];
        if ((t !== op[name] || !(name in op)) && name != cname) {
          if (opts.call(t) == '[object Function]') {
            // non-trivial function method => attach its name
            t.nom = name;
          }
          target[name] = t;
        }
      }
      if (has('bug-for-in-skips-shadowed')) {
        for (var extraNames = lang._extraNames, i = extraNames.length; i;) {
          name = extraNames[--i];
          t = source[name];
          if ((t !== op[name] || !(name in op)) && name != cname) {
            if (opts.call(t) == '[object Function]') {
              // non-trivial function method => attach its name
              t.nom = name;
            }
            target[name] = t;
          }
        }
      }
      return target;
    }
    function extend(source) {
      declare.safeMixin(this.prototype, source);
      return this;
    }
    function createSubclass(mixins, props) {
      // crack parameters
      if (!(mixins instanceof Array || typeof mixins == 'function')) {
        props = mixins;
        mixins = undefined;
      }
      props = props || {};
      mixins = mixins || [];
      return declare([this].concat(mixins), props);
    }
    // chained constructor compatible with the legacy declare()
    function chainedConstructor(bases, ctorSpecial) {
      return function () {
        var a = arguments, args = a, a0 = a[0], f, i, m, l = bases.length, preArgs;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) call two types of the preamble
        if (ctorSpecial && (a0 && a0.preamble || this.preamble)) {
          // full blown ritual
          preArgs = new Array(bases.length);
          // prepare parameters
          preArgs[0] = a;
          for (i = 0;;) {
            // process the preamble of the 1st argument
            a0 = a[0];
            if (a0) {
              f = a0.preamble;
              if (f) {
                a = f.apply(this, a) || a;
              }
            }
            // process the preamble of this class
            f = bases[i].prototype;
            f = f.hasOwnProperty('preamble') && f.preamble;
            if (f) {
              a = f.apply(this, a) || a;
            }
            // one peculiarity of the preamble:
            // it is called if it is not needed,
            // e.g., there is no constructor to call
            // let's watch for the last constructor
            // (see ticket #9795)
            if (++i == l) {
              break;
            }
            preArgs[i] = a;
          }
        }
        // 2) call all non-trivial constructors using prepared arguments
        for (i = l - 1; i >= 0; --i) {
          f = bases[i];
          m = f._meta;
          f = m ? m.ctor : f;
          if (f) {
            f.apply(this, preArgs ? preArgs[i] : a);
          }
        }
        // 3) continue the original ritual: call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, args);
        }
      };
    }
    // chained constructor compatible with the legacy declare()
    function singleConstructor(ctor, ctorSpecial) {
      return function () {
        var a = arguments, t = a, a0 = a[0], f;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) call two types of the preamble
        if (ctorSpecial) {
          // full blown ritual
          if (a0) {
            // process the preamble of the 1st argument
            f = a0.preamble;
            if (f) {
              t = f.apply(this, t) || t;
            }
          }
          f = this.preamble;
          if (f) {
            // process the preamble of this class
            f.apply(this, t);  // one peculiarity of the preamble:
                               // it is called even if it is not needed,
                               // e.g., there is no constructor to call
                               // let's watch for the last constructor
                               // (see ticket #9795)
          }
        }
        // 2) call a constructor
        if (ctor) {
          ctor.apply(this, a);
        }
        // 3) continue the original ritual: call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, a);
        }
      };
    }
    // plain vanilla constructor (can use inherited() to call its base constructor)
    function simpleConstructor(bases) {
      return function () {
        var a = arguments, i = 0, f, m;
        if (!(this instanceof a.callee)) {
          // not called via new, so force it
          return applyNew(a);
        }
        //this._inherited = {};
        // perform the shaman's rituals of the original declare()
        // 1) do not call the preamble
        // 2) call the top constructor (it can use this.inherited())
        for (; f = bases[i]; ++i) {
          // intentional assignment
          m = f._meta;
          f = m ? m.ctor : f;
          if (f) {
            f.apply(this, a);
            break;
          }
        }
        // 3) call the postscript
        f = this.postscript;
        if (f) {
          f.apply(this, a);
        }
      };
    }
    function chain(name, bases, reversed) {
      return function () {
        var b, m, f, i = 0, step = 1;
        if (reversed) {
          i = bases.length - 1;
          step = -1;
        }
        for (; b = bases[i]; i += step) {
          // intentional assignment
          m = b._meta;
          f = (m ? m.hidden : b.prototype)[name];
          if (f) {
            f.apply(this, arguments);
          }
        }
      };
    }
    // forceNew(ctor)
    // return a new object that inherits from ctor.prototype but
    // without actually running ctor on the object.
    function forceNew(ctor) {
    }
    // applyNew(args)
    // just like 'new ctor()' except that the constructor and its arguments come
    // from args, which must be an array or an arguments object
    function applyNew(args) {
      // create an object with ctor's prototype but without
      // calling ctor on it.
      var ctor = args.callee, t = forceNew(ctor);
      // execute the real constructor on the new object
      ctor.apply(t, args);
      return t;
    }
    function declare(className, superclass, props) {
      // summary:
      //		Create a feature-rich constructor from compact notation.
      // className: String?
      //		The optional name of the constructor (loosely, a "class")
      //		stored in the "declaredClass" property in the created prototype.
      //		It will be used as a global name for a created constructor.
      // superclass: Function|Function[]
      //		May be null, a Function, or an Array of Functions. This argument
      //		specifies a list of bases (the left-most one is the most deepest
      //		base).
      // props: Object
      //		An object whose properties are copied to the created prototype.
      //		Add an instance-initialization function by making it a property
      //		named "constructor".
      // returns: dojo/_base/declare.__DeclareCreatedObject
      //		New constructor function.
      // description:
      //		Create a constructor using a compact notation for inheritance and
      //		prototype extension.
      //
      //		Mixin ancestors provide a type of multiple inheritance.
      //		Prototypes of mixin ancestors are copied to the new class:
      //		changes to mixin prototypes will not affect classes to which
      //		they have been mixed in.
      //
      //		Ancestors can be compound classes created by this version of
      //		declare(). In complex cases all base classes are going to be
      //		linearized according to C3 MRO algorithm
      //		(see http://www.python.org/download/releases/2.3/mro/ for more
      //		details).
      //
      //		"className" is cached in "declaredClass" property of the new class,
      //		if it was supplied. The immediate super class will be cached in
      //		"superclass" property of the new class.
      //
      //		Methods in "props" will be copied and modified: "nom" property
      //		(the declared name of the method) will be added to all copied
      //		functions to help identify them for the internal machinery. Be
      //		very careful, while reusing methods: if you use the same
      //		function under different names, it can produce errors in some
      //		cases.
      //
      //		It is possible to use constructors created "manually" (without
      //		declare()) as bases. They will be called as usual during the
      //		creation of an instance, their methods will be chained, and even
      //		called by "this.inherited()".
      //
      //		Special property "-chains-" governs how to chain methods. It is
      //		a dictionary, which uses method names as keys, and hint strings
      //		as values. If a hint string is "after", this method will be
      //		called after methods of its base classes. If a hint string is
      //		"before", this method will be called before methods of its base
      //		classes.
      //
      //		If "constructor" is not mentioned in "-chains-" property, it will
      //		be chained using the legacy mode: using "after" chaining,
      //		calling preamble() method before each constructor, if available,
      //		and calling postscript() after all constructors were executed.
      //		If the hint is "after", it is chained as a regular method, but
      //		postscript() will be called after the chain of constructors.
      //		"constructor" cannot be chained "before", but it allows
      //		a special hint string: "manual", which means that constructors
      //		are not going to be chained in any way, and programmer will call
      //		them manually using this.inherited(). In the latter case
      //		postscript() will be called after the construction.
      //
      //		All chaining hints are "inherited" from base classes and
      //		potentially can be overridden. Be very careful when overriding
      //		hints! Make sure that all chained methods can work in a proposed
      //		manner of chaining.
      //
      //		Once a method was chained, it is impossible to unchain it. The
      //		only exception is "constructor". You don't need to define a
      //		method in order to supply a chaining hint.
      //
      //		If a method is chained, it cannot use this.inherited() because
      //		all other methods in the hierarchy will be called automatically.
      //
      //		Usually constructors and initializers of any kind are chained
      //		using "after" and destructors of any kind are chained as
      //		"before". Note that chaining assumes that chained methods do not
      //		return any value: any returned value will be discarded.
      //
      // example:
      //	|	declare("my.classes.bar", my.classes.foo, {
      //	|		// properties to be added to the class prototype
      //	|		someValue: 2,
      //	|		// initialization function
      //	|		constructor: function(){
      //	|			this.myComplicatedObject = new ReallyComplicatedObject();
      //	|		},
      //	|		// other functions
      //	|		someMethod: function(){
      //	|			doStuff();
      //	|		}
      //	|	});
      //
      // example:
      //	|	var MyBase = declare(null, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyClass1 = declare(MyBase, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyClass2 = declare(MyBase, {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //	|	var MyDiamond = declare([MyClass1, MyClass2], {
      //	|		// constructor, properties, and methods go here
      //	|		// ...
      //	|	});
      //
      // example:
      //	|	var F = function(){ console.log("raw constructor"); };
      //	|	F.prototype.method = function(){
      //	|		console.log("raw method");
      //	|	};
      //	|	var A = declare(F, {
      //	|		constructor: function(){
      //	|			console.log("A.constructor");
      //	|		},
      //	|		method: function(){
      //	|			console.log("before calling F.method...");
      //	|			this.inherited(arguments);
      //	|			console.log("...back in A");
      //	|		}
      //	|	});
      //	|	new A().method();
      //	|	// will print:
      //	|	// raw constructor
      //	|	// A.constructor
      //	|	// before calling F.method...
      //	|	// raw method
      //	|	// ...back in A
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			destroy: "before"
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		constructor: function(){
      //	|			console.log("B.constructor");
      //	|		},
      //	|		destroy: function(){
      //	|			console.log("B.destroy");
      //	|		}
      //	|	});
      //	|	var C = declare(B, {
      //	|		constructor: function(){
      //	|			console.log("C.constructor");
      //	|		},
      //	|		destroy: function(){
      //	|			console.log("C.destroy");
      //	|		}
      //	|	});
      //	|	new C().destroy();
      //	|	// prints:
      //	|	// B.constructor
      //	|	// C.constructor
      //	|	// C.destroy
      //	|	// B.destroy
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			constructor: "manual"
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		constructor: function(){
      //	|			// ...
      //	|			// call the base constructor with new parameters
      //	|			this.inherited(arguments, [1, 2, 3]);
      //	|			// ...
      //	|		}
      //	|	});
      //
      // example:
      //	|	var A = declare(null, {
      //	|		"-chains-": {
      //	|			m1: "before"
      //	|		},
      //	|		m1: function(){
      //	|			console.log("A.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("A.m2");
      //	|		}
      //	|	});
      //	|	var B = declare(A, {
      //	|		"-chains-": {
      //	|			m2: "after"
      //	|		},
      //	|		m1: function(){
      //	|			console.log("B.m1");
      //	|		},
      //	|		m2: function(){
      //	|			console.log("B.m2");
      //	|		}
      //	|	});
      //	|	var x = new B();
      //	|	x.m1();
      //	|	// prints:
      //	|	// B.m1
      //	|	// A.m1
      //	|	x.m2();
      //	|	// prints:
      //	|	// A.m2
      //	|	// B.m2
      // crack parameters
      if (typeof className != 'string') {
        props = superclass;
        superclass = className;
        className = '';
      }
      props = props || {};
      var proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;
      // build a prototype
      if (opts.call(superclass) == '[object Array]') {
        // C3 MRO
        bases = c3mro(superclass, className);
        t = bases[0];
        mixins = bases.length - t;
        superclass = bases[mixins];
      } else {
        bases = [0];
        if (superclass) {
          if (opts.call(superclass) == '[object Function]') {
            t = superclass._meta;
            bases = bases.concat(t ? t.bases : superclass);
          } else {
            err('base class is not a callable constructor.', className);
          }
        } else if (superclass !== null) {
          err('unknown base class. Did you use dojo.require to pull it in?', className);
        }
      }
      if (superclass) {
        for (i = mixins - 1;; --i) {
          proto = forceNew(superclass);
          if (!i) {
            // stop if nothing to add (the last base)
            break;
          }
          // mix in properties
          t = bases[i];
          (t._meta ? mixOwn : mix)(proto, t.prototype);
          // chain in new constructor
          ctor = new Function();
          ctor.superclass = superclass;
          ctor.prototype = proto;
          superclass = proto.constructor = ctor;
        }
      } else {
        proto = {};
      }
      // add all properties
      declare.safeMixin(proto, props);
      // add constructor
      t = props.constructor;
      if (t !== op.constructor) {
        t.nom = cname;
        proto.constructor = t;
      }
      // collect chains and flags
      for (i = mixins - 1; i; --i) {
        // intentional assignment
        t = bases[i]._meta;
        if (t && t.chains) {
          chains = mix(chains || {}, t.chains);
        }
      }
      if (proto['-chains-']) {
        chains = mix(chains || {}, proto['-chains-']);
      }
      // build ctor
      t = !chains || !chains.hasOwnProperty(cname);
      bases[0] = ctor = chains && chains.constructor === 'manual' ? simpleConstructor(bases) : bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t);
      // add meta information to the constructor
      ctor._meta = {
        bases: bases,
        hidden: props,
        chains: chains,
        parents: parents,
        ctor: props.constructor
      };
      ctor.superclass = superclass && superclass.prototype;
      ctor.extend = extend;
      ctor.createSubclass = createSubclass;
      ctor.prototype = proto;
      proto.constructor = ctor;
      // add "standard" methods to the prototype
      proto.getInherited = getInherited;
      proto.isInstanceOf = isInstanceOf;
      proto.inherited = inheritedImpl;
      proto.__inherited = inherited;
      // add name if specified
      if (className) {
        proto.declaredClass = className;
        lang.setObject(className, ctor);
      }
      // build chains and add them to the prototype
      if (chains) {
        for (name in chains) {
          if (proto[name] && typeof chains[name] == 'string' && name != cname) {
            t = proto[name] = chain(name, bases, chains[name] === 'after');
            t.nom = name;
          }
        }
      }
      // chained methods do not return values
      // no need to chain "invisible" functions
      return ctor;  // Function
    }
    /*=====
    	declare.__DeclareCreatedObject = {
    		// summary:
    		//		dojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following
    		//		methods, in addition to the methods and properties specified via the arguments passed to declare().
    
    		inherited: function(name, args, newArgs){
    			// summary:
    			//		Calls a super method.
    			// name: String?
    			//		The optional method name. Should be the same as the caller's
    			//		name. Usually "name" is specified in complex dynamic cases, when
    			//		the calling method was dynamically added, undecorated by
    			//		declare(), and it cannot be determined.
    			// args: Arguments
    			//		The caller supply this argument, which should be the original
    			//		"arguments".
    			// newArgs: Object?
    			//		If "true", the found function will be returned without
    			//		executing it.
    			//		If Array, it will be used to call a super method. Otherwise
    			//		"args" will be used.
    			// returns:
    			//		Whatever is returned by a super method, or a super method itself,
    			//		if "true" was specified as newArgs.
    			// description:
    			//		This method is used inside method of classes produced with
    			//		declare() to call a super method (next in the chain). It is
    			//		used for manually controlled chaining. Consider using the regular
    			//		chaining, because it is faster. Use "this.inherited()" only in
    			//		complex cases.
    			//
    			//		This method cannot me called from automatically chained
    			//		constructors including the case of a special (legacy)
    			//		constructor chaining. It cannot be called from chained methods.
    			//
    			//		If "this.inherited()" cannot find the next-in-chain method, it
    			//		does nothing and returns "undefined". The last method in chain
    			//		can be a default method implemented in Object, which will be
    			//		called last.
    			//
    			//		If "name" is specified, it is assumed that the method that
    			//		received "args" is the parent method for this call. It is looked
    			//		up in the chain list and if it is found the next-in-chain method
    			//		is called. If it is not found, the first-in-chain method is
    			//		called.
    			//
    			//		If "name" is not specified, it will be derived from the calling
    			//		method (using a methoid property "nom").
    			//
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method1: function(a, b, c){
    			//	|			this.inherited(arguments);
    			//	|		},
    			//	|		method2: function(a, b){
    			//	|			return this.inherited(arguments, [a + b]);
    			//	|		}
    			//	|	});
    			//	|	// next method is not in the chain list because it is added
    			//	|	// manually after the class was created.
    			//	|	B.prototype.method3 = function(){
    			//	|		console.log("This is a dynamically-added method.");
    			//	|		this.inherited("method3", arguments);
    			//	|	};
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method: function(a, b){
    			//	|			var super = this.inherited(arguments, true);
    			//	|			// ...
    			//	|			if(!super){
    			//	|				console.log("there is no super method");
    			//	|				return 0;
    			//	|			}
    			//	|			return super.apply(this, arguments);
    			//	|		}
    			//	|	});
    			return	{};	// Object
    		},
    
    		getInherited: function(name, args){
    			// summary:
    			//		Returns a super method.
    			// name: String?
    			//		The optional method name. Should be the same as the caller's
    			//		name. Usually "name" is specified in complex dynamic cases, when
    			//		the calling method was dynamically added, undecorated by
    			//		declare(), and it cannot be determined.
    			// args: Arguments
    			//		The caller supply this argument, which should be the original
    			//		"arguments".
    			// returns:
    			//		Returns a super method (Function) or "undefined".
    			// description:
    			//		This method is a convenience method for "this.inherited()".
    			//		It uses the same algorithm but instead of executing a super
    			//		method, it returns it, or "undefined" if not found.
    			//
    			// example:
    			//	|	var B = declare(A, {
    			//	|		method: function(a, b){
    			//	|			var super = this.getInherited(arguments);
    			//	|			// ...
    			//	|			if(!super){
    			//	|				console.log("there is no super method");
    			//	|				return 0;
    			//	|			}
    			//	|			return super.apply(this, arguments);
    			//	|		}
    			//	|	});
    			return	{};	// Object
    		},
    
    		isInstanceOf: function(cls){
    			// summary:
    			//		Checks the inheritance chain to see if it is inherited from this
    			//		class.
    			// cls: Function
    			//		Class constructor.
    			// returns:
    			//		"true", if this object is inherited from this class, "false"
    			//		otherwise.
    			// description:
    			//		This method is used with instances of classes produced with
    			//		declare() to determine of they support a certain interface or
    			//		not. It models "instanceof" operator.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var B = declare(null, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var C = declare([A, B], {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|	var D = declare(A, {
    			//	|		// constructor, properties, and methods go here
    			//	|		// ...
    			//	|	});
    			//	|
    			//	|	var a = new A(), b = new B(), c = new C(), d = new D();
    			//	|
    			//	|	console.log(a.isInstanceOf(A)); // true
    			//	|	console.log(b.isInstanceOf(A)); // false
    			//	|	console.log(c.isInstanceOf(A)); // true
    			//	|	console.log(d.isInstanceOf(A)); // true
    			//	|
    			//	|	console.log(a.isInstanceOf(B)); // false
    			//	|	console.log(b.isInstanceOf(B)); // true
    			//	|	console.log(c.isInstanceOf(B)); // true
    			//	|	console.log(d.isInstanceOf(B)); // false
    			//	|
    			//	|	console.log(a.isInstanceOf(C)); // false
    			//	|	console.log(b.isInstanceOf(C)); // false
    			//	|	console.log(c.isInstanceOf(C)); // true
    			//	|	console.log(d.isInstanceOf(C)); // false
    			//	|
    			//	|	console.log(a.isInstanceOf(D)); // false
    			//	|	console.log(b.isInstanceOf(D)); // false
    			//	|	console.log(c.isInstanceOf(D)); // false
    			//	|	console.log(d.isInstanceOf(D)); // true
    			return	{};	// Object
    		},
    
    		extend: function(source){
    			// summary:
    			//		Adds all properties and methods of source to constructor's
    			//		prototype, making them available to all instances created with
    			//		constructor. This method is specific to constructors created with
    			//		declare().
    			// source: Object
    			//		Source object which properties are going to be copied to the
    			//		constructor's prototype.
    			// description:
    			//		Adds source properties to the constructor's prototype. It can
    			//		override existing properties.
    			//
    			//		This method is similar to dojo.extend function, but it is specific
    			//		to constructors produced by declare(). It is implemented
    			//		using dojo.safeMixin, and it skips a constructor property,
    			//		and properly decorates copied functions.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		m1: function(){},
    			//	|		s1: "Popokatepetl"
    			//	|	});
    			//	|	A.extend({
    			//	|		m1: function(){},
    			//	|		m2: function(){},
    			//	|		f1: true,
    			//	|		d1: 42
    			//	|	});
    		},
    
    		createSubclass: function(mixins, props){
    			// summary:
    			//		Create a subclass of the declared class from a list of base classes.
    			// mixins: Function[]
    			//		Specifies a list of bases (the left-most one is the most deepest
    			//		base).
    			// props: Object?
    			//		An optional object whose properties are copied to the created prototype.
    			// returns: dojo/_base/declare.__DeclareCreatedObject
    			//		New constructor function.
    			// description:
    			//		Create a constructor using a compact notation for inheritance and
    			//		prototype extension.
    			//
    			//		Mixin ancestors provide a type of multiple inheritance.
    			//		Prototypes of mixin ancestors are copied to the new class:
    			//		changes to mixin prototypes will not affect classes to which
    			//		they have been mixed in.
    			//
    			// example:
    			//	|	var A = declare(null, {
    			//	|		m1: function(){},
    			//	|		s1: "bar"
    			//	|	});
    			//	|	var B = declare(null, {
    			//	|		m2: function(){},
    			//	|		s2: "foo"
    			//	|	});
    			//	|	var C = declare(null, {
    			//	|	});
    			//	|	var D1 = A.createSubclass([B, C], {
    			//	|		m1: function(){},
    			//	|		d1: 42
    			//	|	});
    			//	|	var d1 = new D1();
    			//	|
    			//	|	// this is equivalent to:
    			//	|	var D2 = declare([A, B, C], {
    			//	|		m1: function(){},
    			//	|		d1: 42
    			//	|	});
    			//	|	var d2 = new D2();
    		}
    	};
    	=====*/
    // For back-compat, remove for 2.0
    dojo.safeMixin = declare.safeMixin = safeMixin;
    dojo.declare = declare;
    return declare;
  }(dojo__base_kernel, dojo_has, dojo__base_lang);
  dojo_fx_easing = function (lang) {
    // module:
    //		dojo/fx/easing
    var easingFuncs = {
      // summary:
      //		Collection of easing functions to use beyond the default
      //		`dojo._defaultEasing` function.
      // description:
      //		Easing functions are used to manipulate the iteration through
      //		an `dojo.Animation`s _Line. _Line being the properties of an Animation,
      //		and the easing function progresses through that Line determining
      //		how quickly (or slowly) it should go. Or more accurately: modify
      //		the value of the _Line based on the percentage of animation completed.
      //
      //		All functions follow a simple naming convention of "ease type" + "when".
      //		If the name of the function ends in Out, the easing described appears
      //		towards the end of the animation. "In" means during the beginning,
      //		and InOut means both ranges of the Animation will applied, both
      //		beginning and end.
      //
      //		One does not call the easing function directly, it must be passed to
      //		the `easing` property of an animation.
      // example:
      //	|	dojo.require("dojo.fx.easing");
      //	|	var anim = dojo.fadeOut({
      //	|		node: 'node',
      //	|		duration: 2000,
      //	|		//	note there is no ()
      //	|		easing: dojo.fx.easing.quadIn
      //	|	}).play();
      //
      linear: function (n) {
        // summary:
        //		A linear easing function
        return n;
      },
      quadIn: function (n) {
        return Math.pow(n, 2);
      },
      quadOut: function (n) {
        return n * (n - 2) * -1;
      },
      quadInOut: function (n) {
        n = n * 2;
        if (n < 1) {
          return Math.pow(n, 2) / 2;
        }
        return -1 * (--n * (n - 2) - 1) / 2;
      },
      cubicIn: function (n) {
        return Math.pow(n, 3);
      },
      cubicOut: function (n) {
        return Math.pow(n - 1, 3) + 1;
      },
      cubicInOut: function (n) {
        n = n * 2;
        if (n < 1) {
          return Math.pow(n, 3) / 2;
        }
        n -= 2;
        return (Math.pow(n, 3) + 2) / 2;
      },
      quartIn: function (n) {
        return Math.pow(n, 4);
      },
      quartOut: function (n) {
        return -1 * (Math.pow(n - 1, 4) - 1);
      },
      quartInOut: function (n) {
        n = n * 2;
        if (n < 1) {
          return Math.pow(n, 4) / 2;
        }
        n -= 2;
        return -1 / 2 * (Math.pow(n, 4) - 2);
      },
      quintIn: function (n) {
        return Math.pow(n, 5);
      },
      quintOut: function (n) {
        return Math.pow(n - 1, 5) + 1;
      },
      quintInOut: function (n) {
        n = n * 2;
        if (n < 1) {
          return Math.pow(n, 5) / 2;
        }
        n -= 2;
        return (Math.pow(n, 5) + 2) / 2;
      },
      sineIn: function (n) {
        return -1 * Math.cos(n * (Math.PI / 2)) + 1;
      },
      sineOut: function (n) {
        return Math.sin(n * (Math.PI / 2));
      },
      sineInOut: function (n) {
        return -1 * (Math.cos(Math.PI * n) - 1) / 2;
      },
      expoIn: function (n) {
        return n == 0 ? 0 : Math.pow(2, 10 * (n - 1));
      },
      expoOut: function (n) {
        return n == 1 ? 1 : -1 * Math.pow(2, -10 * n) + 1;
      },
      expoInOut: function (n) {
        if (n == 0) {
          return 0;
        }
        if (n == 1) {
          return 1;
        }
        n = n * 2;
        if (n < 1) {
          return Math.pow(2, 10 * (n - 1)) / 2;
        }
        --n;
        return (-1 * Math.pow(2, -10 * n) + 2) / 2;
      },
      circIn: function (n) {
        return -1 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
      },
      circOut: function (n) {
        n = n - 1;
        return Math.sqrt(1 - Math.pow(n, 2));
      },
      circInOut: function (n) {
        n = n * 2;
        if (n < 1) {
          return -1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) - 1);
        }
        n -= 2;
        return 1 / 2 * (Math.sqrt(1 - Math.pow(n, 2)) + 1);
      },
      backIn: function (n) {
        // summary:
        //		An easing function that starts away from the target,
        //		and quickly accelerates towards the end value.
        //
        //		Use caution when the easing will cause values to become
        //		negative as some properties cannot be set to negative values.
        var s = 1.70158;
        return Math.pow(n, 2) * ((s + 1) * n - s);
      },
      backOut: function (n) {
        // summary:
        //		An easing function that pops past the range briefly, and slowly comes back.
        // description:
        //		An easing function that pops past the range briefly, and slowly comes back.
        //
        //		Use caution when the easing will cause values to become negative as some
        //		properties cannot be set to negative values.
        n = n - 1;
        var s = 1.70158;
        return Math.pow(n, 2) * ((s + 1) * n + s) + 1;
      },
      backInOut: function (n) {
        // summary:
        //		An easing function combining the effects of `backIn` and `backOut`
        // description:
        //		An easing function combining the effects of `backIn` and `backOut`.
        //		Use caution when the easing will cause values to become negative
        //		as some properties cannot be set to negative values.
        var s = 1.70158 * 1.525;
        n = n * 2;
        if (n < 1) {
          return Math.pow(n, 2) * ((s + 1) * n - s) / 2;
        }
        n -= 2;
        return (Math.pow(n, 2) * ((s + 1) * n + s) + 2) / 2;
      },
      elasticIn: function (n) {
        // summary:
        //		An easing function the elastically snaps from the start value
        // description:
        //		An easing function the elastically snaps from the start value
        //
        //		Use caution when the elasticity will cause values to become negative
        //		as some properties cannot be set to negative values.
        if (n == 0 || n == 1) {
          return n;
        }
        var p = 0.3;
        var s = p / 4;
        n = n - 1;
        return -1 * Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p);
      },
      elasticOut: function (n) {
        // summary:
        //		An easing function that elasticly snaps around the target value,
        //		near the end of the Animation
        // description:
        //		An easing function that elasticly snaps around the target value,
        //		near the end of the Animation
        //
        //		Use caution when the elasticity will cause values to become
        //		negative as some properties cannot be set to negative values.
        if (n == 0 || n == 1) {
          return n;
        }
        var p = 0.3;
        var s = p / 4;
        return Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p) + 1;
      },
      elasticInOut: function (n) {
        // summary:
        //		An easing function that elasticly snaps around the value, near
        //		the beginning and end of the Animation.
        // description:
        //		An easing function that elasticly snaps around the value, near
        //		the beginning and end of the Animation.
        //
        //		Use caution when the elasticity will cause values to become
        //		negative as some properties cannot be set to negative values.
        if (n == 0)
          return 0;
        n = n * 2;
        if (n == 2)
          return 1;
        var p = 0.3 * 1.5;
        var s = p / 4;
        if (n < 1) {
          n -= 1;
          return -0.5 * (Math.pow(2, 10 * n) * Math.sin((n - s) * (2 * Math.PI) / p));
        }
        n -= 1;
        return 0.5 * (Math.pow(2, -10 * n) * Math.sin((n - s) * (2 * Math.PI) / p)) + 1;
      },
      bounceIn: function (n) {
        // summary:
        //		An easing function that 'bounces' near the beginning of an Animation
        return 1 - easingFuncs.bounceOut(1 - n);  // Decimal
      },
      bounceOut: function (n) {
        // summary:
        //		An easing function that 'bounces' near the end of an Animation
        var s = 7.5625;
        var p = 2.75;
        var l;
        if (n < 1 / p) {
          l = s * Math.pow(n, 2);
        } else if (n < 2 / p) {
          n -= 1.5 / p;
          l = s * Math.pow(n, 2) + 0.75;
        } else if (n < 2.5 / p) {
          n -= 2.25 / p;
          l = s * Math.pow(n, 2) + 0.9375;
        } else {
          n -= 2.625 / p;
          l = s * Math.pow(n, 2) + 0.984375;
        }
        return l;
      },
      bounceInOut: function (n) {
        // summary:
        //		An easing function that 'bounces' at the beginning and end of the Animation
        if (n < 0.5) {
          return easingFuncs.bounceIn(n * 2) / 2;
        }
        return easingFuncs.bounceOut(n * 2 - 1) / 2 + 0.5;  // Decimal
      }
    };
    lang.setObject('dojo.fx.easing', easingFuncs);
    return easingFuncs;
  }(dojo__base_lang);
  libs_rangy_core = function () {
    // PATCHED AMD CODE
    /**
     * Rangy, a cross-browser JavaScript range and selection library
     * https://github.com/timdown/rangy
     *
     * Copyright 2015, Tim Down
     * Licensed under the MIT license.
     * Version: 1.3.0
     * Build date: 10 May 2015
     */
    var rangy = function (factory, global) {
      //        if (typeof define == "function" && define.amd) {
      //            // AMD. Register as an anonymous module.
      //            define(factory);
      //        } else if (typeof module != "undefined" && typeof exports == "object") {
      //            // Node/CommonJS style
      //            module.exports = factory();
      //        } else {
      //            // No AMD or CommonJS support so we place Rangy in a global variable
      //            global.rangy = factory();
      //        }
      return factory();
    }(function () {
      var OBJECT = 'object', FUNCTION = 'function', UNDEFINED = 'undefined';
      // Minimal set of properties required for DOM Level 2 Range compliance. Comparison constants such as START_TO_START
      // are omitted because ranges in KHTML do not have them but otherwise work perfectly well. See issue 113.
      var domRangeProperties = [
        'startContainer',
        'startOffset',
        'endContainer',
        'endOffset',
        'collapsed',
        'commonAncestorContainer'
      ];
      // Minimal set of methods required for DOM Level 2 Range compliance
      var domRangeMethods = [
        'setStart',
        'setStartBefore',
        'setStartAfter',
        'setEnd',
        'setEndBefore',
        'setEndAfter',
        'collapse',
        'selectNode',
        'selectNodeContents',
        'compareBoundaryPoints',
        'deleteContents',
        'extractContents',
        'cloneContents',
        'insertNode',
        'surroundContents',
        'cloneRange',
        'toString',
        'detach'
      ];
      var textRangeProperties = [
        'boundingHeight',
        'boundingLeft',
        'boundingTop',
        'boundingWidth',
        'htmlText',
        'text'
      ];
      // Subset of TextRange's full set of methods that we're interested in
      var textRangeMethods = [
        'collapse',
        'compareEndPoints',
        'duplicate',
        'moveToElementText',
        'parentElement',
        'select',
        'setEndPoint',
        'getBoundingClientRect'
      ];
      /*----------------------------------------------------------------------------------------------------------------*/
      // Trio of functions taken from Peter Michaux's article:
      // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting
      function isHostMethod(o, p) {
        var t = typeof o[p];
        return t == FUNCTION || !!(t == OBJECT && o[p]) || t == 'unknown';
      }
      function isHostObject(o, p) {
        return !!(typeof o[p] == OBJECT && o[p]);
      }
      function isHostProperty(o, p) {
        return typeof o[p] != UNDEFINED;
      }
      // Creates a convenience function to save verbose repeated calls to tests functions
      function createMultiplePropertyTest(testFunc) {
        return function (o, props) {
          var i = props.length;
          while (i--) {
            if (!testFunc(o, props[i])) {
              return false;
            }
          }
          return true;
        };
      }
      // Next trio of functions are a convenience to save verbose repeated calls to previous two functions
      var areHostMethods = createMultiplePropertyTest(isHostMethod);
      var areHostObjects = createMultiplePropertyTest(isHostObject);
      var areHostProperties = createMultiplePropertyTest(isHostProperty);
      function isTextRange(range) {
        return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);
      }
      function getBody(doc) {
        return isHostObject(doc, 'body') ? doc.body : doc.getElementsByTagName('body')[0];
      }
      var forEach = [].forEach ? function (arr, func) {
        arr.forEach(func);
      } : function (arr, func) {
        for (var i = 0, len = arr.length; i < len; ++i) {
          func(arr[i], i);
        }
      };
      var modules = {};
      var isBrowser = typeof window != UNDEFINED && typeof document != UNDEFINED;
      var util = {
        isHostMethod: isHostMethod,
        isHostObject: isHostObject,
        isHostProperty: isHostProperty,
        areHostMethods: areHostMethods,
        areHostObjects: areHostObjects,
        areHostProperties: areHostProperties,
        isTextRange: isTextRange,
        getBody: getBody,
        forEach: forEach
      };
      var api = {
        version: '1.3.0',
        initialized: false,
        isBrowser: isBrowser,
        supported: true,
        util: util,
        features: {},
        modules: modules,
        config: {
          alertOnFail: false,
          alertOnWarn: false,
          preferTextRange: false,
          autoInitialize: typeof rangyAutoInitialize == UNDEFINED ? true : rangyAutoInitialize
        }
      };
      function consoleLog(msg) {
        if (typeof global !== 'undefined' && /* PATCHED */
          isHostObject(global, 'console') && isHostMethod(global.console, 'log')) {
          global.console.log(msg);
        }
      }
      function alertOrLog(msg, shouldAlert) {
        if (isBrowser && shouldAlert) {
          alert(msg);
        } else {
          consoleLog(msg);
        }
      }
      function fail(reason) {
        api.initialized = true;
        api.supported = false;
        alertOrLog('Rangy is not supported in this environment. Reason: ' + reason, api.config.alertOnFail);
      }
      api.fail = fail;
      function warn(msg) {
        alertOrLog('Rangy warning: ' + msg, api.config.alertOnWarn);
      }
      api.warn = warn;
      // Add utility extend() method
      var extend;
      if ({}.hasOwnProperty) {
        util.extend = extend = function (obj, props, deep) {
          var o, p;
          for (var i in props) {
            if (props.hasOwnProperty(i)) {
              o = obj[i];
              p = props[i];
              if (deep && o !== null && typeof o == 'object' && p !== null && typeof p == 'object') {
                extend(o, p, true);
              }
              obj[i] = p;
            }
          }
          // Special case for toString, which does not show up in for...in loops in IE <= 8
          if (props.hasOwnProperty('toString')) {
            obj.toString = props.toString;
          }
          return obj;
        };
        util.createOptions = function (optionsParam, defaults) {
          var options = {};
          extend(options, defaults);
          if (optionsParam) {
            extend(options, optionsParam);
          }
          return options;
        };
      } else {
        fail('hasOwnProperty not supported');
      }
      // Test whether we're in a browser and bail out if not
      if (!isBrowser) {
        fail('Rangy can only run in a browser');
      }
      // Test whether Array.prototype.slice can be relied on for NodeLists and use an alternative toArray() if not
      (function () {
        var toArray;
        if (isBrowser) {
          var el = document.createElement('div');
          el.appendChild(document.createElement('span'));
          var slice = [].slice;
          try {
            if (slice.call(el.childNodes, 0)[0].nodeType == 1) {
              toArray = function (arrayLike) {
                return slice.call(arrayLike, 0);
              };
            }
          } catch (e) {
          }
        }
        if (!toArray) {
          toArray = function (arrayLike) {
            var arr = [];
            for (var i = 0, len = arrayLike.length; i < len; ++i) {
              arr[i] = arrayLike[i];
            }
            return arr;
          };
        }
        util.toArray = toArray;
      }());
      // Very simple event handler wrapper function that doesn't attempt to solve issues such as "this" handling or
      // normalization of event properties
      var addListener;
      if (isBrowser) {
        if (isHostMethod(document, 'addEventListener')) {
          addListener = function (obj, eventType, listener) {
            obj.addEventListener(eventType, listener, false);
          };
        } else if (isHostMethod(document, 'attachEvent')) {
          addListener = function (obj, eventType, listener) {
            obj.attachEvent('on' + eventType, listener);
          };
        } else {
          fail('Document does not have required addEventListener or attachEvent method');
        }
        util.addListener = addListener;
      }
      var initListeners = [];
      function getErrorDesc(ex) {
        return ex.message || ex.description || String(ex);
      }
      // Initialization
      function init() {
        if (!isBrowser || api.initialized) {
          return;
        }
        var testRange;
        var implementsDomRange = false, implementsTextRange = false;
        // First, perform basic feature tests
        if (isHostMethod(document, 'createRange')) {
          testRange = document.createRange();
          if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {
            implementsDomRange = true;
          }
        }
        var body = getBody(document);
        if (!body || body.nodeName.toLowerCase() != 'body') {
          fail('No body element found');
          return;
        }
        if (body && isHostMethod(body, 'createTextRange')) {
          testRange = body.createTextRange();
          if (isTextRange(testRange)) {
            implementsTextRange = true;
          }
        }
        if (!implementsDomRange && !implementsTextRange) {
          fail('Neither Range nor TextRange are available');
          return;
        }
        api.initialized = true;
        api.features = {
          implementsDomRange: implementsDomRange,
          implementsTextRange: implementsTextRange
        };
        // Initialize modules
        var module, errorMessage;
        for (var moduleName in modules) {
          if ((module = modules[moduleName]) instanceof Module) {
            module.init(module, api);
          }
        }
        // Call init listeners
        for (var i = 0, len = initListeners.length; i < len; ++i) {
          try {
            initListeners[i](api);
          } catch (ex) {
            errorMessage = 'Rangy init listener threw an exception. Continuing. Detail: ' + getErrorDesc(ex);
            consoleLog(errorMessage);
          }
        }
      }
      function deprecationNotice(deprecated, replacement, module) {
        if (module) {
          deprecated += ' in module ' + module.name;
        }
        api.warn('DEPRECATED: ' + deprecated + ' is deprecated. Please use ' + replacement + ' instead.');
      }
      function createAliasForDeprecatedMethod(owner, deprecated, replacement, module) {
        owner[deprecated] = function () {
          deprecationNotice(deprecated, replacement, module);
          return owner[replacement].apply(owner, util.toArray(arguments));
        };
      }
      util.deprecationNotice = deprecationNotice;
      util.createAliasForDeprecatedMethod = createAliasForDeprecatedMethod;
      // Allow external scripts to initialize this library in case it's loaded after the document has loaded
      api.init = init;
      // Execute listener immediately if already initialized
      api.addInitListener = function (listener) {
        if (api.initialized) {
          listener(api);
        } else {
          initListeners.push(listener);
        }
      };
      var shimListeners = [];
      api.addShimListener = function (listener) {
        shimListeners.push(listener);
      };
      function shim(win) {
        win = win || window;
        init();
        // Notify listeners
        for (var i = 0, len = shimListeners.length; i < len; ++i) {
          shimListeners[i](win);
        }
      }
      if (isBrowser) {
        api.shim = api.createMissingNativeApi = shim;
        createAliasForDeprecatedMethod(api, 'createMissingNativeApi', 'shim');
      }
      function Module(name, dependencies, initializer) {
        this.name = name;
        this.dependencies = dependencies;
        this.initialized = false;
        this.supported = false;
        this.initializer = initializer;
      }
      Module.prototype = {
        init: function () {
          var requiredModuleNames = this.dependencies || [];
          for (var i = 0, len = requiredModuleNames.length, requiredModule, moduleName; i < len; ++i) {
            moduleName = requiredModuleNames[i];
            requiredModule = modules[moduleName];
            if (!requiredModule || !(requiredModule instanceof Module)) {
              throw new Error('required module \'' + moduleName + '\' not found');
            }
            requiredModule.init();
            if (!requiredModule.supported) {
              throw new Error('required module \'' + moduleName + '\' not supported');
            }
          }
          // Now run initializer
          this.initializer(this);
        },
        fail: function (reason) {
          this.initialized = true;
          this.supported = false;
          throw new Error(reason);
        },
        warn: function (msg) {
          api.warn('Module ' + this.name + ': ' + msg);
        },
        deprecationNotice: function (deprecated, replacement) {
          api.warn('DEPRECATED: ' + deprecated + ' in module ' + this.name + ' is deprecated. Please use ' + replacement + ' instead');
        },
        createError: function (msg) {
          return new Error('Error in Rangy ' + this.name + ' module: ' + msg);
        }
      };
      function createModule(name, dependencies, initFunc) {
        var newModule = new Module(name, dependencies, function (module) {
          if (!module.initialized) {
            module.initialized = true;
            try {
              initFunc(api, module);
              module.supported = true;
            } catch (ex) {
              var errorMessage = 'Module \'' + name + '\' failed to load: ' + getErrorDesc(ex);
              consoleLog(errorMessage);
              if (ex.stack) {
                consoleLog(ex.stack);
              }
            }
          }
        });
        modules[name] = newModule;
        return newModule;
      }
      api.createModule = function (name) {
        // Allow 2 or 3 arguments (second argument is an optional array of dependencies)
        var initFunc, dependencies;
        if (arguments.length == 2) {
          initFunc = arguments[1];
          dependencies = [];
        } else {
          initFunc = arguments[2];
          dependencies = arguments[1];
        }
        var module = createModule(name, dependencies, initFunc);
        // Initialize the module immediately if the core is already initialized
        if (api.initialized && api.supported) {
          module.init();
        }
      };
      api.createCoreModule = function (name, dependencies, initFunc) {
        createModule(name, dependencies, initFunc);
      };
      /*----------------------------------------------------------------------------------------------------------------*/
      // Ensure rangy.rangePrototype and rangy.selectionPrototype are available immediately
      function RangePrototype() {
      }
      api.RangePrototype = RangePrototype;
      api.rangePrototype = new RangePrototype();
      function SelectionPrototype() {
      }
      api.selectionPrototype = new SelectionPrototype();
      /*----------------------------------------------------------------------------------------------------------------*/
      // DOM utility methods used by Rangy
      api.createCoreModule('DomUtil', [], function (api, module) {
        var UNDEF = 'undefined';
        var util = api.util;
        var getBody = util.getBody;
        // Perform feature tests
        if (!util.areHostMethods(document, [
            'createDocumentFragment',
            'createElement',
            'createTextNode'
          ])) {
          module.fail('document missing a Node creation method');
        }
        if (!util.isHostMethod(document, 'getElementsByTagName')) {
          module.fail('document missing getElementsByTagName method');
        }
        var el = document.createElement('div');
        if (!util.areHostMethods(el, [
            'insertBefore',
            'appendChild',
            'cloneNode'
          ] || !util.areHostObjects(el, [
            'previousSibling',
            'nextSibling',
            'childNodes',
            'parentNode'
          ]))) {
          module.fail('Incomplete Element implementation');
        }
        // innerHTML is required for Range's createContextualFragment method
        if (!util.isHostProperty(el, 'innerHTML')) {
          module.fail('Element is missing innerHTML property');
        }
        var textNode = document.createTextNode('test');
        if (!util.areHostMethods(textNode, [
            'splitText',
            'deleteData',
            'insertData',
            'appendData',
            'cloneNode'
          ] || !util.areHostObjects(el, [
            'previousSibling',
            'nextSibling',
            'childNodes',
            'parentNode'
          ]) || !util.areHostProperties(textNode, ['data']))) {
          module.fail('Incomplete Text Node implementation');
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been
        // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that
        // contains just the document as a single element and the value searched for is the document.
        var arrayContains = /*Array.prototype.indexOf ?
         function(arr, val) {
         return arr.indexOf(val) > -1;
         }:*/
        function (arr, val) {
          var i = arr.length;
          while (i--) {
            if (arr[i] === val) {
              return true;
            }
          }
          return false;
        };
        // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI
        function isHtmlNamespace(node) {
          var ns;
          return typeof node.namespaceURI == UNDEF || ((ns = node.namespaceURI) === null || ns == 'http://www.w3.org/1999/xhtml');
        }
        function parentElement(node) {
          var parent = node.parentNode;
          return parent.nodeType == 1 ? parent : null;
        }
        function getNodeIndex(node) {
          var i = 0;
          while (node = node.previousSibling) {
            ++i;
          }
          return i;
        }
        function getNodeLength(node) {
          switch (node.nodeType) {
          case 7:
          case 10:
            return 0;
          case 3:
          case 8:
            return node.length;
          default:
            return node.childNodes.length;
          }
        }
        function getCommonAncestor(node1, node2) {
          var ancestors = [], n;
          for (n = node1; n; n = n.parentNode) {
            ancestors.push(n);
          }
          for (n = node2; n; n = n.parentNode) {
            if (arrayContains(ancestors, n)) {
              return n;
            }
          }
          return null;
        }
        function isAncestorOf(ancestor, descendant, selfIsAncestor) {
          var n = selfIsAncestor ? descendant : descendant.parentNode;
          while (n) {
            if (n === ancestor) {
              return true;
            } else {
              n = n.parentNode;
            }
          }
          return false;
        }
        function isOrIsAncestorOf(ancestor, descendant) {
          return isAncestorOf(ancestor, descendant, true);
        }
        function getClosestAncestorIn(node, ancestor, selfIsAncestor) {
          var p, n = selfIsAncestor ? node : node.parentNode;
          while (n) {
            p = n.parentNode;
            if (p === ancestor) {
              return n;
            }
            n = p;
          }
          return null;
        }
        function isCharacterDataNode(node) {
          var t = node.nodeType;
          return t == 3 || t == 4 || t == 8;  // Text, CDataSection or Comment
        }
        function isTextOrCommentNode(node) {
          if (!node) {
            return false;
          }
          var t = node.nodeType;
          return t == 3 || t == 8;  // Text or Comment
        }
        function insertAfter(node, precedingNode) {
          var nextNode = precedingNode.nextSibling, parent = precedingNode.parentNode;
          if (nextNode) {
            parent.insertBefore(node, nextNode);
          } else {
            parent.appendChild(node);
          }
          return node;
        }
        // Note that we cannot use splitText() because it is bugridden in IE 9.
        function splitDataNode(node, index, positionsToPreserve) {
          var newNode = node.cloneNode(false);
          newNode.deleteData(0, index);
          node.deleteData(index, node.length - index);
          insertAfter(newNode, node);
          // Preserve positions
          if (positionsToPreserve) {
            for (var i = 0, position; position = positionsToPreserve[i++];) {
              // Handle case where position was inside the portion of node after the split point
              if (position.node == node && position.offset > index) {
                position.node = newNode;
                position.offset -= index;
              }  // Handle the case where the position is a node offset within node's parent
              else if (position.node == node.parentNode && position.offset > getNodeIndex(node)) {
                ++position.offset;
              }
            }
          }
          return newNode;
        }
        function getDocument(node) {
          if (node.nodeType == 9) {
            return node;
          } else if (typeof node.ownerDocument != UNDEF) {
            return node.ownerDocument;
          } else if (typeof node.document != UNDEF) {
            return node.document;
          } else if (node.parentNode) {
            return getDocument(node.parentNode);
          } else {
            throw module.createError('getDocument: no document found for node');
          }
        }
        function getWindow(node) {
          var doc = getDocument(node);
          if (typeof doc.defaultView != UNDEF) {
            return doc.defaultView;
          } else if (typeof doc.parentWindow != UNDEF) {
            return doc.parentWindow;
          } else {
            throw module.createError('Cannot get a window object for node');
          }
        }
        function getIframeDocument(iframeEl) {
          if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument;
          } else if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow.document;
          } else {
            throw module.createError('getIframeDocument: No Document object found for iframe element');
          }
        }
        function getIframeWindow(iframeEl) {
          if (typeof iframeEl.contentWindow != UNDEF) {
            return iframeEl.contentWindow;
          } else if (typeof iframeEl.contentDocument != UNDEF) {
            return iframeEl.contentDocument.defaultView;
          } else {
            throw module.createError('getIframeWindow: No Window object found for iframe element');
          }
        }
        // This looks bad. Is it worth it?
        function isWindow(obj) {
          return obj && util.isHostMethod(obj, 'setTimeout') && util.isHostObject(obj, 'document');
        }
        function getContentDocument(obj, module, methodName) {
          var doc;
          if (!obj) {
            doc = document;
          }  // Test if a DOM node has been passed and obtain a document object for it if so
          else if (util.isHostProperty(obj, 'nodeType')) {
            doc = obj.nodeType == 1 && obj.tagName.toLowerCase() == 'iframe' ? getIframeDocument(obj) : getDocument(obj);
          }  // Test if the doc parameter appears to be a Window object
          else if (isWindow(obj)) {
            doc = obj.document;
          }
          if (!doc) {
            throw module.createError(methodName + '(): Parameter must be a Window object or DOM node');
          }
          return doc;
        }
        function getRootContainer(node) {
          var parent;
          while (parent = node.parentNode) {
            node = parent;
          }
          return node;
        }
        function comparePoints(nodeA, offsetA, nodeB, offsetB) {
          // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing
          var nodeC, root, childA, childB, n;
          if (nodeA == nodeB) {
            // Case 1: nodes are the same
            return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;
          } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {
            // Case 2: node C (container B or an ancestor) is a child node of A
            return offsetA <= getNodeIndex(nodeC) ? -1 : 1;
          } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {
            // Case 3: node C (container A or an ancestor) is a child node of B
            return getNodeIndex(nodeC) < offsetB ? -1 : 1;
          } else {
            root = getCommonAncestor(nodeA, nodeB);
            if (!root) {
              throw new Error('comparePoints error: nodes have no common ancestor');
            }
            // Case 4: containers are siblings or descendants of siblings
            childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);
            childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);
            if (childA === childB) {
              // This shouldn't be possible
              throw module.createError('comparePoints got to case 4 and childA and childB are the same!');
            } else {
              n = root.firstChild;
              while (n) {
                if (n === childA) {
                  return -1;
                } else if (n === childB) {
                  return 1;
                }
                n = n.nextSibling;
              }
            }
          }
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        // Test for IE's crash (IE 6/7) or exception (IE >= 8) when a reference to garbage-collected text node is queried
        var crashyTextNodes = false;
        function isBrokenNode(node) {
          var n;
          try {
            n = node.parentNode;
            return false;
          } catch (e) {
            return true;
          }
        }
        (function () {
          var el = document.createElement('b');
          el.innerHTML = '1';
          var textNode = el.firstChild;
          el.innerHTML = '<br />';
          crashyTextNodes = isBrokenNode(textNode);
          api.features.crashyTextNodes = crashyTextNodes;
        }());
        /*----------------------------------------------------------------------------------------------------------------*/
        function inspectNode(node) {
          if (!node) {
            return '[No node]';
          }
          if (crashyTextNodes && isBrokenNode(node)) {
            return '[Broken node]';
          }
          if (isCharacterDataNode(node)) {
            return '"' + node.data + '"';
          }
          if (node.nodeType == 1) {
            var idAttr = node.id ? ' id="' + node.id + '"' : '';
            return '<' + node.nodeName + idAttr + '>[index:' + getNodeIndex(node) + ',length:' + node.childNodes.length + '][' + (node.innerHTML || '[innerHTML not supported]').slice(0, 25) + ']';
          }
          return node.nodeName;
        }
        function fragmentFromNodeChildren(node) {
          var fragment = getDocument(node).createDocumentFragment(), child;
          while (child = node.firstChild) {
            fragment.appendChild(child);
          }
          return fragment;
        }
        var getComputedStyleProperty;
        if (typeof window.getComputedStyle != UNDEF) {
          getComputedStyleProperty = function (el, propName) {
            return getWindow(el).getComputedStyle(el, null)[propName];
          };
        } else if (typeof document.documentElement.currentStyle != UNDEF) {
          getComputedStyleProperty = function (el, propName) {
            return el.currentStyle ? el.currentStyle[propName] : '';
          };
        } else {
          module.fail('No means of obtaining computed style properties found');
        }
        function createTestElement(doc, html, contentEditable) {
          var body = getBody(doc);
          var el = doc.createElement('div');
          el.contentEditable = '' + !!contentEditable;
          if (html) {
            el.innerHTML = html;
          }
          // Insert the test element at the start of the body to prevent scrolling to the bottom in iOS (issue #292)
          var bodyFirstChild = body.firstChild;
          if (bodyFirstChild) {
            body.insertBefore(el, bodyFirstChild);
          } else {
            body.appendChild(el);
          }
          return el;
        }
        function removeNode(node) {
          return node.parentNode.removeChild(node);
        }
        function NodeIterator(root) {
          this.root = root;
          this._next = root;
        }
        NodeIterator.prototype = {
          _current: null,
          hasNext: function () {
            return !!this._next;
          },
          next: function () {
            var n = this._current = this._next;
            var child, next;
            if (this._current) {
              child = n.firstChild;
              if (child) {
                this._next = child;
              } else {
                next = null;
                while (n !== this.root && !(next = n.nextSibling)) {
                  n = n.parentNode;
                }
                this._next = next;
              }
            }
            return this._current;
          },
          detach: function () {
            this._current = this._next = this.root = null;
          }
        };
        function createIterator(root) {
          return new NodeIterator(root);
        }
        function DomPosition(node, offset) {
          this.node = node;
          this.offset = offset;
        }
        DomPosition.prototype = {
          equals: function (pos) {
            return !!pos && this.node === pos.node && this.offset == pos.offset;
          },
          inspect: function () {
            return '[DomPosition(' + inspectNode(this.node) + ':' + this.offset + ')]';
          },
          toString: function () {
            return this.inspect();
          }
        };
        function DOMException(codeName) {
          this.code = this[codeName];
          this.codeName = codeName;
          this.message = 'DOMException: ' + this.codeName;
        }
        DOMException.prototype = {
          INDEX_SIZE_ERR: 1,
          HIERARCHY_REQUEST_ERR: 3,
          WRONG_DOCUMENT_ERR: 4,
          NO_MODIFICATION_ALLOWED_ERR: 7,
          NOT_FOUND_ERR: 8,
          NOT_SUPPORTED_ERR: 9,
          INVALID_STATE_ERR: 11,
          INVALID_NODE_TYPE_ERR: 24
        };
        DOMException.prototype.toString = function () {
          return this.message;
        };
        api.dom = {
          arrayContains: arrayContains,
          isHtmlNamespace: isHtmlNamespace,
          parentElement: parentElement,
          getNodeIndex: getNodeIndex,
          getNodeLength: getNodeLength,
          getCommonAncestor: getCommonAncestor,
          isAncestorOf: isAncestorOf,
          isOrIsAncestorOf: isOrIsAncestorOf,
          getClosestAncestorIn: getClosestAncestorIn,
          isCharacterDataNode: isCharacterDataNode,
          isTextOrCommentNode: isTextOrCommentNode,
          insertAfter: insertAfter,
          splitDataNode: splitDataNode,
          getDocument: getDocument,
          getWindow: getWindow,
          getIframeWindow: getIframeWindow,
          getIframeDocument: getIframeDocument,
          getBody: getBody,
          isWindow: isWindow,
          getContentDocument: getContentDocument,
          getRootContainer: getRootContainer,
          comparePoints: comparePoints,
          isBrokenNode: isBrokenNode,
          inspectNode: inspectNode,
          getComputedStyleProperty: getComputedStyleProperty,
          createTestElement: createTestElement,
          removeNode: removeNode,
          fragmentFromNodeChildren: fragmentFromNodeChildren,
          createIterator: createIterator,
          DomPosition: DomPosition
        };
        api.DOMException = DOMException;
      });
      /*----------------------------------------------------------------------------------------------------------------*/
      // Pure JavaScript implementation of DOM Range
      api.createCoreModule('DomRange', ['DomUtil'], function (api, module) {
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DOMException = api.DOMException;
        var isCharacterDataNode = dom.isCharacterDataNode;
        var getNodeIndex = dom.getNodeIndex;
        var isOrIsAncestorOf = dom.isOrIsAncestorOf;
        var getDocument = dom.getDocument;
        var comparePoints = dom.comparePoints;
        var splitDataNode = dom.splitDataNode;
        var getClosestAncestorIn = dom.getClosestAncestorIn;
        var getNodeLength = dom.getNodeLength;
        var arrayContains = dom.arrayContains;
        var getRootContainer = dom.getRootContainer;
        var crashyTextNodes = api.features.crashyTextNodes;
        var removeNode = dom.removeNode;
        /*----------------------------------------------------------------------------------------------------------------*/
        // Utility functions
        function isNonTextPartiallySelected(node, range) {
          return node.nodeType != 3 && (isOrIsAncestorOf(node, range.startContainer) || isOrIsAncestorOf(node, range.endContainer));
        }
        function getRangeDocument(range) {
          return range.document || getDocument(range.startContainer);
        }
        function getRangeRoot(range) {
          return getRootContainer(range.startContainer);
        }
        function getBoundaryBeforeNode(node) {
          return new DomPosition(node.parentNode, getNodeIndex(node));
        }
        function getBoundaryAfterNode(node) {
          return new DomPosition(node.parentNode, getNodeIndex(node) + 1);
        }
        function insertNodeAtPosition(node, n, o) {
          var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;
          if (isCharacterDataNode(n)) {
            if (o == n.length) {
              dom.insertAfter(node, n);
            } else {
              n.parentNode.insertBefore(node, o == 0 ? n : splitDataNode(n, o));
            }
          } else if (o >= n.childNodes.length) {
            n.appendChild(node);
          } else {
            n.insertBefore(node, n.childNodes[o]);
          }
          return firstNodeInserted;
        }
        function rangesIntersect(rangeA, rangeB, touchingIsIntersecting) {
          assertRangeValid(rangeA);
          assertRangeValid(rangeB);
          if (getRangeDocument(rangeB) != getRangeDocument(rangeA)) {
            throw new DOMException('WRONG_DOCUMENT_ERR');
          }
          var startComparison = comparePoints(rangeA.startContainer, rangeA.startOffset, rangeB.endContainer, rangeB.endOffset), endComparison = comparePoints(rangeA.endContainer, rangeA.endOffset, rangeB.startContainer, rangeB.startOffset);
          return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
        }
        function cloneSubtree(iterator) {
          var partiallySelected;
          for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {
            partiallySelected = iterator.isPartiallySelectedSubtree();
            node = node.cloneNode(!partiallySelected);
            if (partiallySelected) {
              subIterator = iterator.getSubtreeIterator();
              node.appendChild(cloneSubtree(subIterator));
              subIterator.detach();
            }
            if (node.nodeType == 10) {
              // DocumentType
              throw new DOMException('HIERARCHY_REQUEST_ERR');
            }
            frag.appendChild(node);
          }
          return frag;
        }
        function iterateSubtree(rangeIterator, func, iteratorState) {
          var it, n;
          iteratorState = iteratorState || { stop: false };
          for (var node, subRangeIterator; node = rangeIterator.next();) {
            if (rangeIterator.isPartiallySelectedSubtree()) {
              if (func(node) === false) {
                iteratorState.stop = true;
                return;
              } else {
                // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of
                // the node selected by the Range.
                subRangeIterator = rangeIterator.getSubtreeIterator();
                iterateSubtree(subRangeIterator, func, iteratorState);
                subRangeIterator.detach();
                if (iteratorState.stop) {
                  return;
                }
              }
            } else {
              // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its
              // descendants
              it = dom.createIterator(node);
              while (n = it.next()) {
                if (func(n) === false) {
                  iteratorState.stop = true;
                  return;
                }
              }
            }
          }
        }
        function deleteSubtree(iterator) {
          var subIterator;
          while (iterator.next()) {
            if (iterator.isPartiallySelectedSubtree()) {
              subIterator = iterator.getSubtreeIterator();
              deleteSubtree(subIterator);
              subIterator.detach();
            } else {
              iterator.remove();
            }
          }
        }
        function extractSubtree(iterator) {
          for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {
            if (iterator.isPartiallySelectedSubtree()) {
              node = node.cloneNode(false);
              subIterator = iterator.getSubtreeIterator();
              node.appendChild(extractSubtree(subIterator));
              subIterator.detach();
            } else {
              iterator.remove();
            }
            if (node.nodeType == 10) {
              // DocumentType
              throw new DOMException('HIERARCHY_REQUEST_ERR');
            }
            frag.appendChild(node);
          }
          return frag;
        }
        function getNodesInRange(range, nodeTypes, filter) {
          var filterNodeTypes = !!(nodeTypes && nodeTypes.length), regex;
          var filterExists = !!filter;
          if (filterNodeTypes) {
            regex = new RegExp('^(' + nodeTypes.join('|') + ')$');
          }
          var nodes = [];
          iterateSubtree(new RangeIterator(range, false), function (node) {
            if (filterNodeTypes && !regex.test(node.nodeType)) {
              return;
            }
            if (filterExists && !filter(node)) {
              return;
            }
            // Don't include a boundary container if it is a character data node and the range does not contain any
            // of its character data. See issue 190.
            var sc = range.startContainer;
            if (node == sc && isCharacterDataNode(sc) && range.startOffset == sc.length) {
              return;
            }
            var ec = range.endContainer;
            if (node == ec && isCharacterDataNode(ec) && range.endOffset == 0) {
              return;
            }
            nodes.push(node);
          });
          return nodes;
        }
        function inspect(range) {
          var name = typeof range.getName == 'undefined' ? 'Range' : range.getName();
          return '[' + name + '(' + dom.inspectNode(range.startContainer) + ':' + range.startOffset + ', ' + dom.inspectNode(range.endContainer) + ':' + range.endOffset + ')]';
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)
        function RangeIterator(range, clonePartiallySelectedTextNodes) {
          this.range = range;
          this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;
          if (!range.collapsed) {
            this.sc = range.startContainer;
            this.so = range.startOffset;
            this.ec = range.endContainer;
            this.eo = range.endOffset;
            var root = range.commonAncestorContainer;
            if (this.sc === this.ec && isCharacterDataNode(this.sc)) {
              this.isSingleCharacterDataNode = true;
              this._first = this._last = this._next = this.sc;
            } else {
              this._first = this._next = this.sc === root && !isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : getClosestAncestorIn(this.sc, root, true);
              this._last = this.ec === root && !isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : getClosestAncestorIn(this.ec, root, true);
            }
          }
        }
        RangeIterator.prototype = {
          _current: null,
          _next: null,
          _first: null,
          _last: null,
          isSingleCharacterDataNode: false,
          reset: function () {
            this._current = null;
            this._next = this._first;
          },
          hasNext: function () {
            return !!this._next;
          },
          next: function () {
            // Move to next node
            var current = this._current = this._next;
            if (current) {
              this._next = current !== this._last ? current.nextSibling : null;
              // Check for partially selected text nodes
              if (isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {
                if (current === this.ec) {
                  (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);
                }
                if (this._current === this.sc) {
                  (current = current.cloneNode(true)).deleteData(0, this.so);
                }
              }
            }
            return current;
          },
          remove: function () {
            var current = this._current, start, end;
            if (isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {
              start = current === this.sc ? this.so : 0;
              end = current === this.ec ? this.eo : current.length;
              if (start != end) {
                current.deleteData(start, end - start);
              }
            } else {
              if (current.parentNode) {
                removeNode(current);
              } else {
              }
            }
          },
          // Checks if the current node is partially selected
          isPartiallySelectedSubtree: function () {
            var current = this._current;
            return isNonTextPartiallySelected(current, this.range);
          },
          getSubtreeIterator: function () {
            var subRange;
            if (this.isSingleCharacterDataNode) {
              subRange = this.range.cloneRange();
              subRange.collapse(false);
            } else {
              subRange = new Range(getRangeDocument(this.range));
              var current = this._current;
              var startContainer = current, startOffset = 0, endContainer = current, endOffset = getNodeLength(current);
              if (isOrIsAncestorOf(current, this.sc)) {
                startContainer = this.sc;
                startOffset = this.so;
              }
              if (isOrIsAncestorOf(current, this.ec)) {
                endContainer = this.ec;
                endOffset = this.eo;
              }
              updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);
            }
            return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);
          },
          detach: function () {
            this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;
          }
        };
        /*----------------------------------------------------------------------------------------------------------------*/
        var beforeAfterNodeTypes = [
          1,
          3,
          4,
          5,
          7,
          8,
          10
        ];
        var rootContainerNodeTypes = [
          2,
          9,
          11
        ];
        var readonlyNodeTypes = [
          5,
          6,
          10,
          12
        ];
        var insertableNodeTypes = [
          1,
          3,
          4,
          5,
          7,
          8,
          10,
          11
        ];
        var surroundNodeTypes = [
          1,
          3,
          4,
          5,
          7,
          8
        ];
        function createAncestorFinder(nodeTypes) {
          return function (node, selfIsAncestor) {
            var t, n = selfIsAncestor ? node : node.parentNode;
            while (n) {
              t = n.nodeType;
              if (arrayContains(nodeTypes, t)) {
                return n;
              }
              n = n.parentNode;
            }
            return null;
          };
        }
        var getDocumentOrFragmentContainer = createAncestorFinder([
          9,
          11
        ]);
        var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);
        var getDocTypeNotationEntityAncestor = createAncestorFinder([
          6,
          10,
          12
        ]);
        function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {
          if (getDocTypeNotationEntityAncestor(node, allowSelf)) {
            throw new DOMException('INVALID_NODE_TYPE_ERR');
          }
        }
        function assertValidNodeType(node, invalidTypes) {
          if (!arrayContains(invalidTypes, node.nodeType)) {
            throw new DOMException('INVALID_NODE_TYPE_ERR');
          }
        }
        function assertValidOffset(node, offset) {
          if (offset < 0 || offset > (isCharacterDataNode(node) ? node.length : node.childNodes.length)) {
            throw new DOMException('INDEX_SIZE_ERR');
          }
        }
        function assertSameDocumentOrFragment(node1, node2) {
          if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {
            throw new DOMException('WRONG_DOCUMENT_ERR');
          }
        }
        function assertNodeNotReadOnly(node) {
          if (getReadonlyAncestor(node, true)) {
            throw new DOMException('NO_MODIFICATION_ALLOWED_ERR');
          }
        }
        function assertNode(node, codeName) {
          if (!node) {
            throw new DOMException(codeName);
          }
        }
        function isValidOffset(node, offset) {
          return offset <= (isCharacterDataNode(node) ? node.length : node.childNodes.length);
        }
        function isRangeValid(range) {
          return !!range.startContainer && !!range.endContainer && !(crashyTextNodes && (dom.isBrokenNode(range.startContainer) || dom.isBrokenNode(range.endContainer))) && getRootContainer(range.startContainer) == getRootContainer(range.endContainer) && isValidOffset(range.startContainer, range.startOffset) && isValidOffset(range.endContainer, range.endOffset);
        }
        function assertRangeValid(range) {
          if (!isRangeValid(range)) {
            throw new Error('Range error: Range is not valid. This usually happens after DOM mutation. Range: (' + range.inspect() + ')');
          }
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        // Test the browser's innerHTML support to decide how to implement createContextualFragment
        var styleEl = document.createElement('style');
        var htmlParsingConforms = false;
        try {
          styleEl.innerHTML = '<b>x</b>';
          htmlParsingConforms = styleEl.firstChild.nodeType == 3;  // Opera incorrectly creates an element node
        } catch (e) {
        }
        api.features.htmlParsingConforms = htmlParsingConforms;
        var createContextualFragment = htmlParsingConforms ? // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See
        // discussion and base code for this implementation at issue 67.
        // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface
        // Thanks to Aleks Williams.
        function (fragmentStr) {
          // "Let node the context object's start's node."
          var node = this.startContainer;
          var doc = getDocument(node);
          // "If the context object's start's node is null, raise an INVALID_STATE_ERR
          // exception and abort these steps."
          if (!node) {
            throw new DOMException('INVALID_STATE_ERR');
          }
          // "Let element be as follows, depending on node's interface:"
          // Document, Document Fragment: null
          var el = null;
          // "Element: node"
          if (node.nodeType == 1) {
            el = node;  // "Text, Comment: node's parentElement"
          } else if (isCharacterDataNode(node)) {
            el = dom.parentElement(node);
          }
          // "If either element is null or element's ownerDocument is an HTML document
          // and element's local name is "html" and element's namespace is the HTML
          // namespace"
          if (el === null || el.nodeName == 'HTML' && dom.isHtmlNamespace(getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {
            // "let element be a new Element with "body" as its local name and the HTML
            // namespace as its namespace.""
            el = doc.createElement('body');
          } else {
            el = el.cloneNode(false);
          }
          // "If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm."
          // "If the node's document is an XML document: Invoke the XML fragment parsing algorithm."
          // "In either case, the algorithm must be invoked with fragment as the input
          // and element as the context element."
          el.innerHTML = fragmentStr;
          // "If this raises an exception, then abort these steps. Otherwise, let new
          // children be the nodes returned."
          // "Let fragment be a new DocumentFragment."
          // "Append all new children to fragment."
          // "Return fragment."
          return dom.fragmentFromNodeChildren(el);
        } : // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that
        // previous versions of Rangy used (with the exception of using a body element rather than a div)
        function (fragmentStr) {
          var doc = getRangeDocument(this);
          var el = doc.createElement('body');
          el.innerHTML = fragmentStr;
          return dom.fragmentFromNodeChildren(el);
        };
        function splitRangeBoundaries(range, positionsToPreserve) {
          assertRangeValid(range);
          var sc = range.startContainer, so = range.startOffset, ec = range.endContainer, eo = range.endOffset;
          var startEndSame = sc === ec;
          if (isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {
            splitDataNode(ec, eo, positionsToPreserve);
          }
          if (isCharacterDataNode(sc) && so > 0 && so < sc.length) {
            sc = splitDataNode(sc, so, positionsToPreserve);
            if (startEndSame) {
              eo -= so;
              ec = sc;
            } else if (ec == sc.parentNode && eo >= getNodeIndex(sc)) {
              eo++;
            }
            so = 0;
          }
          range.setStartAndEnd(sc, so, ec, eo);
        }
        function rangeToHtml(range) {
          assertRangeValid(range);
          var container = range.commonAncestorContainer.parentNode.cloneNode(false);
          container.appendChild(range.cloneContents());
          return container.innerHTML;
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        var rangeProperties = [
          'startContainer',
          'startOffset',
          'endContainer',
          'endOffset',
          'collapsed',
          'commonAncestorContainer'
        ];
        var s2s = 0, s2e = 1, e2e = 2, e2s = 3;
        var n_b = 0, n_a = 1, n_b_a = 2, n_i = 3;
        util.extend(api.rangePrototype, {
          compareBoundaryPoints: function (how, range) {
            assertRangeValid(this);
            assertSameDocumentOrFragment(this.startContainer, range.startContainer);
            var nodeA, offsetA, nodeB, offsetB;
            var prefixA = how == e2s || how == s2s ? 'start' : 'end';
            var prefixB = how == s2e || how == s2s ? 'start' : 'end';
            nodeA = this[prefixA + 'Container'];
            offsetA = this[prefixA + 'Offset'];
            nodeB = range[prefixB + 'Container'];
            offsetB = range[prefixB + 'Offset'];
            return comparePoints(nodeA, offsetA, nodeB, offsetB);
          },
          insertNode: function (node) {
            assertRangeValid(this);
            assertValidNodeType(node, insertableNodeTypes);
            assertNodeNotReadOnly(this.startContainer);
            if (isOrIsAncestorOf(node, this.startContainer)) {
              throw new DOMException('HIERARCHY_REQUEST_ERR');
            }
            // No check for whether the container of the start of the Range is of a type that does not allow
            // children of the type of node: the browser's DOM implementation should do this for us when we attempt
            // to add the node
            var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);
            this.setStartBefore(firstNodeInserted);
          },
          cloneContents: function () {
            assertRangeValid(this);
            var clone, frag;
            if (this.collapsed) {
              return getRangeDocument(this).createDocumentFragment();
            } else {
              if (this.startContainer === this.endContainer && isCharacterDataNode(this.startContainer)) {
                clone = this.startContainer.cloneNode(true);
                clone.data = clone.data.slice(this.startOffset, this.endOffset);
                frag = getRangeDocument(this).createDocumentFragment();
                frag.appendChild(clone);
                return frag;
              } else {
                var iterator = new RangeIterator(this, true);
                clone = cloneSubtree(iterator);
                iterator.detach();
              }
              return clone;
            }
          },
          canSurroundContents: function () {
            assertRangeValid(this);
            assertNodeNotReadOnly(this.startContainer);
            assertNodeNotReadOnly(this.endContainer);
            // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
            // no non-text nodes.
            var iterator = new RangeIterator(this, true);
            var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
            iterator.detach();
            return !boundariesInvalid;
          },
          surroundContents: function (node) {
            assertValidNodeType(node, surroundNodeTypes);
            if (!this.canSurroundContents()) {
              throw new DOMException('INVALID_STATE_ERR');
            }
            // Extract the contents
            var content = this.extractContents();
            // Clear the children of the node
            if (node.hasChildNodes()) {
              while (node.lastChild) {
                node.removeChild(node.lastChild);
              }
            }
            // Insert the new node and add the extracted contents
            insertNodeAtPosition(node, this.startContainer, this.startOffset);
            node.appendChild(content);
            this.selectNode(node);
          },
          cloneRange: function () {
            assertRangeValid(this);
            var range = new Range(getRangeDocument(this));
            var i = rangeProperties.length, prop;
            while (i--) {
              prop = rangeProperties[i];
              range[prop] = this[prop];
            }
            return range;
          },
          toString: function () {
            assertRangeValid(this);
            var sc = this.startContainer;
            if (sc === this.endContainer && isCharacterDataNode(sc)) {
              return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : '';
            } else {
              var textParts = [], iterator = new RangeIterator(this, true);
              iterateSubtree(iterator, function (node) {
                // Accept only text or CDATA nodes, not comments
                if (node.nodeType == 3 || node.nodeType == 4) {
                  textParts.push(node.data);
                }
              });
              iterator.detach();
              return textParts.join('');
            }
          },
          // The methods below are all non-standard. The following batch were introduced by Mozilla but have since
          // been removed from Mozilla.
          compareNode: function (node) {
            assertRangeValid(this);
            var parent = node.parentNode;
            var nodeIndex = getNodeIndex(node);
            if (!parent) {
              throw new DOMException('NOT_FOUND_ERR');
            }
            var startComparison = this.comparePoint(parent, nodeIndex), endComparison = this.comparePoint(parent, nodeIndex + 1);
            if (startComparison < 0) {
              // Node starts before
              return endComparison > 0 ? n_b_a : n_b;
            } else {
              return endComparison > 0 ? n_a : n_i;
            }
          },
          comparePoint: function (node, offset) {
            assertRangeValid(this);
            assertNode(node, 'HIERARCHY_REQUEST_ERR');
            assertSameDocumentOrFragment(node, this.startContainer);
            if (comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {
              return -1;
            } else if (comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {
              return 1;
            }
            return 0;
          },
          createContextualFragment: createContextualFragment,
          toHtml: function () {
            return rangeToHtml(this);
          },
          // touchingIsIntersecting determines whether this method considers a node that borders a range intersects
          // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)
          intersectsNode: function (node, touchingIsIntersecting) {
            assertRangeValid(this);
            if (getRootContainer(node) != getRangeRoot(this)) {
              return false;
            }
            var parent = node.parentNode, offset = getNodeIndex(node);
            if (!parent) {
              return true;
            }
            var startComparison = comparePoints(parent, offset, this.endContainer, this.endOffset), endComparison = comparePoints(parent, offset + 1, this.startContainer, this.startOffset);
            return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;
          },
          isPointInRange: function (node, offset) {
            assertRangeValid(this);
            assertNode(node, 'HIERARCHY_REQUEST_ERR');
            assertSameDocumentOrFragment(node, this.startContainer);
            return comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;
          },
          // The methods below are non-standard and invented by me.
          // Sharing a boundary start-to-end or end-to-start does not count as intersection.
          intersectsRange: function (range) {
            return rangesIntersect(this, range, false);
          },
          // Sharing a boundary start-to-end or end-to-start does count as intersection.
          intersectsOrTouchesRange: function (range) {
            return rangesIntersect(this, range, true);
          },
          intersection: function (range) {
            if (this.intersectsRange(range)) {
              var startComparison = comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset), endComparison = comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);
              var intersectionRange = this.cloneRange();
              if (startComparison == -1) {
                intersectionRange.setStart(range.startContainer, range.startOffset);
              }
              if (endComparison == 1) {
                intersectionRange.setEnd(range.endContainer, range.endOffset);
              }
              return intersectionRange;
            }
            return null;
          },
          union: function (range) {
            if (this.intersectsOrTouchesRange(range)) {
              var unionRange = this.cloneRange();
              if (comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {
                unionRange.setStart(range.startContainer, range.startOffset);
              }
              if (comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {
                unionRange.setEnd(range.endContainer, range.endOffset);
              }
              return unionRange;
            } else {
              throw new DOMException('Ranges do not intersect');
            }
          },
          containsNode: function (node, allowPartial) {
            if (allowPartial) {
              return this.intersectsNode(node, false);
            } else {
              return this.compareNode(node) == n_i;
            }
          },
          containsNodeContents: function (node) {
            return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, getNodeLength(node)) <= 0;
          },
          containsRange: function (range) {
            var intersection = this.intersection(range);
            return intersection !== null && range.equals(intersection);
          },
          containsNodeText: function (node) {
            var nodeRange = this.cloneRange();
            nodeRange.selectNode(node);
            var textNodes = nodeRange.getNodes([3]);
            if (textNodes.length > 0) {
              nodeRange.setStart(textNodes[0], 0);
              var lastTextNode = textNodes.pop();
              nodeRange.setEnd(lastTextNode, lastTextNode.length);
              return this.containsRange(nodeRange);
            } else {
              return this.containsNodeContents(node);
            }
          },
          getNodes: function (nodeTypes, filter) {
            assertRangeValid(this);
            return getNodesInRange(this, nodeTypes, filter);
          },
          getDocument: function () {
            return getRangeDocument(this);
          },
          collapseBefore: function (node) {
            this.setEndBefore(node);
            this.collapse(false);
          },
          collapseAfter: function (node) {
            this.setStartAfter(node);
            this.collapse(true);
          },
          getBookmark: function (containerNode) {
            var doc = getRangeDocument(this);
            var preSelectionRange = api.createRange(doc);
            containerNode = containerNode || dom.getBody(doc);
            preSelectionRange.selectNodeContents(containerNode);
            var range = this.intersection(preSelectionRange);
            var start = 0, end = 0;
            if (range) {
              preSelectionRange.setEnd(range.startContainer, range.startOffset);
              start = preSelectionRange.toString().length;
              end = start + range.toString().length;
            }
            return {
              start: start,
              end: end,
              containerNode: containerNode
            };
          },
          moveToBookmark: function (bookmark) {
            var containerNode = bookmark.containerNode;
            var charIndex = 0;
            this.setStart(containerNode, 0);
            this.collapse(true);
            var nodeStack = [containerNode], node, foundStart = false, stop = false;
            var nextCharIndex, i, childNodes;
            while (!stop && (node = nodeStack.pop())) {
              if (node.nodeType == 3) {
                nextCharIndex = charIndex + node.length;
                if (!foundStart && bookmark.start >= charIndex && bookmark.start <= nextCharIndex) {
                  this.setStart(node, bookmark.start - charIndex);
                  foundStart = true;
                }
                if (foundStart && bookmark.end >= charIndex && bookmark.end <= nextCharIndex) {
                  this.setEnd(node, bookmark.end - charIndex);
                  stop = true;
                }
                charIndex = nextCharIndex;
              } else {
                childNodes = node.childNodes;
                i = childNodes.length;
                while (i--) {
                  nodeStack.push(childNodes[i]);
                }
              }
            }
          },
          getName: function () {
            return 'DomRange';
          },
          equals: function (range) {
            return Range.rangesEqual(this, range);
          },
          isValid: function () {
            return isRangeValid(this);
          },
          inspect: function () {
            return inspect(this);
          },
          detach: function () {
          }
        });
        function copyComparisonConstantsToObject(obj) {
          obj.START_TO_START = s2s;
          obj.START_TO_END = s2e;
          obj.END_TO_END = e2e;
          obj.END_TO_START = e2s;
          obj.NODE_BEFORE = n_b;
          obj.NODE_AFTER = n_a;
          obj.NODE_BEFORE_AND_AFTER = n_b_a;
          obj.NODE_INSIDE = n_i;
        }
        function copyComparisonConstants(constructor) {
          copyComparisonConstantsToObject(constructor);
          copyComparisonConstantsToObject(constructor.prototype);
        }
        function createRangeContentRemover(remover, boundaryUpdater) {
          return function () {
            assertRangeValid(this);
            var sc = this.startContainer, so = this.startOffset, root = this.commonAncestorContainer;
            var iterator = new RangeIterator(this, true);
            // Work out where to position the range after content removal
            var node, boundary;
            if (sc !== root) {
              node = getClosestAncestorIn(sc, root, true);
              boundary = getBoundaryAfterNode(node);
              sc = boundary.node;
              so = boundary.offset;
            }
            // Check none of the range is read-only
            iterateSubtree(iterator, assertNodeNotReadOnly);
            iterator.reset();
            // Remove the content
            var returnValue = remover(iterator);
            iterator.detach();
            // Move to the new position
            boundaryUpdater(this, sc, so, sc, so);
            return returnValue;
          };
        }
        function createPrototypeRange(constructor, boundaryUpdater) {
          function createBeforeAfterNodeSetter(isBefore, isStart) {
            return function (node) {
              assertValidNodeType(node, beforeAfterNodeTypes);
              assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);
              var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);
              (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);
            };
          }
          function setRangeStart(range, node, offset) {
            var ec = range.endContainer, eo = range.endOffset;
            if (node !== range.startContainer || offset !== range.startOffset) {
              // Check the root containers of the range and the new boundary, and also check whether the new boundary
              // is after the current end. In either case, collapse the range to the new position
              if (getRootContainer(node) != getRootContainer(ec) || comparePoints(node, offset, ec, eo) == 1) {
                ec = node;
                eo = offset;
              }
              boundaryUpdater(range, node, offset, ec, eo);
            }
          }
          function setRangeEnd(range, node, offset) {
            var sc = range.startContainer, so = range.startOffset;
            if (node !== range.endContainer || offset !== range.endOffset) {
              // Check the root containers of the range and the new boundary, and also check whether the new boundary
              // is after the current end. In either case, collapse the range to the new position
              if (getRootContainer(node) != getRootContainer(sc) || comparePoints(node, offset, sc, so) == -1) {
                sc = node;
                so = offset;
              }
              boundaryUpdater(range, sc, so, node, offset);
            }
          }
          // Set up inheritance
          var F = function () {
          };
          F.prototype = api.rangePrototype;
          constructor.prototype = new F();
          util.extend(constructor.prototype, {
            setStart: function (node, offset) {
              assertNoDocTypeNotationEntityAncestor(node, true);
              assertValidOffset(node, offset);
              setRangeStart(this, node, offset);
            },
            setEnd: function (node, offset) {
              assertNoDocTypeNotationEntityAncestor(node, true);
              assertValidOffset(node, offset);
              setRangeEnd(this, node, offset);
            },
            /**
             * Convenience method to set a range's start and end boundaries. Overloaded as follows:
             * - Two parameters (node, offset) creates a collapsed range at that position
             * - Three parameters (node, startOffset, endOffset) creates a range contained with node starting at
             *   startOffset and ending at endOffset
             * - Four parameters (startNode, startOffset, endNode, endOffset) creates a range starting at startOffset in
             *   startNode and ending at endOffset in endNode
             */
            setStartAndEnd: function () {
              var args = arguments;
              var sc = args[0], so = args[1], ec = sc, eo = so;
              switch (args.length) {
              case 3:
                eo = args[2];
                break;
              case 4:
                ec = args[2];
                eo = args[3];
                break;
              }
              boundaryUpdater(this, sc, so, ec, eo);
            },
            setBoundary: function (node, offset, isStart) {
              this['set' + (isStart ? 'Start' : 'End')](node, offset);
            },
            setStartBefore: createBeforeAfterNodeSetter(true, true),
            setStartAfter: createBeforeAfterNodeSetter(false, true),
            setEndBefore: createBeforeAfterNodeSetter(true, false),
            setEndAfter: createBeforeAfterNodeSetter(false, false),
            collapse: function (isStart) {
              assertRangeValid(this);
              if (isStart) {
                boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);
              } else {
                boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);
              }
            },
            selectNodeContents: function (node) {
              assertNoDocTypeNotationEntityAncestor(node, true);
              boundaryUpdater(this, node, 0, node, getNodeLength(node));
            },
            selectNode: function (node) {
              assertNoDocTypeNotationEntityAncestor(node, false);
              assertValidNodeType(node, beforeAfterNodeTypes);
              var start = getBoundaryBeforeNode(node), end = getBoundaryAfterNode(node);
              boundaryUpdater(this, start.node, start.offset, end.node, end.offset);
            },
            extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),
            deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),
            canSurroundContents: function () {
              assertRangeValid(this);
              assertNodeNotReadOnly(this.startContainer);
              assertNodeNotReadOnly(this.endContainer);
              // Check if the contents can be surrounded. Specifically, this means whether the range partially selects
              // no non-text nodes.
              var iterator = new RangeIterator(this, true);
              var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);
              iterator.detach();
              return !boundariesInvalid;
            },
            splitBoundaries: function () {
              splitRangeBoundaries(this);
            },
            splitBoundariesPreservingPositions: function (positionsToPreserve) {
              splitRangeBoundaries(this, positionsToPreserve);
            },
            normalizeBoundaries: function () {
              assertRangeValid(this);
              var sc = this.startContainer, so = this.startOffset, ec = this.endContainer, eo = this.endOffset;
              var mergeForward = function (node) {
                var sibling = node.nextSibling;
                if (sibling && sibling.nodeType == node.nodeType) {
                  ec = node;
                  eo = node.length;
                  node.appendData(sibling.data);
                  removeNode(sibling);
                }
              };
              var mergeBackward = function (node) {
                var sibling = node.previousSibling;
                if (sibling && sibling.nodeType == node.nodeType) {
                  sc = node;
                  var nodeLength = node.length;
                  so = sibling.length;
                  node.insertData(0, sibling.data);
                  removeNode(sibling);
                  if (sc == ec) {
                    eo += so;
                    ec = sc;
                  } else if (ec == node.parentNode) {
                    var nodeIndex = getNodeIndex(node);
                    if (eo == nodeIndex) {
                      ec = node;
                      eo = nodeLength;
                    } else if (eo > nodeIndex) {
                      eo--;
                    }
                  }
                }
              };
              var normalizeStart = true;
              var sibling;
              if (isCharacterDataNode(ec)) {
                if (eo == ec.length) {
                  mergeForward(ec);
                } else if (eo == 0) {
                  sibling = ec.previousSibling;
                  if (sibling && sibling.nodeType == ec.nodeType) {
                    eo = sibling.length;
                    if (sc == ec) {
                      normalizeStart = false;
                    }
                    sibling.appendData(ec.data);
                    removeNode(ec);
                    ec = sibling;
                  }
                }
              } else {
                if (eo > 0) {
                  var endNode = ec.childNodes[eo - 1];
                  if (endNode && isCharacterDataNode(endNode)) {
                    mergeForward(endNode);
                  }
                }
                normalizeStart = !this.collapsed;
              }
              if (normalizeStart) {
                if (isCharacterDataNode(sc)) {
                  if (so == 0) {
                    mergeBackward(sc);
                  } else if (so == sc.length) {
                    sibling = sc.nextSibling;
                    if (sibling && sibling.nodeType == sc.nodeType) {
                      if (ec == sibling) {
                        ec = sc;
                        eo += sc.length;
                      }
                      sc.appendData(sibling.data);
                      removeNode(sibling);
                    }
                  }
                } else {
                  if (so < sc.childNodes.length) {
                    var startNode = sc.childNodes[so];
                    if (startNode && isCharacterDataNode(startNode)) {
                      mergeBackward(startNode);
                    }
                  }
                }
              } else {
                sc = ec;
                so = eo;
              }
              boundaryUpdater(this, sc, so, ec, eo);
            },
            collapseToPoint: function (node, offset) {
              assertNoDocTypeNotationEntityAncestor(node, true);
              assertValidOffset(node, offset);
              this.setStartAndEnd(node, offset);
            }
          });
          copyComparisonConstants(constructor);
        }
        /*----------------------------------------------------------------------------------------------------------------*/
        // Updates commonAncestorContainer and collapsed after boundary change
        function updateCollapsedAndCommonAncestor(range) {
          range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;
          range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);
        }
        function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {
          range.startContainer = startContainer;
          range.startOffset = startOffset;
          range.endContainer = endContainer;
          range.endOffset = endOffset;
          range.document = dom.getDocument(startContainer);
          updateCollapsedAndCommonAncestor(range);
        }
        function Range(doc) {
          this.startContainer = doc;
          this.startOffset = 0;
          this.endContainer = doc;
          this.endOffset = 0;
          this.document = doc;
          updateCollapsedAndCommonAncestor(this);
        }
        createPrototypeRange(Range, updateBoundaries);
        util.extend(Range, {
          rangeProperties: rangeProperties,
          RangeIterator: RangeIterator,
          copyComparisonConstants: copyComparisonConstants,
          createPrototypeRange: createPrototypeRange,
          inspect: inspect,
          toHtml: rangeToHtml,
          getRangeDocument: getRangeDocument,
          rangesEqual: function (r1, r2) {
            return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;
          }
        });
        api.DomRange = Range;
      });
      /*----------------------------------------------------------------------------------------------------------------*/
      // Wrappers for the browser's native DOM Range and/or TextRange implementation
      api.createCoreModule('WrappedRange', ['DomRange'], function (api, module) {
        var WrappedRange, WrappedTextRange;
        var dom = api.dom;
        var util = api.util;
        var DomPosition = dom.DomPosition;
        var DomRange = api.DomRange;
        var getBody = dom.getBody;
        var getContentDocument = dom.getContentDocument;
        var isCharacterDataNode = dom.isCharacterDataNode;
        /*----------------------------------------------------------------------------------------------------------------*/
        if (api.features.implementsDomRange) {
          // This is a wrapper around the browser's native DOM Range. It has two aims:
          // - Provide workarounds for specific browser bugs
          // - provide convenient extensions, which are inherited from Rangy's DomRange
          (function () {
            var rangeProto;
            var rangeProperties = DomRange.rangeProperties;
            function updateRangeProperties(range) {
              var i = rangeProperties.length, prop;
              while (i--) {
                prop = rangeProperties[i];
                range[prop] = range.nativeRange[prop];
              }
              // Fix for broken collapsed property in IE 9.
              range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;
            }
            function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {
              var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;
              var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset;
              var nativeRangeDifferent = !range.equals(range.nativeRange);
              // Always set both boundaries for the benefit of IE9 (see issue 35)
              if (startMoved || endMoved || nativeRangeDifferent) {
                range.setEnd(endContainer, endOffset);
                range.setStart(startContainer, startOffset);
              }
            }
            var createBeforeAfterNodeSetter;
            WrappedRange = function (range) {
              if (!range) {
                throw module.createError('WrappedRange: Range must be specified');
              }
              this.nativeRange = range;
              updateRangeProperties(this);
            };
            DomRange.createPrototypeRange(WrappedRange, updateNativeRange);
            rangeProto = WrappedRange.prototype;
            rangeProto.selectNode = function (node) {
              this.nativeRange.selectNode(node);
              updateRangeProperties(this);
            };
            rangeProto.cloneContents = function () {
              return this.nativeRange.cloneContents();
            };
            // Due to a long-standing Firefox bug that I have not been able to find a reliable way to detect,
            // insertNode() is never delegated to the native range.
            rangeProto.surroundContents = function (node) {
              this.nativeRange.surroundContents(node);
              updateRangeProperties(this);
            };
            rangeProto.collapse = function (isStart) {
              this.nativeRange.collapse(isStart);
              updateRangeProperties(this);
            };
            rangeProto.cloneRange = function () {
              return new WrappedRange(this.nativeRange.cloneRange());
            };
            rangeProto.refresh = function () {
              updateRangeProperties(this);
            };
            rangeProto.toString = function () {
              return this.nativeRange.toString();
            };
            // Create test range and node for feature detection
            var testTextNode = document.createTextNode('test');
            getBody(document).appendChild(testTextNode);
            var range = document.createRange();
            /*--------------------------------------------------------------------------------------------------------*/
            // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and
            // correct for it
            range.setStart(testTextNode, 0);
            range.setEnd(testTextNode, 0);
            try {
              range.setStart(testTextNode, 1);
              rangeProto.setStart = function (node, offset) {
                this.nativeRange.setStart(node, offset);
                updateRangeProperties(this);
              };
              rangeProto.setEnd = function (node, offset) {
                this.nativeRange.setEnd(node, offset);
                updateRangeProperties(this);
              };
              createBeforeAfterNodeSetter = function (name) {
                return function (node) {
                  this.nativeRange[name](node);
                  updateRangeProperties(this);
                };
              };
            } catch (ex) {
              rangeProto.setStart = function (node, offset) {
                try {
                  this.nativeRange.setStart(node, offset);
                } catch (ex) {
                  this.nativeRange.setEnd(node, offset);
                  this.nativeRange.setStart(node, offset);
                }
                updateRangeProperties(this);
              };
              rangeProto.setEnd = function (node, offset) {
                try {
                  this.nativeRange.setEnd(node, offset);
                } catch (ex) {
                  this.nativeRange.setStart(node, offset);
                  this.nativeRange.setEnd(node, offset);
                }
                updateRangeProperties(this);
              };
              createBeforeAfterNodeSetter = function (name, oppositeName) {
                return function (node) {
                  try {
                    this.nativeRange[name](node);
                  } catch (ex) {
                    this.nativeRange[oppositeName](node);
                    this.nativeRange[name](node);
                  }
                  updateRangeProperties(this);
                };
              };
            }
            rangeProto.setStartBefore = createBeforeAfterNodeSetter('setStartBefore', 'setEndBefore');
            rangeProto.setStartAfter = createBeforeAfterNodeSetter('setStartAfter', 'setEndAfter');
            rangeProto.setEndBefore = createBeforeAfterNodeSetter('setEndBefore', 'setStartBefore');
            rangeProto.setEndAfter = createBeforeAfterNodeSetter('setEndAfter', 'setStartAfter');
            /*--------------------------------------------------------------------------------------------------------*/
            // Always use DOM4-compliant selectNodeContents implementation: it's simpler and less code than testing
            // whether the native implementation can be trusted
            rangeProto.selectNodeContents = function (node) {
              this.setStartAndEnd(node, 0, dom.getNodeLength(node));
            };
            /*--------------------------------------------------------------------------------------------------------*/
            // Test for and correct WebKit bug that has the behaviour of compareBoundaryPoints round the wrong way for
            // constants START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738
            range.selectNodeContents(testTextNode);
            range.setEnd(testTextNode, 3);
            var range2 = document.createRange();
            range2.selectNodeContents(testTextNode);
            range2.setEnd(testTextNode, 4);
            range2.setStart(testTextNode, 2);
            if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 && range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {
              // This is the wrong way round, so correct for it
              rangeProto.compareBoundaryPoints = function (type, range) {
                range = range.nativeRange || range;
                if (type == range.START_TO_END) {
                  type = range.END_TO_START;
                } else if (type == range.END_TO_START) {
                  type = range.START_TO_END;
                }
                return this.nativeRange.compareBoundaryPoints(type, range);
              };
            } else {
              rangeProto.compareBoundaryPoints = function (type, range) {
                return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);
              };
            }
            /*--------------------------------------------------------------------------------------------------------*/
            // Test for IE deleteContents() and extractContents() bug and correct it. See issue 107.
            var el = document.createElement('div');
            el.innerHTML = '123';
            var textNode = el.firstChild;
            var body = getBody(document);
            body.appendChild(el);
            range.setStart(textNode, 1);
            range.setEnd(textNode, 2);
            range.deleteContents();
            if (textNode.data == '13') {
              // Behaviour is correct per DOM4 Range so wrap the browser's implementation of deleteContents() and
              // extractContents()
              rangeProto.deleteContents = function () {
                this.nativeRange.deleteContents();
                updateRangeProperties(this);
              };
              rangeProto.extractContents = function () {
                var frag = this.nativeRange.extractContents();
                updateRangeProperties(this);
                return frag;
              };
            } else {
            }
            body.removeChild(el);
            body = null;
            /*--------------------------------------------------------------------------------------------------------*/
            // Test for existence of createContextualFragment and delegate to it if it exists
            if (util.isHostMethod(range, 'createContextualFragment')) {
              rangeProto.createContextualFragment = function (fragmentStr) {
                return this.nativeRange.createContextualFragment(fragmentStr);
              };
            }
            /*--------------------------------------------------------------------------------------------------------*/
            // Clean up
            getBody(document).removeChild(testTextNode);
            rangeProto.getName = function () {
              return 'WrappedRange';
            };
            api.WrappedRange = WrappedRange;
            api.createNativeRange = function (doc) {
              doc = getContentDocument(doc, module, 'createNativeRange');
              return doc.createRange();
            };
          }());
        }
        if (api.features.implementsTextRange) {
          /*
                           This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()
                           method. For example, in the following (where pipes denote the selection boundaries):
          
                           <ul id="ul"><li id="a">| a </li><li id="b"> b |</li></ul>
          
                           var range = document.selection.createRange();
                           alert(range.parentElement().id); // Should alert "ul" but alerts "b"
          
                           This method returns the common ancestor node of the following:
                           - the parentElement() of the textRange
                           - the parentElement() of the textRange after calling collapse(true)
                           - the parentElement() of the textRange after calling collapse(false)
                           */
          var getTextRangeContainerElement = function (textRange) {
            var parentEl = textRange.parentElement();
            var range = textRange.duplicate();
            range.collapse(true);
            var startEl = range.parentElement();
            range = textRange.duplicate();
            range.collapse(false);
            var endEl = range.parentElement();
            var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);
            return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);
          };
          var textRangeIsCollapsed = function (textRange) {
            return textRange.compareEndPoints('StartToEnd', textRange) == 0;
          };
          // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started
          // out as an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/)
          // but has grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange
          // bugs, handling for inputs and images, plus optimizations.
          var getTextRangeBoundaryPosition = function (textRange, wholeRangeContainerElement, isStart, isCollapsed, startInfo) {
            var workingRange = textRange.duplicate();
            workingRange.collapse(isStart);
            var containerElement = workingRange.parentElement();
            // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so
            // check for that
            if (!dom.isOrIsAncestorOf(wholeRangeContainerElement, containerElement)) {
              containerElement = wholeRangeContainerElement;
            }
            // Deal with nodes that cannot "contain rich HTML markup". In practice, this means form inputs, images and
            // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx
            if (!containerElement.canHaveHTML) {
              var pos = new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));
              return {
                boundaryPosition: pos,
                nodeInfo: {
                  nodeIndex: pos.offset,
                  containerElement: pos.node
                }
              };
            }
            var workingNode = dom.getDocument(containerElement).createElement('span');
            // Workaround for HTML5 Shiv's insane violation of document.createElement(). See Rangy issue 104 and HTML5
            // Shiv issue 64: https://github.com/aFarkas/html5shiv/issues/64
            if (workingNode.parentNode) {
              dom.removeNode(workingNode);
            }
            var comparison, workingComparisonType = isStart ? 'StartToStart' : 'StartToEnd';
            var previousNode, nextNode, boundaryPosition, boundaryNode;
            var start = startInfo && startInfo.containerElement == containerElement ? startInfo.nodeIndex : 0;
            var childNodeCount = containerElement.childNodes.length;
            var end = childNodeCount;
            // Check end first. Code within the loop assumes that the endth child node of the container is definitely
            // after the range boundary.
            var nodeIndex = end;
            //KSK Patch invalid argument exception
            while (true) {
              if (nodeIndex == childNodeCount) {
                containerElement.appendChild(workingNode);
              } else {
                if (navigator.appVersion.indexOf('MSIE 8.0') > -1) {
                  if (containerElement.childNodes[nodeIndex]) {
                    if (String(containerElement.childNodes[nodeIndex]) == '[object HTMLUnknownElement]' || containerElement.childNodes[nodeIndex].nodeType == 3 || String(containerElement.childNodes[nodeIndex]) == '[object HTMLGenericElement]') {
                      break;
                    }
                  }
                }
                containerElement.insertBefore(workingNode, containerElement.childNodes[nodeIndex]);
              }
              // END KSK Patch
              workingRange.moveToElementText(workingNode);
              comparison = workingRange.compareEndPoints(workingComparisonType, textRange);
              if (comparison == 0 || start == end) {
                break;
              } else if (comparison == -1) {
                if (end == start + 1) {
                  // We know the endth child node is after the range boundary, so we must be done.
                  break;
                } else {
                  start = nodeIndex;
                }
              } else {
                end = end == start + 1 ? start : nodeIndex;
              }
              nodeIndex = Math.floor((start + end) / 2);
              containerElement.removeChild(workingNode);
            }
            // We've now reached or gone past the boundary of the text range we're interested in
            // so have identified the node we want
            boundaryNode = workingNode.nextSibling;
            if (comparison == -1 && boundaryNode && isCharacterDataNode(boundaryNode)) {
              // This is a character data node (text, comment, cdata). The working range is collapsed at the start of
              // the node containing the text range's boundary, so we move the end of the working range to the
              // boundary point and measure the length of its text to get the boundary's offset within the node.
              workingRange.setEndPoint(isStart ? 'EndToStart' : 'EndToEnd', textRange);
              var offset;
              if (/[\r\n]/.test(boundaryNode.data)) {
                /*
                                             For the particular case of a boundary within a text node containing rendered line breaks (within a
                                             <pre> element, for example), we need a slightly complicated approach to get the boundary's offset in
                                             IE. The facts:
                
                                             - Each line break is represented as \r in the text node's data/nodeValue properties
                                             - Each line break is represented as \r\n in the TextRange's 'text' property
                                             - The 'text' property of the TextRange does not contain trailing line breaks
                
                                             To get round the problem presented by the final fact above, we can use the fact that TextRange's
                                             moveStart() and moveEnd() methods return the actual number of characters moved, which is not
                                             necessarily the same as the number of characters it was instructed to move. The simplest approach is
                                             to use this to store the characters moved when moving both the start and end of the range to the
                                             start of the document body and subtracting the start offset from the end offset (the
                                             "move-negative-gazillion" method). However, this is extremely slow when the document is large and
                                             the range is near the end of it. Clearly doing the mirror image (i.e. moving the range boundaries to
                                             the end of the document) has the same problem.
                
                                             Another approach that works is to use moveStart() to move the start boundary of the range up to the
                                             end boundary one character at a time and incrementing a counter with the value returned by the
                                             moveStart() call. However, the check for whether the start boundary has reached the end boundary is
                                             expensive, so this method is slow (although unlike "move-negative-gazillion" is largely unaffected
                                             by the location of the range within the document).
                
                                             The approach used below is a hybrid of the two methods above. It uses the fact that a string
                                             containing the TextRange's 'text' property with each \r\n converted to a single \r character cannot
                                             be longer than the text of the TextRange, so the start of the range is moved that length initially
                                             and then a character at a time to make up for any trailing line breaks not contained in the 'text'
                                             property. This has good performance in most situations compared to the previous two methods.
                                             */
                var tempRange = workingRange.duplicate();
                var rangeLength = tempRange.text.replace(/\r\n/g, '\r').length;
                offset = tempRange.moveStart('character', rangeLength);
                while ((comparison = tempRange.compareEndPoints('StartToEnd', tempRange)) == -1) {
                  offset++;
                  tempRange.moveStart('character', 1);
                }
              } else {
                offset = workingRange.text.length;
              }
              boundaryPosition = new DomPosition(boundaryNode, offset);
            } else {
              // If the boundary immediately follows a character data node and this is the end boundary, we should favour
              // a position within that, and likewise for a start boundary preceding a character data node
              previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;
              nextNode = (isCollapsed || isStart) && workingNode.nextSibling;
              if (nextNode && isCharacterDataNode(nextNode)) {
                boundaryPosition = new DomPosition(nextNode, 0);
              } else if (previousNode && isCharacterDataNode(previousNode)) {
                boundaryPosition = new DomPosition(previousNode, previousNode.data.length);
              } else {
                boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));
              }
            }
            // Clean up
            dom.removeNode(workingNode);
            return {
              boundaryPosition: boundaryPosition,
              nodeInfo: {
                nodeIndex: nodeIndex,
                containerElement: containerElement
              }
            };
          };
          // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that
          // node. This function started out as an optimized version of code found in Tim Cameron Ryan's IERange
          // (http://code.google.com/p/ierange/)
          var createBoundaryTextRange = function (boundaryPosition, isStart) {
            var boundaryNode, boundaryParent, boundaryOffset = boundaryPosition.offset;
            var doc = dom.getDocument(boundaryPosition.node);
            var workingNode, childNodes, workingRange = getBody(doc).createTextRange();
            var nodeIsDataNode = isCharacterDataNode(boundaryPosition.node);
            if (nodeIsDataNode) {
              boundaryNode = boundaryPosition.node;
              boundaryParent = boundaryNode.parentNode;
            } else {
              childNodes = boundaryPosition.node.childNodes;
              boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;
              boundaryParent = boundaryPosition.node;
            }
            // Position the range immediately before the node containing the boundary
            workingNode = doc.createElement('span');
            // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within
            // the element rather than immediately before or after it
            workingNode.innerHTML = '&#feff;';
            // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report
            // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12
            if (boundaryNode) {
              boundaryParent.insertBefore(workingNode, boundaryNode);
            } else {
              boundaryParent.appendChild(workingNode);
            }
            workingRange.moveToElementText(workingNode);
            workingRange.collapse(!isStart);
            // Clean up
            boundaryParent.removeChild(workingNode);
            // Move the working range to the text offset, if required
            if (nodeIsDataNode) {
              workingRange[isStart ? 'moveStart' : 'moveEnd']('character', boundaryOffset);
            }
            return workingRange;
          };
          /*------------------------------------------------------------------------------------------------------------*/
          // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a
          // prototype
          WrappedTextRange = function (textRange) {
            this.textRange = textRange;
            this.refresh();
          };
          WrappedTextRange.prototype = new DomRange(document);
          WrappedTextRange.prototype.refresh = function () {
            var start, end, startBoundary;
            // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.
            var rangeContainerElement = getTextRangeContainerElement(this.textRange);
            if (textRangeIsCollapsed(this.textRange)) {
              end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true).boundaryPosition;
            } else {
              startBoundary = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);
              start = startBoundary.boundaryPosition;
              // An optimization used here is that if the start and end boundaries have the same parent element, the
              // search scope for the end boundary can be limited to exclude the portion of the element that precedes
              // the start boundary
              end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false, startBoundary.nodeInfo).boundaryPosition;
            }
            this.setStart(start.node, start.offset);
            this.setEnd(end.node, end.offset);
          };
          WrappedTextRange.prototype.getName = function () {
            return 'WrappedTextRange';
          };
          DomRange.copyComparisonConstants(WrappedTextRange);
          var rangeToTextRange = function (range) {
            if (range.collapsed) {
              return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
            } else {
              var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);
              var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);
              var textRange = getBody(DomRange.getRangeDocument(range)).createTextRange();
              textRange.setEndPoint('StartToStart', startRange);
              textRange.setEndPoint('EndToEnd', endRange);
              return textRange;
            }
          };
          WrappedTextRange.rangeToTextRange = rangeToTextRange;
          WrappedTextRange.prototype.toTextRange = function () {
            return rangeToTextRange(this);
          };
          api.WrappedTextRange = WrappedTextRange;
          // IE 9 and above have both implementations and Rangy makes both available. The next few lines sets which
          // implementation to use by default.
          if (!api.features.implementsDomRange || api.config.preferTextRange) {
            // Add WrappedTextRange as the Range property of the global object to allow expression like Range.END_TO_END to work
            var globalObj = window;
            // PATCHED
            if (typeof globalObj.Range == 'undefined') {
              globalObj.Range = WrappedTextRange;
            }
            api.createNativeRange = function (doc) {
              doc = getContentDocument(doc, module, 'createNativeRange');
              return getBody(doc).createTextRange();
            };
            api.WrappedRange = WrappedTextRange;
          }
        }
        api.createRange = function (doc) {
          doc = getContentDocument(doc, module, 'createRange');
          return new api.WrappedRange(api.createNativeRange(doc));
        };
        api.createRangyRange = function (doc) {
          doc = getContentDocument(doc, module, 'createRangyRange');
          return new DomRange(doc);
        };
        util.createAliasForDeprecatedMethod(api, 'createIframeRange', 'createRange');
        util.createAliasForDeprecatedMethod(api, 'createIframeRangyRange', 'createRangyRange');
        api.addShimListener(function (win) {
          var doc = win.document;
          if (typeof doc.createRange == 'undefined') {
            doc.createRange = function () {
              return api.createRange(doc);
            };
          }
          doc = win = null;
        });
      });
      /*----------------------------------------------------------------------------------------------------------------*/
      // This module creates a selection object wrapper that conforms as closely as possible to the Selection specification
      // in the HTML Editing spec (http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections)
      api.createCoreModule('WrappedSelection', [
        'DomRange',
        'WrappedRange'
      ], function (api, module) {
        api.config.checkSelectionRanges = true;
        var BOOLEAN = 'boolean';
        var NUMBER = 'number';
        var dom = api.dom;
        var util = api.util;
        var isHostMethod = util.isHostMethod;
        var DomRange = api.DomRange;
        var WrappedRange = api.WrappedRange;
        var DOMException = api.DOMException;
        var DomPosition = dom.DomPosition;
        var getNativeSelection;
        var selectionIsCollapsed;
        var features = api.features;
        var CONTROL = 'Control';
        var getDocument = dom.getDocument;
        var getBody = dom.getBody;
        var rangesEqual = DomRange.rangesEqual;
        // Utility function to support direction parameters in the API that may be a string ("backward", "backwards",
        // "forward" or "forwards") or a Boolean (true for backwards).
        function isDirectionBackward(dir) {
          return typeof dir == 'string' ? /^backward(s)?$/i.test(dir) : !!dir;
        }
        function getWindow(win, methodName) {
          if (!win) {
            return window;
          } else if (dom.isWindow(win)) {
            return win;
          } else if (win instanceof WrappedSelection) {
            return win.win;
          } else {
            var doc = dom.getContentDocument(win, module, methodName);
            return dom.getWindow(doc);
          }
        }
        function getWinSelection(winParam) {
          return getWindow(winParam, 'getWinSelection').getSelection();
        }
        function getDocSelection(winParam) {
          return getWindow(winParam, 'getDocSelection').document.selection;
        }
        function winSelectionIsBackward(sel) {
          var backward = false;
          if (sel.anchorNode) {
            backward = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;
          }
          return backward;
        }
        // Test for the Range/TextRange and Selection features required
        // Test for ability to retrieve selection
        var implementsWinGetSelection = isHostMethod(window, 'getSelection'), implementsDocSelection = util.isHostObject(document, 'selection');
        features.implementsWinGetSelection = implementsWinGetSelection;
        features.implementsDocSelection = implementsDocSelection;
        var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);
        if (useDocumentSelection) {
          getNativeSelection = getDocSelection;
          api.isSelectionValid = function (winParam) {
            var doc = getWindow(winParam, 'isSelectionValid').document, nativeSel = doc.selection;
            // Check whether the selection TextRange is actually contained within the correct document
            return nativeSel.type != 'None' || getDocument(nativeSel.createRange().parentElement()) == doc;
          };
        } else if (implementsWinGetSelection) {
          getNativeSelection = getWinSelection;
          api.isSelectionValid = function () {
            return true;
          };
        } else {
          module.fail('Neither document.selection or window.getSelection() detected.');
          return false;
        }
        api.getNativeSelection = getNativeSelection;
        var testSelection = getNativeSelection();
        // In Firefox, the selection is null in an iframe with display: none. See issue #138.
        if (!testSelection) {
          module.fail('Native selection was null (possibly issue 138?)');
          return false;
        }
        var testRange = api.createNativeRange(document);
        var body = getBody(document);
        // Obtaining a range from a selection
        var selectionHasAnchorAndFocus = util.areHostProperties(testSelection, [
          'anchorNode',
          'focusNode',
          'anchorOffset',
          'focusOffset'
        ]);
        features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;
        // Test for existence of native selection extend() method
        var selectionHasExtend = isHostMethod(testSelection, 'extend');
        features.selectionHasExtend = selectionHasExtend;
        // Test if rangeCount exists
        var selectionHasRangeCount = typeof testSelection.rangeCount == NUMBER;
        features.selectionHasRangeCount = selectionHasRangeCount;
        var selectionSupportsMultipleRanges = false;
        var collapsedNonEditableSelectionsSupported = true;
        var addRangeBackwardToNative = selectionHasExtend ? function (nativeSelection, range) {
          var doc = DomRange.getRangeDocument(range);
          var endRange = api.createRange(doc);
          endRange.collapseToPoint(range.endContainer, range.endOffset);
          nativeSelection.addRange(getNativeRange(endRange));
          nativeSelection.extend(range.startContainer, range.startOffset);
        } : null;
        if (util.areHostMethods(testSelection, [
            'addRange',
            'getRangeAt',
            'removeAllRanges'
          ]) && typeof testSelection.rangeCount == NUMBER && features.implementsDomRange) {
          (function () {
            // Previously an iframe was used but this caused problems in some circumstances in IE, so tests are
            // performed on the current document's selection. See issue 109.
            // Note also that if a selection previously existed, it is wiped and later restored by these tests. This
            // will result in the selection direction begin reversed if the original selection was backwards and the
            // browser does not support setting backwards selections (Internet Explorer, I'm looking at you).
            var sel = window.getSelection();
            if (sel) {
              // Store the current selection
              var originalSelectionRangeCount = sel.rangeCount;
              var selectionHasMultipleRanges = originalSelectionRangeCount > 1;
              var originalSelectionRanges = [];
              var originalSelectionBackward = winSelectionIsBackward(sel);
              for (var i = 0; i < originalSelectionRangeCount; ++i) {
                originalSelectionRanges[i] = sel.getRangeAt(i);
              }
              // Create some test elements
              var testEl = dom.createTestElement(document, '', false);
              var textNode = testEl.appendChild(document.createTextNode('\xA0\xA0\xA0'));
              // Test whether the native selection will allow a collapsed selection within a non-editable element
              var r1 = document.createRange();
              r1.setStart(textNode, 1);
              r1.collapse(true);
              sel.removeAllRanges();
              sel.addRange(r1);
              collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;
              sel.removeAllRanges();
              // Test whether the native selection is capable of supporting multiple ranges.
              if (!selectionHasMultipleRanges) {
                // Doing the original feature test here in Chrome 36 (and presumably later versions) prints a
                // console error of "Discontiguous selection is not supported." that cannot be suppressed. There's
                // nothing we can do about this while retaining the feature test so we have to resort to a browser
                // sniff. I'm not happy about it. See
                // https://code.google.com/p/chromium/issues/detail?id=399791
                var chromeMatch = window.navigator.appVersion.match(/Chrome\/(.*?) /);
                if (chromeMatch && parseInt(chromeMatch[1]) >= 36) {
                  selectionSupportsMultipleRanges = false;
                } else {
                  var r2 = r1.cloneRange();
                  if (r2 && r2.setEnd && r2.setStart) {
                    // PATCHED, see https://github.com/timdown/rangy/issues/335
                    r1.setStart(textNode, 0);
                    r2.setEnd(textNode, 3);
                    r2.setStart(textNode, 2);
                    sel.addRange(r1);
                    sel.addRange(r2);
                    selectionSupportsMultipleRanges = sel.rangeCount == 2;
                  } else {
                    consoleLog('Rangy: Failed to execute mutliple range feature test');
                    selectionSupportsMultipleRanges = false;
                  }
                }
              }
              // Clean up
              dom.removeNode(testEl);
              sel.removeAllRanges();
              for (i = 0; i < originalSelectionRangeCount; ++i) {
                if (i == 0 && originalSelectionBackward) {
                  if (addRangeBackwardToNative) {
                    addRangeBackwardToNative(sel, originalSelectionRanges[i]);
                  } else {
                    api.warn('Rangy initialization: original selection was backwards but selection has been restored forwards because the browser does not support Selection.extend');
                    sel.addRange(originalSelectionRanges[i]);
                  }
                } else {
                  try {
                    // PATCHED added try catch to fix issues in IE
                    sel.addRange(originalSelectionRanges[i]);
                  } catch (ex) {
                    consoleLog('Rangy: Error during feature test: ' + ex);
                  }
                }
              }
            }
          }());
        }
        features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;
        features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;
        // ControlRanges
        var implementsControlRange = false, testControlRange;
        if (body && isHostMethod(body, 'createControlRange')) {
          testControlRange = body.createControlRange();
          if (util.areHostProperties(testControlRange, [
              'item',
              'add'
            ])) {
            implementsControlRange = true;
          }
        }
        features.implementsControlRange = implementsControlRange;
        // Selection collapsedness
        if (selectionHasAnchorAndFocus) {
          selectionIsCollapsed = function (sel) {
            return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;
          };
        } else {
          selectionIsCollapsed = function (sel) {
            return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;
          };
        }
        function updateAnchorAndFocusFromRange(sel, range, backward) {
          var anchorPrefix = backward ? 'end' : 'start', focusPrefix = backward ? 'start' : 'end';
          sel.anchorNode = range[anchorPrefix + 'Container'];
          sel.anchorOffset = range[anchorPrefix + 'Offset'];
          sel.focusNode = range[focusPrefix + 'Container'];
          sel.focusOffset = range[focusPrefix + 'Offset'];
        }
        function updateAnchorAndFocusFromNativeSelection(sel) {
          var nativeSel = sel.nativeSelection;
          sel.anchorNode = nativeSel.anchorNode;
          sel.anchorOffset = nativeSel.anchorOffset;
          sel.focusNode = nativeSel.focusNode;
          sel.focusOffset = nativeSel.focusOffset;
        }
        function updateEmptySelection(sel) {
          sel.anchorNode = sel.focusNode = null;
          sel.anchorOffset = sel.focusOffset = 0;
          sel.rangeCount = 0;
          sel.isCollapsed = true;
          sel._ranges.length = 0;
        }
        function getNativeRange(range) {
          var nativeRange;
          if (range instanceof DomRange) {
            nativeRange = api.createNativeRange(range.getDocument());
            nativeRange.setEnd(range.endContainer, range.endOffset);
            nativeRange.setStart(range.startContainer, range.startOffset);
          } else if (range instanceof WrappedRange) {
            nativeRange = range.nativeRange;
          } else if (features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {
            nativeRange = range;
          }
          return nativeRange;
        }
        function rangeContainsSingleElement(rangeNodes) {
          if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {
            return false;
          }
          for (var i = 1, len = rangeNodes.length; i < len; ++i) {
            if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {
              return false;
            }
          }
          return true;
        }
        function getSingleElementFromRange(range) {
          var nodes = range.getNodes();
          if (!rangeContainsSingleElement(nodes)) {
            throw module.createError('getSingleElementFromRange: range ' + range.inspect() + ' did not consist of a single element');
          }
          return nodes[0];
        }
        // Simple, quick test which only needs to distinguish between a TextRange and a ControlRange
        function isTextRange(range) {
          return !!range && typeof range.text != 'undefined';
        }
        function updateFromTextRange(sel, range) {
          // Create a Range from the selected TextRange
          var wrappedRange = new WrappedRange(range);
          sel._ranges = [wrappedRange];
          updateAnchorAndFocusFromRange(sel, wrappedRange, false);
          sel.rangeCount = 1;
          sel.isCollapsed = wrappedRange.collapsed;
        }
        function updateControlSelection(sel) {
          // Update the wrapped selection based on what's now in the native selection
          sel._ranges.length = 0;
          if (sel.docSelection.type == 'None') {
            updateEmptySelection(sel);
          } else {
            var controlRange = sel.docSelection.createRange();
            if (isTextRange(controlRange)) {
              // This case (where the selection type is "Control" and calling createRange() on the selection returns
              // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected
              // ControlRange have been removed from the ControlRange and removed from the document.
              updateFromTextRange(sel, controlRange);
            } else {
              sel.rangeCount = controlRange.length;
              var range, doc = getDocument(controlRange.item(0));
              for (var i = 0; i < sel.rangeCount; ++i) {
                range = api.createRange(doc);
                range.selectNode(controlRange.item(i));
                sel._ranges.push(range);
              }
              sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;
              updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);
            }
          }
        }
        function addRangeToControlSelection(sel, range) {
          var controlRange = sel.docSelection.createRange();
          var rangeElement = getSingleElementFromRange(range);
          // Create a new ControlRange containing all the elements in the selected ControlRange plus the element
          // contained by the supplied range
          var doc = getDocument(controlRange.item(0));
          var newControlRange = getBody(doc).createControlRange();
          for (var i = 0, len = controlRange.length; i < len; ++i) {
            newControlRange.add(controlRange.item(i));
          }
          try {
            newControlRange.add(rangeElement);
          } catch (ex) {
            throw module.createError('addRange(): Element within the specified Range could not be added to control selection (does it have layout?)');
          }
          newControlRange.select();
          // Update the wrapped selection based on what's now in the native selection
          updateControlSelection(sel);
        }
        var getSelectionRangeAt;
        if (isHostMethod(testSelection, 'getRangeAt')) {
          // try/catch is present because getRangeAt() must have thrown an error in some browser and some situation.
          // Unfortunately, I didn't write a comment about the specifics and am now scared to take it out. Let that be a
          // lesson to us all, especially me.
          getSelectionRangeAt = function (sel, index) {
            try {
              return sel.getRangeAt(index);
            } catch (ex) {
              return null;
            }
          };
        } else if (selectionHasAnchorAndFocus) {
          getSelectionRangeAt = function (sel) {
            var doc = getDocument(sel.anchorNode);
            var range = api.createRange(doc);
            range.setStartAndEnd(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset);
            // Handle the case when the selection was selected backwards (from the end to the start in the
            // document)
            if (range.collapsed !== this.isCollapsed) {
              range.setStartAndEnd(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset);
            }
            return range;
          };
        }
        function WrappedSelection(selection, docSelection, win) {
          this.nativeSelection = selection;
          this.docSelection = docSelection;
          this._ranges = [];
          this.win = win;
          this.refresh();
        }
        WrappedSelection.prototype = api.selectionPrototype;
        function deleteProperties(sel) {
          sel.win = sel.anchorNode = sel.focusNode = sel._ranges = null;
          sel.rangeCount = sel.anchorOffset = sel.focusOffset = 0;
          sel.detached = true;
        }
        var cachedRangySelections = [];
        function actOnCachedSelection(win, action) {
          var i = cachedRangySelections.length, cached, sel;
          while (i--) {
            cached = cachedRangySelections[i];
            sel = cached.selection;
            if (action == 'deleteAll') {
              deleteProperties(sel);
            } else if (cached.win == win) {
              if (action == 'delete') {
                cachedRangySelections.splice(i, 1);
                return true;
              } else {
                return sel;
              }
            }
          }
          if (action == 'deleteAll') {
            cachedRangySelections.length = 0;
          }
          return null;
        }
        var getSelection = function (win) {
          // Check if the parameter is a Rangy Selection object
          if (win && win instanceof WrappedSelection) {
            win.refresh();
            return win;
          }
          win = getWindow(win, 'getNativeSelection');
          var sel = actOnCachedSelection(win);
          var nativeSel = getNativeSelection(win), docSel = implementsDocSelection ? getDocSelection(win) : null;
          if (sel) {
            sel.nativeSelection = nativeSel;
            sel.docSelection = docSel;
            sel.refresh();
          } else {
            sel = new WrappedSelection(nativeSel, docSel, win);
            cachedRangySelections.push({
              win: win,
              selection: sel
            });
          }
          return sel;
        };
        api.getSelection = getSelection;
        util.createAliasForDeprecatedMethod(api, 'getIframeSelection', 'getSelection');
        var selProto = WrappedSelection.prototype;
        function createControlSelection(sel, ranges) {
          // Ensure that the selection becomes of type "Control"
          var doc = getDocument(ranges[0].startContainer);
          var controlRange = getBody(doc).createControlRange();
          for (var i = 0, el, len = ranges.length; i < len; ++i) {
            el = getSingleElementFromRange(ranges[i]);
            try {
              controlRange.add(el);
            } catch (ex) {
              throw module.createError('setRanges(): Element within one of the specified Ranges could not be added to control selection (does it have layout?)');
            }
          }
          controlRange.select();
          // Update the wrapped selection based on what's now in the native selection
          updateControlSelection(sel);
        }
        // Selecting a range
        if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [
            'removeAllRanges',
            'addRange'
          ])) {
          selProto.removeAllRanges = function () {
            this.nativeSelection.removeAllRanges();
            updateEmptySelection(this);
          };
          var addRangeBackward = function (sel, range) {
            addRangeBackwardToNative(sel.nativeSelection, range);
            sel.refresh();
          };
          if (selectionHasRangeCount) {
            selProto.addRange = function (range, direction) {
              if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
                addRangeToControlSelection(this, range);
              } else {
                if (isDirectionBackward(direction) && selectionHasExtend) {
                  addRangeBackward(this, range);
                } else {
                  var previousRangeCount;
                  if (selectionSupportsMultipleRanges) {
                    previousRangeCount = this.rangeCount;
                  } else {
                    this.removeAllRanges();
                    previousRangeCount = 0;
                  }
                  // Clone the native range so that changing the selected range does not affect the selection.
                  // This is contrary to the spec but is the only way to achieve consistency between browsers. See
                  // issue 80.
                  var clonedNativeRange = getNativeRange(range).cloneRange();
                  try {
                    this.nativeSelection.addRange(clonedNativeRange);
                  } catch (ex) {
                  }
                  // Check whether adding the range was successful
                  this.rangeCount = this.nativeSelection.rangeCount;
                  if (this.rangeCount == previousRangeCount + 1) {
                    // The range was added successfully
                    // Check whether the range that we added to the selection is reflected in the last range extracted from
                    // the selection
                    if (api.config.checkSelectionRanges) {
                      var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);
                      if (nativeRange && !rangesEqual(nativeRange, range)) {
                        // Happens in WebKit with, for example, a selection placed at the start of a text node
                        range = new WrappedRange(nativeRange);
                      }
                    }
                    this._ranges[this.rangeCount - 1] = range;
                    updateAnchorAndFocusFromRange(this, range, selectionIsBackward(this.nativeSelection));
                    this.isCollapsed = selectionIsCollapsed(this);
                  } else {
                    // The range was not added successfully. The simplest thing is to refresh
                    this.refresh();
                  }
                }
              }
            };
          } else {
            selProto.addRange = function (range, direction) {
              if (isDirectionBackward(direction) && selectionHasExtend) {
                addRangeBackward(this, range);
              } else {
                this.nativeSelection.addRange(getNativeRange(range));
                this.refresh();
              }
            };
          }
          selProto.setRanges = function (ranges) {
            if (implementsControlRange && implementsDocSelection && ranges.length > 1) {
              createControlSelection(this, ranges);
            } else {
              this.removeAllRanges();
              for (var i = 0, len = ranges.length; i < len; ++i) {
                this.addRange(ranges[i]);
              }
            }
          };
        } else if (isHostMethod(testSelection, 'empty') && isHostMethod(testRange, 'select') && implementsControlRange && useDocumentSelection) {
          selProto.removeAllRanges = function () {
            // Added try/catch as fix for issue #21
            try {
              this.docSelection.empty();
              // Check for empty() not working (issue #24)
              if (this.docSelection.type != 'None') {
                // Work around failure to empty a control selection by instead selecting a TextRange and then
                // calling empty()
                var doc;
                if (this.anchorNode) {
                  doc = getDocument(this.anchorNode);
                } else if (this.docSelection.type == CONTROL) {
                  var controlRange = this.docSelection.createRange();
                  if (controlRange.length) {
                    doc = getDocument(controlRange.item(0));
                  }
                }
                if (doc) {
                  var textRange = getBody(doc).createTextRange();
                  textRange.select();
                  this.docSelection.empty();
                }
              }
            } catch (ex) {
            }
            updateEmptySelection(this);
          };
          selProto.addRange = function (range) {
            if (this.docSelection.type == CONTROL) {
              addRangeToControlSelection(this, range);
            } else {
              api.WrappedTextRange.rangeToTextRange(range).select();
              this._ranges[0] = range;
              this.rangeCount = 1;
              this.isCollapsed = this._ranges[0].collapsed;
              updateAnchorAndFocusFromRange(this, range, false);
            }
          };
          selProto.setRanges = function (ranges) {
            this.removeAllRanges();
            var rangeCount = ranges.length;
            if (rangeCount > 1) {
              createControlSelection(this, ranges);
            } else if (rangeCount) {
              this.addRange(ranges[0]);
            }
          };
        } else {
          module.fail('No means of selecting a Range or TextRange was found');
          return false;
        }
        selProto.getRangeAt = function (index) {
          if (index < 0 || index >= this.rangeCount) {
            throw new DOMException('INDEX_SIZE_ERR');
          } else {
            // Clone the range to preserve selection-range independence. See issue 80.
            return this._ranges[index].cloneRange();
          }
        };
        var refreshSelection;
        if (useDocumentSelection) {
          refreshSelection = function (sel) {
            var range;
            if (api.isSelectionValid(sel.win)) {
              range = sel.docSelection.createRange();
            } else {
              range = getBody(sel.win.document).createTextRange();
              range.collapse(true);
            }
            if (sel.docSelection.type == CONTROL) {
              updateControlSelection(sel);
            } else if (isTextRange(range)) {
              updateFromTextRange(sel, range);
            } else {
              updateEmptySelection(sel);
            }
          };
        } else if (isHostMethod(testSelection, 'getRangeAt') && typeof testSelection.rangeCount == NUMBER) {
          refreshSelection = function (sel) {
            if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {
              updateControlSelection(sel);
            } else {
              sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;
              if (sel.rangeCount) {
                for (var i = 0, len = sel.rangeCount; i < len; ++i) {
                  sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));
                }
                updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackward(sel.nativeSelection));
                sel.isCollapsed = selectionIsCollapsed(sel);
              } else {
                updateEmptySelection(sel);
              }
            }
          };
        } else if (selectionHasAnchorAndFocus && typeof testSelection.isCollapsed == BOOLEAN && typeof testRange.collapsed == BOOLEAN && features.implementsDomRange) {
          refreshSelection = function (sel) {
            var range, nativeSel = sel.nativeSelection;
            if (nativeSel.anchorNode) {
              range = getSelectionRangeAt(nativeSel, 0);
              sel._ranges = [range];
              sel.rangeCount = 1;
              updateAnchorAndFocusFromNativeSelection(sel);
              sel.isCollapsed = selectionIsCollapsed(sel);
            } else {
              updateEmptySelection(sel);
            }
          };
        } else {
          module.fail('No means of obtaining a Range or TextRange from the user\'s selection was found');
          return false;
        }
        selProto.refresh = function (checkForChanges) {
          var oldRanges = checkForChanges ? this._ranges.slice(0) : null;
          var oldAnchorNode = this.anchorNode, oldAnchorOffset = this.anchorOffset;
          refreshSelection(this);
          if (checkForChanges) {
            // Check the range count first
            var i = oldRanges.length;
            if (i != this._ranges.length) {
              return true;
            }
            // Now check the direction. Checking the anchor position is the same is enough since we're checking all the
            // ranges after this
            if (this.anchorNode != oldAnchorNode || this.anchorOffset != oldAnchorOffset) {
              return true;
            }
            // Finally, compare each range in turn
            while (i--) {
              if (!rangesEqual(oldRanges[i], this._ranges[i])) {
                return true;
              }
            }
            return false;
          }
        };
        // Removal of a single range
        var removeRangeManually = function (sel, range) {
          var ranges = sel.getAllRanges();
          sel.removeAllRanges();
          for (var i = 0, len = ranges.length; i < len; ++i) {
            if (!rangesEqual(range, ranges[i])) {
              sel.addRange(ranges[i]);
            }
          }
          if (!sel.rangeCount) {
            updateEmptySelection(sel);
          }
        };
        if (implementsControlRange && implementsDocSelection) {
          selProto.removeRange = function (range) {
            if (this.docSelection.type == CONTROL) {
              var controlRange = this.docSelection.createRange();
              var rangeElement = getSingleElementFromRange(range);
              // Create a new ControlRange containing all the elements in the selected ControlRange minus the
              // element contained by the supplied range
              var doc = getDocument(controlRange.item(0));
              var newControlRange = getBody(doc).createControlRange();
              var el, removed = false;
              for (var i = 0, len = controlRange.length; i < len; ++i) {
                el = controlRange.item(i);
                if (el !== rangeElement || removed) {
                  newControlRange.add(controlRange.item(i));
                } else {
                  removed = true;
                }
              }
              newControlRange.select();
              // Update the wrapped selection based on what's now in the native selection
              updateControlSelection(this);
            } else {
              removeRangeManually(this, range);
            }
          };
        } else {
          selProto.removeRange = function (range) {
            removeRangeManually(this, range);
          };
        }
        // Detecting if a selection is backward
        var selectionIsBackward;
        if (!useDocumentSelection && selectionHasAnchorAndFocus && features.implementsDomRange) {
          selectionIsBackward = winSelectionIsBackward;
          selProto.isBackward = function () {
            return selectionIsBackward(this);
          };
        } else {
          selectionIsBackward = selProto.isBackward = function () {
            return false;
          };
        }
        // Create an alias for backwards compatibility. From 1.3, everything is "backward" rather than "backwards"
        selProto.isBackwards = selProto.isBackward;
        // Selection stringifier
        // This is conformant to the old HTML5 selections draft spec but differs from WebKit and Mozilla's implementation.
        // The current spec does not yet define this method.
        selProto.toString = function () {
          var rangeTexts = [];
          for (var i = 0, len = this.rangeCount; i < len; ++i) {
            rangeTexts[i] = '' + this._ranges[i];
          }
          return rangeTexts.join('');
        };
        function assertNodeInSameDocument(sel, node) {
          if (sel.win.document != getDocument(node)) {
            throw new DOMException('WRONG_DOCUMENT_ERR');
          }
        }
        // No current browser conforms fully to the spec for this method, so Rangy's own method is always used
        selProto.collapse = function (node, offset) {
          assertNodeInSameDocument(this, node);
          var range = api.createRange(node);
          range.collapseToPoint(node, offset);
          this.setSingleRange(range);
          this.isCollapsed = true;
        };
        selProto.collapseToStart = function () {
          if (this.rangeCount) {
            var range = this._ranges[0];
            this.collapse(range.startContainer, range.startOffset);
          } else {
            throw new DOMException('INVALID_STATE_ERR');
          }
        };
        selProto.collapseToEnd = function () {
          if (this.rangeCount) {
            var range = this._ranges[this.rangeCount - 1];
            this.collapse(range.endContainer, range.endOffset);
          } else {
            throw new DOMException('INVALID_STATE_ERR');
          }
        };
        // The spec is very specific on how selectAllChildren should be implemented and not all browsers implement it as
        // specified so the native implementation is never used by Rangy.
        selProto.selectAllChildren = function (node) {
          assertNodeInSameDocument(this, node);
          var range = api.createRange(node);
          range.selectNodeContents(node);
          this.setSingleRange(range);
        };
        selProto.deleteFromDocument = function () {
          // Sepcial behaviour required for IE's control selections
          if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {
            var controlRange = this.docSelection.createRange();
            var element;
            while (controlRange.length) {
              element = controlRange.item(0);
              controlRange.remove(element);
              dom.removeNode(element);
            }
            this.refresh();
          } else if (this.rangeCount) {
            var ranges = this.getAllRanges();
            if (ranges.length) {
              this.removeAllRanges();
              for (var i = 0, len = ranges.length; i < len; ++i) {
                ranges[i].deleteContents();
              }
              // The spec says nothing about what the selection should contain after calling deleteContents on each
              // range. Firefox moves the selection to where the final selected range was, so we emulate that
              this.addRange(ranges[len - 1]);
            }
          }
        };
        // The following are non-standard extensions
        selProto.eachRange = function (func, returnValue) {
          for (var i = 0, len = this._ranges.length; i < len; ++i) {
            if (func(this.getRangeAt(i))) {
              return returnValue;
            }
          }
        };
        selProto.getAllRanges = function () {
          var ranges = [];
          this.eachRange(function (range) {
            ranges.push(range);
          });
          return ranges;
        };
        selProto.setSingleRange = function (range, direction) {
          this.removeAllRanges();
          this.addRange(range, direction);
        };
        selProto.callMethodOnEachRange = function (methodName, params) {
          var results = [];
          this.eachRange(function (range) {
            results.push(range[methodName].apply(range, params || []));
          });
          return results;
        };
        function createStartOrEndSetter(isStart) {
          return function (node, offset) {
            var range;
            if (this.rangeCount) {
              range = this.getRangeAt(0);
              range['set' + (isStart ? 'Start' : 'End')](node, offset);
            } else {
              range = api.createRange(this.win.document);
              range.setStartAndEnd(node, offset);
            }
            this.setSingleRange(range, this.isBackward());
          };
        }
        selProto.setStart = createStartOrEndSetter(true);
        selProto.setEnd = createStartOrEndSetter(false);
        // Add select() method to Range prototype. Any existing selection will be removed.
        api.rangePrototype.select = function (direction) {
          getSelection(this.getDocument()).setSingleRange(this, direction);
        };
        selProto.changeEachRange = function (func) {
          var ranges = [];
          var backward = this.isBackward();
          this.eachRange(function (range) {
            func(range);
            ranges.push(range);
          });
          this.removeAllRanges();
          if (backward && ranges.length == 1) {
            this.addRange(ranges[0], 'backward');
          } else {
            this.setRanges(ranges);
          }
        };
        selProto.containsNode = function (node, allowPartial) {
          return this.eachRange(function (range) {
            return range.containsNode(node, allowPartial);
          }, true) || false;
        };
        selProto.getBookmark = function (containerNode) {
          return {
            backward: this.isBackward(),
            rangeBookmarks: this.callMethodOnEachRange('getBookmark', [containerNode])
          };
        };
        selProto.moveToBookmark = function (bookmark) {
          var selRanges = [];
          for (var i = 0, rangeBookmark, range; rangeBookmark = bookmark.rangeBookmarks[i++];) {
            range = api.createRange(this.win);
            range.moveToBookmark(rangeBookmark);
            selRanges.push(range);
          }
          if (bookmark.backward) {
            this.setSingleRange(selRanges[0], 'backward');
          } else {
            this.setRanges(selRanges);
          }
        };
        selProto.saveRanges = function () {
          return {
            backward: this.isBackward(),
            ranges: this.callMethodOnEachRange('cloneRange')
          };
        };
        selProto.restoreRanges = function (selRanges) {
          this.removeAllRanges();
          for (var i = 0, range; range = selRanges.ranges[i]; ++i) {
            this.addRange(range, selRanges.backward && i == 0);
          }
        };
        selProto.toHtml = function () {
          var rangeHtmls = [];
          this.eachRange(function (range) {
            rangeHtmls.push(DomRange.toHtml(range));
          });
          return rangeHtmls.join('');
        };
        if (features.implementsTextRange) {
          selProto.getNativeTextRange = function () {
            var sel, textRange;
            if (sel = this.docSelection) {
              var range = sel.createRange();
              if (isTextRange(range)) {
                return range;
              } else {
                throw module.createError('getNativeTextRange: selection is a control selection');
              }
            } else if (this.rangeCount > 0) {
              return api.WrappedTextRange.rangeToTextRange(this.getRangeAt(0));
            } else {
              throw module.createError('getNativeTextRange: selection contains no range');
            }
          };
        }
        function inspect(sel) {
          var rangeInspects = [];
          var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);
          var focus = new DomPosition(sel.focusNode, sel.focusOffset);
          var name = typeof sel.getName == 'function' ? sel.getName() : 'Selection';
          if (typeof sel.rangeCount != 'undefined') {
            for (var i = 0, len = sel.rangeCount; i < len; ++i) {
              rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));
            }
          }
          return '[' + name + '(Ranges: ' + rangeInspects.join(', ') + ')(anchor: ' + anchor.inspect() + ', focus: ' + focus.inspect() + ']';
        }
        selProto.getName = function () {
          return 'WrappedSelection';
        };
        selProto.inspect = function () {
          return inspect(this);
        };
        selProto.detach = function () {
          actOnCachedSelection(this.win, 'delete');
          deleteProperties(this);
        };
        WrappedSelection.detachAll = function () {
          actOnCachedSelection(null, 'deleteAll');
        };
        WrappedSelection.inspect = inspect;
        WrappedSelection.isDirectionBackward = isDirectionBackward;
        api.Selection = WrappedSelection;
        api.selectionPrototype = selProto;
        api.addShimListener(function (win) {
          if (typeof win.getSelection == 'undefined') {
            win.getSelection = function () {
              return getSelection(win);
            };
          }
          win = null;
        });
      });
      // Wait for document to load before initializing
      var docReady = false;
      var loadHandler = function (e) {
        if (!docReady) {
          docReady = true;
          if (!api.initialized && api.config.autoInitialize) {
            init();
          }
        }
      };
      if (isBrowser) {
        // Test whether the document has already been loaded and initialize immediately if so
        if (/^(?:complete|interactive)$/.test(document.readyState)) {
          loadHandler();
        } else {
          if (isHostMethod(document, 'addEventListener')) {
            document.addEventListener('DOMContentLoaded', loadHandler, false);
          }
          // Add a fallback in case the DOMContentLoaded event isn't supported
          addListener(window, 'load', loadHandler);
        }
      }
      return api;
    }, window);
    // PATCHED
    // PATCHED AMD CODE
    return rangy;
  }();
  libs_rangy_serializer = function (rangy) {
    /**
     * Serializer module for Rangy.
     * Serializes Ranges and Selections. An example use would be to store a user's selection on a particular page in a
     * cookie or local storage and restore it on the user's next visit to the same page.
     *
     * Part of Rangy, a cross-browser JavaScript range and selection library
     * http://code.google.com/p/rangy/
     *
     * Depends on Rangy core.
     *
     * Copyright 2014, Tim Down
     * Licensed under the MIT license.
     * Version: 1.3.0-alpha.20140825
     * Build date: 25 August 2014
     */
    //    (function(factory, global) {
    //        if (typeof define == "function" && define.amd) {
    //            // AMD. Register as an anonymous module with a dependency on Rangy.
    //            define(["./rangy-core"], factory);
    //        } else if (typeof module != "undefined" && typeof exports == "object") {
    //            // Node/CommonJS style
    //            module.exports = factory( require("rangy") );
    //        } else {
    //            // No AMD or CommonJS support so we use the rangy global variable
    //            factory(global.rangy);
    //        }
    //    })
    //    (function(rangy) {
    rangy.createModule('Serializer', ['WrappedSelection'], function (api, module) {
      var UNDEF = 'undefined';
      // encodeURIComponent and decodeURIComponent are required for cookie handling
      if (typeof encodeURIComponent == UNDEF || typeof decodeURIComponent == UNDEF) {
        module.fail('Global object is missing encodeURIComponent and/or decodeURIComponent method');
      }
      // Checksum for checking whether range can be serialized
      var crc32 = function () {
        function utf8encode(str) {
          var utf8CharCodes = [];
          for (var i = 0, len = str.length, c; i < len; ++i) {
            c = str.charCodeAt(i);
            if (c < 128) {
              utf8CharCodes.push(c);
            } else if (c < 2048) {
              utf8CharCodes.push(c >> 6 | 192, c & 63 | 128);
            } else {
              utf8CharCodes.push(c >> 12 | 224, c >> 6 & 63 | 128, c & 63 | 128);
            }
          }
          return utf8CharCodes;
        }
        var cachedCrcTable = null;
        function buildCRCTable() {
          var table = [];
          for (var i = 0, j, crc; i < 256; ++i) {
            crc = i;
            j = 8;
            while (j--) {
              if ((crc & 1) == 1) {
                crc = crc >>> 1 ^ 3988292384;
              } else {
                crc >>>= 1;
              }
            }
            table[i] = crc >>> 0;
          }
          return table;
        }
        function getCrcTable() {
          if (!cachedCrcTable) {
            cachedCrcTable = buildCRCTable();
          }
          return cachedCrcTable;
        }
        return function (str) {
          var utf8CharCodes = utf8encode(str), crc = -1, crcTable = getCrcTable();
          for (var i = 0, len = utf8CharCodes.length, y; i < len; ++i) {
            y = (crc ^ utf8CharCodes[i]) & 255;
            crc = crc >>> 8 ^ crcTable[y];
          }
          return (crc ^ -1) >>> 0;
        };
      }();
      var dom = api.dom;
      function escapeTextForHtml(str) {
        return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function nodeToInfoString(node, infoParts) {
        infoParts = infoParts || [];
        var nodeType = node.nodeType, children = node.childNodes, childCount = children.length;
        var nodeInfo = [
          nodeType,
          node.nodeName,
          childCount
        ].join(':');
        var start = '', end = '';
        switch (nodeType) {
        case 3:
          // Text node
          start = escapeTextForHtml(node.nodeValue);
          break;
        case 8:
          // Comment
          start = '<!--' + escapeTextForHtml(node.nodeValue) + '-->';
          break;
        default:
          start = '<' + nodeInfo + '>';
          end = '</>';
          break;
        }
        if (start) {
          infoParts.push(start);
        }
        for (var i = 0; i < childCount; ++i) {
          nodeToInfoString(children[i], infoParts);
        }
        if (end) {
          infoParts.push(end);
        }
        return infoParts;
      }
      // Creates a string representation of the specified element's contents that is similar to innerHTML but omits all
      // attributes and comments and includes child node counts. This is done instead of using innerHTML to work around
      // IE <= 8's policy of including element properties in attributes, which ruins things by changing an element's
      // innerHTML whenever the user changes an input within the element.
      function getElementChecksum(el) {
        var info = nodeToInfoString(el).join('');
        return crc32(info).toString(16);
      }
      function serializePosition(node, offset, rootNode) {
        var pathParts = [], n = node;
        rootNode = rootNode || dom.getDocument(node).documentElement;
        while (n && n != rootNode) {
          pathParts.push(dom.getNodeIndex(n, true));
          n = n.parentNode;
        }
        return pathParts.join('/') + ':' + offset;
      }
      function deserializePosition(serialized, rootNode, doc) {
        if (!rootNode) {
          rootNode = (doc || document).documentElement;
        }
        var parts = serialized.split(':');
        var node = rootNode;
        var nodeIndices = parts[0] ? parts[0].split('/') : [], i = nodeIndices.length, nodeIndex;
        while (i--) {
          nodeIndex = parseInt(nodeIndices[i], 10);
          if (nodeIndex < node.childNodes.length) {
            node = node.childNodes[nodeIndex];
          } else {
            throw module.createError('deserializePosition() failed: node ' + dom.inspectNode(node) + ' has no child with index ' + nodeIndex + ', ' + i);
          }
        }
        return new dom.DomPosition(node, parseInt(parts[1], 10));
      }
      function serializeRange(range, omitChecksum, rootNode) {
        rootNode = rootNode || api.DomRange.getRangeDocument(range).documentElement;
        if (!dom.isOrIsAncestorOf(rootNode, range.commonAncestorContainer)) {
          throw module.createError('serializeRange(): range ' + range.inspect() + ' is not wholly contained within specified root node ' + dom.inspectNode(rootNode));
        }
        var serialized = serializePosition(range.startContainer, range.startOffset, rootNode) + ',' + serializePosition(range.endContainer, range.endOffset, rootNode);
        if (!omitChecksum) {
          serialized += '{' + getElementChecksum(rootNode) + '}';
        }
        return serialized;
      }
      var deserializeRegex = /^([^,]+),([^,\{]+)(\{([^}]+)\})?$/;
      function deserializeRange(serialized, rootNode, doc) {
        if (rootNode) {
          doc = doc || dom.getDocument(rootNode);
        } else {
          doc = doc || document;
          rootNode = doc.documentElement;
        }
        var result = deserializeRegex.exec(serialized);
        var checksum = result[4];
        if (checksum) {
          var rootNodeChecksum = getElementChecksum(rootNode);
          if (checksum !== rootNodeChecksum) {
            throw module.createError('deserializeRange(): checksums of serialized range root node (' + checksum + ') and target root node (' + rootNodeChecksum + ') do not match');
          }
        }
        var start = deserializePosition(result[1], rootNode, doc), end = deserializePosition(result[2], rootNode, doc);
        var range = api.createRange(doc);
        range.setStartAndEnd(start.node, start.offset, end.node, end.offset);
        return range;
      }
      function canDeserializeRange(serialized, rootNode, doc) {
        if (!rootNode) {
          rootNode = (doc || document).documentElement;
        }
        var result = deserializeRegex.exec(serialized);
        var checksum = result[3];
        return !checksum || checksum === getElementChecksum(rootNode);
      }
      function serializeSelection(selection, omitChecksum, rootNode) {
        selection = api.getSelection(selection);
        var ranges = selection.getAllRanges(), serializedRanges = [];
        for (var i = 0, len = ranges.length; i < len; ++i) {
          serializedRanges[i] = serializeRange(ranges[i], omitChecksum, rootNode);
        }
        return serializedRanges.join('|');
      }
      function deserializeSelection(serialized, rootNode, win) {
        if (rootNode) {
          win = win || dom.getWindow(rootNode);
        } else {
          win = win || window;
          rootNode = win.document.documentElement;
        }
        var serializedRanges = serialized.split('|');
        var sel = api.getSelection(win);
        var ranges = [];
        for (var i = 0, len = serializedRanges.length; i < len; ++i) {
          ranges[i] = deserializeRange(serializedRanges[i], rootNode, win.document);
        }
        sel.setRanges(ranges);
        return sel;
      }
      function canDeserializeSelection(serialized, rootNode, win) {
        var doc;
        if (rootNode) {
          doc = win ? win.document : dom.getDocument(rootNode);
        } else {
          win = win || window;
          rootNode = win.document.documentElement;
        }
        var serializedRanges = serialized.split('|');
        for (var i = 0, len = serializedRanges.length; i < len; ++i) {
          if (!canDeserializeRange(serializedRanges[i], rootNode, doc)) {
            return false;
          }
        }
        return true;
      }
      var cookieName = 'rangySerializedSelection';
      function getSerializedSelectionFromCookie(cookie) {
        var parts = cookie.split(/[;,]/);
        for (var i = 0, len = parts.length, nameVal, val; i < len; ++i) {
          nameVal = parts[i].split('=');
          if (nameVal[0].replace(/^\s+/, '') == cookieName) {
            val = nameVal[1];
            if (val) {
              return decodeURIComponent(val.replace(/\s+$/, ''));
            }
          }
        }
        return null;
      }
      function restoreSelectionFromCookie(win) {
        win = win || window;
        var serialized = getSerializedSelectionFromCookie(win.document.cookie);
        if (serialized) {
          deserializeSelection(serialized, win.doc);
        }
      }
      function saveSelectionCookie(win, props) {
        win = win || window;
        props = typeof props == 'object' ? props : {};
        var expires = props.expires ? ';expires=' + props.expires.toUTCString() : '';
        var path = props.path ? ';path=' + props.path : '';
        var domain = props.domain ? ';domain=' + props.domain : '';
        var secure = props.secure ? ';secure' : '';
        var serialized = serializeSelection(api.getSelection(win));
        win.document.cookie = encodeURIComponent(cookieName) + '=' + encodeURIComponent(serialized) + expires + path + domain + secure;
      }
      api.serializePosition = serializePosition;
      api.deserializePosition = deserializePosition;
      api.serializeRange = serializeRange;
      api.deserializeRange = deserializeRange;
      api.canDeserializeRange = canDeserializeRange;
      api.serializeSelection = serializeSelection;
      api.deserializeSelection = deserializeSelection;
      api.canDeserializeSelection = canDeserializeSelection;
      api.restoreSelectionFromCookie = restoreSelectionFromCookie;
      api.saveSelectionCookie = saveSelectionCookie;
      api.getElementChecksum = getElementChecksum;
      api.nodeToInfoString = nodeToInfoString;
    });
    //})();
    return rangy;
  }(libs_rangy_core);
  libs_rangy = function (rangy) {
    return rangy;
  }(libs_rangy_core);
  synchronite_ui_effects = function (lang, declare, baseWindow, baseArray, has, aspect, dom, query, domStyle, domClass, Color, baseFx, on, fxEasing, synchEvent, synchDom, synchQuery, rangy) {
    //, cursorArrow, cursorLink, cursorSelect) {
    var MARKUP_FILTER = /(<|>)/gi;
    var CATEGORY_UI_SESSION = 'uiSession';
    var CATEGORY_UI_POINTERS = 'uiPointers';
    var win = window, doc = win.document, config = win.synchroniteConfig, uiSessionConfig = config[CATEGORY_UI_SESSION], uiPointers = config[CATEGORY_UI_POINTERS];
    var HIGHLIGHT_COLOR = uiSessionConfig && uiSessionConfig.highlightColor || '#FFEB53', HIGHLIGHT_COLOR_INPUT = '#CCE6FF', CLICK_COLOR = HIGHLIGHT_COLOR;
    var SYNCHRONITE_WIDGETS = 'synchronite-widgets';
    var COBROWSE_ANIM_ATTR = 'data-lp-cobrowse-animated';
    var MARKED_IGNORED = '__COBROWSE_IGNORED__';
    var store;
    // Comment but do not remove synchronite brand colors for nostalgic reasons.
    //    SYNC_DARKBLUE = "#005892",
    //    SYNC_LIGHTBLUE = "#0075BA";
    var CLICK_SYMBOLS = {
      defaultValues: {
        x: 0.5,
        y: 0.5,
        start: 50,
        end: 100
      },
      solidCircle: {
        ch: '\u25CF',
        //
        x: 0.5,
        y: 0.52,
        start: 50,
        end: 120
      },
      doubleCircle: {
        ch: '\u25CE'  //
      },
      doubleCircleInnerSolid: {
        ch: '\u25C9'  //
      },
      heart: {
        ch: '\u2764'  //
      },
      x: {
        ch: '\u2716'  //
      },
      asterisk: {
        ch: '\u2724'  //
      },
      solidStarBorder: {
        ch: '\u272D'  //
      },
      solidStar: {
        ch: '\u2605'  //
      },
      circleWhiteStar: {
        ch: '\u272A'  //
      },
      fancyCircle: {
        ch: '\u2742'  //
      },
      arrowRight: {
        ch: '\u27A5'  //
      },
      snowFlake: {
        ch: '\u2744'  //
      },
      leftHand: {
        ch: '\u261C',
        //
        x: 0.1,
        y: 0.45
      }
    };
    var symbolName = uiSessionConfig && uiSessionConfig.highlightSymbol || 'solidCircle';
    var CLICK_SYMBOL = lang.mixin(CLICK_SYMBOLS.defaultValues, CLICK_SYMBOLS[symbolName]), MOUSEUP_DURATION = 300, POINTER_ZINDEX = 16777000,
      // max browser z-index is 16777271.
      POINTER_BLUR_RADIUS = uiSessionConfig && uiSessionConfig.clickBlurRadius || 15;
    //15
    var clickAnimation = [], upAnims = [];
    has.add('textshadow', function (global, doc, element) {
      return element.style.textShadow === '';
    });
    has.add('textshadow-spread', function (global, doc, element) {
      var savedShadow, style = element.style;
      if (style.textShadow === '') {
        style.textShadow = '#FF0000 0 0 10px 10px';
        savedShadow = element.style.textShadow;
        style.textShadow = '';
        return savedShadow !== '';
      }
      return false;
    });
    has.add('webrenderer', function (global, doc) {
      if (!has('ff')) {
        return false;
      }
      var iframe = doc.createElement('iframe');
      iframe.style.display = 'none';
      iframe.onload = function () {
        iframe.parentNode.removeChild(iframe);
      };
      //noinspection JSHint
      iframe.src = 'javascript:false';
      doc.body.appendChild(iframe);
      try {
        iframe.contentWindow.location.href = 'wrui://test';
      } catch (e) {
        if (e.name == 'NS_ERROR_UNKNOWN_PROTOCOL') {
          return false;
        }
      }
      return true;
    });
    function _updatePointerImage(userId, mouseOverNode) {
      var pointerId = 'pointer-' + userId;
      var type = 'arrow';
      //var svgCursor = cursorArrow;
      //var svgDataUrl = "data:image/svg+xml;utf8,";
      var cursorColorName = 'yellow';
      if (uiPointers.useCustom) {
        var userEntry = store.get(userId);
        if (userEntry && userEntry.cursor) {
          cursorColorName = userEntry.cursor;
        }
      }
      //var cursorColor = _getColorByUserId(userId);
      try {
        if (mouseOverNode) {
          var nodeName = mouseOverNode.nodeName.toLowerCase();
          if (/^(a|label|area)$/i.test(nodeName)) {
            type = 'link';  //svgCursor = cursorLink;
          } else if (synchDom.isTypeable(mouseOverNode)) {
            type = 'select';  //svgCursor = cursorSelect;
          }
        }
        //var svgImageStyle = {
        //  arrow: {width: "auto", height: "28px"}
        //};
        var img = dom.byId(pointerId + '-img');
        var pointer = dom.byId(pointerId);
        if (pointer) {
          pointer.className = 'ignoreDOM pointer ' + type;
        }
        if (img) {
          //var rgbCursorColor = new Color(cursorColor).toCss(); // convert to rgb color, FF does not understand hex colors in svg
          //var coloredSvg = svgCursor.replace("\n", "").replace(/#000/g, rgbCursorColor);
          //img.src = svgDataUrl + coloredSvg;
          //domStyle.set(img, svgImageStyle[type]);
          var imageUrl = config.serverUrl;
          if (typeof imageUrl == 'string' && !/\/$/.test(imageUrl)  /*ends with slash */) {
            imageUrl += '/';
          }
          imageUrl = imageUrl + 'images/cursor/' + cursorColorName + '-' + type + '.png';
          img.src = imageUrl;  // CT: removed preceding slash
        }
      } catch (e) {
        console.log('Updating mousepointer failed. Seems like window has already been unloaded.');
      }
    }
    function _updatePointerLabel(userId, userName, container) {
      // Escape username to prevent XSS attacks
      var cleanUsername = userName.replace(MARKUP_FILTER, '');
      // cut off any comma-seprated characters (meta info such as agent team)
      cleanUsername = cleanUsername.split(',')[0];
      var pointerLabelId = 'pointer-' + userId + '-label', pointerLabel = dom.byId(pointerLabelId);
      if (cleanUsername) {
        var labelColor = _getColorByUserId(userId);
        if (pointerLabel) {
          pointerLabel.style.background = labelColor;
          pointerLabel.innerHTML = cleanUsername;
        } else {
          if (container) {
            pointerLabel = synchDom.create('div', {
              id: pointerLabelId,
              innerHTML: cleanUsername,
              zIndex: POINTER_ZINDEX + 1,
              className: 'pointer-label'
            }, { background: labelColor }, container);
            //Use existing pointer or create new one
            dom.setSelectable(pointerLabel, false);
          }
        }
        return pointerLabel;
      }
    }
    var _applyColor = function (node, color) {
      // We achieve a blurry effect in CSS3 browser as described in:
      // see: http://simurai.com/post/684792689/text-blur
      // color: transparent;
      // text-shadow: #fff 0 0 100px;
      // SYNTAX FOR TEXT-SHADOW:
      // Formal grammar:
      //   - none | [<shadow>,]* <shadow>
      //   - where <shadow> is: [ <color>? <offset-x> <offset-y> <blur-radius>? | <offset-x> <offset-y> <blur-radius>? <color>? ]
      if (typeof color == 'string') {
        color = Color.fromString(color);
      }
      if (has('textshadow')) {
        var textShadowProperty;
        try {
          if (!has('webrenderer')) {
            //apply transparent color for browsers that support it.
            domStyle.set(node, {
              // Using rgba(0, 0, 0, 0) instead of "transparent" for better cross browser support
              // http://css-tricks.com/snippets/css/blurry-text/
              color: 'rgba(0, 0, 0, 0)'  //"transparent" //color.toCss(true)
            });
          } else {
            // fallback for webrenderer/liveperson
            domStyle.set(node, { color: color.toCss() });
          }
          textShadowProperty = color.toCss() + '0 0  ' + POINTER_BLUR_RADIUS + 'px';
          if (has('textshadow-spread')) {
            // Add spread in IE10/11, otherwise shadow is not shown.
            textShadowProperty += ' ' + POINTER_BLUR_RADIUS + 'px';
          }
          domStyle.set(node, { textShadow: textShadowProperty });
        } catch (e) {
        }
        console.log('main: _applyColor - color: ' + textShadowProperty);
      } else {
        //SEE: http://ie.microsoft.com/testdrive/Graphics/hands-on-css3/hands-on_text-shadow.htm
        domStyle.set(node.parentNode, {
          filter: 'progid:DXImageTransform.Microsoft.Blur(pixelradius=' + POINTER_BLUR_RADIUS + ')',
          zoom: 1,
          marginLeft: -POINTER_BLUR_RADIUS + 'px',
          marginTop: -POINTER_BLUR_RADIUS + 'px'
        });
        domStyle.set(node, { color: color.toCss() });
      }
      dom.setSelectable(node, false);
      dom.setSelectable(node.parentNode, false);
    };
    // borrowed from dojox/fx/ext-dojo/complex
    var complexAnimateProperty = lang.hitch(baseFx, function (options) {
      // summary:
      //		An extension of dojo.animateProperty which adds functionality
      //		that animates a "complex property". The primary example is the
      //		clip style: rect(10px 30px 10px 50px).
      //		Note this can also be used with (and is actually intended for)
      //		CSS3 properties, such as transform:
      //		transform: rotate(10deg) translateX(0px)
      // description:
      //		The standard animation doesn't know what to do with something like
      //		rect(...). This class identifies complex properties by they being a
      //		string and having parenthesis. If so, that property is made into a
      //		dojox.fx._Complex object and the getValue() is obtained from
      //		there.
      // example:
      //		|	var ani = dojo.animateProperty({
      //		|		node:dojo.byId("myDiv"),
      //		|		duration:600,
      //		|		properties:{
      //		|			clip:{start:'rect(0px 50px 50px 0px)', end:'rect(10px 30px 30px 10px)'}
      //		|		}
      //		|	}).play();
      var ani = baseFx.animateProperty(options);
      aspect.after(ani, 'beforeBegin', function () {
        // dojo.Animate original still invokes and still
        // works. We're appending this functionality to
        // modify targeted properties.
        ani.curve.getValue = function (r) {
          // Overwriting dojo.Animate's curve.getValue
          // This is mostly duplicate code, except it looks
          // for an instance of dojox.fx._Complex.
          var ret = {};
          //noinspection JSHint
          for (var p in this._properties) {
            var prop = this._properties[p], start = prop.start;
            if (start instanceof Color) {
              ret[p] = Color.blendColors(start, prop.end, r, prop.tempColor).toCss();
            } else if (start instanceof ComplexAnimation) {
              ret[p] = start.getValue(r);
            } else if (!lang.isArray(start)) {
              ret[p] = (prop.end - start) * r + start + (p != 'opacity' ? prop.units || 'px' : 0);
            }
          }
          return ret;
        };
        // this.properties has already been set, as has this.curve._properties.
        // We're fixing the props in curve which will have NaN attributes from
        // our string property.
        //noinspection JSHint
        var pm = {};
        //noinspection JSHint
        for (var p in this.properties) {
          var o = this.properties[p];
          if (typeof o.start == 'string' && /\(/.test(o.start)) {
            this.curve._properties[p].start = new ComplexAnimation(o);
          }
        }
      });
      return ani;  // dojo.Animation
    });
    var ComplexAnimation = declare(null, {
      // summary:
      //		A class that takes a complex property such as
      //		clip style: rect(10px 30px 10px 50px), and breaks it
      //		into separate animatable units. The object has a getValue()
      //		that will return a string with the modified units.
      PROP: /\([\w|,|+|\-|#|\.|\s]*\)/g,
      constructor: function (options) {
        var beg = options.start.match(this.PROP);
        var end = options.end.match(this.PROP);
        var begProps = baseArray.map(beg, this.getProps, this);
        var endProps = baseArray.map(end, this.getProps, this);
        this._properties = {};
        this.strProp = options.start;
        baseArray.forEach(begProps, function (prop, i) {
          baseArray.forEach(prop, function (p, j) {
            this.strProp = this.strProp.replace(p, 'PROP_' + i + '' + j);
            this._properties['PROP_' + i + '' + j] = this.makePropObject(p, endProps[i][j]);
          }, this);
        }, this);
      },
      getValue: function (r) {
        // summary:
        //		Returns a string with teh same integrity as the
        //		original star and end, but with the modified units.
        var str = this.strProp, u;
        //noinspection JSHint
        for (var nm in this._properties) {
          var v, o = this._properties[nm];
          if (o.units == 'isColor') {
            v = Color.blendColors(o.beg, o.end, r).toCss(false);
            u = '';
          } else {
            v = (o.end - o.beg) * r + o.beg;
            u = o.units;
          }
          str = str.replace(nm, v + u);
        }
        return str;  // String
      },
      makePropObject: function (beg, end) {
        // summary:
        //		Returns an object that stores the numeric value and
        //		units of the beginning and ending properties.
        var b = this.getNumAndUnits(beg);
        var e = this.getNumAndUnits(end);
        return {
          beg: b.num,
          end: e.num,
          units: b.units
        };  // Object
      },
      getProps: function (str) {
        // summary:
        //		Helper function that splits a stringified set of properties
        //		into individual units.
        str = str.substring(1, str.length - 1);
        var s;
        if (/,/.test(str)) {
          str = str.replace(/\s/g, '');
          s = str.split(',');
        } else {
          str = str.replace(/\s{2,}/g, ' ');
          s = str.split(' ');
        }
        return s;  // String
      },
      getNumAndUnits: function (prop) {
        // summary:
        //		Helper function that returns the numeric verion of the string
        //		property (or dojo.Color object) and the unit in which it was
        //		defined.
        if (!prop) {
          return {};
        }
        if (/#/.test(prop)) {
          return {
            num: new Color(prop),
            units: 'isColor'
          };  // Object
        }
        var o = { num: parseFloat(/-*[\d\.\d|\d]{1,}/.exec(prop).join('')) };
        o.units = /[a-z]{1,}/.exec(prop);
        //.join("");
        o.units = o.units && o.units.length ? o.units.join('') : '';
        return o;  // Object
      }
    });
    var SCALE = 'scale', ROTATE = 'rotate', DEGREE_LEFT = '-3deg', DEGREE_RIGHT = '3deg';
    function _tada(args) {
      var node = args.node;
      var COBROWSE_TADA_ANIM_ATTR = 'data-lp-cobrowse-tada-animated';
      if (node.hasAttribute(COBROWSE_TADA_ANIM_ATTR)) {
        console.info('This node is already animated.');
        return;
      }
      var anims = [], SIZE_NORMAL = 1, SCALE_BY = 0.2, MAX_SIZE = SIZE_NORMAL + SCALE_BY, MIN_SIZE = SIZE_NORMAL - SCALE_BY, start = {
          start: SCALE + '(' + SIZE_NORMAL + ')',
          end: SCALE + '(' + MIN_SIZE + ') ' + ROTATE + '(' + DEGREE_LEFT + ')'  //20%
        }, firstRight = {
          start: SCALE + '(' + MIN_SIZE + ') ' + ROTATE + '(' + DEGREE_LEFT + ')',
          // 10%
          end: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_RIGHT + ')'
        }, left = {
          start: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_RIGHT + ')',
          // 10%
          end: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_LEFT + ')'
        }, right = {
          start: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_LEFT + ')',
          // 10%
          end: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_RIGHT + ')'
        }, end = {
          start: SCALE + '(' + MAX_SIZE + ') ' + ROTATE + '(' + DEGREE_LEFT + ')',
          end: SCALE + '(' + SIZE_NORMAL + ') ' + ROTATE + '(0)'
        }, transforms = [
          start,
          firstRight,
          left,
          right,
          left,
          right,
          left,
          end
        ], transformsDuration = [
          0.2,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.1,
          0.2
        ], duration = args.duration || 1200;
      var i;
      for (i = 0; i < transforms.length; i++) {
        anims.push(complexAnimateProperty({
          node: node,
          duration: transformsDuration[i] * duration,
          properties: {
            webkitTransform: transforms[i],
            transform: transforms[i]
          }
        }));
      }
      for (i = 0; i < anims.length - 1; i++) {
        anims[i].onEnd = lang.hitch(anims[i + 1], anims[i + 1].play);
      }
      // When last animation sequence has finished, we need to reset the
      // css transform property.
      var nodeStyle = node.style;
      var storedTransform = nodeStyle.transform || nodeStyle.webkitTransform;
      anims[0].onBegin = function () {
        node.setAttribute(COBROWSE_TADA_ANIM_ATTR, 'true');
        // must be a string because of dojo bug
        domClass.add(node, 'ignoreDOM');
        nodeStyle.transitionDuration = '0s';
      };
      anims[anims.length - 1].onEnd = function () {
        if (storedTransform) {
          nodeStyle.transform = storedTransform;
          nodeStyle.webkitTransform = storedTransform;  // Safari on iOS 8 requires vendor prefix
        } else {
          if (nodeStyle.removeProperty) {
            nodeStyle.removeProperty('transform');
            nodeStyle.removeProperty('webkitTransform');
            nodeStyle.removeProperty('transitionDuration');
          }
        }
        node.removeAttribute(COBROWSE_TADA_ANIM_ATTR);
        domClass.remove(node, 'ignoreDOM');
      };
      anims[0].play();
    }
    function _createMouseUpAnim(userId) {
      console.debug('Creating mouse up animation for user: ' + userId);
      var clickVisualParent = dom.byId('pointer-' + userId + '-action');
      var clickVisual = clickVisualParent.firstChild;
      return baseFx.animateProperty({
        node: clickVisual,
        duration: MOUSEUP_DURATION,
        easing: fxEasing.quadOut,
        beforeBegin: function (node) {
          // Ensure the parent node is visible. Fixes a bug where
          // mouseup events occur without previous mousedown events
          // on mobile devices.
          domStyle.set(node.parentNode, { display: 'block' });
        },
        onStop: function () {
          if (synchDom.isVisible(this.node)) {
            domStyle.set(clickVisualParent, 'display', 'none');
          }
        },
        onEnd: function (node) {
          if (synchDom.isVisible(node)) {
            domStyle.set(clickVisualParent, 'display', 'none');
          }
        },
        properties: {
          fontSize: {
            start: CLICK_SYMBOL.start,
            end: CLICK_SYMBOL.end,
            unit: 'px'
          }
        }
      });
    }
    function _visualizeClick(aNode, realPos, userId) {
      if (clickAnimation[userId]) {
        clickAnimation[userId].stop();
        clickAnimation[userId] = null;
      }
      try {
        if (!realPos.pageX || !realPos.pageY) {
          console.warn('No click visualization. pageX/pageY undefined.');
          return;
        }
      } catch (e) {
        return;
      }
      var activeDocument = aNode.ownerDocument;
      if (!activeDocument) {
        //FIX for IE8 VML elements on schantz.
        return;
      }
      var activeWindow = activeDocument.defaultView || activeDocument.parentWindow;
      var clickVisualParent = dom.byId('pointer-' + userId + '-action', activeDocument) || _updatePointerAction(userId, synchDom.getBody(activeDocument));
      var clickVisual = clickVisualParent.firstChild;
      domStyle.set(clickVisualParent, {
        left: realPos.pageX - CLICK_SYMBOL.x * CLICK_SYMBOL.end + 'px',
        top: realPos.pageY - CLICK_SYMBOL.y * CLICK_SYMBOL.end + 'px'
      });
      domStyle.set(clickVisualParent, 'display', 'block');
      var anim = baseFx.animateProperty({
        node: clickVisual,
        duration: 400,
        easing: fxEasing.quadOut,
        beforeBegin: function (node) {
          domStyle.set(node, { display: 'inline' });
        },
        onStop: function () {
          if (synchDom.isVisible(this.node)) {
            domStyle.set(clickVisualParent, 'display', 'none');
          }
        },
        onEnd: function (node) {
          if (synchDom.isVisible(node)) {
            domStyle.set(clickVisualParent, 'display', 'none');
          }
          unloadListener.remove();
        },
        properties: {
          fontSize: {
            start: CLICK_SYMBOL.start,
            end: CLICK_SYMBOL.end,
            unit: 'px'
          }
        }
      });
      clickAnimation[userId] = anim;
      var destroyAnim = function () {
        if (anim) {
          anim.stop();
          anim = null;
        }
      };
      // tell dojo not to fix the event to avoid error in ie8
      var unloadListener = synchEvent.on(activeWindow, 'beforeunload', destroyAnim);
      try {
        anim.play();
      } catch (e) {
      }
    }
    function _showMouseIndication(position, userName) {
      var indicatonId = 'cobrowse-pointer-indication', pointerIndication = dom.byId(indicatonId);
      if (!pointerIndication) {
        var pointerContainer = dom.byId(SYNCHRONITE_WIDGETS) || synchDom.create('div', { id: SYNCHRONITE_WIDGETS }, baseWindow.body());
        if (!userName || userName === 'null') {
          userName = '';
        }
        pointerIndication = doc.createElement('div');
        pointerIndication.id = indicatonId;
        pointerIndication.className = 'ignoreDOM cobrowse-reset cobrowse-pointer-indication';
        pointerIndication.innerHTML = '<p>' + userName + '</p>';
        pointerContainer.appendChild(pointerIndication);  //domConstruct.place('<div id="cobrowse-pointer-indication" class="ignoreDOM cobrowse-reset cobrowse-pointer-indication"><p>' + userName + '</p></div>', pointerContainer);
      }
      domStyle.set(pointerIndication, {
        display: 'block',
        top: position.top + 'px',
        left: position.left + 'px',
        transform: 'rotate(' + position.rotate + 'deg)',
        '-webkit-transform': 'rotate(' + position.rotate + 'deg)'
      });
      domStyle.set(pointerIndication.firstChild, {
        transform: 'rotate(' + (360 - position.rotate) + 'deg)',
        '-webkit-transform': 'rotate(' + (360 - position.rotate) + 'deg)'
      });
    }
    function _compareColor(color1, color2) {
      if (color1.indexOf('#') != -1 && color2.indexOf('#') != -1 || color1.indexOf('rgb') != -1 && color2.indexOf('rgb') != -1) {
        return color1.toLowerCase() == color2.toLowerCase();
      } else {
        var xCol_1 = color1;
        var xCol_2 = color2;
        if (xCol_1.indexOf('#') != -1) {
          xCol_1 = _toRGBcolor(xCol_1);
        }
        if (xCol_2.indexOf('#') != -1) {
          xCol_2 = _toRGBcolor(xCol_2);
        }
        return xCol_1.toLowerCase() == xCol_2.toLowerCase();
      }
    }
    function _toRGBcolor(hexcolor) {
      var varR = parseInt(hexcolor.substring(1, 3), 16);
      var varG = parseInt(hexcolor.substring(3, 5), 16);
      var varB = parseInt(hexcolor.substring(5, 7), 16);
      return 'rgb(' + varR + ',' + varG + ',' + varB + ')';
    }
    function _shouldNotHighlight(node) {
      var tagName = node && node.tagName;
      //Do not highlight options
      if (tagName) {
        // Why did we not highlight anchor elements?
        // -> Because of the :hover class which makes it hard to
        //    reset the correct background color.
        return /^(option|a)$/i.test(tagName) || /^(select)$/i.test(tagName) && node.multiple && node.options > 0;
      }
      // do not highlight because this is probably not even a node.
      return true;
    }
    function _useDirectHighlight(node) {
      var nodeName;
      try {
        if (node) {
          nodeName = node.nodeName;
          if (nodeName) {
            var bgImage = domStyle.get(node, 'backgroundImage');
            // if table data has a background image we should not use direct highlight
            if (/^(td|input)$/i.test(nodeName) && bgImage !== 'none') {
              return false;
            }
            // Only access node.type when we can be sure, that node is an input field
            // otherwise IE8 throws "Failed" error for VML Nodes: http://bugs.jquery.com/ticket/7071
            return /^(textarea|label|th|td|tr)$/i.test(nodeName) || /^input$/i.test(nodeName) && !/^(submit|button)$/i.test(node.type);
          }
        }
      } catch (e) {
        console.warn('Cannot access node.type for ' + nodeName);
      }
      return false;
    }
    function _highlight(aNode, realPos, pointerId) {
      if (!synchDom.canAccessNode(aNode)) {
        return;
      }
      if (_shouldNotHighlight(aNode)) {
        return;
      }
      var circularHighlight = typeof realPos != 'undefined' && realPos;
      //Highlight these elements directly
      if (_useDirectHighlight(aNode)) {
        circularHighlight = false;
      }
      if (has('opera') < 11) {
        circularHighlight = false;
      }
      if (circularHighlight) {
        console.debug('aNode: ' + aNode.tagName);
        _visualizeClick(aNode, realPos, pointerId);
      } else {
        _highlightElement(aNode);
      }
    }
    function _getColorByUserId(userId) {
      var color = CLICK_COLOR;
      if (userId && uiPointers && uiPointers.useCustom) {
        var userEntry = store.get(userId);
        if (userEntry && userEntry.color) {
          color = userEntry.color;
        }
      }
      return color;
    }
    function _highlightElement(aNode, userId) {
      if (!synchDom.canAccessNode(aNode)) {
        return;
      }
      if (_shouldNotHighlight(aNode)) {
        return;
      }
      var startColor = _getColorByUserId(userId);
      var nodeName = aNode.nodeName.toLowerCase();
      if (aNode && aNode.tagName) {
        var activeDocument = aNode.ownerDocument;
        var activeWindow = activeDocument.defaultView || activeDocument.parentWindow;
        var bgImage = domStyle.get(aNode, 'backgroundImage');
        if (bgImage != 'none' && bgImage != '') {
          console.debug('Canceling highlight on ' + nodeName + ' node because it has a backgroundImage.');
          return;
        }
        //html nodes have no style, so use body node
        if (aNode.tagName.toLowerCase() == 'html') {
          aNode = synchDom.getBody(aNode.ownerDocument);
        }
        var isCurrentlyAnimated = aNode.getAttribute(COBROWSE_ANIM_ATTR);
        if (isCurrentlyAnimated != null) {
          return;
        } else {
          aNode.setAttribute(COBROWSE_ANIM_ATTR, 'true');
          aNode[MARKED_IGNORED] = true;
        }
        // check if style was directly set on the node e.g. style="background-color: #FFF"
        // in that case we need to reset the style at the end
        // FIXME: IE8 has no getPropertyValue
        var explicitBackgroundColor = aNode.style.getPropertyValue && aNode.style.getPropertyValue('background-color');
        var endColor = domStyle.get(aNode, 'backgroundColor').toLowerCase();
        var wasTransparent = endColor == 'transparent' || endColor == 'rgba(0, 0, 0, 0)';
        if (wasTransparent) {
          // FIXED: set back to transparent, when color is not found.
          endColor = synchDom.getInheritedBgcolor(aNode) || endColor;
        }
        startColor = startColor.replace(/ /gi, '');
        endColor = endColor.replace(/ /gi, '');
        if (endColor == 'transparent') {
          endColor = '#FFFFFF';
        }
        if (_compareColor(startColor, endColor)) {
          startColor = '#FFFFFF';
        }
        var anim = baseFx.animateProperty({
          node: aNode,
          duration: 750,
          //2350,
          properties: {
            backgroundColor: {
              start: Color.fromString(startColor),
              end: Color.fromString(endColor)
            }
          },
          onEnd: function () {
            try {
              if (aNode && aNode.ownerDocument && (aNode.ownerDocument.defaultView || aNode.ownerDocument.parentWindow)) {
                if (!explicitBackgroundColor) {
                  // we need to remove the style property,
                  // otherwise me might override inherited styles
                  if (aNode.style) {
                    aNode.style.removeProperty('background-color');
                  }
                } else {
                  if (wasTransparent) {
                    domStyle.set(aNode, { backgroundColor: 'transparent' });
                  }
                }
                aNode.removeAttribute(COBROWSE_ANIM_ATTR);
                delete aNode[MARKED_IGNORED];
              }
              unloadListener.remove();
            } catch (e) {
            }
          }
        });
        // stop animation when new page is loaded
        // also tell dojo not to fix the event!
        //otherwise IE throws errors
        var unloadListener = synchDom.addEvent(activeWindow, 'beforeunload', function () {
          if (anim) {
            anim.stop();
            anim = null;
          }
        }, true);
        anim.play();
      }
    }
    function _getBodyOrRoot() {
      var attachTo;
      if (query('body').length === 0) {
        attachTo = document.documentElement;
      } else {
        attachTo = query('body')[0];
      }
      return attachTo;
    }
    function _updatePointerAction(userId, container) {
      var pointerId = 'pointer-' + userId;
      var activeDoc;
      if (container) {
        activeDoc = container.ownerDocument;
      } else {
        var syncWin = synchQuery.synchronizedWindow();
        if (synchDom.canAccessWindow(syncWin)) {
          activeDoc = syncWin.document;
        } else {
          console.error('_updatePointerAction: Unable to access synchronized window');
          return;
        }
      }
      var pointerActionId = pointerId + '-action';
      var pointerAction = dom.byId(pointerActionId, activeDoc);
      var pointerActionVisual;
      if (pointerAction) {
        pointerActionVisual = pointerAction.firstChild;
      } else {
        if (!container) {
          container = dom.byId(pointerId, activeDoc);
          if (!container) {
            return;
          }
        }
        // Create click visuals
        pointerAction = activeDoc.createElement('div');
        pointerAction.id = pointerActionId;
        pointerAction.className = 'pointer-action ignoreDOM';
        domStyle.set(pointerAction, {
          position: 'absolute',
          lineHeight: CLICK_SYMBOL.end + 'px',
          display: 'none',
          // FIXED: We must not detect mouseUp events on the mouse pointer or the click
          // highlight itself. "In addition to indicating that the element is not the target
          // of mouse events, the value none instructs the mouse event to go "through" the
          // element and target whatever is "underneath" that element instead.
          // see: https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
          pointerEvents: 'none',
          //FIXED: Must be there otherwise animation
          //is hiden under layered elements. Maximum cross-
          //browser z-index is 16777271.
          zIndex: POINTER_ZINDEX - 2,
          backgroundColor: 'transparent',
          margin: 0,
          padding: 0,
          border: 0,
          borderRadius: 0,
          fontWeight: 400,
          height: CLICK_SYMBOL.end + 'px',
          width: CLICK_SYMBOL.end + 'px',
          textAlign: 'center'
        });
        container.appendChild(pointerAction);
        pointerActionVisual = activeDoc.createElement('span');
        pointerActionVisual.innerHTML = CLICK_SYMBOL.ch;
        //DOUBLE_CIRCLE_INNER_SOLID,
        pointerActionVisual.className = 'action ignoreDOM';
        domStyle.set(pointerActionVisual, {
          fontSize: CLICK_SYMBOL.start + 'px',
          lineHeight: CLICK_SYMBOL.end + 'px',
          fontFamily: 'sans-serif',
          fontWeight: 400,
          margin: 0,
          background: 'none',
          // FIXED: We must not detect mouseUp events on the mouse pointer or the click
          // highlight itself. "In addition to indicating that the element is not the target
          // of mouse events, the value none instructs the mouse event to go "through" the
          // element and target whatever is "underneath" that element instead.
          // see: https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
          pointerEvents: 'none',
          //FIXED: Must be there otherwise animation
          //is hiden under layered elements. Maximum cross-
          //browser z-index is 16777271.
          zIndex: POINTER_ZINDEX - 1,
          cursor: 'default',
          //textShadow: "0px 0px 3px #FFEB53",
          padding: 0,
          border: 0
        });
        pointerAction.appendChild(pointerActionVisual);
      }
      var color = _getColorByUserId(userId);
      console.info('_updatePointerAction user: ' + userId + ' - color: ' + color);
      _applyColor(pointerActionVisual, color);
      dom.setSelectable(pointerActionVisual, false);
      dom.setSelectable(pointerAction, false);
      return pointerAction;
    }
    var mouse = {
      stopAnims: function () {
        baseArray.forEach(upAnims, function (anim) {
          anim.stop();
        }, this);
      },
      down: function (user) {
        var clickVisualParent = dom.byId('pointer-' + user + '-action');
        var clickVisual = clickVisualParent.firstChild;
        domStyle.set(clickVisual, { fontSize: CLICK_SYMBOL.start + 'px' });
        domStyle.set(clickVisualParent, { display: 'block' });
      },
      up: function (userId) {
        var anim = upAnims[userId] || _createMouseUpAnim(userId);
        try {
          anim.play();
        } catch (e) {
        }
      }
    };
    function _createWidgetsContainer() {
      var attachTo = _getBodyOrRoot(), doc = attachTo.ownerDocument, container = doc.createElement('div');
      container.id = SYNCHRONITE_WIDGETS;
      attachTo.appendChild(container);
      return container;
    }
    var effects = {
      highlightText: function (range, rootNode, userId) {
        console.debug('highlightText by userId=' + userId);
        //var isLocal = (userId == config.userId);
        if (typeof range == 'string') {
          if (rootNode) {
            try {
              var nodeDoc = rootNode.ownerDocument;
              var win = nodeDoc.defaultView || nodeDoc.parentWindow;
              range = rangy.deserializeRange(range, rootNode, win);
              range.select();
            } catch (e) {
              console.warn('highlightText: ' + e);
            }
          } else {
            console.warn('highlightText: range rootNode is missing or invalid');
          }
        }  //defaultHighlight.backgroundColor = dojoColor.fromString(color).toCss(false); //no alpha
           //highlightApplier.elementProperties = {style: defaultHighlight};
           //                                    if (isLocal) {
           //                                        highlightApplier.applyToRange(range);
           //                                        removeTextHighlights(userId);
           //                                    } else {
           //                                        removeTextHighlights(userId);
           //                                        highlightApplier.applyToRange(range);
           //                                    }
           //                                    storedHighlights[userId] = range;
      },
      removePointers: function () {
        query('#' + SYNCHRONITE_WIDGETS + ' .pointer', doc).forEach(function (node) {
          node.parentNode.removeChild(node);
        });
        query('#' + SYNCHRONITE_WIDGETS + ' .cobrowse-pointer-indication', doc).forEach(function (node) {
          node.parentNode.removeChild(node);
        });
      },
      createPointer: function (userId, userName) {
        console.debug('Creating Mouse Pointer');
        var pointerId = 'pointer-' + userId;
        var pointerImageId = pointerId + '-img';
        // Place inside synchronite-widgets if present (proxyless visitor) to protect against style overrides
        var pointerContainer = dom.byId(SYNCHRONITE_WIDGETS) || _createWidgetsContainer();
        // Create the pointer container
        var pointerDiv = synchDom.create('div', {
          id: pointerId,
          className: 'pointer cobrowse-reset ignoreDOM'
        }, {
          // FIXED: We must not detect mouseUp events on the mouse pointer or the click
          // highlight itself. "In addition to indicating that the element is not the target
          // of mouse events, the value none instructs the mouse event to go "through" the
          // element and target whatever is "underneath" that element instead.
          // see: https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
          pointerEvents: 'none',
          left: '40px',
          top: '40px',
          zIndex: POINTER_ZINDEX
        }, pointerContainer);
        var clickVisualParent = _updatePointerAction(userId, pointerDiv);
        domStyle.set(clickVisualParent, {
          left: -CLICK_SYMBOL.x * CLICK_SYMBOL.end + 'px',
          top: -CLICK_SYMBOL.y * CLICK_SYMBOL.end + 'px'
        });
        // Create pointer + image container
        var piContainer = synchDom.create('div', { className: 'pointer-image-container cobrowse-reset ignoreDOM' }, {
          // FIXED: We must not detect mouseUp events on the mouse pointer or the click
          // highlight itself. "In addition to indicating that the element is not the target
          // of mouse events, the value none instructs the mouse event to go "through" the
          // element and target whatever is "underneath" that element instead.
          // see: https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
          pointerEvents: 'none',
          position: 'absolute',
          top: '0px',
          left: '0px',
          zIndex: POINTER_ZINDEX + 1
        }, pointerDiv);
        //Use existing pointer or create new one
        // Create the pointer image
        synchDom.create('img', {
          id: pointerImageId,
          className: 'ignoreDOM',
          alt: 'Telepointer'
        }, {
          // FIXED: We must not detect mouseUp events on the mouse pointer or the click
          // highlight itself. "In addition to indicating that the element is not the target
          // of mouse events, the value none instructs the mouse event to go "through" the
          // element and target whatever is "underneath" that element instead.
          // see: https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events
          pointerEvents: 'none',
          zIndex: POINTER_ZINDEX + 1
        }, piContainer);
        _updatePointerImage(userId);
        // Create the pointer label
        _updatePointerLabel(userId, userName, piContainer);
        on(pointerDiv, 'mouseover', function () {
          domStyle.set(pointerDiv, 'display', 'none');
        });
        return pointerDiv;
      },
      teleHighlight: function (node, userId, special) {
        if (!synchDom.canAccessNode(node)) {
          return;
        }
        if (_shouldNotHighlight(node)) {
          return;
        }
        if (_useDirectHighlight(node)) {
          // highlight node itself
          win.setTimeout(function () {
            _highlightElement(node, userId);
          }, 20);
        } else {
          // visualize mouse up event for remote user's telepointers
          mouse.up(userId);
        }
        if (special) {
          _tada({ node: node });
        }
      },
      localHighlight: function (node, position, special) {
        var userId = config.userId;
        if (!synchDom.canAccessNode(node)) {
          return;
        }
        if (_shouldNotHighlight(node)) {
          return;
        }
        if (_useDirectHighlight(node)) {
          // highlight node itself
          win.setTimeout(function () {
            _highlightElement(node, userId);
          }, 20);
        } else {
          // create mouse up click visualization at specified coordinates
          win.setTimeout(function () {
            _visualizeClick(node, position, userId);
          }, 50);
        }
        if (special) {
          _tada({ node: node });
        }
      },
      tada: function (node) {
        _tada({
          node: node,
          duration: 1000
        });
      },
      showMouseIndication: _showMouseIndication,
      highlight: _highlight,
      highlightElement: _highlightElement,
      updatePointerLabel: _updatePointerLabel,
      updatePointerAction: _updatePointerAction,
      updatePointerImage: _updatePointerImage,
      configure: function (_store) {
        store = _store;
      }
    };
    return effects;
  }(dojo__base_lang, dojo__base_declare, dojo__base_window, dojo__base_array, dojo_has, dojo_aspect, dojo_dom, dojo_query, dojo_dom_style, dojo_dom_class, dojo__base_Color, dojo__base_fx, dojo_on, dojo_fx_easing, synchronite__base_event, synchronite_micro_dom, synchronite__base_query, libs_rangy);
  synchronite__base_frames = function (dojoBaseWindow, dojoGeometry) {
    //////////////////////////////////////
    // Private Variables and Functions
    /////////////////////////////////////
    //            var _isFrameColumn = function(frameset) {
    //                var aCols = frameset.getAttribute("cols");
    //                var aRows = frameset.getAttribute("rows");
    //                if (aCols && aRows) {
    //                    return (aRows == "*");
    //                } else {
    //                    return !(!(aCols));
    //                }
    //            },
    //                    _getFrameSize = function(frame) {
    //                var doc = frame.contentWindow.document.documentElement;
    //                //return dojoGeometry.position(frame);
    //                return {
    //                    w: doc.clientWidth,
    //                    h: doc.clientHeight
    //                };
    //            },
    //                    _getFramesetSize = function(frameset) {
    //                var nodes = frameset.children;
    //                var h = 0, w = 0;
    //                var size;
    //                var isColumn = _isFrameColumn(frameset);
    //
    //                for (var i = 0; i < nodes.length; i++) {
    //                    var node = nodes[i];
    //                    var nodeName = node.nodeName.toLowerCase();
    //
    //                    if (nodeName == "frame") {
    //                        size = _getFrameSize(node);
    //                    } else if (nodeName == "frameset") {
    //                        size = _getFramesetSize(node);
    //                    } else {
    //                        size = null;
    //                    }
    //                    if (size && isColumn) {
    //                        h = size.h;
    //                        w += size.w;
    //                    } else {
    //                        w = size.w;
    //                        h += size.h;
    //                    }
    //                }
    //                return {
    //                    h: h,
    //                    w: w
    //                };
    //            },
    //                    _addOffset = function(o1, o2) {
    //                o1.x += o2.x;
    //                o1.y += o2.y;
    //                return o1;
    //            };
    //            var _getFrameElementOffset = function(frameElement) {
    //                //frameElement can be iframe, frame or frameset
    //                var nodeName = frameElement.nodeName.toLowerCase();
    //                var offset = {
    //                    x: 0,
    //                    y: 0
    //                };
    //
    //                if (frameElement) {
    //
    //                    if (nodeName == "frame" || nodeName == "frameset") {
    //
    //                        var frameParent = frameElement.parentNode;
    //
    //                        //to get the offset of this frame, we must add height or width
    //                        //of previous sibling
    //
    //                        try {
    //                            do {
    //                                frameElement = frameElement.previousSibling;
    //                                if (!(frameElement)) {
    //                                    //check if is nested frameset
    //                                    if (frameParent.parentNode && frameParent.parentNode.nodeName.toLowerCase() == "frameset") {
    //                                        frameElement = frameParent.previousSibling;
    //                                        if (frameElement) {
    //                                            frameParent = frameElement.parentNode;
    //                                        }
    //                                    }
    //                                }
    //                            } while (frameElement && frameElement.nodeType != 1);
    //
    //                            if (!(frameElement) || frameElement.nodeType != 1) {
    //                                return offset;
    //                            }
    //
    //                        } catch (e) {
    //                            console.debug("SKANDAL!");
    //                            console.debug(e);
    //                        }
    //
    //                        var size;
    //                        var isColumn = _isFrameColumn(frameParent);
    //                        console.debug(frameElement.name + " parent is: " + (isColumn ? "column" : "row"));
    //                        nodeName = frameElement.nodeName.toLowerCase();
    //                        if (nodeName == "frameset") {
    //                            size = _getFramesetSize(frameElement);
    //                        } else if (nodeName == "frame") {
    //                            size = _getFrameSize(frameElement);
    //                        } else {
    //                            console.warn("getFrameSize: Unknown element.");
    //                        }
    //
    //                        console.debug("first frame: " + frameElement.name);
    //                        if (isColumn) {
    //                            offset.x += size.w;
    //                            console.debug("offset.x+=" + size.w);
    //                            console.dir(offset);
    //                        } else {
    //                            offset.y += size.h;
    //                            console.debug("offset.y+=" + size.h);
    //                            console.dir(offset);
    //                        }
    //
    //                        return _addOffset(offset, _getFrameElementOffset(frameElement));
    //
    //                    } else if (nodeName == "iframe") {
    //                        var activeWindow = dojoWindow.get(frameElement.ownerDocument);
    //                        var o = dojoBaseWindow.withGlobal(activeWindow, dojoGeometry.position, dojoGeometry, [frameElement]);
    //                        offset.x += o.x;
    //                        offset.y += o.y;
    //                        return offset;
    //                    }
    //                    /* else if (nodeName == "frameset") {
    //                     var size= _getFramesetSize(frameElement);
    //                     if (_isFrameColumn(frameElement)) {
    //                     offset.x += size.w;
    //                     } else {
    //                     offset.y += size.h;
    //                     }
    //                     return offset;
    //                     } */ else {
    //                        //TextNode or noframe node
    //                        return offset;
    //                    }
    //                } else {
    //                    return offset;
    //                }
    //
    //
    //            };
    //////////////////////////////////////
    // Public Properties and Methods
    /////////////////////////////////////
    var synchFrames = {
      frameOffset: function (element, stopWindow) {
        var doc = element.ownerDocument;
        var activeWindow = doc.parentWindow || doc.defaultView;
        var offset = {
          x: 0,
          y: 0
        };
        // Not Needed for opera 12.16
        //                if (dojoHas("opera")) {
        //                    // Not Needed for opera 12.16
        //                    while (activeWindow.frameElement && activeWindow!=stopWindow && activeWindow!=activeWindow.parent) {
        //                        //does not work for frames in frameset in opera because offsetTop is zero.
        //                        var frameElement = activeWindow.frameElement;
        //                        var tmpOffset = _getFrameElementOffset(frameElement);
        //                        console.debug(" frame: " + frameElement.nodeName + " name: "+ frameElement.name + " x:" + tmpOffset.x + ", y: " + tmpOffset.y);
        //                        offset.x += tmpOffset.x;
        //                        offset.y += tmpOffset.y;
        //                        if (activeWindow!=activeWindow.parent) {
        //                            activeWindow = activeWindow.parent;
        //                        } else {
        //                            break;
        //                        }
        //
        //                    }
        //                    console.debug("==>Total: x:" + offset.x + ", y: " + offset.y);
        //
        //                } else {
        try {
          while (activeWindow.frameElement && activeWindow != stopWindow) {
            //does not work for frames in frameset in opera because offsetTop is zero.
            var o = dojoBaseWindow.withGlobal(activeWindow, dojoGeometry.position, dojoGeometry, [activeWindow.frameElement]);
            offset.x += o.x;
            offset.y += o.y;
            var parentWin = activeWindow.frameElement.ownerDocument.defaultView || activeWindow.frameElement.ownerDocument.parentWindow;
            if (activeWindow != parentWin) {
              activeWindow = parentWin;
            } else {
              break;
            }
          }
        } catch (e) {
          console.warn('Attempt of cross-origin iframe to access parent window property: ' + e);
        }
        //}
        return offset;
      }
    };
    return synchFrames;
  }(dojo__base_window, dojo_dom_geometry);
  synchronite_page = function (Evented, synchQuery) {
    var pageEvents = new Evented();
    pageEvents.FRAME_LOADED = 'frameLoaded';
    pageEvents.ALL_FRAMES_LOADED_STATUS = 'allFramesLoadedStatus';
    pageEvents.MAIN_FRAME_LOADED = 'mainFrameLoaded';
    pageEvents.FRAME_HASH_SET = 'frameHashSet';
    pageEvents.INTENDED_LOAD = 'intendedLoad';
    pageEvents.on(pageEvents.FRAME_LOADED, function (event) {
      console.debug('New page has been loaded');
      if (event.window && event.window == synchQuery.synchronizedWindow()) {
        console.debug('Emitting MAIN_FRAME_LOADED');
        pageEvents.emit(pageEvents.MAIN_FRAME_LOADED, event);
      }
    });
    return pageEvents;
  }(dojo_Evented, synchronite__base_query);
  synchronite_events_mouse = function (lang, baseWindow, baseEvent, baseArray, baseFx, has, query, dom, domClass, domStyle, domGeometry, Deferred, on, Evented, touch, synchQuery, effects, synchEvent, synchWindow, microDom, synchFrames, synchState, page, strings, rangy) {
    //------------------- Event constants -----------------------//
    var NAMESPACE = 'mouse';
    var type = {
      MOUSE: NAMESPACE,
      CLICK: NAMESPACE + ':click',
      DOWN: NAMESPACE + ':down',
      UP: NAMESPACE + ':up',
      DRAG: NAMESPACE + ':drag',
      MOVE: NAMESPACE + ':move',
      SELECT: NAMESPACE + ':select'
    };
    var profile,
      // defines what events should be listened to and replicated
      Syn,
      // Extended Syn JS library
      parserJavascript;
    // JavaScript parser. Not directly included using require as it's quite heavy and not used in proxyless
    var listeners = [];
    var contextWindow = window,
      // execution context window
      config = contextWindow.synchroniteConfig, localEvents = new Evented(), remoteEvents = new Evented(), replicatorHandles = [];
    // buffer messages while state is being set
    var _messageBuffer = [], _bufferMessages = false;
    var blockMouse;
    var storedRange;
    var allFramesLoaded = true;
    page.on(page.ALL_FRAMES_LOADED_STATUS, function (event) {
      allFramesLoaded = event.status;
    });
    // click and mousedown and mouseup
    var leftMouseDownMoves = 0, leftMouseDown, _mouseDownUpClickTimeout, mouseDownSelector, mouseUpSelector, monitorClicks = true;
    // attach click listeners directly to these nodes
    var mouseClickNodes = [
        'a',
        'span',
        'button',
        '.clickable',
        'input'
      ], _excludeList = [];
    // selectors for which no clicks/mousedowns should be monitored
    // mouse moves
    var throttleMouseMoveTimer, mouseMoveInProgress, hidePointerTimer = {}, moveMouse = {},
      // adjusts the mouse move parent in case of magnifying glass effects that are found on many e-commerce pages
      // (mousemove target moves with mousemove)
      mouseMoveUseParent = config.mouseMoveUseParent, lastMouseMove = {
        target: null,
        selector: null,
        pageX: 0,
        pageY: 0,
        time: 0
      };
    // mouse event buffering
    var mouseBuffer = {},
      // incoming events
      waitForFrame = 0, waitForFrameTimeout = 20000;
    // Syn.js
    var synMouseQueue, _clickInProgress, _clickInProgressTimeout;
    //-------------------  Listener Registration -----------------------//
    function startListening(documentOrNode) {
      if (profile.monitor.mouseClick || profile.monitor.highlight) {
        // FIXED: We need to catch the event on the HTML element not on the body element, so we can
        //        detect dragEnd/mouseUp operations on easyCredit.
        //  Did we use the body element to catch events before others?
        var mouseNode = documentOrNode.nodeType == 9 ? documentOrNode.documentElement || microDom.getBody(documentOrNode) : documentOrNode;
        if (!mouseNode) {
          // There might not be a body element (e.g.only head tag)
          mouseNode = documentOrNode;
        }
        listeners.push(registerMouseClick(documentOrNode));
        listeners.push.apply(listeners, registerNodesMouseClick(documentOrNode));
        listeners.push.apply(listeners, registerMouseDown(mouseNode));
        // Disable the contextMenu on macosx when ctrl + click is actually meant to trigger
        // the tada/wiggle effect on the underlying node
        listeners.push(_addEvent(mouseNode, 'contextmenu', function (event) {
          if (event.ctrlKey || event.metaKey) {
            event.preventDefault();
          }
        }, true));
        mouseClickNodes.push('[onclick]');
      }
      listeners.push(registerMouseMove(documentOrNode));
    }
    function stopListening() {
      baseArray.forEach(listeners, function (handle) {
        handle.remove();
      });
      // clear array instead of re-assigning empty array to improve tests
      listeners.splice(0, listeners.length);
    }
    /* idempotent */
    function startReplicating(_config) {
      console.info('STARTREPLICATING mouse events');
      var replicatorConfig = _config || {};
      if (replicatorConfig.remoteEvents) {
        remoteEvents = replicatorConfig.remoteEvents;
      }
      baseArray.forEach(replicatorHandles, function (handle) {
        handle.remove();
      });
      for (var key in type) {
        if (type.hasOwnProperty(key)) {
          //noinspection JSHint
          replicatorHandles.push(remoteEvents.on(type[key], function (t) {
            return function (event) {
              handleMouse(event, t);
            };
          }(type[key])));
        }
      }
      replicatorHandles.push(microDom.addEvent(window, 'resize', function () {
        redrawMouseIndicator();
      }));
      replicatorHandles.push(microDom.addEvent(window, 'scroll', function () {
        redrawMouseIndicator();
      }));
    }
    function redrawMouseIndicator() {
      if (!config.showTelepointerHint) {
        return;
      }
      for (var id in moveMouse) {
        if (moveMouse.hasOwnProperty(id)) {
          var pointerData = moveMouse[id];
          if (typeof pointerData === 'undefined') {
            return;
          }
          var pointer = dom.byId(pointerData.pointerId);
          if (isVisible(pointer)) {
            var cobrowsePointerIndication = dom.byId('cobrowse-pointer-indication');
            if (cobrowsePointerIndication) {
              cobrowsePointerIndication.style.display = 'none';
            }
          } else {
            var position = calculateMouseIndicationPosition(pointer);
            effects.showMouseIndication(position, pointerData.userName);
          }
        }
      }
    }
    function registerMouseClick(documentOrNode) {
      // do not fix click listeners
      return _addEvent(documentOrNode, 'click', monitorMouseClick);
    }
    function registerNodesMouseClick(rootNode) {
      var clickSignals = [];
      baseArray.forEach(mouseClickNodes, function (selector) {
        query(selector, rootNode).forEach(function (node) {
          if (!node[strings.PROP_CLICK_MONITORED]) {
            clickSignals.push(registerMouseClick(node));
            node[strings.PROP_CLICK_MONITORED] = true;
          }
        });
      });
      return clickSignals;
    }
    function registerMouseMove(documentOrNode) {
      throttleMouseMoveTimer = null;
      // IMPROVED: As a performance improvement, we set dontFix=true, to prevent dojo
      // from fixing mouse events in IE8 when not needed.
      return _addEvent(documentOrNode, 'mousemove', monitorMouseMove, true);
    }
    function registerMouseDown(mouseNode) {
      //2.1.1 monitorMouseDown on document
      //      press => touchstart or mousedown
      // mouseUp and mouseDown MUST be registered on the same node, otherwise ipod gets confused.
      var mouseDownSignals = [];
      if (mouseNode) {
        if (has('dom-addeventlistener')) {
          var type = 'mousedown', capture = true;
          mouseNode.addEventListener(type, trackMouseDownState, capture);
          mouseDownSignals.push({
            remove: function () {
              mouseNode.removeEventListener(type, trackMouseDownState, capture);
            }
          });
        } else {
          mouseDownSignals.push(touch.press(mouseNode, trackMouseDownState));
        }
        // FIXED: Use touch.press directly to avoid dojo.on prototype bug.
        mouseDownSignals.push(touch.press(mouseNode, monitorMouseDown));
        //2.1.2 monitorMouseUp on document
        //      release => touchend or mouseup
        // FIXED: Use touch.press directly to avoid dojo.on prototype bug.
        mouseDownSignals.push(touch.release(mouseNode, monitorMouseUp));
      }
      return mouseDownSignals;
    }
    function trackMouseDownState(event) {
      if (synchEvent.isSimulated(event)) {
        return true;  //do not stop event propagation
      }
      console.log('trackMouseDownState button: ' + event.button + ', which: ' + event.which);
      if (event.which === 1  /* left button */) {
        var downNode = event.target || event.srcElement;
        leftMouseDown = {
          target: downNode,
          offset: microDom.getNormalizedMouseOffset(downNode, event.pageX, event.pageY),
          selector: synchQuery.getNodeSelectorFromEvent(event)
        };
      }
    }
    function monitorMouseMove(event) {
      if (!profile.monitor.mouseMove) {
        return;
      }
      if (synchEvent.isSimulated(event)) {
        return true;  //do not stop event propagation
      }
      var eventTarget = event.target || event.srcElement;
      if (eventTarget.tagName) {
        // only proceed if target is a node
        // could also be an ActiveX Object
        // normalizes properties on the event object including event
        // bubbling methods, keystroke normalization, and x/y positions
        // This is quite expensive, so we only do it when needed.
        // (only executed in IE8)
        event = baseEvent.fix(event, eventTarget);
        // dojoMouse.isLeft does not work here.
        // Does this work on mobile?
        if (leftMouseDown) {
          leftMouseDownMoves++;
        }
        var pageDistance, firstMove;
        if (lastMouseMove && lastMouseMove.pageX) {
          var deltaX = event.pageX - lastMouseMove.pageX;
          var deltaY = event.pageY - lastMouseMove.pageY;
          pageDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        } else {
          console.debug('First mouse move on this page.');
          firstMove = true;
        }
        var activeDocument = eventTarget.ownerDocument;
        if (pageDistance > 2 || firstMove) {
          lastMouseMove.pageX = event.pageX;
          lastMouseMove.pageY = event.pageY;
          lastMouseMove.pageDistance = pageDistance;
          try {
            // if last target is on unloaded page then in IE access will
            // result in permission denied error.
            var selector = synchQuery.getNodeSelectorFromEvent(event);
            if (lastMouseMove.selector === null || !selectorsAreEqual(lastMouseMove.selector, selector)) {
              // mouse over new target
              lastMouseMove.target = eventTarget;
              lastMouseMove.selector = synchQuery.getNodeSelectorFromEvent(event);
            }
          } catch (e) {
            lastMouseMove.target = eventTarget;
          }
          var activeWindow = activeDocument.defaultView || activeDocument.parentWindow;
          //send mouse move every x milliseconds when all frames are loaded
          //FIXED: activeWindow.initialized was false although window was loaded.
          try {
            if (!throttleMouseMoveTimer && activeWindow && synchWindow.isWindowInitialized(activeWindow)) {
              throttleMouseMoveTimer = contextWindow.setTimeout(emitMouseMove, profile.mouseMoveIntervall);
            }
          } catch (e) {
            if (typeof console !== 'undefined') {
              console.warn('Unable to access window object. Seems like the window is just being unloaded? ' + e);
            }
          }
        }
      }
    }
    function selectorsAreEqual(sel1, sel2) {
      if (sel1.shadow) {
        return sel1.shadow === sel2.shadow && sel1.element === sel2.element;
      } else {
        return sel1.element === sel2.element;
      }
    }
    function isMenubarShown() {
      var slaveMenuBarShown = top == self;
      return config.cobrowseEngine !== 'proxyless' || slaveMenuBarShown && config.isSlave;
    }
    function monitorMouseDown(event) {
      // Sends mouse highlight but does not create a local echo.
      if (!synchEvent.isSimulated(event)) {
        // Track the number of pixels the mouse is moved while the mousekey is
        // pressed. Required for drag & drop detection.
        leftMouseDownMoves = 0;
        var target = event.target || event.srcElement;
        if (isExcluded('click', target)) {
          console.log('monitorMouseDown: Mouse Event is EXCLUDED');
          return;
        }
        var el = _closestElement(target);
        //stupid IE triggers strange mousedown when scrolling
        if (el && el.ownerDocument) {
          if (/label/i.test(target.nodeName) || synchQuery.closestParent(target, 'label')) {
            // do not handle click events on label elements!
            // clicking on a <label> automatically dispatches a click
            // event for it's connected <input> -  <label> elements
            // do actually dispatch a distinct click event that would
            // result in a duplicate submission.
            // see: http://stackoverflow.com/questions/1342658/ie-onclick-will-not-check-a-checkbox-unless-you-click-the-image-in-the-label
            return true;  //do not stop subsequent event handlers.
          }
          if (/object|embed/i.test(target.nodeName)) {
            //&& (has("ie")<=9)) {
            var wrappedEvent = _collectEventData(event);
            wrappedEvent.type = 'click';
            wrappedEvent.monitoredBy = 'mousedown';
            // mouse downs on flash objects are actually mouse clicks in IE
            if (target.playVideo) {
              //setTimeout(lang.hitch(this, _delayedYTSync, wrappedEvent), 25);
              if (!target.getAttribute('stateListener')) {
                target.setAttribute('stateListener', true);
                // var doc = target.ownerDocument;
                // var win = doc.parentWindow || doc.defaultView;
                // TODO: FIXME Is this even required?
                // win.onYTStateChange = lang.hitch(this, this.monitorYtState, target);
                target.addEventListener('onStateChange', 'onYTStateChange');
              }
            } else {
              monitorMouseClick(wrappedEvent);
            }
            return true;
          }
          // The event target is collected during on the mouseDown event,
          // because it might not be accessible anymore at mouse click stage
          // (e.g. because the page is just being unloaded)
          mouseDownSelector = synchQuery.getNodeSelectorFromEvent(event);
          console.debug('monitorMouseDown: ' + mouseDownSelector.element);
          var msg = _collectMouseMessageData(event);
          // FIXES: IE10 MSPointerDown issue
          msg.mouseEvent.type = 'mousedown';
          if (/select|option/i.test(el.tagName)) {
            msg.preventMove = true;
          } else {
            if (event.ctrlKey || event.metaKey) {
              // prevent text selection on ctrl + mousedown
              // because we use that for the "tada/wiggle" effect
              event.preventDefault();
            }
          }
          if ((event.metaKey || event.ctrlKey) && synchQuery.closestParent(target, 'a')) {
            // Do not open links in new tab when a special highlight (ctrl key down) is applied.
            _preventDefault(event);
          }
          console.info('PUBLISHING MOUSEDOWN: ' + JSON.stringify(msg));
          msg.type = type.DOWN;
          localEvents.emit(type.DOWN, msg);
        } else {
          console.warn('Unexpected Mousedown target.');
        }
      }
    }
    function monitorMouseUp(event) {
      if (!synchEvent.isSimulated(event)) {
        var eventTarget = event.target || event.srcElement;
        var el = _closestElement(eventTarget);
        mouseUpSelector = synchQuery.getNodeSelectorFromEvent(event);
        console.debug('monitorMouseUp: ' + mouseUpSelector.element);
        var mu = mouseUpSelector, md = mouseDownSelector;
        // update text selections
        updateSelection(event);
        if (config.isDragEnabled && checkDragEnded(event)) {
          return;
        }
        // Do not publish mouse up click because iOS 4.1 is buggy.
        if (!has('touch')) {
          if (mu && md && mu.element == md.element) {
            console.debug('monitorMouseUp: down target == up target ==> Click detected.');
            if (/(select|option)/i.test(el.nodeName)) {
              return true;  //clicks on select and option element are published onchange
            }
            var wrappedEvent = _collectEventData(event);
            wrappedEvent.type = 'click';
            wrappedEvent.currentTarget = event.currentTarget;
            // Create synthetic click event, if none is created automatically within 300ms
            // This is to also catch clicks that are stopped within their original event handlers
            _mouseDownUpClickTimeout = contextWindow.setTimeout(function () {
              monitorMouseClick(wrappedEvent);
            }, 300);
          }
        }
      }
    }
    function checkDragEnded(event) {
      if (leftMouseDownMoves && leftMouseDownMoves > 0) {
        console.log('DRAG ACTION DETECTED: ' + leftMouseDownMoves);
        monitorMouseDrag(event);
        leftMouseDownMoves = 0;
        leftMouseDown = null;
        return true;
      } else {
        console.log('NO DRAG ACTION DETECTED: ' + leftMouseDownMoves);
      }
      return false;
    }
    function updateSelection(event) {
      var rangyReady = false;
      try {
        rangy.init();
        rangyReady = true;
      } catch (e) {
        console.log('Failed to initialize Rangy. Cannot update selection. ' + e);
        rangyReady = false;
      }
      if (!rangyReady || !rangy.initialized) {
        return;
      }
      // check if rangy is initialized. On pages without a body element, rangy will not work, so just skip it
      if (typeof rangy.getSelection === 'undefined') {
        return;
      }
      var target = event.target;
      if (target) {
        var doc = target.ownerDocument;
        var win = doc.parentWindow || doc.defaultView;
        //dojoWindow.get(element.ownerDocument);
        contextWindow.setTimeout(function () {
          var selection = rangy.getSelection(win);
          //var doc = selection.win.document;
          // Store the existing selection as character ranges
          var ranges;
          try {
            ranges = selection.getAllRanges();
          } catch (e) {
            console.error('RANGY: Unable to get ranges: ' + e);
            return;
          }
          if (ranges.length > 0) {
            var range = ranges[0];
            var commonAncestor = range.commonAncestorContainer;
            try {
              // might be a text node
              while (commonAncestor.nodeType == 3) {
                commonAncestor = commonAncestor.parentNode;
              }
              var serializedRange;
              serializedRange = rangy.serializeRange(range, true, commonAncestor);
            } catch (e) {
              console.error('RANGY: Unable to serialize range: ' + e);
              return;
            }
            if (storedRange != serializedRange) {
              storedRange = serializedRange;
              var msg = {
                cssSelector: synchQuery.getNodeSelector(commonAncestor),
                range: serializedRange,
                senderId: config.userId,
                userName: config.userName || null
              };
              msg.type = type.SELECT;
              localEvents.emit(type.SELECT, msg);
            }
          }
        }, 1);
      }
    }
    function monitorSelectClicks(event) {
      // monitor changes on "select" elements and publish click
      // messages as a workaround since mouseClick Events on select<option
      // elements are not generated by some browsers including IE.
      if (synchEvent.isSimulated(event)) {
        return true;  //do not stop event propagation
      }
      var element = event.target || event.srcElement;
      if (!element) {
        // some synthetic events do not have a target, so do not monitor
        // those events
        return true;
      }
      var nodeName = element.nodeName.toLowerCase();
      if (nodeName == 'select') {
        //console.error("MONITOR SELECT CHANGE");
        var selectNode = element;
        if (Syn.data(selectNode, 'createChange')) {
          // This is a simulated click.
          console.info('Aborting replication of simulated onchange.');
          return true;  //do not stop event propagation
        }
        var optionState;
        if (selectNode.multiple && selectNode.options) {
          // multi select
          optionState = [];
          baseArray.forEach(selectNode.options, function (opt, index) {
            optionState[index] = opt.selected;
          });
        }
        // keys cannot be read in change events
        //                        if (event.ctrlKey) {
        //                            mouse.ctrlKey = true;
        //                        } else if (event.metaKey) {
        //                            mouse.metaKey = true;
        //                        }
        //  -1: none selected
        // >=0: index of selected item
        var selectedIndex = selectNode.selectedIndex;
        var selectedOption = selectNode.options[selectedIndex];
        var monitoredClick = {
          cssSelector: synchQuery.getNodeSelector(selectedOption || selectNode),
          senderId: config.userId,
          nOffset: {
            nx: 0.9,
            ny: 0.5
          },
          mouseEvent: { type: 'click' },
          preventMove: true,
          //do not wait for mouse to be moved over option
          type: type.CLICK
        };
        if (optionState) {
          monitoredClick.oS = optionState;
        }
        console.debug('publishing select change');
        // We need to make sure, that the primary (this) request reaches the
        // server before the secondary request.
        //
        contextWindow.setTimeout(function () {
          //maximum load time for new pages
          //Either timeout or allFramesLoaded enables cached responses
          if (synchWindow.hasInflightRequest('post')) {
            return false;
          }
          localEvents.emit(type.CLICK, monitoredClick);
        }, 25);
      }
    }
    function monitorMouseClick(evt, publishNow) {
      // We received an actual click event. So we remove the fallback timer, that triggers
      // an artificial mouse click, when mouseDown and mouseUp are detected on the same
      // node.
      if (_mouseDownUpClickTimeout) {
        contextWindow.clearTimeout(_mouseDownUpClickTimeout);
      }
      if (!evt) {
        console.warn('monitorMouseClick: Missing mouse click event object');
        return;
      }
      var target = synchEvent.getNodeFromEvent(evt);
      if (synchEvent.isSimulated(evt) || !monitorClicks) {
        //FIXED: Must be unobstrusive and always return the value of
        //       previously executed event handlers
        console.debug('Simulated Click Event Type: ' + evt.type);
        return synchEvent.previousReturnValue(evt);
      }
      // Must be after isSimulated, so simulated events are passed through
      if (synchQuery.isProtected(target) && config.isAgent && // field is protected and user is an agent AND
        _isButton(target)) {
        // field is an input button
        console.warn('CLICK IS BLOCKED. DATA-PROTECTED=>TRUE');
        baseEvent.stop(evt);
        //stop propagation and prevent default
        if (evt.stopImmediatePropagation) {
          evt.stopImmediatePropagation();
        }
        return false;
      }
      if (isExcluded('click', target)) {
        console.log('monitorMouseClick: Mouse Event is EXCLUDED');
        return;
      }
      // Create local click highlight
      if (profile.monitor.highlight) {
        // remote highlights are published via monitorMouseDown
        // setTimeout(function() {
        // Wrap in timeout so we do not block target of mouseUp Event
        // Do not wrap. IE8 has issues wrapping it.
        effects.localHighlight(target, evt, evt.ctrlKey);  //}, 10);
      }
      if (!profile.monitor.mouseClick) {
        // only highlight node but do not publish click event
        if (profile.blockEvents) {
          baseEvent.stop(evt);  // stopPropagation(); and preventDefault();
        }
        if (profile.handle.dom) {
          try {
            evt.preventDefault();
          } catch (e) {
            console.warn('Failed to stop event propagation');
          }
          return false;
        }
        // Only because clicks are not monitored it does not mean, we have to
        // block clicks entirely.
        return;
      }
      target = _closestElement(target);
      if (target === null) {
        console.warn('monitorMouseClick: Cannot get closest node. Probably a click in IE8 on VML?');
        return true;  //do not stop propagation
      }
      //                    if (domClass.contains(target, "ui-slider-handle")) {
      //                        return true;
      //                    }
      var nodeName = target.nodeName.toLowerCase();
      if (/option/i.test(nodeName) || /select/i.test(nodeName)) {
        // do not handle click events on select<option elements as these
        // are handled more consistently via select onchange events
        // e.g. via monitorChange
        // element == select in ie<=8 when actually clicking an
        // option in a select dropdown.
        // make sure we are really monitoring the change event
        var selectNode = synchQuery.closestParent(target, 'select');
        //query(target).closest("select");
        var isSelectMonitored = selectNode[strings.PROP_CHANGE_MONITORED];
        if (!isSelectMonitored) {
          on(selectNode, 'change', monitorSelectClicks);
          selectNode[strings.PROP_CHANGE_MONITORED] = true;
        }
        return true;
      }
      if (/object|embed/i.test(nodeName) && evt.monitoredBy != 'mousedown') {
        // mouse clicks on flash content are handled inconsistently
        // across browsers, so we use the mousedown event instead.
        // This is here to avoid duplicate events.
        return true;
      }
      if (isDuplicateEvent(evt, target)) {
        return;
      }
      console.log('monitorMouseClick on ' + nodeName);
      // Save MouseClick Information now and send it later
      lastMouseMove.target = target;
      var wrappedEvent = _collectEventData(evt);
      wrappedEvent.target = target;
      // must be before early exits
      var eventData = {};
      lang.mixin(eventData, wrappedEvent);
      eventData.preventDefault = evt.preventDefault;
      lastMouseMove.pageX = evt.pageX;
      lastMouseMove.pageY = evt.pageY;
      var parentAnchor = synchQuery.closestParent(target, 'a');
      if (parentAnchor) {
        // && /^a$/i.test(parentAnchor.nodeName)) {
        if (config.rewriteTargets) {
          synchWindow.rewriteLinkTarget(parentAnchor);
        }
        if (config.cobrowseEngine !== 'proxyless' && parserJavascript) {
          var loadsNewPage = parserJavascript.proxifyNodeHref(parentAnchor, evt);
          if (loadsNewPage) {
            //FIXED: Only uninitialize window, when we know that this link triggers a new page.
            var targetWindow = synchQuery.getTargetWindow(parentAnchor);
            page.emit(page.INTENDED_LOAD, {
              target: targetWindow,
              method: 'get'
            });
          }
        }
      }
      //console.debug("monitorMouseClick: " + target.nodeName);
      if (evt.metaKey || evt.ctrlKey) {
        // Do not open links in new tab when a special highlight (ctrl key down) is applied.
        _preventDefault(evt);
        return false;
      }
      // get all required mouse event details
      var msg;
      if (microDom.canAccessNode(eventData.target)) {
        msg = _collectMouseMessageData(eventData);
      } else {
        console.warn('emitMouseClick unable to access element');
        msg = {};
      }
      // calculate time difference since last mouse action
      msg.dT = timeSinceLastMouseAction();
      if (publishNow || config.cobrowseEngine === 'proxyless') {
        emitMouseClick(msg);
      } else {
        // We need to make sure, that the primary (this) request reaches the
        // server before the secondary request.
        // Wait 50ms before publishing the mouse click. Be extra cautious for clicks button, input submits and
        // anchors inside post form fields.
        var publishTimeout;
        if (_isButton(target) && synchQuery.closestParent(target, 'form')) {
          publishTimeout = 2000;
          console.warn('monitorMouseClick publishTimeout:' + publishTimeout);
        } else {
          publishTimeout = 50;
        }
        contextWindow.setTimeout(function () {
          emitMouseClick(msg);
        }, publishTimeout);
      }
      if (profile.handle.dom) {
        if (evt && evt.preventDefault) {
          evt.preventDefault();
        }
        return false;
      }
    }
    function monitorMouseDrag(upEvent) {
      var msg = _collectMouseMessageData(upEvent);
      msg.mouseEvent.type = 'drag';
      var downNode = leftMouseDown.target;
      msg.downSelector = leftMouseDown.selector;
      msg.downOffset = leftMouseDown.offset;
      var upNode = upEvent.target;
      var upOffsetNode = downNode === upNode ? downNode.offsetParent || downNode : upNode;
      msg.upSelector = synchQuery.getNodeSelector(upNode);
      msg.offsetSelector = synchQuery.getNodeSelector(upOffsetNode);
      msg.upOffset = microDom.getNormalizedMouseOffset(upOffsetNode, upEvent.pageX, upEvent.pageY);
      console.info('Drag Monitored: From=[' + msg.downOffset.ox + ', ' + msg.downOffset.oy + '] To =[' + msg.upOffset.ox + ', ' + msg.upOffset.oy + ']');
      // FIXES: IE10 MSPointerDown issue
      msg.type = type.DRAG;
      localEvents.emit(type.DRAG, msg);
    }
    function emitMouseClick(msg) {
      //var msg;
      //TODO : Remove the following IF CLAUSE
      //QUICK FIX For Citibank Autenticated space (Quick Link section)
      // Method assumes that Popup Window issues POST request (allFramesLoaded=false)
      if (synchroniteConfig.tenantId != 'liveperson') {
        //maximum load time for new pages
        //Either timeout or allFramesLoaded enables cached responses
        if (synchWindow.hasInflightRequest('post')) {
          // Important fix. We need to reset the mousedown selector for cancelled events.
          console.warn('NOT PUBLISHING MOUSE CLICK, because we think it triggered a POST request');
          mouseDownSelector = null;
          return false;
        }
      }
      // The event target is collected during on the mouseDown event,
      // because it might not be accessible anymore at this stage
      // (e.g. because the page is just being unloaded)
      if (mouseDownSelector) {
        msg.cssSelector = mouseDownSelector;
        console.debug('emitMouseClick: using mousedown selector: ' + mouseDownSelector.element);
        mouseDownSelector = null;
        mouseUpSelector = null;
      }
      // console.info("PUBLISHING CLICK: " + JSON.stringify(msg));
      msg.type = type.CLICK;
      localEvents.emit(type.CLICK, msg);
    }
    function emitMouseMove() {
      var target = lastMouseMove.target;
      var msg = {
        senderId: config.userId,
        userName: config.userName || null
      };
      if (microDom.canAccessNode(target)) {
        // adjust target in case the target is a product slideshow magnifier that
        // moves with the mouse, our relative approach does not work, so we use the
        // parent element instead.
        // Example: http://meinprofireinigungsgeraet.de/epages/Unger.sf/de_DE/?ObjectPath=/Shops/Unger/Products/AL00462
        target = _maybeAdjustMouseMoveTarget(target);
        _addOffsetAndSelector(msg, target, lastMouseMove.selector, lastMouseMove.pageX, lastMouseMove.pageY);
      } else {
        //Permission denied. Probably a new page was loaded.
        contextWindow.clearTimeout(throttleMouseMoveTimer);
        throttleMouseMoveTimer = null;
        console.warn('Unable to determine CSS Selector for node: ' + target.tagName);
        return false;
      }
      msg.dT = timeSinceLastMouseAction();
      msg.type = type.MOVE;
      localEvents.emit(type.MOVE, msg);
      contextWindow.clearTimeout(throttleMouseMoveTimer);
      throttleMouseMoveTimer = null;
    }
    //------------------- Scroll Event Handler -----------------------//
    function handleMouse(event, eventType) {
      var id = event.senderId;
      event.type = eventType;
      if (id != config.userId) {
        // init buffer for user id
        if (!mouseBuffer[id]) {
          mouseBuffer[id] = [];
        }
        // create articial move before click if necessary
        if (type.CLICK == eventType) {
          if (!event.preventMove) {
            if (profile.handle.mouseMove) {
              // should telepointer be moved to click target?
              var moveEvent = lang.clone(event);
              moveEvent.type = type.MOVE;
              moveEvent.mouseEvent.type = 'mouseMove';
              mouseBuffer[id].push(moveEvent);
            }
          }
        }
        //add msg to buffer
        mouseBuffer[id].push(event);
        //execute event in buffer
        var telepointerIsMoving = mouseMoveInProgress && moveMouse[event.senderId] !== null;
        if (!telepointerIsMoving) {
          //The senders telepointer is currently not moving, so execute next action at once.
          shiftMouseBuffer(id);
        } else {
          var next = mouseBuffer[id][0];
          if (next && (next.type == type.MOVE && !(next.type == type.CLICK || next.type == 'highlight' || next.type == type.SELECT))) {
            // The senders telepointer is moving but the next mouse operation
            // is also a mouse move, so execute that mouse move and update the pointers direction.
            shiftMouseBuffer(id);
          } else {
            console.debug('handleMouse called, but telepointer still moving for user: ' + id);
          }
        }
      }
    }
    function executeMouseOperation(event) {
      if (blockMouse) {
        shiftMouseBuffer(event.senderId);
        console.warn('Blocked mouse ' + event.type);
        return;
      }
      var mouseEvent = event.mouseEvent;
      if (event.type == type.CLICK) {
        if (!mouseEvent) {
          console.error('Incomplete mouse event: ' + event);
          return;
        }
        switch (mouseEvent.type) {
        case 'MSPointerDown':
        case 'mousedown':
        case 'touchstart':
          handleMouseDown(event);
          break;
        case 'MSPointerUp':
        case 'touchend':
        case 'mouseup':
          handleMouseUp(event);
          break;
        case 'click':
          handleMouseClick(event);
          break;
        case 'drag':
          handleMouseDrag(event);
          break;
        default:
          console.error('Unknown mouse event: ' + event.mouseEvent.type);
        }
        shiftMouseBuffer(event.senderId);
      } else if (event.type == type.MOVE) {
        handleMouseMove(event);
        if (!mouseMoveInProgress) {
          updateTelepointers();
        }
      } else if (event.type == type.DOWN) {
        handleHighlight(event);
        shiftMouseBuffer(event.senderId);
      } else if (event.type == type.SELECT) {
        handleSelect(event);
        shiftMouseBuffer(event.senderId);
      }
    }
    function shiftMouseBuffer(id) {
      if (mouseBuffer[id].length > 0) {
        // check if mouse action can be executed now, or if we have to wait
        // until target window is ready.
        var selector = mouseBuffer[id][0].cssSelector;
        if (!selector) {
          console.error('shiftMouseBuffer: cssSelector is missing. Droppping mouse event. ' + JSON.stringify(mouseBuffer[id][0]));
          dropMouseEvent(id);
        }
        if (synchWindow.isWindowInitialized(selector)) {
          waitForFrame = 0;
          var next = mouseBuffer[id].shift();
          if (next) {
            executeMouseOperation(next);
          }
        } else {
          waitForFrame += 750;
          if (waitForFrame > waitForFrameTimeout) {
            waitForFrame = 0;
            console.warn('Timeout occurred. Triggering frame reload.: ' + selector);
            if (allFramesLoaded && !_bufferMessages) {
              console.error('shiftMouseBuffer: cssSelector is missing. Droppping mouse event.' + JSON.stringify(mouseBuffer[id][0]));
              dropMouseEvent(id);  // TODO: synchComet.requestWindowState(selector);
            }
          } else {
            //try again in 300ms
            var selWinName = selector.windowName || selector.frameName;
            console.debug('Delaying Mouse Event, because frame [' + selWinName + '] has not finished loading: [' + waitForFrame + '<' + waitForFrameTimeout + ']');
            setTimeout(lang.hitch(this, shiftMouseBuffer, id), 750);
          }  //id not send?
        }
      }
    }
    function dropMouseEvent(id) {
      mouseBuffer[id].shift();
    }
    function handleSelect(data) {
      if (data.senderId != config.userId) {
        if (typeof data.range != 'undefined') {
          contextWindow.setTimeout(function () {
            var rootNode = synchQuery.queryElement(data.cssSelector);
            effects.highlightText(data.range, rootNode, data.senderId);
          }, 10);
        }
      }
    }
    function handleMouseUp(data) {
      //summary: visualizes the mouse up event but does not dispatch a synthetic event
      if (data.senderId != config.userId) {
        console.debug('Mouse Up Event: ' + data.cssSelector.element);
      }
    }
    function getInputFromLabel(element) {
      var input = query('input', element);
      if (!input.length && element.hasAttribute('for')) {
        var forAttr = element.getAttribute('for');
        input = query('#' + forAttr);
      }
      if (input.length) {
        return input[0];
      }
    }
    function handleMouseClick(data) {
      var element, clickOptions;
      var nodeName;
      var targetData;
      if (data.senderId != config.userId) {
        if (!profile.handle.mouseClick) {
          return;
        }
        // Time Synchronization is done on mousedown only.
        //_updateSynchronizedTime(data);
        targetData = _queryMouseTarget(data);
        if (targetData) {
          element = targetData.t;
          //                        if (element && element.id == "ui-menuitem-active") {
          //                            // COSMOS QUICKFIX
          //                            return true;
          //                        }
          console.debug('handleMouseClick: Found element nodeName=' + element.nodeName + ' for selector=' + data.cssSelector.element);
          if (config.cobrowseEngine === 'proxyless' && !config.isAgent && (synchQuery.isProtected(element) && _isButton(element) || /label/i.test(element.nodeName) && synchQuery.isProtected(getInputFromLabel(element)))) {
            console.warn('REPLICATE CLICK IS BLOCKED. DATA-PROTECTED=>TRUE');
            return;
          }
          try {
            // If the initial click on the remote client resulted
            // in an alert or confirm box to be displayed, the same
            // box MUST NOT be displayed again. Instead the decision
            // [clicked yes=true|no=false|ok=true] has to be remembered
            // and repeated automatically.
            if (data.decision === false || data.decision === true) {
              this.lastRemoteDecision = data.decision;
            }
            // This is required to make scrolling click in wikipedia chapters work
            var closestAnchor = synchQuery.closestParent(element, 'a');
            if (closestAnchor && !element.onclick) {
              element = closestAnchor;
              console.debug('Found parent anchor tag for click on: ' + data.cssSelector.element);  //                                    if (domClass.contains(closestAnchor, "ui-slider-handle")) {
                                                                                                   //                                        console.debug("STOP: Will not replicate click on ui-slider-handle");
                                                                                                   //                                        return;
                                                                                                   //                                    }
            }
            nodeName = element.tagName.toLowerCase();
            clickOptions = targetData.o;
            // Click offset
            //FIXED: Mouseclicks on elements that are invisible
            // (ePos = null) should not be replicated except for
            //  option and anchor tags.
            clickOptions.composed = data.mouseEvent.composed;
            if (clickOptions == {} && nodeName != 'option' && nodeName != 'a') {
              return;
            }
            //                            if (config.tenantId == "cosmos" && !/option/i.test(nodeName) && !_isVisible(element)) {
            //                                // COSMOS QUICKFIX
            //                                return true;
            //                            }
            if (nodeName == 'a') {
              if (config.rewriteTargets) {
                synchWindow.rewriteLinkTarget(element);
              }
              if (config.cobrowseEngine !== 'proxyless' && parserJavascript) {
                var loadsNewPage = parserJavascript.proxifyNodeHref(element);
                if (loadsNewPage) {
                  //FIXED: Only uninitialize window, when we know that this link probably triggers a new page.
                  var targetWindow = synchQuery.getTargetWindow(element);
                  page.emit(page.INTENDED_LOAD, {
                    target: targetWindow,
                    method: 'get'
                  });
                }
              }
            }
            if (/option|select/i.test(nodeName) && data.oS) {
              // multi select fields are special
              clickOptions.ctrlKey = true;
              clickOptions.metaKey = true;
              var selectNode = synchQuery.closestParent(element, 'select');
              var optionNodes = selectNode.options;
              var optionState = data.oS;
              if (optionNodes && optionNodes.length > 0) {
                baseArray.forEach(optionNodes, function (optionNode, index) {
                  // option is not selected locally
                  var asyncOptions = lang.clone(clickOptions);
                  asyncOptions.selected = optionState[index];
                  synClick(asyncOptions, optionNode);
                });
              }
              return;
            }
            // FIXME: The click must be more precise and include
            //        coordinates.
            // params: option, node, callback
            // This actually creates a mousedown, focus, mouseup, and click.
            synClick(clickOptions, element);  //console.debug(data.mouseEvent.type);
          } catch (e) {
            console.warn('MouseClick Exception, element: ' + data.cssSelector.element);
            console.warn(e);
          }
        } else {
          console.warn('handleMouseClick: element not found ' + data.cssSelector.element);
        }
      }
    }
    function handleMouseDown(event) {
      //summary: visualizes the mouse down event but does not dispatch a synthetic event
      if (event.senderId != config.userId) {
        console.debug('handleMouseDown: ' + event.cssSelector.element);
        _updateSynchronizedTime(event);
        var targetData = _queryMouseTarget(event);
        var node = targetData && targetData.t;
        if (node) {
          // Lesson learned: We cannot just blur the active element here. If the activeElement is blurred and
          // focus is not set on any other element on the page IE is moved to the background and is overlayed
          // by other windows.
          // NOTE: This is commented out because Syn.js already focusses elements
          //       as a part of "click" replication: mousedown-(focus)-mouseup-click
          // TODO: We need to detect if mousedown is part of a click event or not,
          //       but we cannot always replicate mousedown twice.
          //                            if (config.mousedownChangesFocus) {
          //                                if (Syn.isFocusable(node)) {
          //                                    //// FIXME! AVOID BACKSCROLLING.
          //                                    node.focus();
          //                                    console.info("Mouse Down Event: FOCUSSING " + node.tagName);
          //                                } else {
          //                                    try {
          //                                        var activeElement = node.ownerDocument.activeElement;
          //                                        console.info("Mouse Down Event: BLURRING ACTIVELEMENT " + activeElement.nodeName);
          //                                        activeElement.blur();
          //                                    } catch (e) {
          //                                        console.info("Unable to blur element.")
          //                                    }
          //                                }
          //                            }
          var wiggle = event.mouseEvent && event.mouseEvent.ctrlKey;
          effects.teleHighlight(node, event.senderId, wiggle);
        } else {
          console.debug('Mouse Down Event: CAN\'T FIND ELEMENT ');
        }
      }
    }
    function handleHighlight(event) {
      if (event.senderId != config.userId) {
        console.debug('handleHighlight: ' + event.cssSelector.element);
        _updateSynchronizedTime(event);
        var targetData = _queryMouseTarget(event);
        var node = targetData && targetData.t;
        if (node) {
          try {
            var wiggle = event.mouseEvent && event.mouseEvent.ctrlKey;
            effects.teleHighlight(node, event.senderId, wiggle);
          } catch (ignore) {
          }
        }
      }
    }
    function handleMouseMove(data) {
      var targetData;
      var targetElement;
      var senderId = data.senderId;
      //console.debug("mouse moved");
      if (senderId != config.userId) {
        try {
          targetData = _queryMouseTarget(data);
        } catch (e) {
          console.warn('Error querying mousetarget. Maybe the page has not finsihed loading yet: ' + e);
        }
        //console.debug("MOUSMOVE RECEIVED");
        if (!targetData || !targetData.t) {
          console.warn(data.cssSelector.element + ' not found!');
          return;
        }
        targetElement = targetData.t;
        var tagName = targetElement.tagName.toLowerCase();
        if (tagName == 'option') {
          return;
        }
        updateTelepointerTargetPosition(senderId, data.userName, targetElement, targetData.o, data.dT);
      }
    }
    // creates a mousemove event, but first triggering mouseout / mouseover if appropriate
    var LastHoveredNodes = null, hoverClass = 'sn_ps_hover', rhoverClassL = new RegExp('\\s*' + hoverClass), rhoverClassOnly = new RegExp('^\\s*' + hoverClass + '\\s*$'), hoverOn = config.hoverEmulation === 'on' || /noOldIE|limitedOldIE/.test(config.hoverEmulation) && has('ie') >= 9, hoverLimited = config.hoverEmulation === 'limitedOldIE' && has('ie') <= 8, classContains = domClass.contains, filterPseudoClass = config.filterPseudoClass;
    // This method is a modified version of mouseMove from drag.js
    // It adds the :hover effect.
    function synMouseMove(point, mouseOverNode, mouseOutNode) {
      var isProxylessMaster = config.cobrowseEngine == 'proxyless' && !config.isSlave;
      //mouseOverNode = elementFromPoint(point, element)
      if (mouseOutNode !== mouseOverNode && mouseOverNode && mouseOutNode) {
        //                console.debug("MouseOut:  " + mouseOutNode.nodeName); // +  " - " + mouseOutNode.outerHTML);
        //                console.debug("MouseOver: " + mouseOverNode.nodeName); //+ " - " + mouseOverNode.outerHTML);
        // 1. Simulate events
        var options = Syn.helpers.extend({}, point);
        options.relatedTarget = mouseOverNode;
        Syn.trigger('mouseout', options, mouseOutNode);
        options.relatedTarget = mouseOutNode;
        Syn.trigger('mouseover', options, mouseOverNode);
        if (hoverOn || hoverLimited) {
          // 2. PATCH add pseudo classes
          // REMOVE PSEUDO STYLE
          if (LastHoveredNodes) {
            LastHoveredNodes.forEach(function (node) {
              try {
                if (classContains(node, hoverClass)) {
                  // FIXED: We must not modify spacing in existing
                  // className attribute, so we cannot use dojo.
                  // e.g. dojoClass.remove(node, hoverClass);
                  if (rhoverClassOnly.test(node.className)) {
                    node.className = '';
                  } else {
                    //"classA classB classC"
                    node.className = node.className.replace(rhoverClassL, '');
                  }
                }
              } catch (e) {
                console.warn('Error removing pseudo styles: ', e);
              }
            });
          }
          // SET PSEUDO STYLE
          var currentList = [];
          if (!isProxylessMaster) {
            if (!hoverLimited || synchQuery.closestParent(mouseOverNode, 'a')) {
              currentList = getParents(mouseOverNode);
              currentList.push(mouseOverNode);
              currentList.forEach(function (node) {
                try {
                  if (node.className) {
                    if (!classContains(node, hoverClass) && (!filterPseudoClass || !classContains(node, filterPseudoClass))) {
                      // FIXED: We must not modify spacing in existing
                      // className attribute, so we cannot use dojo.
                      // e.g. dojoClass.add(node, hoverClass);
                      node.className += ' ' + hoverClass;
                    }
                  } else {
                    node.className = hoverClass;
                  }
                } catch (e) {
                  console.warn('Error setting pseudo styles: ', e);
                }
              });
            }
          }
          LastHoveredNodes = currentList;
        }
      }
      //console.debug("synMouseMove: " + point.clientX + ", " + point.clientY);
      // FF and Chrome automatically create pageX and pageY properties based on submitted
      // clientX and clientY values.
      // IE89 do NOT do this: http://yuilibrary.com/projects/yui3/ticket/2531581
      Syn.trigger('mousemove', point, mouseOverNode);
      return mouseOverNode;
    }
    function handleMouseDrag(data) {
      if (data.senderId != config.userId) {
        console.info('Mouse Drag Event: ' + JSON.stringify(data));
        var downNode = synchQuery.queryElement(data.downSelector);
        var downOffset = _realPosition(data.downOffset, downNode);
        var upOffsetNode = synchQuery.queryElement(data.offsetSelector);
        var upOffset = _realPosition(data.upOffset, upOffsetNode);
        console.info('Drag Handled: From=[' + downOffset.offsetX + ', ' + downOffset.offsetY + '] To=[' + upOffset.offsetX + ', ' + upOffset.offsetY + ']==page[' + upOffset.pageX + ', ' + upOffset.pageY + ']');
        var dragOptions = {
          from: downOffset,
          to: upOffset
        };
        dragOptions.adjust = false;
        dragOptions.duration = 0;
        blockMouse = true;
        // drag(to, from, callback)
        try {
          // Syn.trigger("mousedown", point, el || element)
          //                startMove(start, end, duration, element, function() {
          //                    createEventAtPoint("mouseup", end, element);
          //                    callback();
          //                })
          Syn.trigger('mousedown', downOffset, downNode);
          updateTelepointerTargetPosition(data.senderId, data.userName, downNode, upOffset, 100, true).then(function () {
            Syn.trigger('mouseup', upOffset, upOffsetNode);
            console.info('DRAG REPLICATED!');
            blockMouse = false;
          }, function (error) {
            console.error('Error occurred replicating the drag operation: ' + error);
          });
          // start mouse move if not already started
          if (!mouseMoveInProgress) {
            updateTelepointers();
          }
        } catch (e) {
          console.info('DRAG FAILED!');
          blockMouse = false;
        }
      }
    }
    function isVisible(el) {
      var rect = el.getBoundingClientRect();
      var visible = rect.bottom >= 0 && rect.top <= window.innerHeight;
      visible = visible && rect.right >= 0 && rect.left <= window.innerWidth;
      return visible;
    }
    function calculateMouseIndicationPosition(el) {
      var rect = el.getBoundingClientRect(), elemTop = rect.top, elemBottom = rect.bottom, elemLeft = rect.left, elemRight = rect.right;
      var position = {};
      if (elemTop >= window.innerHeight) {
        position.rotate = 180;
        if (isMenubarShown()) {
          position.top = window.innerHeight - 110;
        } else {
          position.top = window.innerHeight - 60;
        }
      } else if (elemBottom <= 0) {
        position.rotate = 0;
        if (isMenubarShown()) {
          position.top = 60;
        } else {
          position.top = 10;
        }
      } else {
        position.top = elemTop;
      }
      if (elemLeft >= window.innerWidth) {
        position.left = window.innerWidth - 60;
        position.rotate = 90;
      } else if (elemRight <= 0) {
        position.rotate = 270;
        position.left = 15;
      } else {
        position.left = elemLeft;
      }
      return position;
    }
    function updateTelepointers() {
      var _acceleration = 0.01;
      var _speedMax = 0.8;
      var _speedMin = 0.15;
      var atLeastOne = false;
      var idsToShift = [];
      if (moveMouse) {
        for (var id in moveMouse) {
          if (moveMouse.hasOwnProperty(id)) {
            try {
              var pointerData = moveMouse[id];
              // FIXED: Make sure this is really a mouse move property and not
              //        a nasty prototype array extension property
              if (pointerData && pointerData.currentPos) {
                var pointer = dom.byId(pointerData.pointerId);
                if (pointerData._speedCurrent < _speedMin) {
                  pointerData._speedCurrent = _speedMin;
                }
                if (pointerData._speedCurrent < _speedMax) {
                  pointerData._speedCurrent += _acceleration;
                } else {
                  pointerData._speedCurrent = _speedMax;
                }
                //                                if (pointerData.lastMouseOverNode) {
                //                                    console.info("lastOverElement: " + pointerData.lastMouseOverNode.tagName);
                //                                } else {
                //                                    console.info("lastOverElement: UNKNOWN");
                //                                }
                var deltaX = parseInt(pointerData.targetPos.x - pointerData.currentPos.x, 10);
                var deltaY = parseInt(pointerData.targetPos.y - pointerData.currentPos.y, 10);
                //                fraction = (now - startTime) / duration,
                //                options = {
                //                    clientX: distX * fraction + start.clientX,
                //                    clientY: distY * fraction + start.clientY
                //                };
                //                if (fraction < 1) {
                var s = parseInt(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 10);
                // TODO: Find more intelligent way of calculating this
                var frameOffsetY = isMenubarShown() ? 40 : 0;
                //if (top != window) {
                //    // elementFromPoint is relative to viewport
                //    var frameOff = synchFrames.frameOffset(document.documentElement, top);
                //    frameOffsetY = frameOff.y;
                //}
                // get the current mouseover element;
                var currentFromPoint = elementFromPoint({
                  clientX: pointerData.currentPos.x,
                  clientY: pointerData.currentPos.y - frameOffsetY
                }, pointerData.targetNode);
                // VERIFY LAST MOUSE OVER NODE IS BOTH VISIBLE
                // AND ACCESSIBLE
                try {
                  if (!pointerData.lastMouseOverNode || !microDom.isVisible(pointerData.lastMouseOverNode)) {
                    console.debug('updatePointer: Last Mouseover not found.');
                    pointerData.lastMouseOverNode = microDom.getBody(pointerData.targetNode.ownerDocument);
                  }
                } catch (e) {
                  console.warn('updateTelepointers: last mouse over node not accessible.');
                  pointerData.lastMouseOverNode = microDom.getBody(pointerData.targetNode.ownerDocument);
                }
                // SET CURRENT MOUSE OVER NODE
                if (currentFromPoint) {
                  // Best choice
                  pointerData.mouseOverNode = currentFromPoint;  //console.debug("Using best choice.");
                } else {
                  // Unable to determine last mouseOver node
                  // so take the last known one.
                  // Causes flashing hover in IE 9
                  // console.warn("Unable to determine mouseoverNode using elementFromPoint x=" + pointerData.currentPos.x + ",y=" + pointerData.currentPos.y );
                  if (pointerData.mouseOverNode) {
                    // Leave the current value unchanged.
                    console.info('mouseOverNode -> Leave the current value unchanged.');
                  } else {
                    // Pretend we are already over the target node.
                    pointerData.mouseOverNode = pointerData.targetNode;
                  }
                }
                var finalMove = s < 3;
                if (finalMove) {
                  pointerData.currentPos.x = pointerData.targetPos.x;
                  pointerData.currentPos.y = pointerData.targetPos.y;
                } else {
                  pointerData.currentPos.x += pointerData._speedCurrent * deltaX;
                  pointerData.currentPos.y += pointerData._speedCurrent * deltaY;
                }
                domStyle.set(pointer, 'left', pointerData.currentPos.x + 'px');
                domStyle.set(pointer, 'top', pointerData.currentPos.y + 'px');
                // create synthetic event.
                //console.info("MouseMove: " + JSON.stringify(pointerData.currentPos));
                var moveCoords = {
                  clientX: pointerData.currentPos.x,
                  clientY: pointerData.currentPos.y - 40
                };
                if (isClickInProgress() || config.disableMouseMove) {
                  // We must not move the mouse while a click is executed. This only happens in rare cases
                  // and with slow network connections. Fixes cosmosdirekt bug.
                  console.warn('Skipping mousemove/over/enter and pseudo hover event, b/c click is in progress.');
                } else {
                  synMouseMove(moveCoords, pointerData.mouseOverNode, // mouseOverNode
                  pointerData.lastMouseOverNode);  // mouseOutNode
                }
                //console.debug("move - current: " + current.nodeName + ", last: " + pointerData.lastMouseOverNode.nodeName);
                pointerData.lastMouseOverNode = pointerData.mouseOverNode;
                if (finalMove) {
                  // Finished mouse move
                  if (pointerData.promise) {
                    console.info('FINISHED MouseMove for ' + id);
                    pointerData.promise.resolve();
                  }
                  effects.updatePointerImage(id, pointerData.targetNode);
                  idsToShift.push(id);
                } else {
                  atLeastOne = true;
                }
                if (config.showTelepointerHint) {
                  if (isVisible(pointer)) {
                    var cobrowsePointerIndication = dom.byId('cobrowse-pointer-indication');
                    if (cobrowsePointerIndication) {
                      cobrowsePointerIndication.style.display = 'none';
                    }
                  } else {
                    var position = calculateMouseIndicationPosition(pointer);
                    effects.showMouseIndication(position, pointerData.userName);
                  }
                }
              }
            } catch (e) {
              if (pointerData.promise) {
                pointerData.promise.reject(e);
              }
              moveMouse[id] = null;
              console.warn('updateTelepointers with id ' + id + ' error:' + e);
              atLeastOne = false;
            }
          }
        }
      }
      if (atLeastOne) {
        mouseMoveInProgress = true;
        contextWindow.setTimeout(updateTelepointers, 25);  // 1000/25 = 40 frames per second
      } else {
        mouseMoveInProgress = false;
        for (var i = 0; i < idsToShift.length; i++) {
          //console.debug("Resting Telepointer for user: " + idsToShift[i]);
          //console.debug("Saving lastMouseOverNode = " + moveMouse[idsToShift[i]].mouseOverNode);
          moveMouse[idsToShift[i]].lastMouseOverNode = moveMouse[idsToShift[i]].mouseOverNode;
          moveMouse[idsToShift[i]].mouseOverNode = null;
          shiftMouseBuffer(idsToShift[i]);
        }
      }
    }
    function resetMouseReplicator() {
      // reset animations
      mouseMoveInProgress = false;
      contextWindow.clearTimeout(throttleMouseMoveTimer);
      throttleMouseMoveTimer = null;
    }
    function updateTelepointerTargetPosition(senderId, userName, toElement, toPosition, deltaTime, createPromise) {
      var dT = deltaTime || 25, pointerId = 'pointer-' + senderId, pointer = dom.byId(pointerId) || effects.createPointer(senderId, userName);
      if (toElement && pointer) {
        // console.info("New MouseTarget = " + JSON.stringify(toPosition) + " drag: " + !!createPromise);
        // var activeDocument = element.ownerDocument;
        //                        var activeWindow = dojoWin.get(activeDocument);
        //                        if (this.scrollAnim && this.scrollAnim.stop) {
        //                            this.scrollAnim.stop();
        //                            console.debug("mouseMove: Stopping Scroll");
        //                        }
        //                //FIXED: Uses dojo._docScroll, so must be executed in context of
        //                //       window to be scrolled.
        //                dojoBaseWindow.withGlobal(activeWindow, function(node, activeWindow) {
        //
        //                    var anim=dojox.fx.smoothScroll({
        //                        node: node,
        //                        win: activeWindow,
        //                        duration:150,
        //                        easing: dojo.fx.easing.sineOut,
        //                        onEnd: function() {
        //                            // Scroll Events are fired even after Animation has stopped
        //                            // so insert delay before resetting animation
        //                            this.win.setTimeout(function() {
        //                                console.debug("mouseMove: Ending Scroll");
        //                                this.scrollAnim=null;
        //                            }, 500);
        //                        }
        //                    });
        //
        //                    anim.play();
        //                    console.debug("mouseMove: Playing Scroll");
        //                }, this, [element, activeWindow]);
        //DO NOT REMOVE
        //dojoBaseWindow.withGlobal(activeWindow, this.scrollIntoView, this, [element]);
        var frameOff;
        if (isMenubarShown() && has('touch')) {
          frameOff = {
            x: 0,
            y: 40
          };
        } else {
          frameOff = synchFrames.frameOffset(toElement, window);
        }
        //console.debug("frameOff: [" + frameOff.x + ", " + frameOff.y + "]");
        //console.debug("realPos: [" + realPos.clientX + ", " + realPos.clientY + "]");
        if (!toPosition.clientX || !toPosition.clientY) {
          console.warn('Normalized Pos could not be determined.');
          //FIXED: Next event must be triggered, when this method is
          //       exited prematurely
          shiftMouseBuffer(senderId);
          return;
        }
        //console.debug("Handle Mouse Move: ", realPos);
        var oldPos = {
          x: domStyle.get(pointerId, 'left'),
          y: domStyle.get(pointerId, 'top')
        };
        var docScroll = domGeometry.docScroll();
        var targetPos = {
          x: toPosition.clientX + frameOff.x + docScroll.x,
          y: toPosition.clientY + frameOff.y + docScroll.y
        };
        //console.debug("ADJUSTING MOUSE TARGET!");
        moveMouse[senderId] = moveMouse[senderId] || {};
        moveMouse[senderId].targetPos = targetPos;
        moveMouse[senderId].currentPos = oldPos;
        moveMouse[senderId].pointerId = pointerId;
        moveMouse[senderId].targetNode = toElement;
        moveMouse[senderId].userName = userName;
        moveMouse[senderId].userId = senderId;
        moveMouse[senderId].dT = dT;
        moveMouse[senderId]._speedCurrent = 25 / moveMouse[senderId].dT;
        if (moveMouse[senderId].mouseOverNode) {
          // if pointer is currently moving save node
          moveMouse[senderId].lastMouseOverNode = moveMouse[senderId].mouseOverNode;  // reset current pointer
        }
        if (createPromise) {
          moveMouse[senderId].promise = new Deferred();
        }
        moveMouse[senderId].mouseOverNode = null;
        // reset current pointer
        if (dom.byId(pointerId)) {
          domStyle.set(dom.byId(pointerId), {
            opacity: 1,
            display: ''
          });
          contextWindow.clearTimeout(hidePointerTimer[pointerId]);
          var hidePointer = function () {
            if (dom.byId(pointerId)) {
              baseFx.fadeOut({
                node: pointerId,
                duration: 750,
                onEnd: function (node) {
                  domStyle.set(node, 'display', 'none');
                }
              }).play();
            } else {
              console.info('hidePointer: pointer has already been removed from dom.');
            }
          };
          hidePointerTimer[pointerId] = setTimeout(hidePointer, 120000);  //}
        }
      }
      if (createPromise) {
        return moveMouse[senderId].promise;
      }
    }
    //------------------- Syn.js Adapter functions -----------------------//
    // START: SUPPORT FOR SYNTHETIC EVENT QUEUING
    // We need to store a reference to the SynClickQueue in order to be able to chain mouse clicks that arrive
    // simultaneously. In other words, the click method needs to be executed on the same object.
    // Not chaining mouse actions results in kendo selectables / radio buttons not being checked on cosmosdirekt.de
    var isClickInProgress = function () {
      return synMouseQueue && synMouseQueue.queue && synMouseQueue.queue.length > 0 || _clickInProgress;
    };
    var getSynMouse = function () {
      if (isClickInProgress()) {
        console.warn('Wooohhaa! You managed to click faster than network latency. But don\'t worry. Event queueing will ensure clicks are executed correctly.');
        return synMouseQueue;
      } else {
        return Syn;
      }
    };
    var synClick = function (options, element) {
      var synMouse = getSynMouse();
      _clickInProgress = true;
      if (_clickInProgressTimeout) {
        contextWindow.clearTimeout(_clickInProgressTimeout);
      }
      try {
        synMouseQueue = synMouse.click(options, element, function () {
          _clickInProgress = false;
        });
        _clickInProgressTimeout = contextWindow.setTimeout(function () {
          _clickInProgress = false;
        }, 1000);
      } catch (e) {
        _clickInProgress = false;
      }
    };
    // END: SUPPORT FOR SYNTHETIC EVENT QUEUING
    //------------------- Utility functions -----------------------//
    /**
     *
     * @param target
     * @param eventType
     * @param listener
     * @param dontFix
     * @returns signal Call signal.remove() to remove event listener.
     * @private
     */
    function _addEvent(target, eventType, listener, dontFix) {
      var capture = true;
      if (has('dom-addeventlistener')) {
        if (eventType == 'click') {
          target.addEventListener(eventType, listener, capture);
          // create and return the signal
          return {
            remove: function () {
              target.removeEventListener(eventType, listener, capture);
            }
          };
        } else {
          return on(target, eventType, listener);
        }
      } else {
        // IE<9 uses DOM Level 0 event handlers like node.onclick
        // which can be overriden other event 0 handler on
        // the target page.
        //WARN: on._fixEvent is only present in ie8 when has("dom-addeventlistener")= false
        var fixedListener = function (evt) {
          if (!dontFix) {
            evt = on._fixEvent(evt, target);
          }
          return listener.call(this, evt);
        };
        target.attachEvent('on' + eventType, fixedListener);
        // create and return the signal
        return {
          remove: function () {
            target.detachEvent(eventType, fixedListener);
          }
        };
      }
    }
    function _closestElement(el) {
      if (el) {
        try {
          while (el.nodeType != 1 && // ELEMENT_NODE
            el.nodeType != 9 && // DOCUMENT_NODE
            el.nodeType != 11) {
            // DOCUMENT_FRAGMENT_NODE
            el = el.parentNode;
          }
          return el;
        } catch (e) {
          console.warn('Unable to get closest element: ' + e);
        }
      }
      return null;
    }
    function isExcluded(eventType, target) {
      if (target) {
        var doc = target.ownerDocument;
        if (synchQuery.closestAttr(target, strings.DATA_ATTR_NO + eventType)) {
          return true;
        }
        if (_excludeList.length > 0) {
          return baseArray.some(_excludeList, function (selector) {
            return query(selector, doc).indexOf(target) >= 0;
          });
        }
      }
      return false;
    }
    function _collectEventData(event) {
      //summary: wraps event object to avoid permission denied error when window has already unloaded.
      var wrappedEvent = {};
      wrappedEvent.type = event.type;
      wrappedEvent.composed = event.composed;
      wrappedEvent.canBubble = !!event.canBubble;
      wrappedEvent.cancelable = !!event.cancelable;
      wrappedEvent.screenX = event.screenX;
      wrappedEvent.screenY = event.screenY;
      wrappedEvent.clientX = event.clientX;
      wrappedEvent.clientY = event.clientY;
      wrappedEvent.pageX = event.pageX;
      wrappedEvent.pageY = event.pageY;
      wrappedEvent.ctrlKey = !!event.ctrlKey;
      wrappedEvent.altKey = !!event.altKey;
      wrappedEvent.shiftKey = !!event.shiftKey;
      wrappedEvent.metaKey = !!event.metaKey;
      wrappedEvent.button = event.button;
      //dojoMouse.isRight(event)
      wrappedEvent.target = _closestElement(event.target || event.srcElement);
      wrappedEvent.path = event.path;
      if (typeof event.ytState === 'number') {
        wrappedEvent.ytState = event.ytState;
      }
      if (event.ytState) {
        wrappedEvent.ytSeek = event.ytSeek;
      }
      return wrappedEvent;
    }
    function _collectMouseMessageData(event, pageX, pageY) {
      var eventTarget = event.target || event.srcElement;
      var closestTarget = _closestElement(eventTarget);
      if (!(pageX && pageY)) {
        pageX = event.pageX;
        pageY = event.pageY;
      }
      //var nOffset = event.nOffset || synchDom.getNormalizedMouseOffset(closestTarget, event.pageX, event.pageY);
      var msg = { mouseEvent: _collectEventData(event) };
      msg = _mixinUserData(msg);
      try {
        var synchronizedTime = _getSynchronizedTime();
        msg.sT = synchronizedTime;
      } catch (e) {
        console.debug('Error getting synchronized Time');
      }
      var selector = synchQuery.getNodeSelectorFromEvent(event);
      _addOffsetAndSelector(msg, closestTarget, selector, pageX, pageY);
      if (msg.mouseEvent.target) {
        delete msg.mouseEvent.target;
      }
      if (msg.mouseEvent.path) {
        delete msg.mouseEvent.path;
      }
      return msg;
    }
    function _mixinUserData(msg) {
      lang.mixin(msg, {
        userName: config.userName || null,
        senderId: config.userId
      });
      return msg;
    }
    function _preventDefault(event) {
      if (event.preventDefault) {
        event.preventDefault();
      } else {
        // IE9
        // The value of this property takes precedence over values returned
        // by the function, such as through a Microsoft JScript return statement.
        event.returnValue = false;
      }
    }
    function _isButton(node) {
      return /^(button|a)$/i.test(node.nodeName) || /input/i.test(node.nodeName) && /submit|button|reset|range|option|checkbox|radio/i.test(node.type) || /select/i.test(node.nodeName);
    }
    function isDuplicateEvent(event, target) {
      try {
        // Storing data inside the event object does not work in internet explorer.
        var stampAttr = 'data-' + event.type + 'Stamp';
        var stampNode = target;
        // Do not handle clicks on input radios or checkboxes that have labels because browsers will
        // implicitly trigger a click on the corresponding input for a click on the label. These must
        // be recognized as duplicate events (but only if the label for attribute is
        // specified).
        // More info:
        // http://stackoverflow.com/questions/1342658/ie-onclick-will-not-check-a-checkbox-unless-you-click-the-image-in-the-label
        //
        // Direct clicks on input fields do not trigger duplicate events.
        var labelNode = synchQuery.closestParent(target, 'label') || /input/i.test(target.nodeName) && target.id && query('label[for=' + synchQuery.escapeQuery(target.id) + ']', target.ownerDocument)[0];
        if (labelNode) {
          stampNode = labelNode;
        }
        var storedTimestampAttr = stampNode.getAttribute(stampAttr);
        // IE9, Chrome, FF have event.timeStamp, IE8 does not
        // Because of a bug open since 2004 FireFox gived inconsistent timeStamp
        // values, so we canot use event.timeStamp at all:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=238041
        //
        // Lesson learned:
        // For retargeted click events FireFox sets timeStamp == 0,
        // in Chrome and Safari event.detail is 0 for retargeted clicks.
        var timestamp = parseInt(new Date().getTime(), 10);
        if (storedTimestampAttr != null) {
          var storedTimestamp = parseInt(storedTimestampAttr, 10);
          var diff = Math.abs(storedTimestamp - timestamp);
          console.log('Time difference to previous event: ' + diff);
          if (diff < 300) {
            // reduced from 500
            // assume same event chain
            console.info('Second monitor in event chain');
            return true;
          }
        }
        //console.info("First monitor in event chain");
        stampNode.setAttribute(stampAttr, timestamp);
      } catch (e) {
        console.error('isDuplicateEvent: Unable to set event prop');
        console.error(e);
        return false;
      }
    }
    function _getSynchronizedTime() {
      var contentWindow = synchQuery.synchronizedWindow();
      if (contentWindow && contentWindow.synchTime) {
        return contentWindow.synchTime;
      }
      return null;
    }
    function _addOffsetAndSelector(msg, target, selector, pageX, pageY, omitFallback) {
      var offset;
      var fallbackTarget, fallbackOffset;
      // Add Offset and Target
      offset = microDom.getNormalizedMouseOffset(target, pageX, pageY);
      msg.cssSelector = selector || synchQuery.getNodeSelector(target);
      msg.nOffset = offset;
      if (!omitFallback) {
        // If this is a browser-specfic element look if there is a cover that represents a
        // common denominator for synchroniszing across different browsers.
        fallbackTarget = _fallbackNode(target);
        if (fallbackTarget) {
          fallbackOffset = microDom.getNormalizedMouseOffset(fallbackTarget, pageX, pageY);
        }
        if (fallbackTarget) {
          msg.fS = synchQuery.getNodeSelector(fallbackTarget);
          msg.fO = fallbackOffset;
        }
      }
    }
    function _fallbackNode(el) {
      var parentEl = el;
      try {
        if (el && el.tagName && /area/i.test(el.tagName)) {
          parentEl = el.parentNode;
          if (/map/i.test(parentEl.tagName)) {
            var img = synchQuery.getImageForMap(parentEl);
            if (img) {
              return img;
            }
          }
        }
        while (parentEl && // Element exists
          parentEl.nodeType != 9 && // DOCUMENT_NODE
          parentEl.nodeType != 11) {
          // DOCUMENT_FRAGMENT_NODE
          if (domClass.contains(parentEl, 'coverGraph') || parentEl.id == 'chart') {
            // schantz and cosmos charts
            return parentEl;
          } else {
            parentEl = parentEl.parentNode;
          }
        }
      } catch (e) {
        console.warn('Unable to get closest element: ' + e);
      }
      return null;
    }
    function _maybeAdjustMouseMoveTarget(target) {
      var useParent = false;
      var img, parentNode;
      if (target && target.tagName && /area/i.test(target.tagName)) {
        parentNode = target.parentNode;
        if (/map/i.test(parentNode.tagName)) {
          img = synchQuery.getImageForMap(parentNode);
          if (img) {
            return img;
          }
        }
      }
      if (mouseMoveUseParent && mouseMoveUseParent instanceof Array && mouseMoveUseParent.length > 0) {
        useParent = baseArray.some(mouseMoveUseParent, function (clsName) {
          return domClass.contains(target, clsName);
        });
      }
      return useParent ? target.parentNode : target;
    }
    function timeSinceLastMouseAction() {
      var deltaT;
      if (lastMouseMove.time > 0) {
        deltaT = new Date().getTime() - lastMouseMove.time;
      } else {
        deltaT = 25;
      }
      lastMouseMove.time = new Date().getTime();
      return deltaT;
    }
    function _updateSynchronizedTime(msg) {
      if (msg && msg.sT) {
        //sT = synchronizedTime
        var contentWindow = synchQuery.synchronizedWindow();
        if (contentWindow) {
          contentWindow.synchTime = parseInt(msg.sT, 10);
        }
      }
    }
    function _queryMouseTarget(data) {
      var target, offset;
      target = synchQuery.queryElement(data.cssSelector);
      if (target) {
        offset = _realPosition(data.nOffset, target);
        return {
          o: offset,
          t: target
        };
      }
      //Use fallbackTarget if present
      if (data.fS) {
        target = synchQuery.queryElement(data.fS);
        if (target) {
          offset = _realPosition(data.fO, target);
        }
        return {
          o: offset,
          t: target
        };
      }
      return null;
    }
    function _realPosition(normalizedOffset, element) {
      var doc = element.ownerDocument;
      var resetStyle, previousDisplay, previousVisibility;
      var elementStyle;
      var activeWindow = doc.parentWindow || doc.defaultView;
      //dojoWindow.get(element.ownerDocument);
      var realPos = {};
      if (!microDom.isVisible(element)) {
        if (element.firstChild && microDom.isVisible(element.firstChild)) {
          // Fallback for <a><img></a>
          element = element.firstChild;
        } else {
          // The element might only become visible when hovered. So to get the dimensions
          // we need to check if it is inside the dom make it visible for a short period.
          elementStyle = element.style;
          // do not reset this to you dojo/dom-style. We need to get only the style
          // that is directly set (inline) on this element.
          previousDisplay = elementStyle && elementStyle.display;
          previousVisibility = elementStyle && elementStyle.visibility;
          resetStyle = true;
          domStyle.set(element, {
            display: 'block',
            visibility: 'hidden'
          });
        }
      }
      var scrollOffset = baseWindow.withGlobal(activeWindow, 'docScroll', domGeometry);
      var p = domGeometry.position(element);
      if (!normalizedOffset) {
        console.warn('_realPosition: normalizedOffset not defined');
      }
      if (resetStyle) {
        // Remove the property or reset to previous value
        if (previousDisplay) {
          domStyle.set(element, 'display', previousDisplay);
        } else {
          if (elementStyle.removeProperty) {
            // Note: The removeProperty method is NOT supported in IE<9.
            elementStyle.removeProperty('display');
          }
        }
        if (previousVisibility) {
          domStyle.set(element, 'visibility', previousVisibility);
        } else {
          if (elementStyle.removeProperty) {
            // Note: The removeProperty method is NOT supported in IE<9.
            elementStyle.removeProperty('visibility');
          }
        }
      }
      realPos.offsetX = parseInt(p.w * normalizedOffset.nx, 10);
      realPos.offsetY = parseInt(p.h * normalizedOffset.ny, 10);
      realPos.clientX = realPos.offsetX + p.x;
      realPos.clientY = realPos.offsetY + p.y;
      realPos.pageX = realPos.clientX + scrollOffset.x;
      realPos.pageY = realPos.clientY + scrollOffset.y;
      return realPos;
    }
    function elementFromPoint(point, element) {
      var clientX = point.clientX, clientY = point.clientY, win = Syn.helpers.getWindow(element), el;
      if (!microDom.canAccessNode(element)) {
        // Check for IE8 "Access denied"
        console.warn('XSS: elementFromPoint: Unable to access element properties');
        return null;
      }
      if (!win) {
        return element;
      }
      if (Syn.support.elementFromPage) {
        // elementFromPoint is relative to page
        var off = Syn.helpers.scrollOffset(win);
        clientX += off.left;
        //convert to pageX
        clientY += off.top;  //convert to pageY
      }
      el = win.document.elementFromPoint ? win.document.elementFromPoint(clientX, clientY) : element;
      if (el === win.document.documentElement && (point.clientY < 0 || point.clientX < 0)) {
        console.warn('Using targetNode (bypoint).');
        return element;
      } else {
        return el;
      }
    }
    function getParents(node) {
      var nl = [];
      while (node.parentNode) {
        node = node.parentNode;
        nl.push(node);
      }
      return nl;
    }
    function exclude(eventType, target) {
      if (typeof target === 'string') {
        if (baseArray.indexOf(_excludeList, target) == -1) {
          _excludeList.push(target);
        }
      } else if (target) {
        target.setAttribute(strings.DATA_ATTR_NO + eventType, 'true');
      }
    }
    function _applyBuffer(buffer, stateTimestamp) {
      //description: Applies the buffer of messages that were cached while
      //    waiting for the serialized state.
      //buffer: Array: An Array of cached Bayeux messages
      //stateTimestamp: The Time the received state was serialized
      if (buffer.length > 0) {
        console.debug('Applying message buffer');
        //time random client serialized its state
        for (var i = 0; i < buffer.length; i++) {
          var data = buffer[i];
          //message received after state was serialized then apply operation
          if (data.syncTime > stateTimestamp) {
            //                    if (data.lock) {
            //                        this._handleLock(data);
            //                    } else if (data.method) {
            //                        this._handleOperation(data);
            //                    }
            console.debug(data);
          }
        }
      }
    }
    // EXPORTS
    /////////////////
    return {
      type: type,
      local: localEvents,
      remote: remoteEvents,
      exclude: exclude,
      bufferEvents: function () {
        _messageBuffer = [];
        _bufferMessages = true;
      },
      runBufferedEvents: function (data) {
        _bufferMessages = false;
        _applyBuffer(_messageBuffer, data.syncTime);
        _messageBuffer = [];
      },
      configure: function (_config) {
        profile = profile || _config.profile;
        Syn = Syn || _config.Syn;
        parserJavascript = parserJavascript || _config.parserJavascript;
        effects.configure(_config.store);
      },
      enableClickMonitoring: function () {
        console.debug('ENABLE CLICK MONITORING');
        monitorClicks = true;
      },
      disableClickMonitoring: function () {
        console.debug('DISABLE CLICK MONITORING');
        monitorClicks = false;
      },
      startListening: startListening,
      listeners: listeners,
      // exposed for testing only
      startReplicating: startReplicating,
      monitorMouseClick: monitorMouseClick,
      // Deprecated but required for proxy-based solution.
      registerNodesMouseClick: registerNodesMouseClick,
      resetMouseReplicator: resetMouseReplicator,
      stopListening: stopListening,
      /**
       * tearDown will remove listeners, stop mouse replication, and remove pointers from the dom.
       */
      tearDown: function (stopReplicating) {
        stopListening();
        if (stopReplicating) {
          resetMouseReplicator();
          effects.removePointers();
          baseArray.forEach(replicatorHandles, function (handle) {
            handle.remove();
          });
        }
      }
    };
  }(dojo__base_lang, dojo__base_window, dojo__base_event, dojo__base_array, dojo__base_fx, dojo_has, dojo_query, dojo_dom, dojo_dom_class, dojo_dom_style, dojo_dom_geometry, dojo_Deferred, dojo_on, dojo_Evented, dojo_touch, synchronite__base_query, synchronite_ui_effects, synchronite__base_event, synchronite__base_window, synchronite_micro_dom, synchronite__base_frames, synchronite__base_state, synchronite_page, synchronite_constants_strings, libs_rangy);
  dojo_debounce = function (cb, wait) {
    // summary:
    //		Create a function that will only execute after `wait` milliseconds
    // description:
    //		Create a function that will only execute after `wait` milliseconds
    //		of repeated execution. Useful for delaying some event action slightly to allow
    //		for rapidly-firing events such as window.resize, node.mousemove and so on.
    // cb: Function
    //		A callback to fire. Like hitch() and partial(), arguments passed to the
    //		returned function curry along to the original callback.
    // wait: Integer
    //		Time to spend caching executions before actually executing.
    var timer;
    return function () {
      if (timer) {
        clearTimeout(timer);
      }
      var self = this;
      var a = arguments;
      timer = setTimeout(function () {
        cb.apply(self, a);
      }, wait);
    };
  };
  synchronite_events_resize = function (lang, baseArray, has, domStyle, domClass, domGeometry, on, debounce, Evented, synchQuery, dom, state, constants, fx) {
    var contextWindow = window,
      // execution context window
      localEvents = new Evented(), remoteEvents = new Evented(), listeningHandles = [], replicatorHandle, profile = profile, lastDims, mobileScreenOverlayCreated = false, type = 'window:resize';
    // store window coordinates
    var screenX, screenY, windowMoveTimer;
    var maxHeight = 0;
    //------------------- Resize Listener Registration -----------------------//
    function startListening(rootCobrowseWindow) {
      if (!synchroniteConfig.resizeAgentsScreen) {
        return;
      }
      console.info('resize -  startListening()');
      if (rootCobrowseWindow) {
        contextWindow = rootCobrowseWindow;
      }
      baseArray.forEach(listeningHandles, function (handle) {
        handle.remove();
      });
      listeningHandles = [
        // throttle ensures listener is invoked only once every 300ms
        dom.addEvent(contextWindow, 'resize', debounce(monitorResize, 300)),
        localEvents.on('move', monitorResize),
        state.on('get', function (state) {
          if (state) {
            state.screenSize = getScreenDimensions();
            state.windowSize = getWindowDimensions();
          }
        }),
        state.on('set', function (state) {
          try {
          } catch (e) {
            console.error('Filed to set window size');
            console.error(e);
          }
          if (state.screenSize && state.windowSize) {
            setWindowDimensions(state);
          }
        })
      ];
      if (windowMoveTimer) {
        contextWindow.clearInterval(windowMoveTimer);
      }
      windowMoveTimer = contextWindow.setInterval(function () {
        var newX = contextWindow.screenX || contextWindow.screenLeft, newY = contextWindow.screenY || contextWindow.screenTop;
        if (screenX != newX || screenY != newY) {
          screenX = newX;
          screenY = newY;
          localEvents.emit('move', {
            screenX: newX,
            screenY: newY
          });
        }
      }, 500);
      monitorResize();
    }
    //only used by proxy-based solution so far
    function setWindowDimensions(params) {
      if (!(profile && profile.handle && profile.handle.resize)) {
        return true;
      }
      if (synchroniteConfig.isSlave && synchroniteConfig.cobrowseEngine === 'proxyless') {
        contextWindow = _getProxylessFrame().contentWindow;
      }
      var windowSize = params.windowSize, screenSize = params.screenSize;
      if (windowSize) {
        try {
          if (contextWindow.frameElement && dom.canAccessNode(contextWindow.frameElement)) {
            var frameElement = contextWindow.frameElement, parentNode = frameElement.parentNode, iframeContainerSize = domGeometry.position(parentNode);
            // need to do math.abs because values for top or left could be negative in multi monitor setups
            var screenHeight = screenSize.availHeight || screenSize.height, screenWidth = screenSize.availWidth || screenSize.width;
            var scaleY = (iframeContainerSize.h - windowSize.height) / (screenHeight - windowSize.height), scaleX = (iframeContainerSize.w - windowSize.width) / (screenWidth - windowSize.width);
            var windowTop = windowSize.top < 0 ? windowSize.top + screenHeight : windowSize.top, windowLeft = windowSize.left < 0 ? windowSize.left + screenWidth : windowSize.left;
            var l = Math.max(0, parseInt(windowLeft * scaleX, 10)), t = Math.max(0, parseInt(windowTop * scaleY, 10)), w = Math.min(iframeContainerSize.w, windowSize.width), h = Math.min(iframeContainerSize.h, windowSize.height);
            var props = {
              position: 'absolute',
              left: l + 'px',
              top: t + 'px',
              width: w + 'px',
              height: h + 'px'
            };
            console.info('setWindowDimensions ' + JSON.stringify(props));
            domClass.add(frameElement, 'iframeShadow');
            domStyle.set(frameElement, props);
          } else {
            // cobrowse window is not in an iframe. This would be the case
            // for cobrowse proxyless visitors (masters)
            contextWindow.resizeTo(windowSize.width, windowSize.height);
          }
        } catch (e) {
          console.warn('Exception setWindowDimensions. Probably the window is not accessible.');
        }
      }
    }
    function getWindowDimensions() {
      // see: http://stackoverflow.com/a/11744120
      var w = contextWindow, d = contextWindow.document, e = d.documentElement, g = d.body || d.getElementsByTagName('body')[0];
      if (w.innerHeight > maxHeight || e.clientHeight > maxHeight) {
        maxHeight = w.innerHeight;
        console.log('MaxHeight Set => ', maxHeight);
      }
      var windowDimensions = {
        left: w.screenX || w.screenLeft,
        top: w.screenY || w.screenTop,
        width: w.innerWidth || e.clientWidth || g.clientWidth,
        height: maxHeight
      };
      console.log('resize.js - windowDimensions-> ', windowDimensions);
      return windowDimensions;
    }
    function getScreenDimensions() {
      var winScreen = contextWindow.screen;
      var screenDimensions = {
        top: winScreen.top,
        left: winScreen.left,
        height: winScreen.height,
        width: winScreen.width,
        // The available width and height on the screen (excluding OS taskbars and such).
        // see: http://www.quirksmode.org/dom/w3c_cssom.html#t10
        availWidth: winScreen.availWidth,
        availHeight: winScreen.availHeight
      };
      return screenDimensions;
    }
    function monitorResize() {
      if (!(profile && profile.monitor && profile.monitor.resize)) {
        return true;
      }
      var resizeEvent = {
        screenSize: getScreenDimensions(),
        windowSize: getWindowDimensions(),
        userAgent: navigator.userAgent
      };
      console.debug('monitorResize ' + JSON.stringify(resizeEvent));
      resizeEvent.type = type;
      localEvents.emit(type, resizeEvent);
    }
    function createMobileOverlay(event) {
      _changeAgentsViewport(event.windowSize);
      if (mobileScreenOverlayCreated) {
        return;
      }
      var container = _getProxylessFrame();
      var borderImageURL = '/images/device_mockup.png';
      if (container) {
        container.style.top = '30px';
        container.style.opacity = 0;
        container.style.borderImage = 'url(' + borderImageURL + ') 70 stretch';
        container.style.borderImageWidth = '60px';
        container.style.borderTop = '35px';
        container.style.borderLeft = '14px';
        container.style.borderRight = '12px';
        container.style.borderBottom = '35px';
        container.style.borderColor = 'transparent';
        container.style.borderStyle = 'double';
        fx.fadeIn({ node: container }).play();
        mobileScreenOverlayCreated = true;
        domClass.remove(container, 'iframeShadow');
      }
    }
    function resetMobileOverlay() {
      var container = _getProxylessFrame();
      if (container) {
        container.style.borderImage = '';
        container.style.borderWidth = '0px';
      }
      mobileScreenOverlayCreated = false;
    }
    function isMobileBrowser(event) {
      var visitorUserAgent = event.userAgent;
      return /android|iPad|iPod|iPhone/i.test(visitorUserAgent);
    }
    function mobileOverlayFitsScreen(event) {
      return event.windowSize.width < window.innerWidth && event.windowSize.height < window.innerHeight - 60;
    }
    function isMobileOverlaySupported() {
      return has('IE') < 11 === false;
    }
    function handleResize(event) {
      if (synchroniteConfig.cobrowseEngine === 'proxyless') {
        lastDims = event;
        var isVisitorOnMobile = isMobileBrowser(event);
        var mobileOverlayEnabled = synchroniteConfig.enableMobileOverlay;
        var mobileOverlaySupported = isMobileOverlaySupported();
        if (mobileOverlayEnabled && isVisitorOnMobile && mobileOverlaySupported && mobileOverlayFitsScreen(event)) {
          synchroniteConfig.showTelepointerHint = false;
          createMobileOverlay(event);
        } else {
          synchroniteConfig.showTelepointerHint = true;
          resetMobileOverlay();
          _changeAgentsViewport(event.windowSize);
          //add a margin on top if we have enough space
          var frame = _getProxylessFrame();
          if (window.innerHeight - event.windowSize.height > 35 && event.windowSize.width <= window.innerWidth) {
            _animateTop(frame, 30);
          } else {
            _animateTop(frame, 0);
          }
        }
      } else {
        setWindowDimensions(event);
      }
    }
    function _changeAgentsViewport(dim) {
      var frame = _getProxylessFrame();
      frame.style.bottom = 'initial';
      if (dim.width <= window.innerWidth) {
        _animateWidth(frame, dim.width);
      } else {
        // using full width but not full height looks weird, so stretch height to height of window in this case
        _animateWidth(frame, dim.width + 25);
        _animateHeight(frame, window.innerHeight);
        return;
      }
      if (dim.height <= window.innerHeight) {
        _animateHeight(frame, dim.height);
      } else {
        _animateHeight(frame, window.innerHeight);
      }
    }
    function _animateWidth(node, width) {
      fx.animateProperty({
        node: node,
        properties: { width: width }
      }).play();
    }
    function _animateHeight(node, height) {
      fx.animateProperty({
        node: node,
        properties: { height: height }
      }).play();
    }
    function _animateTop(node, top) {
      fx.animateProperty({
        node: node,
        properties: { top: top }
      }).play();
    }
    /* idempotent */
    function startReplicating(_config) {
      if (!synchroniteConfig.resizeAgentsScreen) {
        return;
      }
      console.info('STARTREPLICATING resize events');
      var replicatorConfig = _config || {};
      if (replicatorConfig.remoteEvents) {
        remoteEvents = replicatorConfig.remoteEvents;
      }
      if (replicatorHandle) {
        replicatorHandle.remove();
      }
      replicatorHandle = remoteEvents.on(type, handleResize);
      dom.addEvent(contextWindow, 'resize', debounce(fitIframe, 500));
    }
    function fitIframe() {
      if (!has('ios')) {
        //ios forces all frames to be full width
        if (lastDims) {
          handleResize(lastDims);
          return;
        }
        if (synchroniteConfig.isSlave && synchroniteConfig.cobrowseEngine === 'proxyless') {
          contextWindow = _getProxylessFrame().contentWindow;
        }
        if (contextWindow.frameElement && dom.canAccessNode(contextWindow.frameElement)) {
          var frameElement = contextWindow.frameElement, parentNode = frameElement.parentNode, maxSize = domGeometry.position(parentNode), windowSize = getWindowDimensions();
          var cur;
          if (maxSize.w < windowSize.width) {
            cur = domStyle.set(frameElement, 'width');
            if (cur != '100%') {
              domStyle.set(frameElement, { width: '100%' });
            }
          }
          if (maxSize.h < windowSize.height) {
            cur = domStyle.set(frameElement, 'height');
            if (cur != '100%') {
              domStyle.set(frameElement, { height: '100%' });
            }
          }
        }
      }
    }
    function setDefaultSize() {
      _changeAgentsViewport({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    function _getProxylessFrame() {
      return document.getElementById(constants.cobrowsingFrameName);
    }
    // EXPORTS
    /////////////////
    return {
      type: type,
      local: localEvents,
      remote: remoteEvents,
      startListening: startListening,
      startReplicating: startReplicating,
      setDefaultSize: setDefaultSize,
      resetMobileOverlay: resetMobileOverlay,
      configure: function (_config) {
        profile = profile || _config.profile;
      }
    };
  }(dojo__base_lang, dojo__base_array, dojo_has, dojo_dom_style, dojo_dom_class, dojo_dom_geometry, dojo_on, dojo_debounce, dojo_Evented, synchronite__base_query, synchronite_micro_dom, synchronite__base_state, synchronite_constants_constants, dojo__base_fx);
  synchronite_events_focus = function (lang, baseEvent, has, domStyle, domClass, domGeometry, on, dom, debounce, Evented, dojoString, synchQuery, synchDom, fx, baseArray) {
    var localEvents = new Evented(), remoteEvents = new Evented(), listeningHandles = [], replicatorHandle, scrollHandle, type = 'focus', SYNCHRONITE_WIDGETS = 'synchronite-widgets', CATEGORY_UI_POINTERS = 'uiPointers', synConfig = window.synchroniteConfig, uiPointers = synConfig[CATEGORY_UI_POINTERS], fadeOutTimeoutRef, currentFocusedNode;
    var config, store;
    function startListening(_config) {
      config = _config;
      if (synConfig.synchronizeFocus) {
        stopListening();
        var doc = window.document;
        listeningHandles.push(baseEvent.on(doc, 'keyup', function (e) {
          if (e.which == 9 && !baseEvent.isSimulated(e)) {
            var selector = synchQuery.getNodeSelector(doc.activeElement);
            localEvents.emit(type, {
              target: selector,
              userId: config.userId,
              userName: synConfig.userName
            });
          }
        }));
      }
    }
    function configure(_config) {
      config = _config;
      store = config.store;
    }
    function startReplicating() {
      if (synConfig.synchronizeFocus) {
        stopReplicating();
        replicatorHandle = remoteEvents.on(type, replicateFocus);
      }
    }
    function listenToScroll() {
      if (scrollHandle) {
        scrollHandle.remove();
      }
      var reposition = debounce(function () {
        if (currentFocusedNode) {
          repositionOverlay(currentFocusedNode, false);
        }
      }, 10);
      var win = dom.byId('displayContent').contentWindow;
      scrollHandle = baseEvent.on(win, 'scroll', reposition);
      baseEvent.on(window, 'resize', reposition);
    }
    function _getScrollTop() {
      var doc = window.document;
      return Math.max(doc.documentElement.scrollTop, doc.body.scrollTop);
    }
    function _getColorByUserId(userId) {
      var color = '#FFEB53';
      if (userId && uiPointers && uiPointers.useCustom) {
        var userEntry = store.get(userId);
        if (userEntry && userEntry.color && /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(userEntry.color)) {
          color = userEntry.color;
        }
      }
      return color;
    }
    function replicateFocus(msg) {
      var node = synchQuery.queryElement(msg.target);
      var container = dom.byId(SYNCHRONITE_WIDGETS) || synchDom.create('div', { id: SYNCHRONITE_WIDGETS }, document.body);
      if (!node || node && node.tagName === 'HTML') {
        //hide the overlay if we don't find the element (may be hidden on agent side) or if the focus is on the HTML element
        hideOverlay();
      } else if (node) {
        currentFocusedNode = node;
        clearTimeout(fadeOutTimeoutRef);
        var color = _getColorByUserId(msg.userId), username = msg.userName, el = dom.byId('cobrowse-focus-highlight');
        if (!el) {
          var html = synchDom.toDom('<div style="border-color: ' + color + '" id="cobrowse-focus-highlight" class="cobrowse-focus-highlight" class="ignoreDOM">' + '<div class="cobrowse-focus-label-container"><span style="background-color: ' + color + '" class="cobrowse-focus-label">' + username + '</span></div>' + '</div>');
          container.appendChild(html);
        }
        repositionOverlay(node, true);
      }
    }
    function repositionOverlay(node, animate) {
      var el = dom.byId('cobrowse-focus-highlight');
      var pos = node.getBoundingClientRect(), scrollTop = _getScrollTop(), top = pos.top + scrollTop;
      // if agent's view is resized, content frame might be smaller than viewport.
      // => calculate possible offset and add it
      var containerPos = dom.byId('displayContent').getBoundingClientRect(), offsetTop = containerPos.top, offsetLeft = containerPos.left > 0 ? containerPos.left : 0;
      var OFFSET = 3;
      // used to have a small margin between the element and the overlay
      var props = {
        top: top + offsetTop - OFFSET,
        left: pos.left + offsetLeft - OFFSET,
        width: pos.width + OFFSET,
        height: pos.height + OFFSET
      };
      if (animate) {
        fx.fadeIn({ node: el }).play();
        fx.animateProperty({
          node: el,
          properties: props,
          duration: 250
        }).play();
        fadeOutTimeoutRef = setTimeout(hideOverlay, 120000);
      } else {
        domStyle.set(el, 'top', props.top + 'px');
        domStyle.set(el, 'left', props.left + 'px');
        domStyle.set(el, 'width', props.width + 'px');
        domStyle.set(el, 'height', props.height + 'px');
      }
    }
    function hideOverlay() {
      var el = dom.byId('cobrowse-focus-highlight');
      if (el) {
        fx.fadeOut({
          node: el,
          onEnd: function () {
            currentFocusedNode = null;
          }
        }).play();
      }
    }
    function stopListening() {
      baseArray.forEach(listeningHandles, function (handle) {
        handle.remove();
      });
    }
    function stopReplicating() {
      if (replicatorHandle) {
        replicatorHandle.remove();
      }
      if (scrollHandle) {
        scrollHandle.remove();
      }
    }
    // EXPORTS
    /////////////////
    return {
      type: type,
      local: localEvents,
      remote: remoteEvents,
      startListening: startListening,
      listenToScroll: listenToScroll,
      startReplicating: startReplicating,
      stopListening: stopListening,
      stopReplicating: stopReplicating,
      hideOverlay: hideOverlay,
      configure: configure
    };
  }(dojo__base_lang, synchronite__base_event, dojo_has, dojo_dom_style, dojo_dom_class, dojo_dom_geometry, dojo_on, dojo_dom, dojo_debounce, dojo_Evented, dojo_string, synchronite__base_query, synchronite_micro_dom, dojo__base_fx, dojo__base_array);
  synchronite_ui_typing = function (has, dojoDom, domStyle, dojoGeometry, dojoBaseWindow, dojoFx, i18next, synchFrames, synchQuery) {
    var CATEGORY_UI_SESSION = 'uiSession';
    var CATEGORY_UI_POINTERS = 'uiPointers';
    var config = synchroniteConfig, uiSessionConfig = config[CATEGORY_UI_SESSION], uiPointers = config[CATEGORY_UI_POINTERS];
    /////////////////////////////////////////////////////////
    // HAS.JS Feature tests for EMOJI support in the browser
    //////////////////////////////////////////////////////////
    // Add dojo has tests to see if we can use UTF8 emojis
    has.add('canvas', function (global, doc) {
      var elem = doc.createElement('canvas');
      return !!(elem.getContext && elem.getContext('2d'));
    });
    has.add('canvastext', function (global, doc) {
      if (!has('canvas')) {
        return false;
      }
      return typeof doc.createElement('canvas').getContext('2d').fillText == 'function';
    });
    has.add('emoji', function (global, doc) {
      if (!has('canvastext')) {
        return false;
      }
      var node = doc.createElement('canvas'), ctx = node.getContext('2d');
      ctx.fillStyle = '#f00';
      ctx.textBaseline = 'top';
      ctx.font = '32px Arial';
      ctx.fillText('\uD83D\uDC28', 0, 0);
      // U+1F428 KOALA
      return ctx.getImageData(16, 16, 1, 1).data[0] !== 0;
    });
    var MARKUP_FILTER = /(<|>)/gi;
    var _typingAnims = [];
    // see: http://www.charbase.com/1f512-unicode-lock
    var serverUrl = config.serverUrl || 'https://' + config.tenantHost;
    var emojiLock = '&#x1f512;';
    var imageLock = '<img src=\'' + serverUrl + '/images/iconLock.png\' alt=\'typing indicator\'>';
    var SYMBOL_LOCK = has('emoji') ? emojiLock : imageLock;
    var _getColor = function (userId) {
      var color = uiSessionConfig.highlightColor;
      //        var pointersConfig = synchroniteConfig.uiPointers;
      // DISABLING CUTOM COLORS FOR NOW
      //        if (pointersConfig && pointersConfig.useCustom) {
      //            var userEntry = this.store.get(userId);
      //            if (userEntry) {
      //                color = userEntry.color;
      //            }
      //        }
      return color;
    };
    var _createIndicator = function (activeBody, id, left, top, text, color) {
      var activeDoc = activeBody.ownerDocument, indicator;
      indicator = activeDoc.createElement('div');
      domStyle.set(indicator, {
        background: color + ' no-repeat scroll 0%',
        position: 'absolute',
        left: left + 'px',
        top: top + 'px',
        lineHeight: '20px',
        fontStyle: 'italic',
        fontWeight: 'bold',
        font: '11px/1.5 \'Helvetica Neue\', Helvetica, Arial, sans-serif',
        display: 'inline',
        margin: 0,
        padding: '1px',
        zIndex: 7001,
        opacity: 0,
        border: '1px solid #dddddd',
        color: '#222'
      });
      indicator.id = id;
      indicator.innerHTML = text;
      indicator.className = 'ignoreDOM';
      activeBody.appendChild(indicator);
      return indicator;
    };
    var showIndicator = function (element, userName, userId, isProtected) {
      isProtected = isProtected || synchQuery.isProtected(element);
      var cleanUsername = userName.replace(MARKUP_FILTER, '');
      var typingIndicatorId = 'typing-' + element.id;
      var activeDocument = element.ownerDocument;
      var activeWindow = activeDocument.defaultView || activeDocument.parentWindow;
      var activeBody = activeDocument.body || activeDocument.getElementsByTagName[0];
      var frameOffset = synchFrames.frameOffset(element, activeWindow);
      var ePos = dojoBaseWindow.withGlobal(activeWindow, dojoGeometry.position, dojoGeometry, [
        element,
        true
      ]);
      var bPos = dojoBaseWindow.withGlobal(activeWindow, dojoGeometry.position, dojoGeometry, [
        activeBody,
        true
      ]);
      // name must be escaped to prevent XSS attacks
      var text = '';
      if (isProtected) {
        text = SYMBOL_LOCK;
      }
      text += ' ' + cleanUsername.replace(MARKUP_FILTER, '') + ' ' + i18next.t('IS_TYPING', { ns: ['session'] });
      var tiTop = frameOffset.y + ePos.y - 22;
      if (tiTop < 0) {
        tiTop = frameOffset.y + ePos.y + ePos.h;
      }
      if (bPos.y > 0) {
        tiTop -= bPos.y;  // fixes strange issue on jcpenney checkout page
      }
      var color = _getColor(userId);
      var tiLeft = frameOffset.x + ePos.x;
      var typingIndicatorDiv = dojoDom.byId(typingIndicatorId, activeDocument) || _createIndicator(activeBody, typingIndicatorId, tiLeft, tiTop, text, color);
      typingIndicatorDiv.innerHTML = text;
      domStyle.set(typingIndicatorDiv, {
        opacity: 1,
        display: 'inline',
        top: tiTop + 'px'  // might change so always update it
      });
      if (_typingAnims[typingIndicatorId]) {
        _typingAnims[typingIndicatorId].stop();
        _typingAnims[typingIndicatorId].play();
      } else {
        _typingAnims[typingIndicatorId] = dojoFx.fadeOut({
          duration: 250,
          delay: 1500,
          node: typingIndicatorDiv,
          onEnd: function () {
            domStyle.set(this.node, 'display', 'none');
            _typingAnims[typingIndicatorId] = null;
          }
        }).play();
      }
    };
    return { show: showIndicator };
  }(dojo_has, dojo_dom, dojo_dom_style, dojo_dom_geometry, dojo__base_window, dojo__base_fx, i18next_loader, synchronite__base_frames, synchronite__base_query);
  transpiled_node_modules_ua_parser = function (i) {
    var e = {};
    function o(r) {
      if (e[r])
        return e[r].exports;
      var n = e[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return i[r].call(n.exports, n, n.exports, o), n.l = !0, n.exports;
    }
    return o.m = i, o.c = e, o.d = function (i, e, r) {
      o.o(i, e) || Object.defineProperty(i, e, {
        enumerable: !0,
        get: r
      });
    }, o.r = function (i) {
      'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(i, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(i, '__esModule', { value: !0 });
    }, o.t = function (i, e) {
      if (1 & e && (i = o(i)), 8 & e)
        return i;
      if (4 & e && 'object' == typeof i && i && i.__esModule)
        return i;
      var r = Object.create(null);
      if (o.r(r), Object.defineProperty(r, 'default', {
          enumerable: !0,
          value: i
        }), 2 & e && 'string' != typeof i)
        for (var n in i)
          o.d(r, n, function (e) {
            return i[e];
          }.bind(null, n));
      return r;
    }, o.n = function (i) {
      var e = i && i.__esModule ? function () {
        return i.default;
      } : function () {
        return i;
      };
      return o.d(e, 'a', e), e;
    }, o.o = function (i, e) {
      return Object.prototype.hasOwnProperty.call(i, e);
    }, o.p = '', o(o.s = 0);
  }([
    function (i, e, o) {
      (function (i) {
        var r;
        function n(i) {
          return (n = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (i) {
            return typeof i;
          } : function (i) {
            return i && 'function' == typeof Symbol && i.constructor === Symbol && i !== Symbol.prototype ? 'symbol' : typeof i;
          })(i);
        }
        !function (a, t) {
          'use strict';
          var s = 'model', b = 'name', l = 'type', w = 'vendor', d = 'version', u = 'mobile', c = 'tablet', m = 'smarttv', p = function (i) {
              for (var e = {}, o = 0; o < i.length; o++)
                e[i[o].toUpperCase()] = i[o];
              return e;
            }, f = function (i, e) {
              return 'string' === n(i) && -1 !== h(e).indexOf(h(i));
            }, h = function (i) {
              return i.toLowerCase();
            }, v = function (i, e) {
              if ('string' === n(i))
                return i = i.replace(/^\s\s*/, ''), 'undefined' === n(e) ? i : i.substring(0, 350);
            }, g = function (i, e) {
              for (var o, r, a, t, s, b, l = 0; l < e.length && !s;) {
                var w = e[l], d = e[l + 1];
                for (o = r = 0; o < w.length && !s;)
                  if (s = w[o++].exec(i))
                    for (a = 0; a < d.length; a++)
                      b = s[++r], 'object' === n(t = d[a]) && t.length > 0 ? 2 === t.length ? 'function' == n(t[1]) ? this[t[0]] = t[1].call(this, b) : this[t[0]] = t[1] : 3 === t.length ? 'function' !== n(t[1]) || t[1].exec && t[1].test ? this[t[0]] = b ? b.replace(t[1], t[2]) : void 0 : this[t[0]] = b ? t[1].call(this, b, t[2]) : void 0 : 4 === t.length && (this[t[0]] = b ? t[3].call(this, b.replace(t[1], t[2])) : void 0) : this[t] = b || void 0;
                l += 2;
              }
            }, x = function (i, e) {
              for (var o in e)
                if ('object' === n(e[o]) && e[o].length > 0) {
                  for (var r = 0; r < e[o].length; r++)
                    if (f(e[o][r], i))
                      return '?' === o ? void 0 : o;
                } else if (f(e[o], i))
                  return '?' === o ? void 0 : o;
              return i;
            }, k = {
              ME: '4.90',
              'NT 3.11': 'NT3.51',
              'NT 4.0': 'NT4.0',
              2000: 'NT 5.0',
              XP: [
                'NT 5.1',
                'NT 5.2'
              ],
              Vista: 'NT 6.0',
              7: 'NT 6.1',
              8: 'NT 6.2',
              8.1: 'NT 6.3',
              10: [
                'NT 6.4',
                'NT 10.0'
              ],
              RT: 'ARM'
            }, y = {
              browser: [
                [/\b(?:crmo|crios)\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Chrome'
                  ]
                ],
                [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Edge'
                  ]
                ],
                [
                  /(opera mini)\/([-\w\.]+)/i,
                  /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                  /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [/opios[\/ ]+([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Opera Mini'
                  ]
                ],
                [/\bopr\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Opera'
                  ]
                ],
                [
                  /(kindle)\/([\w\.]+)/i,
                  /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                  /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                  /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                  /(?:ms|\()(ie) ([\w\.]+)/i,
                  /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                  /(weibo)__([\d\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'UCBrowser'
                  ]
                ],
                [
                  /microm.+\bqbcore\/([\w\.]+)/i,
                  /\bqbcore\/([\w\.]+).+microm/i
                ],
                [
                  d,
                  [
                    b,
                    'WeChat(Win) Desktop'
                  ]
                ],
                [/micromessenger\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'WeChat'
                  ]
                ],
                [/konqueror\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Konqueror'
                  ]
                ],
                [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                [
                  d,
                  [
                    b,
                    'IE'
                  ]
                ],
                [/yabrowser\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Yandex'
                  ]
                ],
                [/(avast|avg)\/([\w\.]+)/i],
                [
                  [
                    b,
                    /(.+)/,
                    '$1 Secure Browser'
                  ],
                  d
                ],
                [/\bfocus\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Firefox Focus'
                  ]
                ],
                [/\bopt\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Opera Touch'
                  ]
                ],
                [/coc_coc\w+\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Coc Coc'
                  ]
                ],
                [/dolfin\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Dolphin'
                  ]
                ],
                [/coast\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Opera Coast'
                  ]
                ],
                [/miuibrowser\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'MIUI Browser'
                  ]
                ],
                [/fxios\/([-\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Firefox'
                  ]
                ],
                [/\bqihu|(qi?ho?o?|360)browser/i],
                [[
                    b,
                    '360 Browser'
                  ]],
                [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                [
                  [
                    b,
                    /(.+)/,
                    '$1 Browser'
                  ],
                  d
                ],
                [/(comodo_dragon)\/([\w\.]+)/i],
                [
                  [
                    b,
                    /_/g,
                    ' '
                  ],
                  d
                ],
                [
                  /(electron)\/([\w\.]+) safari/i,
                  /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                  /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [
                  /(metasr)[\/ ]?([\w\.]+)/i,
                  /(lbbrowser)/i,
                  /\[(linkedin)app\]/i
                ],
                [b],
                [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                [
                  [
                    b,
                    'Facebook'
                  ],
                  d
                ],
                [
                  /safari (line)\/([\w\.]+)/i,
                  /\b(line)\/([\w\.]+)\/iab/i,
                  /(chromium|instagram)[\/ ]([-\w\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [/\bgsa\/([\w\.]+) .*safari\//i],
                [
                  d,
                  [
                    b,
                    'GSA'
                  ]
                ],
                [/headlesschrome(?:\/([\w\.]+)| )/i],
                [
                  d,
                  [
                    b,
                    'Chrome Headless'
                  ]
                ],
                [/ wv\).+(chrome)\/([\w\.]+)/i],
                [
                  [
                    b,
                    'Chrome WebView'
                  ],
                  d
                ],
                [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                [
                  d,
                  [
                    b,
                    'Android Browser'
                  ]
                ],
                [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                [
                  b,
                  d
                ],
                [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                [
                  d,
                  [
                    b,
                    'Mobile Safari'
                  ]
                ],
                [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                [
                  d,
                  b
                ],
                [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                [
                  b,
                  [
                    d,
                    x,
                    {
                      '1.0': '/8',
                      1.2: '/1',
                      1.3: '/3',
                      '2.0': '/412',
                      '2.0.2': '/416',
                      '2.0.3': '/417',
                      '2.0.4': '/419',
                      '?': '/'
                    }
                  ]
                ],
                [/(webkit|khtml)\/([\w\.]+)/i],
                [
                  b,
                  d
                ],
                [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                [
                  [
                    b,
                    'Netscape'
                  ],
                  d
                ],
                [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                [
                  d,
                  [
                    b,
                    'Firefox Reality'
                  ]
                ],
                [
                  /ekiohf.+(flow)\/([\w\.]+)/i,
                  /(swiftfox)/i,
                  /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                  /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                  /(firefox)\/([\w\.]+)/i,
                  /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                  /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                  /(links) \(([\w\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [/(cobalt)\/([\w\.]+)/i],
                [
                  b,
                  [
                    d,
                    /master.|lts./,
                    ''
                  ]
                ]
              ],
              cpu: [
                [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                [[
                    'architecture',
                    'amd64'
                  ]],
                [/(ia32(?=;))/i],
                [[
                    'architecture',
                    h
                  ]],
                [/((?:i[346]|x)86)[;\)]/i],
                [[
                    'architecture',
                    'ia32'
                  ]],
                [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                [[
                    'architecture',
                    'arm64'
                  ]],
                [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                [[
                    'architecture',
                    'armhf'
                  ]],
                [/windows (ce|mobile); ppc;/i],
                [[
                    'architecture',
                    'arm'
                  ]],
                [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                [[
                    'architecture',
                    /ower/,
                    '',
                    h
                  ]],
                [/(sun4\w)[;\)]/i],
                [[
                    'architecture',
                    'sparc'
                  ]],
                [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],
                [[
                    'architecture',
                    h
                  ]]
              ],
              device: [
                [/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],
                [
                  s,
                  [
                    w,
                    'Samsung'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                  /samsung[- ]([-\w]+)/i,
                  /sec-(sgh\w+)/i
                ],
                [
                  s,
                  [
                    w,
                    'Samsung'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\((ip(?:hone|od)[\w ]*);/i],
                [
                  s,
                  [
                    w,
                    'Apple'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /\((ipad);[-\w\),; ]+apple/i,
                  /applecoremedia\/[\w\.]+ \((ipad)/i,
                  /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
                ],
                [
                  s,
                  [
                    w,
                    'Apple'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/(macintosh);/i],
                [
                  s,
                  [
                    w,
                    'Apple'
                  ]
                ],
                [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                [
                  s,
                  [
                    w,
                    'Huawei'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /(?:huawei|honor)([-\w ]+)[;\)]/i,
                  /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
                ],
                [
                  s,
                  [
                    w,
                    'Huawei'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /\b(poco[\w ]+)(?: bui|\))/i,
                  /\b; (\w+) build\/hm\1/i,
                  /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                  /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                  /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
                ],
                [
                  [
                    s,
                    /_/g,
                    ' '
                  ],
                  [
                    w,
                    'Xiaomi'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                [
                  [
                    s,
                    /_/g,
                    ' '
                  ],
                  [
                    w,
                    'Xiaomi'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /; (\w+) bui.+ oppo/i,
                  /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
                ],
                [
                  s,
                  [
                    w,
                    'OPPO'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /vivo (\w+)(?: bui|\))/i,
                  /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
                ],
                [
                  s,
                  [
                    w,
                    'Vivo'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                [
                  s,
                  [
                    w,
                    'Realme'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                  /\bmot(?:orola)?[- ](\w*)/i,
                  /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
                ],
                [
                  s,
                  [
                    w,
                    'Motorola'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                [
                  s,
                  [
                    w,
                    'Motorola'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
                [
                  s,
                  [
                    w,
                    'LG'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                  /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                  /\blg-?([\d\w]+) bui/i
                ],
                [
                  s,
                  [
                    w,
                    'LG'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /(ideatab[-\w ]+)/i,
                  /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
                ],
                [
                  s,
                  [
                    w,
                    'Lenovo'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /(?:maemo|nokia).*(n900|lumia \d+)/i,
                  /nokia[-_ ]?([-\w\.]*)/i
                ],
                [
                  [
                    s,
                    /_/g,
                    ' '
                  ],
                  [
                    w,
                    'Nokia'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/(pixel c)\b/i],
                [
                  s,
                  [
                    w,
                    'Google'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                [
                  s,
                  [
                    w,
                    'Google'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],
                [
                  s,
                  [
                    w,
                    'Sony'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /sony tablet [ps]/i,
                  /\b(?:sony)?sgp\w+(?: bui|\))/i
                ],
                [
                  [
                    s,
                    'Xperia Tablet'
                  ],
                  [
                    w,
                    'Sony'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  / (kb2005|in20[12]5|be20[12][59])\b/i,
                  /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
                ],
                [
                  s,
                  [
                    w,
                    'OnePlus'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /(alexa)webm/i,
                  /(kf[a-z]{2}wi)( bui|\))/i,
                  /(kf[a-z]+)( bui|\)).+silk\//i
                ],
                [
                  s,
                  [
                    w,
                    'Amazon'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                [
                  [
                    s,
                    /(.+)/g,
                    'Fire Phone $1'
                  ],
                  [
                    w,
                    'Amazon'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/(playbook);[-\w\),; ]+(rim)/i],
                [
                  s,
                  w,
                  [
                    l,
                    c
                  ]
                ],
                [
                  /\b((?:bb[a-f]|st[hv])100-\d)/i,
                  /\(bb10; (\w+)/i
                ],
                [
                  s,
                  [
                    w,
                    'BlackBerry'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],
                [
                  s,
                  [
                    w,
                    'ASUS'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                [
                  s,
                  [
                    w,
                    'ASUS'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/(nexus 9)/i],
                [
                  s,
                  [
                    w,
                    'HTC'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                  /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                  /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i
                ],
                [
                  w,
                  [
                    s,
                    /_/g,
                    ' '
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                [
                  s,
                  [
                    w,
                    'Acer'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /droid.+; (m[1-5] note) bui/i,
                  /\bmz-([-\w]{2,})/i
                ],
                [
                  s,
                  [
                    w,
                    'Meizu'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                [
                  s,
                  [
                    w,
                    'Sharp'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                  /(hp) ([\w ]+\w)/i,
                  /(asus)-?(\w+)/i,
                  /(microsoft); (lumia[\w ]+)/i,
                  /(lenovo)[-_ ]?([-\w]+)/i,
                  /(jolla)/i,
                  /(oppo) ?([\w ]+) bui/i
                ],
                [
                  w,
                  s,
                  [
                    l,
                    u
                  ]
                ],
                [
                  /(archos) (gamepad2?)/i,
                  /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                  /(kindle)\/([\w\.]+)/i,
                  /(nook)[\w ]+build\/(\w+)/i,
                  /(dell) (strea[kpr\d ]*[\dko])/i,
                  /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                  /(trinity)[- ]*(t\d{3}) bui/i,
                  /(gigaset)[- ]+(q\w{1,9}) bui/i,
                  /(vodafone) ([\w ]+)(?:\)| bui)/i
                ],
                [
                  w,
                  s,
                  [
                    l,
                    c
                  ]
                ],
                [/(surface duo)/i],
                [
                  s,
                  [
                    w,
                    'Microsoft'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                [
                  s,
                  [
                    w,
                    'Fairphone'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/(u304aa)/i],
                [
                  s,
                  [
                    w,
                    'AT&T'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\bsie-(\w*)/i],
                [
                  s,
                  [
                    w,
                    'Siemens'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(rct\w+) b/i],
                [
                  s,
                  [
                    w,
                    'RCA'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(venue[\d ]{2,7}) b/i],
                [
                  s,
                  [
                    w,
                    'Dell'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(q(?:mv|ta)\w+) b/i],
                [
                  s,
                  [
                    w,
                    'Verizon'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                [
                  s,
                  [
                    w,
                    'Barnes & Noble'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(tm\d{3}\w+) b/i],
                [
                  s,
                  [
                    w,
                    'NuVision'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(k88) b/i],
                [
                  s,
                  [
                    w,
                    'ZTE'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(nx\d{3}j) b/i],
                [
                  s,
                  [
                    w,
                    'ZTE'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(gen\d{3}) b.+49h/i],
                [
                  s,
                  [
                    w,
                    'Swiss'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(zur\d{3}) b/i],
                [
                  s,
                  [
                    w,
                    'Swiss'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b((zeki)?tb.*\b) b/i],
                [
                  s,
                  [
                    w,
                    'Zeki'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [
                  /\b([yr]\d{2}) b/i,
                  /\b(dragon[- ]+touch |dt)(\w{5}) b/i
                ],
                [
                  [
                    w,
                    'Dragon Touch'
                  ],
                  s,
                  [
                    l,
                    c
                  ]
                ],
                [/\b(ns-?\w{0,9}) b/i],
                [
                  s,
                  [
                    w,
                    'Insignia'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b((nxa|next)-?\w{0,9}) b/i],
                [
                  s,
                  [
                    w,
                    'NextBook'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                [
                  [
                    w,
                    'Voice'
                  ],
                  s,
                  [
                    l,
                    u
                  ]
                ],
                [/\b(lvtel\-)?(v1[12]) b/i],
                [
                  [
                    w,
                    'LvTel'
                  ],
                  s,
                  [
                    l,
                    u
                  ]
                ],
                [/\b(ph-1) /i],
                [
                  s,
                  [
                    w,
                    'Essential'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/\b(v(100md|700na|7011|917g).*\b) b/i],
                [
                  s,
                  [
                    w,
                    'Envizen'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\b(trio[-\w\. ]+) b/i],
                [
                  s,
                  [
                    w,
                    'MachSpeed'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/\btu_(1491) b/i],
                [
                  s,
                  [
                    w,
                    'Rotor'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/(shield[\w ]+) b/i],
                [
                  s,
                  [
                    w,
                    'Nvidia'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/(sprint) (\w+)/i],
                [
                  w,
                  s,
                  [
                    l,
                    u
                  ]
                ],
                [/(kin\.[onetw]{3})/i],
                [
                  [
                    s,
                    /\./g,
                    ' '
                  ],
                  [
                    w,
                    'Microsoft'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                [
                  s,
                  [
                    w,
                    'Zebra'
                  ],
                  [
                    l,
                    c
                  ]
                ],
                [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                [
                  s,
                  [
                    w,
                    'Zebra'
                  ],
                  [
                    l,
                    u
                  ]
                ],
                [
                  /(ouya)/i,
                  /(nintendo) ([wids3utch]+)/i
                ],
                [
                  w,
                  s,
                  [
                    l,
                    'console'
                  ]
                ],
                [/droid.+; (shield) bui/i],
                [
                  s,
                  [
                    w,
                    'Nvidia'
                  ],
                  [
                    l,
                    'console'
                  ]
                ],
                [/(playstation [345portablevi]+)/i],
                [
                  s,
                  [
                    w,
                    'Sony'
                  ],
                  [
                    l,
                    'console'
                  ]
                ],
                [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                [
                  s,
                  [
                    w,
                    'Microsoft'
                  ],
                  [
                    l,
                    'console'
                  ]
                ],
                [/smart-tv.+(samsung)/i],
                [
                  w,
                  [
                    l,
                    m
                  ]
                ],
                [/hbbtv.+maple;(\d+)/i],
                [
                  [
                    s,
                    /^/,
                    'SmartTV'
                  ],
                  [
                    w,
                    'Samsung'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                [
                  [
                    w,
                    'LG'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/(apple) ?tv/i],
                [
                  w,
                  [
                    s,
                    'Apple TV'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/crkey/i],
                [
                  [
                    s,
                    'Chromecast'
                  ],
                  [
                    w,
                    'Google'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/droid.+aft(\w)( bui|\))/i],
                [
                  s,
                  [
                    w,
                    'Amazon'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [
                  /\(dtv[\);].+(aquos)/i,
                  /(aquos-tv[\w ]+)\)/i
                ],
                [
                  s,
                  [
                    w,
                    'Sharp'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/(bravia[\w ]+)( bui|\))/i],
                [
                  s,
                  [
                    w,
                    'Sony'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/(mitv-\w{5}) bui/i],
                [
                  s,
                  [
                    w,
                    'Xiaomi'
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [
                  /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                  /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i
                ],
                [
                  [
                    w,
                    v
                  ],
                  [
                    s,
                    v
                  ],
                  [
                    l,
                    m
                  ]
                ],
                [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                [[
                    l,
                    m
                  ]],
                [/((pebble))app/i],
                [
                  w,
                  s,
                  [
                    l,
                    'wearable'
                  ]
                ],
                [/droid.+; (glass) \d/i],
                [
                  s,
                  [
                    w,
                    'Google'
                  ],
                  [
                    l,
                    'wearable'
                  ]
                ],
                [/droid.+; (wt63?0{2,3})\)/i],
                [
                  s,
                  [
                    w,
                    'Zebra'
                  ],
                  [
                    l,
                    'wearable'
                  ]
                ],
                [/(quest( 2)?)/i],
                [
                  s,
                  [
                    w,
                    'Facebook'
                  ],
                  [
                    l,
                    'wearable'
                  ]
                ],
                [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                [
                  w,
                  [
                    l,
                    'embedded'
                  ]
                ],
                [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                [
                  s,
                  [
                    l,
                    u
                  ]
                ],
                [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                [
                  s,
                  [
                    l,
                    c
                  ]
                ],
                [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                [[
                    l,
                    c
                  ]],
                [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
                [[
                    l,
                    u
                  ]],
                [/(android[-\w\. ]{0,9});.+buil/i],
                [
                  s,
                  [
                    w,
                    'Generic'
                  ]
                ]
              ],
              engine: [
                [/windows.+ edge\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'EdgeHTML'
                  ]
                ],
                [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Blink'
                  ]
                ],
                [
                  /(presto)\/([\w\.]+)/i,
                  /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                  /ekioh(flow)\/([\w\.]+)/i,
                  /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                  /(icab)[\/ ]([23]\.[\d\.]+)/i
                ],
                [
                  b,
                  d
                ],
                [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                [
                  d,
                  b
                ]
              ],
              os: [
                [/microsoft (windows) (vista|xp)/i],
                [
                  b,
                  d
                ],
                [
                  /(windows) nt 6\.2; (arm)/i,
                  /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                  /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
                ],
                [
                  b,
                  [
                    d,
                    x,
                    k
                  ]
                ],
                [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                [
                  [
                    b,
                    'Windows'
                  ],
                  [
                    d,
                    x,
                    k
                  ]
                ],
                [
                  /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                  /cfnetwork\/.+darwin/i
                ],
                [
                  [
                    d,
                    /_/g,
                    '.'
                  ],
                  [
                    b,
                    'iOS'
                  ]
                ],
                [
                  /(mac os x) ?([\w\. ]*)/i,
                  /(macintosh|mac_powerpc\b)(?!.+haiku)/i
                ],
                [
                  [
                    b,
                    'Mac OS'
                  ],
                  [
                    d,
                    /_/g,
                    '.'
                  ]
                ],
                [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                [
                  d,
                  b
                ],
                [
                  /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                  /(blackberry)\w*\/([\w\.]*)/i,
                  /(tizen|kaios)[\/ ]([\w\.]+)/i,
                  /\((series40);/i
                ],
                [
                  b,
                  d
                ],
                [/\(bb(10);/i],
                [
                  d,
                  [
                    b,
                    'BlackBerry'
                  ]
                ],
                [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                [
                  d,
                  [
                    b,
                    'Symbian'
                  ]
                ],
                [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Firefox OS'
                  ]
                ],
                [
                  /web0s;.+rt(tv)/i,
                  /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
                ],
                [
                  d,
                  [
                    b,
                    'webOS'
                  ]
                ],
                [/crkey\/([\d\.]+)/i],
                [
                  d,
                  [
                    b,
                    'Chromecast'
                  ]
                ],
                [/(cros) [\w]+ ([\w\.]+\w)/i],
                [
                  [
                    b,
                    'Chromium OS'
                  ],
                  d
                ],
                [
                  /(nintendo|playstation) ([wids345portablevuch]+)/i,
                  /(xbox); +xbox ([^\);]+)/i,
                  /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                  /(mint)[\/\(\) ]?(\w*)/i,
                  /(mageia|vectorlinux)[; ]/i,
                  /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                  /(hurd|linux) ?([\w\.]*)/i,
                  /(gnu) ?([\w\.]*)/i,
                  /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                  /(haiku) (\w+)/i
                ],
                [
                  b,
                  d
                ],
                [/(sunos) ?([\w\.\d]*)/i],
                [
                  [
                    b,
                    'Solaris'
                  ],
                  d
                ],
                [
                  /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                  /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                  /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                  /(unix) ?([\w\.]*)/i
                ],
                [
                  b,
                  d
                ]
              ]
            }, S = function i(e, o) {
              if ('object' === n(e) && (o = e, e = void 0), !(this instanceof i))
                return new i(e, o).getResult();
              var r = e || ('undefined' !== n(a) && a.navigator && a.navigator.userAgent ? a.navigator.userAgent : ''), t = o ? function (i, e) {
                  var o = {};
                  for (var r in i)
                    e[r] && e[r].length % 2 == 0 ? o[r] = e[r].concat(i[r]) : o[r] = i[r];
                  return o;
                }(y, o) : y;
              return this.getBrowser = function () {
                var i, e = {};
                return e[b] = void 0, e[d] = void 0, g.call(e, r, t.browser), e.major = 'string' === n(i = e.version) ? i.replace(/[^\d\.]/g, '').split('.')[0] : void 0, e;
              }, this.getCPU = function () {
                var i = { architecture: void 0 };
                return g.call(i, r, t.cpu), i;
              }, this.getDevice = function () {
                var i = {
                  vendor: void 0,
                  model: void 0,
                  type: void 0
                };
                return g.call(i, r, t.device), i;
              }, this.getEngine = function () {
                var i = {
                  name: void 0,
                  version: void 0
                };
                return g.call(i, r, t.engine), i;
              }, this.getOS = function () {
                var i = {
                  name: void 0,
                  version: void 0
                };
                return g.call(i, r, t.os), i;
              }, this.getResult = function () {
                return {
                  ua: this.getUA(),
                  browser: this.getBrowser(),
                  engine: this.getEngine(),
                  os: this.getOS(),
                  device: this.getDevice(),
                  cpu: this.getCPU()
                };
              }, this.getUA = function () {
                return r;
              }, this.setUA = function (i) {
                return r = 'string' === n(i) && i.length > 350 ? v(i, 350) : i, this;
              }, this.setUA(r), this;
            };
          S.VERSION = '0.7.33', S.BROWSER = p([
            b,
            d,
            'major'
          ]), S.CPU = p(['architecture']), S.DEVICE = p([
            s,
            w,
            l,
            'console',
            u,
            m,
            c,
            'wearable',
            'embedded'
          ]), S.ENGINE = S.OS = p([
            b,
            d
          ]), 'undefined' !== n(e) ? ('undefined' !== n(i) && i.exports && (e = i.exports = S), e.UAParser = S) : 'function' === n(o(2)) && o(3) ? void 0 === (r = function () {
            return S;
          }.call(e, o, e, i)) || (i.exports = r) : 'undefined' !== n(a) && (a.UAParser = S);
          var _ = 'undefined' !== n(a) && (a.jQuery || a.Zepto);
          if (_ && !_.ua) {
            var T = new S();
            _.ua = T.getResult(), _.ua.get = function () {
              return T.getUA();
            }, _.ua.set = function (i) {
              T.setUA(i);
              var e = T.getResult();
              for (var o in e)
                _.ua[o] = e[o];
            };
          }
        }('object' === ('undefined' == typeof window ? 'undefined' : n(window)) ? window : this);
      }.call(this, o(1)(i)));
    },
    function (i, e) {
      i.exports = function (i) {
        return i.webpackPolyfill || (i.deprecate = function () {
        }, i.paths = [], i.children || (i.children = []), Object.defineProperty(i, 'loaded', {
          enumerable: !0,
          get: function () {
            return i.l;
          }
        }), Object.defineProperty(i, 'id', {
          enumerable: !0,
          get: function () {
            return i.i;
          }
        }), i.webpackPolyfill = 1), i;
      };
    },
    function (i, e) {
      i.exports = function () {
        throw new Error('define cannot be used indirect');
      };
    },
    function (i, e) {
      (function (e) {
        i.exports = e;
      }.call(this, {}));
    }
  ]);
  transpiled_node_modules_launch_darkly = function (e) {
    var n = {};
    function t(r) {
      if (n[r])
        return n[r].exports;
      var o = n[r] = {
        i: r,
        l: !1,
        exports: {}
      };
      return e[r].call(o.exports, o, o.exports, t), o.l = !0, o.exports;
    }
    return t.m = e, t.c = n, t.d = function (e, n, r) {
      t.o(e, n) || Object.defineProperty(e, n, {
        enumerable: !0,
        get: r
      });
    }, t.r = function (e) {
      'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 });
    }, t.t = function (e, n) {
      if (1 & n && (e = t(e)), 8 & n)
        return e;
      if (4 & n && 'object' == typeof e && e && e.__esModule)
        return e;
      var r = Object.create(null);
      if (t.r(r), Object.defineProperty(r, 'default', {
          enumerable: !0,
          value: e
        }), 2 & n && 'string' != typeof e)
        for (var o in e)
          t.d(r, o, function (n) {
            return e[n];
          }.bind(null, o));
      return r;
    }, t.n = function (e) {
      var n = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return t.d(n, 'a', n), n;
    }, t.o = function (e, n) {
      return Object.prototype.hasOwnProperty.call(e, n);
    }, t.p = '', t(t.s = 0);
  }([function (e, n, t) {
      var r, o, i;
      function a(e) {
        return (a = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function (e) {
          return typeof e;
        } : function (e) {
          return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
        })(e);
      }
      !function (t, u) {
        'object' == a(n) && void 0 !== e ? u(n) : (o = [n], void 0 === (i = 'function' == typeof (r = u) ? r.apply(n, o) : r) || (e.exports = i));
      }(0, function (e) {
        'use strict';
        function n(e) {
          return (n = 'function' == typeof Symbol && 'symbol' == a(Symbol.iterator) ? function (e) {
            return a(e);
          } : function (e) {
            return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : a(e);
          })(e);
        }
        function t(e, n) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            n && (r = r.filter(function (n) {
              return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), t.push.apply(t, r);
          }
          return t;
        }
        function r(e) {
          for (var n = 1; n < arguments.length; n++) {
            var r = null != arguments[n] ? arguments[n] : {};
            n % 2 ? t(r, !0).forEach(function (n) {
              var t, o, i;
              t = e, i = r[o = n], o in t ? Object.defineProperty(t, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              }) : t[o] = i;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : t(r).forEach(function (n) {
              Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
            });
          }
          return e;
        }
        function o(e) {
          return function (e) {
            if (Array.isArray(e)) {
              for (var n = 0, t = new Array(e.length); n < e.length; n++)
                t[n] = e[n];
              return t;
            }
          }(e) || function (e) {
            if (Symbol.iterator in Object(e) || '[object Arguments]' === Object.prototype.toString.call(e))
              return Array.from(e);
          }(e) || function () {
            throw new TypeError('Invalid attempt to spread non-iterable instance');
          }();
        }
        function i(e) {
          function n(e, n) {
            Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.message = e, this.code = n;
          }
          return (n.prototype = new Error()).name = e, n.prototype.constructor = n;
        }
        var u = i('LaunchDarklyUnexpectedResponseError'), s = i('LaunchDarklyInvalidEnvironmentIdError'), c = i('LaunchDarklyInvalidUserError'), l = i('LaunchDarklyInvalidEventKeyError'), f = i('LaunchDarklyInvalidArgumentError'), d = i('LaunchDarklyFlagFetchError'), v = i('LaunchDarklyInvalidDataError');
        function g(e) {
          return !(400 <= e && e < 500) || 400 === e || 408 === e || 429 === e;
        }
        for (var p = Object.freeze({
              __proto__: null,
              LDUnexpectedResponseError: u,
              LDInvalidEnvironmentIdError: s,
              LDInvalidUserError: c,
              LDInvalidEventKeyError: l,
              LDInvalidArgumentError: f,
              LDFlagFetchError: d,
              LDInvalidDataError: v,
              isHttpErrorRecoverable: g
            }), m = [], y = [], h = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', b = 0, w = h.length; b < w; ++b)
          m[b] = h[b], y[h.charCodeAt(b)] = b;
        function k(e, n, t) {
          for (var r, o, i = [], a = n; a < t; a += 3)
            r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), i.push(m[(o = r) >> 18 & 63] + m[o >> 12 & 63] + m[o >> 6 & 63] + m[63 & o]);
          return i.join('');
        }
        y['-'.charCodeAt(0)] = 62, y['_'.charCodeAt(0)] = 63;
        var E = Array.isArray, S = Object.keys, D = Object.prototype.hasOwnProperty, O = [
            'key',
            'secondary',
            'ip',
            'country',
            'email',
            'firstName',
            'lastName',
            'avatar',
            'name'
          ];
        function P(e) {
          return function (e) {
            for (var n, t = e.length, r = t % 3, o = [], i = 0, a = t - r; i < a; i += 16383)
              o.push(k(e, i, a < i + 16383 ? a : i + 16383));
            return 1 == r ? (n = e[t - 1], o.push(m[n >> 2] + m[n << 4 & 63] + '==')) : 2 == r && (n = (e[t - 2] << 8) + e[t - 1], o.push(m[n >> 10] + m[n >> 4 & 63] + m[n << 2 & 63] + '=')), o.join('');
          }(function (e) {
            for (var n = [], t = 0; t < e.length; t++)
              n.push(e.charCodeAt(t));
            return n;
          }(unescape(encodeURIComponent(e))));
        }
        function j(e) {
          return P(e).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
        }
        function U(e) {
          return JSON.parse(JSON.stringify(e));
        }
        function I(e, n) {
          return function e(n, t) {
            if (n === t)
              return !0;
            if (n && t && 'object' == a(n) && 'object' == a(t)) {
              var r, o, i, u = E(n), s = E(t);
              if (u && s) {
                if ((o = n.length) != t.length)
                  return !1;
                for (r = o; 0 != r--;)
                  if (!e(n[r], t[r]))
                    return !1;
                return !0;
              }
              if (u != s)
                return !1;
              var c = n instanceof Date, l = t instanceof Date;
              if (c != l)
                return !1;
              if (c && l)
                return n.getTime() == t.getTime();
              var f = n instanceof RegExp, d = t instanceof RegExp;
              if (f != d)
                return !1;
              if (f && d)
                return n.toString() == t.toString();
              var v = S(n);
              if ((o = v.length) !== S(t).length)
                return !1;
              for (r = o; 0 != r--;)
                if (!D.call(t, v[r]))
                  return !1;
              for (r = o; 0 != r--;)
                if (!e(n[i = v[r]], t[i]))
                  return !1;
              return !0;
            }
            return n != n && t != t;
          }(e, n);
        }
        function R(e) {
          setTimeout(e, 0);
        }
        function T(e, n) {
          var t = e.then(function (e) {
            return n && setTimeout(function () {
              n(null, e);
            }, 0), e;
          }, function (e) {
            if (!n)
              return Promise.reject(e);
            setTimeout(function () {
              n(e, null);
            }, 0);
          });
          return n ? void 0 : t;
        }
        function L(e) {
          var n = {};
          for (var t in e)
            _(e, t) && (n[t] = {
              value: e[t],
              version: 0
            });
          return n;
        }
        function x(e) {
          var n = {};
          for (var t in e)
            _(e, t) && (n[t] = e[t].value);
          return n;
        }
        function N(e, n) {
          for (var t, r = n.slice(0), o = [], i = e; 0 < r.length;) {
            for (t = []; 0 < i;) {
              var a = r.shift();
              if (!a)
                break;
              (i -= j(JSON.stringify(a)).length) < 0 && 0 < t.length ? r.unshift(a) : t.push(a);
            }
            i = e, o.push(t);
          }
          return o;
        }
        function C(e) {
          var n = e.version || '3.5.1';
          return e.userAgent + '/' + n;
        }
        function F(e, n) {
          if (n && !n.sendLDHeaders)
            return {};
          var t = { 'X-LaunchDarkly-User-Agent': C(e) };
          return n && n.wrapperName && (t['X-LaunchDarkly-Wrapper'] = n.wrapperVersion ? n.wrapperName + '/' + n.wrapperVersion : n.wrapperName), t;
        }
        function A(e, n) {
          return n && n.requestHeaderTransform ? n.requestHeaderTransform(r({}, e)) : e;
        }
        function q() {
          for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++)
            n[t] = arguments[t];
          return n.reduce(function (e, n) {
            return r({}, e, {}, n);
          }, {});
        }
        function _(e, n) {
          return Object.prototype.hasOwnProperty.call(e, n);
        }
        function M(e) {
          if (!e)
            return e;
          var n;
          for (var t in O) {
            var o = O[t], i = e[o];
            void 0 !== i && 'string' != typeof i && ((n = n || r({}, e))[o] = String(i));
          }
          return n || e;
        }
        Object.freeze({
          __proto__: null,
          btoa: P,
          base64URLEncode: j,
          clone: U,
          deepEquals: I,
          onNextTick: R,
          wrapPromiseCallback: T,
          transformValuesToVersionedValues: L,
          transformVersionedValuesToValues: x,
          chunkUserEventsForUrl: N,
          getLDUserAgentString: C,
          getLDHeaders: F,
          transformHeaders: A,
          extend: q,
          objectHasOwnProperty: _,
          sanitizeUser: M
        });
        for (var V, z = (void 0, function (e) {
              var n = 'undefined' != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || 'undefined' != typeof msCrypto && 'function' == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
              if (n) {
                var t = new Uint8Array(16);
                e.exports = function () {
                  return n(t), t;
                };
              } else {
                var r = new Array(16);
                e.exports = function () {
                  for (var e, n = 0; n < 16; n++)
                    0 == (3 & n) && (e = 4294967296 * Math.random()), r[n] = e >>> ((3 & n) << 3) & 255;
                  return r;
                };
              }
            }(V = { exports: {} }), V.exports), J = [], H = 0; H < 256; ++H)
          J[H] = (H + 256).toString(16).substr(1);
        var K, $, B = 0, G = 0, X = function (e, n, t) {
            var r = n && t || 0, o = n || [], i = (e = e || {}).node || K, a = void 0 !== e.clockseq ? e.clockseq : $;
            if (null == i || null == a) {
              var u = z();
              null == i && (i = K = [
                1 | u[0],
                u[1],
                u[2],
                u[3],
                u[4],
                u[5]
              ]), null == a && (a = $ = 16383 & (u[6] << 8 | u[7]));
            }
            var s = void 0 !== e.msecs ? e.msecs : new Date().getTime(), c = void 0 !== e.nsecs ? e.nsecs : G + 1, l = s - B + (c - G) / 10000;
            if (l < 0 && void 0 === e.clockseq && (a = a + 1 & 16383), (l < 0 || B < s) && void 0 === e.nsecs && (c = 0), 10000 <= c)
              throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
            B = s, $ = a;
            var f = (10000 * (268435455 & (s += 12219292800000)) + (G = c)) % 4294967296;
            o[r++] = f >>> 24 & 255, o[r++] = f >>> 16 & 255, o[r++] = f >>> 8 & 255, o[r++] = 255 & f;
            var d = s / 4294967296 * 10000 & 268435455;
            o[r++] = d >>> 8 & 255, o[r++] = 255 & d, o[r++] = d >>> 24 & 15 | 16, o[r++] = d >>> 16 & 255, o[r++] = a >>> 8 | 128, o[r++] = 255 & a;
            for (var v = 0; v < 6; ++v)
              o[r + v] = i[v];
            return n || function (e, n) {
              var t = 0, r = J;
              return [
                r[e[t++]],
                r[e[t++]],
                r[e[t++]],
                r[e[t++]],
                '-',
                r[e[t++]],
                r[e[t++]],
                '-',
                r[e[t++]],
                r[e[t++]],
                '-',
                r[e[t++]],
                r[e[t++]],
                '-',
                r[e[t++]],
                r[e[t++]],
                r[e[t++]],
                r[e[t++]],
                r[e[t++]],
                r[e[t++]]
              ].join('');
            }(o);
          };
        function W(e, n, t) {
          var r = '/a/' + n + '.gif', o = q({ 'Content-Type': 'application/json' }, F(e, t)), i = e.httpFallbackPing, a = {
              sendChunk: function (n, a, u, s) {
                var c = JSON.stringify(n), l = u ? null : X();
                return s ? function n(r) {
                  var i = u ? o : q({}, o, {
                    'X-LaunchDarkly-Event-Schema': '3',
                    'X-LaunchDarkly-Payload-ID': l
                  });
                  return e.httpRequest('POST', a, A(i, t), c).promise.then(function (e) {
                    if (e)
                      return 400 <= e.status && g(e.status) && r ? n(!1) : function (e) {
                        var n = { status: e.status }, t = e.header('date');
                        if (t) {
                          var r = Date.parse(t);
                          r && (n.serverTime = r);
                        }
                        return n;
                      }(e);
                  }).catch(function () {
                    return r ? n(!1) : Promise.reject();
                  });
                }(!0).catch(function () {
                }) : (i && i(a + r + '?d=' + j(c)), Promise.resolve());
              },
              sendEvents: function (n, t, r) {
                if (!e.httpRequest)
                  return Promise.resolve();
                var o, i = e.httpAllowsPost();
                o = i ? [n] : N(2000 - t.length, n);
                for (var u = [], s = 0; s < o.length; s++)
                  u.push(a.sendChunk(o[s], t, r, i));
                return Promise.all(u);
              }
            };
          return a;
        }
        function Q(e) {
          var n = {}, t = e.allAttributesPrivate, r = e.privateAttributeNames || [], o = {
              key: !0,
              custom: !0,
              anonymous: !0
            }, i = {
              key: !0,
              secondary: !0,
              ip: !0,
              country: !0,
              email: !0,
              firstName: !0,
              lastName: !0,
              avatar: !0,
              name: !0,
              anonymous: !0,
              custom: !0
            };
          return n.filterUser = function (e) {
            if (!e)
              return null;
            function n(e, n) {
              return Object.keys(e).reduce(function (i, u) {
                var s, c = i;
                return n(u) && (o[s = u] || !t && -1 === a.indexOf(s) && -1 === r.indexOf(s) ? c[0][u] = e[u] : c[1][u] = !0), c;
              }, [
                {},
                {}
              ]);
            }
            var a = e.privateAttributeNames || [], u = n(e, function (e) {
                return i[e];
              }), s = u[0], c = u[1];
            if (e.custom) {
              var l = n(e.custom, function () {
                return !0;
              });
              s.custom = l[0], c = q({}, c, l[1]);
            }
            var f = Object.keys(c);
            return f.length && (f.sort(), s.privateAttrs = f), s;
          }, n;
        }
        function Y(e) {
          return e && e.message ? e.message : 'string' == typeof e || e instanceof String ? e : JSON.stringify(e);
        }
        var Z = ' Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initializing-the-client for instructions on SDK initialization.', ee = function (e) {
            return 'Expected application/json content type but got "' + e + '"';
          }, ne = function (e) {
            return 'local storage is unavailable: ' + Y(e);
          }, te = function (e) {
            return 'network error' + (e ? ' (' + e + ')' : '');
          }, re = function (e) {
            return 'Custom event "' + e + '" does not exist';
          }, oe = function () {
            return 'Environment not found. Double check that you specified a valid environment/client-side ID.' + Z;
          }, ie = function () {
            return 'No environment/client-side ID was specified.' + Z;
          }, ae = function (e) {
            return 'Error fetching flag settings: ' + Y(e);
          }, ue = function () {
            return 'No user specified.' + Z;
          }, se = function () {
            return 'Invalid user specified.' + Z;
          }, ce = function () {
            return 'LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. Events may not be sent correctly.' + Z;
          }, le = function (e, n) {
            return n ? '"' + e + '" is deprecated, please use "' + n + '"' : '"' + e + '" is deprecated';
          }, fe = function (e, n, t) {
            return 'Received error ' + e + (401 === e ? ' (invalid SDK key)' : '') + ' for ' + n + ' - ' + (g(e) ? t : 'giving up permanently');
          }, de = function () {
            return 'Cannot make HTTP requests in this environment.' + Z;
          }, ve = function (e) {
            return 'Opening stream connection to ' + e;
          }, ge = function (e, n) {
            return 'Error on stream connection: ' + Y(e) + ', will continue retrying every ' + n + ' milliseconds.';
          }, pe = function (e) {
            return 'Ignoring unknown config option "' + e + '"';
          }, me = function (e, n, t) {
            return 'Config option "' + e + '" should be of type ' + n + ', got ' + t + ', using default value';
          }, ye = function (e, n) {
            return 'Config option "' + e + '" should be a boolean, got ' + n + ', converting to boolean';
          }, he = function (e, n, t) {
            return 'Config option "' + e + '" was set to ' + n + ', changing to minimum value of ' + t;
          }, be = function (e) {
            return 'polling for feature flags at ' + e;
          }, we = function (e) {
            return 'received streaming update for flag "' + e + '"';
          }, ke = function (e) {
            return 'received streaming update for flag "' + e + '" but ignored due to version check';
          }, Ee = function (e) {
            return 'received streaming deletion for flag "' + e + '"';
          }, Se = function (e) {
            return 'received streaming deletion for flag "' + e + '" but ignored due to version check';
          }, De = function (e) {
            return 'enqueueing "' + e + '" event';
          }, Oe = function (e) {
            return 'sending ' + e + ' events';
          }, Pe = Object.freeze({
            __proto__: null,
            clientInitialized: function () {
              return 'LaunchDarkly client initialized';
            },
            clientNotReady: function () {
              return 'LaunchDarkly client is not ready';
            },
            eventCapacityExceeded: function () {
              return 'Exceeded event queue capacity. Increase capacity to avoid dropping events.';
            },
            eventWithoutUser: function () {
              return 'Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript';
            },
            invalidContentType: ee,
            invalidKey: function () {
              return 'Event key must be a string';
            },
            localStorageUnavailable: ne,
            networkError: te,
            unknownCustomEventKey: re,
            environmentNotFound: oe,
            environmentNotSpecified: ie,
            errorFetchingFlags: ae,
            userNotSpecified: ue,
            invalidUser: se,
            invalidData: function () {
              return 'Invalid data received from LaunchDarkly; connection may have been interrupted';
            },
            bootstrapOldFormat: ce,
            bootstrapInvalid: function () {
              return 'LaunchDarkly bootstrap data is not available because the back end could not read the flags.';
            },
            deprecated: le,
            httpErrorMessage: fe,
            httpUnavailable: de,
            identifyDisabled: function () {
              return 'identify() has no effect here; it must be called on the main client instance';
            },
            streamClosing: function () {
              return 'Closing stream connection';
            },
            streamConnecting: ve,
            streamError: ge,
            unknownOption: pe,
            wrongOptionType: me,
            wrongOptionTypeBoolean: ye,
            optionBelowMinimum: he,
            debugPolling: be,
            debugStreamPing: function () {
              return 'received ping message from stream';
            },
            debugStreamPut: function () {
              return 'received streaming update for all flags';
            },
            debugStreamPatch: we,
            debugStreamPatchIgnored: ke,
            debugStreamDelete: Ee,
            debugStreamDeleteIgnored: Se,
            debugEnqueueingEvent: De,
            debugPostingEvents: Oe,
            debugPostingDiagnosticEvent: function (e) {
              return 'sending diagnostic event (' + e.kind + ')';
            }
          });
        function je(e, n, t, r) {
          var o = {};
          function i() {
            var e = '', o = r.getUser();
            return o && (e = t || P(JSON.stringify(o))), 'ld:' + n + ':' + e;
          }
          return o.loadFlags = function () {
            return e.get(i()).then(function (e) {
              if (null == e)
                return null;
              try {
                var n = JSON.parse(e);
                if (n) {
                  var t = n.$schema;
                  void 0 === t || t < 1 ? n = L(n) : delete n.$schema;
                }
                return n;
              } catch (e) {
                return o.clearFlags().then(function () {
                  return null;
                });
              }
            });
          }, o.saveFlags = function (n) {
            var t = q({}, n, { $schema: 1 });
            return e.set(i(), JSON.stringify(t));
          }, o.clearFlags = function () {
            return e.clear(i());
          }, o;
        }
        function Ue(e, n, t, r) {
          var o, i = n.streamUrl, a = n.logger, u = {}, s = i + '/eval/' + t, c = n.useReport, l = n.evaluationReasons, f = n.streamReconnectDelay, d = F(e, n), v = !1, g = null, p = null, m = null, y = null, h = null;
          function b(e) {
            v || (a.warn(ge(e, f)), v = !0), S(!1), E(), w(f);
          }
          function w(e) {
            p || (e ? p = setTimeout(k, e) : k());
          }
          function k() {
            var r;
            p = null;
            var u = '', f = {
                headers: d,
                readTimeoutMillis: 300000
              };
            if (e.eventSourceFactory) {
              for (var v in (null != y && (u = 'h=' + y), c ? e.eventSourceAllowsReport ? (r = s, f.method = 'REPORT', f.headers['Content-Type'] = 'application/json', f.body = JSON.stringify(m)) : (r = i + '/ping/' + t, u = '') : r = s + '/' + j(JSON.stringify(m)), f.headers = A(f.headers, n), l && (u = u + (u ? '&' : '') + 'withReasons=true'), r = r + (u ? '?' : '') + u, E(), a.info(ve(r)), o = new Date().getTime(), g = e.eventSourceFactory(r, f), h))
                _(h, v) && g.addEventListener(v, h[v]);
              g.onerror = b;
            }
          }
          function E() {
            g && (a.info('Closing stream connection'), g.close(), g = null);
          }
          function S(e) {
            o && r && r.recordStreamInit(o, !e, new Date().getTime() - o), o = null;
          }
          return u.connect = function (e, n, t) {
            function r(e) {
              h[e] = function (n) {
                S(!(v = !1)), t[e] && t[e](n);
              };
            }
            for (var o in (m = e, y = n, h = {}, t || {}))
              r(o);
            w();
          }, u.disconnect = function () {
            clearTimeout(p), p = null, E();
          }, u.isConnected = function () {
            return !!(g && e.eventSourceIsActive && e.eventSourceIsActive(g));
          }, u;
        }
        function Ie(e, n, t) {
          var r = n.baseUrl, o = n.useReport, i = n.evaluationReasons, a = n.logger, u = {}, c = {};
          function l(t, r) {
            if (!e.httpRequest)
              return new Promise(function (e, n) {
                n(new d(de()));
              });
            var o = r ? 'REPORT' : 'GET', i = F(e, n);
            r && (i['Content-Type'] = 'application/json');
            var a, u, l, f, v, g, p = c[t];
            p || (a = function () {
              delete c[t];
            }, (g = {
              addPromise: function (e, n) {
                u = e, l && l(), l = n, e.then(function (n) {
                  u === e && (f(n), a());
                }, function (n) {
                  u === e && (v(n), a());
                });
              }
            }).resultPromise = new Promise(function (e, n) {
              f = e, v = n;
            }), p = g, c[t] = p);
            var m = e.httpRequest(o, t, A(i, n), r), y = m.promise.then(function (e) {
                if (200 !== e.status)
                  return Promise.reject(404 === (n = e).status ? new s(oe()) : new d(ae(n.statusText || String(n.status))));
                if (e.header('content-type') && 'application/json' === e.header('content-type').substring(0, 'application/json'.length))
                  return JSON.parse(e.body);
                var n, t = ee(e.header('content-type') || '');
                return Promise.reject(new d(t));
              }, function (e) {
                return Promise.reject(new d(te(e)));
              });
            return p.addPromise(y, function () {
              m.cancel && m.cancel();
            }), p.resultPromise;
          }
          return u.fetchJSON = function (e) {
            return l(r + e, null);
          }, u.fetchFlagSettings = function (e, n) {
            var u, s, c, f = '';
            return o ? (s = [
              r,
              '/sdk/evalx/',
              t,
              '/user'
            ].join(''), c = JSON.stringify(e)) : (u = j(JSON.stringify(e)), s = [
              r,
              '/sdk/evalx/',
              t,
              '/users/',
              u
            ].join('')), n && (f = 'h=' + n), i && (f = f + (f ? '&' : '') + 'withReasons=true'), s = s + (f ? '?' : '') + f, a.debug(be(s)), l(s, c);
          }, u;
        }
        function Re(e) {
          var n = {
            validateUser: function (n) {
              if (!n)
                return Promise.reject(new c(ue()));
              var t = U(n);
              return null !== t.key && void 0 !== t.key ? (t.key = t.key.toString(), Promise.resolve(t)) : t.anonymous ? e.get('ld:$anonUserId').then(function (n) {
                if (n)
                  return t.key = n, t;
                var r, o = X();
                return t.key = o, (r = o, e.set('ld:$anonUserId', r)).then(function () {
                  return t;
                });
              }) : Promise.reject(new c(se()));
            }
          };
          return n;
        }
        var Te = [
          'debug',
          'info',
          'warn',
          'error',
          'none'
        ];
        function Le(e, n) {
          return function (e, n) {
            if (e && e.destination && 'function' != typeof e.destination)
              throw new Error('destination for basicLogger was set to a non-function');
            function t(e) {
              return function (n) {
                console && console[e] && console[e].call(console, n);
              };
            }
            var r = e && e.destination ? [
                e.destination,
                e.destination,
                e.destination,
                e.destination
              ] : [
                t('log'),
                t('info'),
                t('warn'),
                t('error')
              ], i = !(!e || !e.destination), a = e && void 0 !== e.prefix && null !== e.prefix ? e.prefix : '[LaunchDarkly] ', u = 1;
            if (e && e.level)
              for (var s = 0; s < Te.length; s++)
                Te[s] === e.level && (u = s);
            for (var c = {}, l = function (e) {
                  var t = Te[e];
                  if ('none' !== t)
                    if (e < u)
                      c[t] = function () {
                      };
                    else {
                      var s = e;
                      c[t] = function () {
                        !function (e, t, u) {
                          if (!(u.length < 1)) {
                            var s, c = i ? t + ': ' + a : a;
                            if (1 !== u.length && n) {
                              var l = o(u);
                              l[0] = c + l[0], s = n.apply(void 0, o(l));
                            } else
                              s = c + u[0];
                            try {
                              r[e](s);
                            } catch (e) {
                              console && console.log && console.log('[LaunchDarkly] Configured logger\'s ' + t + ' method threw an exception: ' + e);
                            }
                          }
                        }(s, t, arguments);
                      };
                    }
                }, f = 0; f < Te.length; f++)
              l(f);
            return c;
          }({
            level: e,
            prefix: n
          });
        }
        var xe = {
          baseUrl: { default: 'https://app.launchdarkly.com' },
          streamUrl: { default: 'https://clientstream.launchdarkly.com' },
          eventsUrl: { default: 'https://events.launchdarkly.com' },
          sendEvents: { default: !0 },
          streaming: { type: 'boolean' },
          sendLDHeaders: { default: !0 },
          requestHeaderTransform: { type: 'function' },
          inlineUsersInEvents: { default: !1 },
          allowFrequentDuplicateEvents: { default: !1 },
          sendEventsOnlyForVariation: { default: !1 },
          useReport: { default: !1 },
          evaluationReasons: { default: !1 },
          eventCapacity: {
            default: 100,
            minimum: 1
          },
          flushInterval: {
            default: 2000,
            minimum: 2000
          },
          samplingInterval: {
            default: 0,
            minimum: 0
          },
          streamReconnectDelay: {
            default: 1000,
            minimum: 0
          },
          allAttributesPrivate: { default: !1 },
          privateAttributeNames: { default: [] },
          bootstrap: { type: 'string|object' },
          diagnosticRecordingInterval: {
            default: 900000,
            minimum: 2000
          },
          diagnosticOptOut: { default: !1 },
          wrapperName: { type: 'string' },
          wrapperVersion: { type: 'string' },
          stateProvider: { type: 'object' },
          autoAliasingOptOut: { default: !1 }
        };
        function Ne(e, t, r, o) {
          var i = q({ logger: { default: o } }, xe, r), a = {
              all_attributes_private: 'allAttributesPrivate',
              private_attribute_names: 'privateAttributeNames',
              samplingInterval: null
            };
          function u(e) {
            R(function () {
              t && t.maybeReportError(new f(e));
            });
          }
          var s, c, l, d, v, g = q({}, e || {});
          return v = g, Object.keys(a).forEach(function (e) {
            if (void 0 !== v[e]) {
              var n = a[e];
              o && o.warn(le(e, n)), n && (void 0 === v[n] && (v[n] = v[e]), delete v[e]);
            }
          }), s = (d = q({}, g), Object.keys(i).forEach(function (e) {
            void 0 !== d[e] && null !== d[e] || (d[e] = i[e] && i[e].default);
          }), c = g = d, l = q({}, c), Object.keys(c).forEach(function (e) {
            var n = c[e];
            if (null != n) {
              var t = i[e];
              if (void 0 === t)
                u(pe(e));
              else {
                var r = t.type || p(t.default);
                if ('any' !== r) {
                  var o = r.split('|'), a = p(n);
                  o.indexOf(a) < 0 ? 'boolean' === r ? (l[e] = !!n, u(ye(e, a))) : (u(me(e, r, a)), l[e] = t.default) : 'number' === a && void 0 !== t.minimum && n < t.minimum && (u(he(e, n, t.minimum)), l[e] = t.minimum);
                }
              }
            }
          }), g = l).logger, Te.forEach(function (e) {
            if ('none' !== e && (!s[e] || 'function' != typeof s[e]))
              throw new Error('Provided logger instance must support logger.' + e + '(...) method');
          }), g;
          function p(e) {
            if (null === e)
              return 'any';
            if (void 0 !== e) {
              if (Array.isArray(e))
                return 'array';
              var t = n(e);
              return 'boolean' === t || 'string' === t || 'number' === t || 'function' === t ? t : 'object';
            }
          }
        }
        var Ce = Object.freeze({
            __proto__: null,
            baseOptionDefs: xe,
            validate: Ne
          }).baseOptionDefs, Fe = function (e) {
            var n = { diagnosticId: X() };
            return e && (n.sdkKeySuffix = 6 < e.length ? e.substring(e.length - 6) : e), n;
          }, Ae = function (e, n, t, o, i, a, u) {
            var s, c, l = !!e.diagnosticUseCombinedEvent, f = 'ld:' + i + ':$diagnostics', d = a.eventsUrl + '/events/diagnostic/' + i, v = a.diagnosticRecordingInterval, g = t, p = !!a.streaming, m = {};
            function y() {
              return {
                sdk: function () {
                  var n = r({}, e.diagnosticSdkData);
                  return a.wrapperName && (n.wrapperName = a.wrapperName), a.wrapperVersion && (n.wrapperVersion = a.wrapperVersion), n;
                }(),
                configuration: (n = {
                  customBaseURI: a.baseUrl !== Ce.baseUrl.default,
                  customStreamURI: a.streamUrl !== Ce.streamUrl.default,
                  customEventsURI: a.eventsUrl !== Ce.eventsUrl.default,
                  eventsCapacity: a.eventCapacity,
                  eventsFlushIntervalMillis: a.flushInterval,
                  reconnectTimeMillis: a.streamReconnectDelay,
                  streamingDisabled: !p,
                  allAttributesPrivate: !!a.allAttributesPrivate,
                  inlineUsersInEvents: !!a.inlineUsersInEvents,
                  diagnosticRecordingIntervalMillis: a.diagnosticRecordingInterval,
                  usingSecureMode: !!a.hash,
                  bootstrapMode: !!a.bootstrap,
                  fetchGoalsDisabled: !a.fetchGoals,
                  allowFrequentDuplicateEvents: !!a.allowFrequentDuplicateEvents,
                  sendEventsOnlyForVariation: !!a.sendEventsOnlyForVariation,
                  autoAliasingOptOut: !!a.autoAliasingOptOut
                }, n),
                platform: e.diagnosticPlatformData
              };
              var n;
            }
            function h(e) {
              a.logger && a.logger.debug(Pe.debugPostingDiagnosticEvent(e)), o.sendEvents(e, d, !0).then(function () {
              }).catch(function () {
              });
            }
            function b() {
              var e, t;
              h((e = new Date().getTime(), t = r({
                kind: l ? 'diagnostic-combined' : 'diagnostic',
                id: u,
                creationDate: e
              }, g.getProps()), l && (t = r({}, t, {}, y())), g.reset(e), t)), c = setTimeout(b, v), s = new Date().getTime(), l && function () {
                if (n.isEnabled()) {
                  var e = r({}, g.getProps());
                  n.set(f, JSON.stringify(e));
                }
              }();
            }
            return m.start = function () {
              l ? function (e) {
                if (!n.isEnabled())
                  return e(!1);
                n.get(f).then(function (n) {
                  if (n)
                    try {
                      var t = JSON.parse(n);
                      g.setProps(t), s = t.dataSinceDate;
                    } catch (n) {
                    }
                  e(!0);
                }).catch(function () {
                  e(!1);
                });
              }(function (e) {
                if (e) {
                  var n = (s || 0) + v, t = new Date().getTime();
                  n <= t ? b() : c = setTimeout(b, n - t);
                } else
                  0 === Math.floor(4 * Math.random()) ? b() : c = setTimeout(b, v);
              }) : (h(r({
                kind: 'diagnostic-init',
                id: u,
                creationDate: g.getProps().dataSinceDate
              }, y())), c = setTimeout(b, v));
            }, m.stop = function () {
              c && clearTimeout(c);
            }, m.setStreaming = function (e) {
              p = e;
            }, m;
          };
        function qe(e, t, o, i, a) {
          var c, f, p, m, y, h, b, w, k, E = o && o.logger ? o.logger : a && a.logger && a.logger.default || Le('warn'), S = function (e) {
              var n = {}, t = {};
              return n.on = function (e, n, r) {
                t[e] = t[e] || [], t[e] = t[e].concat({
                  handler: n,
                  context: r
                });
              }, n.off = function (e, n, r) {
                if (t[e])
                  for (var o = 0; o < t[e].length; o++)
                    t[e][o].handler === n && t[e][o].context === r && (t[e] = t[e].slice(0, o).concat(t[e].slice(o + 1)));
              }, n.emit = function (e) {
                if (t[e])
                  for (var n = t[e].slice(0), r = 0; r < n.length; r++)
                    n[r].handler.apply(n[r].context, Array.prototype.slice.call(arguments, 1));
              }, n.getEvents = function () {
                return Object.keys(t);
              }, n.getEventListenerCount = function (e) {
                return t[e] ? t[e].length : 0;
              }, n.maybeReportError = function (n) {
                n && (t.error ? this.emit('error', n) : (e || console).error(n.message));
              }, n;
            }(E), D = function (e) {
              var n = !1, t = !1, r = null, o = null, i = new Promise(function (n) {
                  e.on('ready', function t() {
                    e.off('ready', t), n();
                  });
                }).catch(function () {
                });
              return {
                getInitializationPromise: function () {
                  return o || (n ? Promise.resolve() : t ? Promise.reject(r) : o = new Promise(function (n, t) {
                    e.on('initialized', function t() {
                      e.off('initialized', t), n();
                    }), e.on('failed', function n(r) {
                      e.off('failed', n), t(r);
                    });
                  }));
                },
                getReadyPromise: function () {
                  return i;
                },
                signalSuccess: function () {
                  n || t || (n = !0, e.emit('initialized'), e.emit('ready'));
                },
                signalFailure: function (o) {
                  n || t || (t = !0, r = o, e.emit('failed', o), e.emit('ready')), e.maybeReportError(o);
                }
              };
            }(S), O = Ne(o, S, a, E), P = O.sendEvents, j = e, L = O.hash, N = (h = i.localStorage, b = E, k = !(w = {}), w.isEnabled = function () {
              return !!h;
            }, w.get = function (e) {
              return new Promise(function (n) {
                h ? h.get(e).then(n).catch(function (e) {
                  se(e), n(void 0);
                }) : n(void 0);
              });
            }, w.set = function (e, n) {
              return new Promise(function (t) {
                h ? h.set(e, n).then(function () {
                  return t(!0);
                }).catch(function (e) {
                  se(e), t(!1);
                }) : t(!1);
              });
            }, w.clear = function (e) {
              return new Promise(function (n) {
                h ? h.clear(e).then(function () {
                  return n(!0);
                }).catch(function (e) {
                  se(e), n(!1);
                }) : n(!1);
              });
            }, w), C = W(i, j, O), F = O.sendEvents && !O.diagnosticOptOut, A = F ? Fe(j) : null, V = F ? function (e) {
              var n, t, r, o;
              function i(e) {
                n = e, r = t = 0, o = [];
              }
              return i(e), {
                getProps: function () {
                  return {
                    dataSinceDate: n,
                    droppedEvents: t,
                    eventsInLastBatch: r,
                    streamInits: o
                  };
                },
                setProps: function (e) {
                  n = e.dataSinceDate, t = e.droppedEvents || 0, r = e.eventsInLastBatch || 0, o = e.streamInits || [];
                },
                incrementDroppedEvents: function () {
                  t++;
                },
                setEventsInLastBatch: function (e) {
                  r = e;
                },
                recordStreamInit: function (e, n, t) {
                  var r = {
                    timestamp: e,
                    failed: n,
                    durationMillis: t
                  };
                  o.push(r);
                },
                reset: i
              };
            }(new Date().getTime()) : null, z = F ? Ae(i, N, V, C, j, O, A) : null, J = Ue(i, O, j, V), H = O.eventProcessor || function (e, n, t, r, o, i) {
              var a, s = 3 < arguments.length && void 0 !== r ? r : null, c = 4 < arguments.length && void 0 !== o ? o : null, l = {}, f = (5 < arguments.length && void 0 !== i ? i : null) || W(e, t, n), d = n.eventsUrl + '/events/bulk/' + t, v = function () {
                  var e = {}, n = 0, t = 0, r = {};
                  return e.summarizeEvent = function (e) {
                    if ('feature' === e.kind) {
                      var o = e.key + ':' + (null !== e.variation && void 0 !== e.variation ? e.variation : '') + ':' + (null !== e.version && void 0 !== e.version ? e.version : ''), i = r[o];
                      i ? i.count = i.count + 1 : r[o] = {
                        count: 1,
                        key: e.key,
                        variation: e.variation,
                        version: e.version,
                        value: e.value,
                        default: e.default
                      }, (0 === n || e.creationDate < n) && (n = e.creationDate), e.creationDate > t && (t = e.creationDate);
                    }
                  }, e.getSummary = function () {
                    var e = {}, o = !0;
                    for (var i in r) {
                      var a = r[i], u = e[a.key];
                      u || (u = {
                        default: a.default,
                        counters: []
                      }, e[a.key] = u);
                      var s = {
                        value: a.value,
                        count: a.count
                      };
                      void 0 !== a.variation && null !== a.variation && (s.variation = a.variation), a.version ? s.version = a.version : s.unknown = !0, u.counters.push(s), o = !1;
                    }
                    return o ? null : {
                      startDate: n,
                      endDate: t,
                      features: e
                    };
                  }, e.clearSummary = function () {
                    t = n = 0, r = {};
                  }, e;
                }(), p = Q(n), m = n.inlineUsersInEvents, y = n.samplingInterval, h = n.eventCapacity, b = n.flushInterval, w = n.logger, k = [], E = 0, S = !1, D = !1;
              function O() {
                return 0 === y || 0 === Math.floor(Math.random() * y);
              }
              function P(e) {
                k.length < h ? (k.push(e), D = !1) : (D || (D = !0, w.warn('Exceeded event queue capacity. Increase capacity to avoid dropping events.')), s && s.incrementDroppedEvents());
              }
              return l.enqueue = function (e) {
                if (!S) {
                  var n = !1, t = !1;
                  if (v.summarizeEvent(e), 'feature' === e.kind ? O() && (n = !!e.trackEvents, t = function (e) {
                      return !!e.debugEventsUntilDate && e.debugEventsUntilDate > E && e.debugEventsUntilDate > new Date().getTime();
                    }(e)) : n = O(), n && P(function (e) {
                      var n = q({}, e);
                      return 'alias' === e.kind || (m || 'identify' === e.kind ? n.user = p.filterUser(e.user) : (n.userKey = e.user.key, delete n.user), 'feature' === e.kind && (delete n.trackEvents, delete n.debugEventsUntilDate)), n;
                    }(e)), t) {
                    var r = q({}, e, { kind: 'debug' });
                    r.user = p.filterUser(r.user), delete r.trackEvents, delete r.debugEventsUntilDate, P(r);
                  }
                }
              }, l.flush = function () {
                if (S)
                  return Promise.resolve();
                var e = k, n = v.getSummary();
                return v.clearSummary(), n && (n.kind = 'summary', e.push(n)), s && s.setEventsInLastBatch(e.length), 0 === e.length ? Promise.resolve() : (k = [], w.debug(Oe(e.length)), f.sendEvents(e, d).then(function (e) {
                  e && (e.serverTime && (E = e.serverTime), g(e.status) || (S = !0), 400 <= e.status && R(function () {
                    c.maybeReportError(new u(fe(e.status, 'event posting', 'some events were dropped')));
                  }));
                }));
              }, l.start = function () {
                a = setTimeout(function e() {
                  l.flush(), a = setTimeout(e, b);
                }, b);
              }, l.stop = function () {
                clearTimeout(a);
              }, l;
            }(i, O, j, V, S, C), K = Ie(i, O, j), $ = {}, B = {}, G = O.streaming, X = !1, Y = !1, Z = !0, ee = O.stateProvider, te = (m = function (e, n) {
              var t;
              t = e, ee || t && le({
                kind: 'identify',
                key: t.key,
                user: t,
                creationDate: new Date().getTime()
              }), !O.autoAliasingOptOut && n && n.anonymous && e && !e.anonymous && me(e, n);
            }, {
              setUser: function (e) {
                var n = y && U(y);
                (y = M(e)) && m && m(U(y), n);
              },
              getUser: function () {
                return y ? U(y) : null;
              }
            }), oe = Re(N), ue = N.isEnabled() ? new je(N, j, L, te, E) : null;
          function se(e) {
            k || (k = !0, b.warn(ne(e)));
          }
          function le(e) {
            if (j && !(ee && ee.enqueueEvent && ee.enqueueEvent(e))) {
              if ('alias' !== e.kind) {
                if (!e.user)
                  return void (Z && (E.warn('Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript'), Z = !1));
                Z = !1;
              }
              !P || Y || i.isDoNotTrack() || (E.debug(De(e.kind)), H.enqueue(e));
            }
          }
          function de(e, n, t, r) {
            var o = te.getUser(), i = new Date(), a = n ? n.value : null;
            if (!O.allowFrequentDuplicateEvents) {
              var u = JSON.stringify(a) + (o && o.key ? o.key : '') + e, s = $[u];
              if (s && i - s < 300000)
                return;
              $[u] = i;
            }
            var c = {
              kind: 'feature',
              key: e,
              user: o,
              value: a,
              variation: n ? n.variationIndex : null,
              default: t,
              creationDate: i.getTime()
            };
            o && o.anonymous && (c.contextKind = pe(o));
            var l = B[e];
            l && (c.version = l.flagVersion ? l.flagVersion : l.version, c.trackEvents = l.trackEvents, c.debugEventsUntilDate = l.debugEventsUntilDate), (r || l && l.trackReason) && n && (c.reason = n.reason), le(c);
          }
          function ve(e, n, t, r) {
            var o;
            if (B && _(B, e) && B[e] && !B[e].deleted) {
              var i = B[e];
              o = ge(i), null !== i.value && void 0 !== i.value || (o.value = n);
            } else
              o = {
                value: n,
                variationIndex: null,
                reason: {
                  kind: 'ERROR',
                  errorKind: 'FLAG_NOT_FOUND'
                }
              };
            return t && de(e, o, n, r), o;
          }
          function ge(e) {
            return {
              value: e.value,
              variationIndex: void 0 === e.variation ? null : e.variation,
              reason: e.reason || null
            };
          }
          function pe(e) {
            return e.anonymous ? 'anonymousUser' : 'user';
          }
          function me(e, n) {
            ee || e && n && le({
              kind: 'alias',
              key: e.key,
              contextKind: pe(e),
              previousKey: n.key,
              previousContextKind: pe(n),
              creationDate: new Date().getTime()
            });
          }
          function ye() {
            if (f = !0, te.getUser()) {
              var e = function (e) {
                try {
                  return JSON.parse(e);
                } catch (e) {
                  return void S.maybeReportError(new v('Invalid data received from LaunchDarkly; connection may have been interrupted'));
                }
              };
              J.connect(te.getUser(), L, {
                ping: function () {
                  E.debug('received ping message from stream');
                  var e = te.getUser();
                  K.fetchFlagSettings(e, L).then(function (n) {
                    I(e, te.getUser()) && be(n || {});
                  }).catch(function (e) {
                    S.maybeReportError(new d(ae(e)));
                  });
                },
                put: function (n) {
                  var t = e(n.data);
                  t && (E.debug('received streaming update for all flags'), be(t));
                },
                patch: function (n) {
                  var t = e(n.data);
                  if (t) {
                    var r = B[t.key];
                    if (!r || !r.version || !t.version || r.version < t.version) {
                      E.debug(we(t.key));
                      var o = {}, i = q({}, t);
                      delete i.key;
                      var a = ge(B[t.key] = i);
                      o[t.key] = r ? {
                        previous: r.value,
                        current: a
                      } : { current: a }, Pe(o);
                    } else
                      E.debug(ke(t.key));
                  }
                },
                delete: function (n) {
                  var t = e(n.data);
                  if (t)
                    if (!B[t.key] || B[t.key].version < t.version) {
                      E.debug(Ee(t.key));
                      var r = {};
                      B[t.key] && !B[t.key].deleted && (r[t.key] = { previous: B[t.key].value }), B[t.key] = {
                        version: t.version,
                        deleted: !0
                      }, Pe(r);
                    } else
                      E.debug(Se(t.key));
                }
              });
            }
          }
          function he() {
            f && (J.disconnect(), f = !1);
          }
          function be(e) {
            var n = {};
            if (!e)
              return Promise.resolve();
            for (var t in B)
              _(B, t) && B[t] && (e[t] && !I(e[t].value, B[t].value) ? n[t] = {
                previous: B[t].value,
                current: ge(e[t])
              } : e[t] && !e[t].deleted || (n[t] = { previous: B[t].value }));
            for (var o in e)
              _(e, o) && e[o] && (!B[o] || B[o].deleted) && (n[o] = { current: ge(e[o]) });
            return B = r({}, e), Pe(n).catch(function () {
            });
          }
          function Pe(e) {
            var n = Object.keys(e);
            if (0 < n.length) {
              var t = {};
              n.forEach(function (n) {
                var r = e[n].current, o = r ? r.value : void 0, i = e[n].previous;
                S.emit('change:' + n, o, i), t[n] = r ? {
                  current: o,
                  previous: i
                } : { previous: i };
              }), S.emit('change', t), S.emit('internal-change', B), O.sendEventsOnlyForVariation || ee || n.forEach(function (n) {
                de(n, e[n].current);
              });
            }
            return c && ue ? ue.saveFlags(B) : Promise.resolve();
          }
          function Te() {
            var e = G || p && void 0 === G;
            e && !f ? ye() : !e && f && he(), z && z.setStreaming(e);
          }
          function xe(e) {
            return 'change' === e || 'change:' === e.substr(0, 'change'.length + 1);
          }
          if ('string' == typeof O.bootstrap && 'LOCALSTORAGE' === O.bootstrap.toUpperCase() && (ue ? c = !0 : E.warn(ne())), 'object' === n(O.bootstrap) && (B = function (e) {
              var n = Object.keys(e), t = e.$flagsState;
              !t && n.length && E.warn(ce()), !1 === e.$valid && E.warn('LaunchDarkly bootstrap data is not available because the back end could not read the flags.');
              var r = {};
              return n.forEach(function (n) {
                if ('$flagsState' !== n && '$valid' !== n) {
                  var o = { value: e[n] };
                  t && t[n] ? o = q(o, t[n]) : o.version = 0, r[n] = o;
                }
              }), r;
            }(O.bootstrap)), ee) {
            var Ce = ee.getInitialState();
            Ce ? qe(Ce) : ee.on('init', qe), ee.on('update', function (e) {
              e.user && te.setUser(e.user), e.flags && be(e.flags);
            });
          } else
            (e ? oe.validateUser(t).then(function (e) {
              return te.setUser(e), 'object' === n(O.bootstrap) ? _e() : c ? ue.loadFlags().then(function (e) {
                return null == e ? (B = {}, K.fetchFlagSettings(te.getUser(), L).then(function (e) {
                  return be(e || {});
                }).then(_e).catch(function (e) {
                  Me(new d(ae(e)));
                })) : (B = e, R(_e), K.fetchFlagSettings(te.getUser(), L).then(function (e) {
                  return be(e);
                }).catch(function (e) {
                  return S.maybeReportError(e);
                }));
              }) : K.fetchFlagSettings(te.getUser(), L).then(function (e) {
                B = e || {}, _e();
              }).catch(function (e) {
                B = {}, Me(e);
              });
            }) : Promise.reject(new s(ie()))).catch(Me);
          function qe(e) {
            j = e.environment, te.setUser(e.user), B = r({}, e.flags), R(_e);
          }
          function _e() {
            E.info('LaunchDarkly client initialized'), X = !0, Te(), D.signalSuccess();
          }
          function Me(e) {
            D.signalFailure(e);
          }
          return {
            client: {
              waitForInitialization: function () {
                return D.getInitializationPromise();
              },
              waitUntilReady: function () {
                return D.getReadyPromise();
              },
              identify: function (e, n, t) {
                return Y ? T(Promise.resolve({}), t) : ee ? (E.warn('identify() has no effect here; it must be called on the main client instance'), T(Promise.resolve(x(B)), t)) : T((c && ue ? ue.clearFlags() : Promise.resolve()).then(function () {
                  return oe.validateUser(e);
                }).then(function (e) {
                  return K.fetchFlagSettings(e, n).then(function (t) {
                    var r = x(t);
                    return te.setUser(e), L = n, t ? be(t).then(function () {
                      return r;
                    }) : r;
                  });
                }).then(function (e) {
                  return f && ye(), e;
                }).catch(function (e) {
                  return S.maybeReportError(e), Promise.reject(e);
                }), t);
              },
              getUser: function () {
                return te.getUser();
              },
              variation: function (e, n) {
                return ve(e, n, !0, !1).value;
              },
              variationDetail: function (e, n) {
                return ve(e, n, !0, !0);
              },
              track: function (e, n, t) {
                if ('string' == typeof e) {
                  i.customEventFilter && !i.customEventFilter(e) && E.warn(re(e));
                  var r = te.getUser(), o = {
                      kind: 'custom',
                      key: e,
                      user: r,
                      url: i.getCurrentUrl(),
                      creationDate: new Date().getTime()
                    };
                  r && r.anonymous && (o.contextKind = pe(r)), null != n && (o.data = n), null != t && (o.metricValue = t), le(o);
                } else
                  S.maybeReportError(new l(re(e)));
              },
              alias: me,
              on: function (e, n, t) {
                xe(e) ? (p = !0, X && Te(), S.on(e, n, t)) : S.on.apply(S, arguments);
              },
              off: function (e) {
                if (S.off.apply(S, arguments), xe(e)) {
                  var n = !1;
                  S.getEvents().forEach(function (e) {
                    xe(e) && 0 < S.getEventListenerCount(e) && (n = !0);
                  }), n || (p = !1, f && void 0 === G && he());
                }
              },
              setStreaming: function (e) {
                var n = null === e ? void 0 : e;
                n !== G && (G = n, Te());
              },
              flush: function (e) {
                return T(P ? H.flush() : Promise.resolve(), e);
              },
              allFlags: function () {
                var e = {};
                if (!B)
                  return e;
                for (var n in B)
                  _(B, n) && (e[n] = ve(n, null, !O.sendEventsOnlyForVariation).value);
                return e;
              },
              close: function (e) {
                if (Y)
                  return T(Promise.resolve(), e);
                function n() {
                  Y = !0, B = {};
                }
                return T(Promise.resolve().then(function () {
                  if (he(), z && z.stop(), P)
                    return H.stop(), H.flush();
                }).then(n).catch(n), e);
              }
            },
            options: O,
            emitter: S,
            ident: te,
            logger: E,
            requestor: K,
            start: function () {
              P && (z && z.start(), H.start());
            },
            enqueueEvent: le,
            getFlagsInternal: function () {
              return B;
            },
            getEnvironmentId: function () {
              return j;
            },
            internalChangeEventName: 'internal-change'
          };
        }
        function _e(e, n) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            n && (r = r.filter(function (n) {
              return Object.getOwnPropertyDescriptor(e, n).enumerable;
            })), t.push.apply(t, r);
          }
          return t;
        }
        function Me(e) {
          for (var n = 1; n < arguments.length; n++) {
            var t = null != arguments[n] ? arguments[n] : {};
            n % 2 ? _e(Object(t), !0).forEach(function (n) {
              var r, o, i;
              r = e, i = t[o = n], o in r ? Object.defineProperty(r, o, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              }) : r[o] = i;
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : _e(Object(t)).forEach(function (n) {
              Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n));
            });
          }
          return e;
        }
        var Ve = {
          promise: Promise.resolve({
            status: 200,
            header: function () {
              return null;
            },
            body: null
          })
        };
        function ze(e, n, t, r, o) {
          if (o && !function () {
              var e = window.navigator && window.navigator.userAgent;
              if (e) {
                var n = e.match(/Chrom(e|ium)\/([0-9]+)\./);
                if (n)
                  return parseInt(n[2], 10) < 73;
              }
              return !0;
            }())
            return Ve;
          var i, a = new window.XMLHttpRequest();
          for (var u in (a.open(e, n, !o), t || {}))
            Object.prototype.hasOwnProperty.call(t, u) && a.setRequestHeader(u, t[u]);
          return o ? (a.send(r), Ve) : {
            promise: new Promise(function (e, n) {
              a.addEventListener('load', function () {
                i || e({
                  status: a.status,
                  header: function (e) {
                    return a.getResponseHeader(e);
                  },
                  body: a.responseText
                });
              }), a.addEventListener('error', function () {
                i || n(new Error());
              }), a.send(r);
            }),
            cancel: function () {
              i = !0, a.abort();
            }
          };
        }
        var Je = /[|\\{}()[\]^$+*?.]/g, He = function (e) {
            if ('string' != typeof e)
              throw new TypeError('Expected a string');
            return e.replace(Je, '\\$&');
          };
        function Ke(e, n, t, r) {
          var o, i, a = ('substring' !== e.kind && 'regex' !== e.kind || !r.includes('/') ? n.replace(r, '') : n).replace(t, '');
          switch (e.kind) {
          case 'exact':
            i = n, o = new RegExp('^' + He(e.url) + '/?$');
            break;
          case 'canonical':
            i = a, o = new RegExp('^' + He(e.url) + '/?$');
            break;
          case 'substring':
            i = a, o = new RegExp('.*' + He(e.substring) + '.*$');
            break;
          case 'regex':
            i = a, o = new RegExp(e.pattern);
            break;
          default:
            return !1;
          }
          return o.test(i);
        }
        function $e(e, n) {
          for (var t = {}, r = null, o = [], i = 0; i < e.length; i++)
            for (var a = e[i], u = a.urls || [], s = 0; s < u.length; s++)
              if (Ke(u[s], window.location.href, window.location.search, window.location.hash)) {
                'pageview' === a.kind ? n('pageview', a) : (o.push(a), n('click_pageview', a));
                break;
              }
          return 0 < o.length && (r = function (e) {
            for (var t = function (e, n) {
                  for (var t = [], r = 0; r < n.length; r++)
                    for (var o = e.target, i = n[r], a = i.selector, u = document.querySelectorAll(a); o && 0 < u.length;) {
                      for (var s = 0; s < u.length; s++)
                        o === u[s] && t.push(i);
                      o = o.parentNode;
                    }
                  return t;
                }(e, o), r = 0; r < t.length; r++)
              n('click', t[r]);
          }, document.addEventListener('click', r)), t.dispose = function () {
            document.removeEventListener('click', r);
          }, t;
        }
        function Be(e, n) {
          var t, r;
          function o() {
            r && r.dispose(), t && t.length && (r = $e(t, i));
          }
          function i(n, t) {
            var r = e.ident.getUser(), o = {
                kind: n,
                key: t.key,
                data: null,
                url: window.location.href,
                user: r,
                creationDate: new Date().getTime()
              };
            return r && r.anonymous && (o.contextKind = 'anonymousUser'), 'click' === n && (o.selector = t.selector), e.enqueueEvent(o);
          }
          return e.requestor.fetchJSON('/sdk/goals/' + e.getEnvironmentId()).then(function (e) {
            e && 0 < e.length && (r = $e(t = e, i), function (e, n) {
              var t, r = window.location.href;
              function o() {
                (t = window.location.href) !== r && (r = t, n());
              }
              !function e(n, t) {
                n(), setTimeout(function () {
                  e(n, t);
                }, t);
              }(o, e), window.history && window.history.pushState ? window.addEventListener('popstate', o) : window.addEventListener('hashchange', o);
            }(300, o)), n();
          }).catch(function (t) {
            e.emitter.maybeReportError(new p.LDUnexpectedResponseError((t && t.message, t.message))), n();
          }), {};
        }
        var Ge = 'goalsReady', Xe = {
            fetchGoals: { default: !0 },
            hash: { type: 'string' },
            eventProcessor: { type: 'object' },
            eventUrlTransformer: { type: 'function' },
            disableSyncEventPost: { default: !1 }
          };
        function We(e, n) {
          var t = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, r = function (e) {
              var n, t = { synchronousFlush: !1 };
              if (window.XMLHttpRequest) {
                var r = e && e.disableSyncEventPost;
                t.httpRequest = function (e, n, o, i) {
                  var a = t.synchronousFlush & !r;
                  return t.synchronousFlush = !1, ze(e, n, o, i, a);
                };
              }
              t.httpAllowsPost = function () {
                return void 0 === n && (n = !!window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest()), n;
              }, t.httpFallbackPing = function (e) {
                new window.Image().src = e;
              };
              var o, i = e && e.eventUrlTransformer;
              t.getCurrentUrl = function () {
                return i ? i(window.location.href) : window.location.href;
              }, t.isDoNotTrack = function () {
                var e;
                return 1 === (e = window.navigator && void 0 !== window.navigator.doNotTrack ? window.navigator.doNotTrack : window.navigator && void 0 !== window.navigator.msDoNotTrack ? window.navigator.msDoNotTrack : window.doNotTrack) || !0 === e || '1' === e || 'yes' === e;
              };
              try {
                window.localStorage && (t.localStorage = {
                  get: function (e) {
                    return new Promise(function (n) {
                      n(window.localStorage.getItem(e));
                    });
                  },
                  set: function (e, n) {
                    return new Promise(function (t) {
                      window.localStorage.setItem(e, n), t();
                    });
                  },
                  clear: function (e) {
                    return new Promise(function (n) {
                      window.localStorage.removeItem(e), n();
                    });
                  }
                });
              } catch (e) {
                t.localStorage = null;
              }
              var a = e && e.useReport;
              return o = a && 'function' == typeof window.EventSourcePolyfill && window.EventSourcePolyfill.supportedOptions && window.EventSourcePolyfill.supportedOptions.method ? (t.eventSourceAllowsReport = !0, window.EventSourcePolyfill) : (t.eventSourceAllowsReport = !1, window.EventSource), window.EventSource && (t.eventSourceFactory = function (e, n) {
                var t = Me(Me({}, {
                  heartbeatTimeout: 300000,
                  silentTimeout: 300000,
                  skipDefaultHeaders: !0
                }), n);
                return new o(e, t);
              }, t.eventSourceIsActive = function (e) {
                return e.readyState === window.EventSource.OPEN || e.readyState === window.EventSource.CONNECTING;
              }), t.userAgent = 'JSClient', t.version = '2.20.2', t.diagnosticSdkData = {
                name: 'js-client-sdk',
                version: '2.20.2'
              }, t.diagnosticPlatformData = { name: 'JS' }, t.diagnosticUseCombinedEvent = !0, t;
            }(t), o = qe(e, n, t, r, Xe), i = o.client, a = o.options, u = o.emitter, s = new Promise(function (e) {
              var n = u.on(Ge, function () {
                u.off(Ge, n), e();
              });
            });
          function c() {
            r.synchronousFlush = !0, i.flush().catch(function () {
            }), r.synchronousFlush = !1;
          }
          return i.waitUntilGoalsReady = function () {
            return s;
          }, a.fetchGoals ? Be(o, function () {
            return u.emit(Ge);
          }) : u.emit(Ge), 'complete' !== document.readyState ? window.addEventListener('load', o.start) : o.start(), window.addEventListener('beforeunload', c), window.addEventListener('unload', c), i;
        }
        var Qe = Le, Ye = {
            initialize: function (e, n) {
              var t = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
              return console && console.warn && console.warn(Pe.deprecated('default export', 'named LDClient export')), We(e, n, t);
            },
            version: '2.20.2'
          };
        e.createConsoleLogger = Qe, e.default = Ye, e.initialize = We, e.version = '2.20.2', Object.defineProperty(e, '__esModule', { value: !0 });
      });
    }]);
  synchronite_proxyless_env = function () {
    var env = {
      //Launchdarkly env : Testing QA
      qa: { launchDarklyClientSideId: '62134ae1823f6f14193bd937' },
      //Launchdarkly env : Alpha [Prod]
      alpha: { launchDarklyClientSideId: '62134ae1823f6f14193bd92f' },
      //Launchdarkly env : Sydney [Prod]
      sydneyProd: { launchDarklyClientSideId: '62134ae1823f6f14193bd933' },
      //Launchdarkly env : London [Prod]
      londonProd: { launchDarklyClientSideId: '62134ae1823f6f14193bd935' },
      //Launchdarkly env : Virginia [Prod]
      virginiaProd: { launchDarklyClientSideId: '62134ae1823f6f14193bd939' },
      //Launchdarkly env : California [DR]
      californiaDR: { launchDarklyClientSideId: '62134ae1823f6f14193bd929' },
      //Launchdarkly env : Melbourne [DR]
      melbourneDR: { launchDarklyClientSideId: '62134ae1823f6f14193bd92b' },
      //Launchdarkly env : Amsterdam [DR]
      amsterdamDR: { launchDarklyClientSideId: '62134ae1823f6f14193bd92d' },
      //Launchdarkly env : CA-Alpha [DR]
      caAlphaDR: { launchDarklyClientSideId: '62134ae1823f6f14193bd931' }
    };
    return env;
  }();
  synchronite_proxyless_getCsdsSettings = function () {
    function getSiteID() {
      var params = getSiteSettingsFromIframeQueryParams();
      var isLoadedFromTheNAW = isLoadedInIframe();
      var isStandaloneMode = isInOwnWindow();
      var isUnifiedWindow = window.lpTag;
      if (isLoadedFromTheNAW && params && params.siteId) {
        return params.siteId;
      } else if (isStandaloneMode) {
        var host = window.location.host;
        var siteId = host.split('.')[0];
        return siteId;
      } else if (isUnifiedWindow) {
        return window.lpTag.site;
      }
    }
    /**
     * Get site settings url params from iframe url
     * when loaded via NAW
     * */
    function getSiteSettingsFromIframeQueryParams() {
      // eslint-disable-next-line
      var url = new URL(window.location);
      var params = {
        accdnDomain: url.searchParams.get('accdndomain'),
        siteId: url.searchParams.get('siteId'),
        skillId: url.searchParams.get('skillId')
      };
      return params;
    }
    /**
     * Determine if it is being loaded within an iframe
     * */
    function isLoadedInIframe() {
      try {
        return window.self !== window.top;
      } catch (err) {
        console.log('getCSDSSettings.js - isLoadedInIframe', err);
        return true;
      }
    }
    /**
     * Determine if in standalone mode
     */
    function isInOwnWindow() {
      if (window.lpCallStandaloneMode) {
        return true;
      }
      return false;
    }
    return { getSiteID: getSiteID };
  }();
  synchronite_call_launchDarkly = function (LDClient, env, CSDSSettings) {
    var client;
    function init(tenantId) {
      return new Promise(function (resolve) {
        var ldClientConfig = { key: tenantId || 'cobrowse' };
        var fetchClientSideId;
        var siteId = CSDSSettings.getSiteID();
        console.log('Site Id based on environment - ', siteId);
        try {
          makeHTTPRequest('https://adminlogin.liveperson.net/api/account/' + siteId + '/service/baseURI.json?version=1.0').then(function (response) {
            var json;
            try {
              json = JSON.parse(response);
            } catch (e) {
              resolve();
            }
            var data = json.baseURIs;
            // If condition handles the case for QA and CI domain
            if (Object.keys(data).length === 0) {
              console.log('QA Environment Detected');
              fetchClientSideId = getClientSideId('qa');
            } else {
              var environmentURL;
              console.log('DATA Filter ', data.filter(function (item) {
                if (item.service === 'coBrowse') {
                  environmentURL = item.baseURI;
                  fetchClientSideId = getClientSideId(environmentURL);
                }
              }));
            }
            // eslint-disable-next-line
            client = LDClient.initialize(fetchClientSideId, ldClientConfig);
            if (client) {
              client.on('ready', function () {
                getAllFlags(resolve);
              });
            } else {
              resolve();
            }
          });
        } catch (err) {
          console.log('Error occured while detecting cobrowse environment: ', err);
        }
      });
    }
    function makeHTTPRequest(url) {
      // eslint-disable-next-line
      return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve(xhr.response);
          } else {
            reject({
              status: xhr.status,
              statusText: xhr.statusText
            });
          }
        };
        xhr.onerror = function () {
          reject({
            status: xhr.status,
            statusText: xhr.statusText
          });
        };
        xhr.send();
      });
    }
    /**
     * Get ClientSideId based on the cobrowse Domain
     */
    function getClientSideId(cobrowseDomain) {
      var launchDarklyClientId;
      switch (cobrowseDomain) {
      case 'qa':
      // determined by 'le' in account number or zero length baseURIs. 'le' preferred.
      case 'ctvr-hap01.dev.lprnd.net':
      case 'lp-lecobrowse-ci-web.dev.lprnd.net':
      case 'qa.cobrowse.dev.lprnd.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['qa']['launchDarklyClientSideId'];
        break;
      case 'va-a.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['alpha']['launchDarklyClientSideId'];
        break;
      case 'ca-a.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['caAlphaDR']['launchDarklyClientSideId'];
        break;
      case 'lo.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['londonProd']['launchDarklyClientSideId'];
        break;
      case 'sy.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['sydneyProd']['launchDarklyClientSideId'];
        break;
      case 'va.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['virginiaProd']['launchDarklyClientSideId'];
        break;
      //DR Cases below CA, AM, MEL
      case 'ca.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['californiaDR']['launchDarklyClientSideId'];
        break;
      case 'am.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['amsterdamDR']['launchDarklyClientSideId'];
        break;
      case 'me.cobrowse.liveperson.net':
        // eslint-disable-next-line
        launchDarklyClientId = env['melbourneDR']['launchDarklyClientSideId'];
        break;
      default:
      }
      return launchDarklyClientId;
    }
    /**
     * Get All Flags for detected environment from Launchdarkly.
     * Filter out all false flags. Store true flags to "LaunchDarklyFlags" session storage.
     */
    function getAllFlags(callback) {
      var flags = client.allFlags();
      var enabledFlags = Object.keys(flags).filter(function (flag) {
        return flags[flag];
      });
      try {
        sessionStorage.setItem('LaunchdarklyFlags', enabledFlags);
      } catch (e) {
        console.log('cobrowse launchDarky.js - getAllFlags', e);
      }
      callback();
    }
    /**
     * Get status of feature flag from local storage
     */
    function isFeatureFlagEnabled(featureFlag) {
      var enabledFlag = false;
      var flagValues;
      try {
        flagValues = sessionStorage.getItem('LaunchdarklyFlags').split(',');
      } catch (e) {
        console.log('cobrowse launchDarky.js - isFeatureFlagEnabled', e);
      }
      if (flagValues) {
        Object.keys(flagValues).map(function (key) {
          if (flagValues[key] === featureFlag) {
            enabledFlag = true;
          }
        });
        return enabledFlag;
      } else {
        return enabledFlag;
      }
    }
    return {
      init: init,
      isFeatureFlagEnabled: isFeatureFlagEnabled
    };
  }(transpiled_node_modules_launch_darkly, synchronite_proxyless_env, synchronite_proxyless_getCsdsSettings);
  synchronite_events_keyboard = function (lang, baseArray, query, Evented, on, has, synchQuery, synchEvent, synchDom, baseState, typing, strings, UAParser, launchDarkly) {
    var contextWindow = window,
      // execution context window
      config = contextWindow.synchroniteConfig, localEvents = new Evented(), remoteEvents = new Evented(), replicatorHandles = [], listeners = [];
    var isFirefoxBrowser = new UAParser().getBrowser().name === 'Firefox';
    //------------------- Event constants -----------------------//
    var type = 'key';
    var keyCodesToName = {};
    // initialized in startReplicating
    var keyNodes = [
      'input[type=text]',
      'input[type=search]',
      'input[type=password]',
      'textarea'
    ];
    var profile,
      // defines what events should be listened to and replicated
      Syn;
    // Extended Syn JS library
    //        baseArray.forEach(Syn.key.kinds.special, function(key) {
    //            keyCodesToName[Syn.keycodes[key]] = key;
    //        });
    //        baseArray.forEach(Syn.key.kinds.navigation, function(key) {
    //            keyCodesToName[Syn.keycodes[key]] = key;
    //        });
    //        baseArray.forEach(Syn.key.kinds["function"], function(key) {
    //            keyCodesToName[Syn.keycodes[key]] = key;
    //        });
    //-------------------  Listener Registration -----------------------//
    /* should be idempotent */
    function startListening(activeDocument) {
      // 3.1 Block Keydown Events, if required by active profile
      if (profile.blockEvents) {
        _addEvent(activeDocument, 'keydown', lang.hitch(synchEvent, synchEvent.blockEvent), true);
        var blockKeydowns = [
          'select',
          'input',
          'textarea'
        ];
        baseArray.forEach(blockKeydowns, function (selector) {
          query(selector, activeDocument).on('keydown', lang.hitch(synchEvent, synchEvent.blockEvent));
        }, this);
      }
      // 3.2 Monitor Keypress
      if (profile.monitor.key) {
        // FIXED: "keypress" -> only records characters not backspace and control sequences
        listeners.push(on(activeDocument, 'keydown', monitorKeyDown));
        listeners.push(on(activeDocument, 'keyup', monitorKeyUp));
        if (has('dom-addeventlistener')) {
          // Try to catch keypress before anyone else does and stops propagation (PDF Viewer Zoom)
          activeDocument.addEventListener('keypress', monitorKeyPress, true);
          listeners.push({
            remove: function () {
              activeDocument.removeEventListener('keypress', monitorKeyPress, true);
            }
          });
        } else {
          listeners.push(on(activeDocument, 'keypress', monitorKeyPress));
        }
        registerNodeListeners(activeDocument);
      }
    }
    function stopListening() {
      baseArray.forEach(listeners, function (handle) {
        handle.remove();
      });
      // clear array instead of re-assigning empty array to improve tests
      listeners.splice(0, listeners.length);
      removeNodeListeners(window.document);
    }
    /* idempotent */
    function startReplicating(_config) {
      console.info('STARTREPLICATING keyboard events');
      var replicatorConfig = _config || {};
      if (replicatorConfig.remoteEvents) {
        remoteEvents = replicatorConfig.remoteEvents;
      }
      if (replicatorHandles) {
        baseArray.forEach(replicatorHandles, function (handle) {
          handle.remove();
        });
      }
      replicatorHandles = [remoteEvents.on(type, handleKey)];
      var synKey;
      for (var name in Syn.keycodes) {
        if (Syn.keycodes.hasOwnProperty(name)) {
          synKey = Syn.keycodes[name];
          // if (name && name.length > 1 && ("a" <= name.charAt(0) && name.charAt(0) <= "z")) {
          //   keyCodesToName[synKey] = "[" + name + "]";
          // } else {
          keyCodesToName[synKey] = name;  // }
        }
      }
    }
    //------------------- Event Replicator -----------------------/
    function handleKey(data) {
      if (data.senderId != config.userId) {
        var remoteEvent = data.keyboardEvent;
        console.debug('handleKeyEvent - TYPE: ' + remoteEvent.type + ' KEYCODE: ' + remoteEvent.keyCode);
        var element = synchQuery.queryElement(data.cssSelector);
        if (element && remoteEvent.type == 'keypress' || remoteEvent.type == 'keydown') {
          var isProtected = synchQuery.isProtected(element) || remoteEvent.isProtected;
          if (isProtected && config.sendProtected && config.isAgent) {
            // hide text input
            if (synchDom.isHtml5Typeable(element) && element.type != 'password') {
              element.setAttribute('data-original-type', element.type);
              element.type = 'password';
            }
          }
          if (!isProtected || config.sendProtected) {
            var keyCode = remoteEvent.keyCode;
            var synKey = remoteEvent.synKey;
            // we get trouble when we use keyCode to check unprint. char
            if (!synKey) {
              if (typeof keyCodesToName[keyCode] != 'undefined') {
                synKey = keyCodesToName[keyCode];
              }
            }
            if (synKey == 'insert') {
              // FIXME: insert key
              return;
            }
            if (!synKey) {
              console.info('handleKey -> Unknwown keyCode ' + keyCode);
              // most likely mac-meta key: 224
              return;
            }
            console.debug('HandleKeyDown: ', synKey);
            //ensure the text is the same, before new chracter is inserted
            handleChange(data);
            //position cursor
            if (data.targetNodeHadWindowFocus !== false) {
              // data.selectRange is only correct if the focus was correct
              var sel = data.selectRange;
              if (sel) {
                try {
                  Syn.selectText(element, sel.start, sel.end);
                } catch (e) {
                  console.error('Error setting selection', {
                    error: e,
                    element: element,
                    selection: sel
                  });
                }
              }
              //type key
              Syn.key(synKey, element);
            }
          }
          if (synchDom.isTypeable(element)) {
            typing.show(element, data.userName, data.senderId, isProtected);
          }  //console.debug("Firing handleChange from handleKeyDown");
             //handleChange(msg);
        }  //}
      }
    }
    function handleChange(data) {
      console.log('handleChange', data);
      if (data.senderId != config.userId) {
        var node = synchQuery.queryElement(data.cssSelector);
        if (!node) {
          console.warn('handleChange: Node not found ', data.cssSelector);
          return;
        }
        if (synchQuery.isProtected(node)) {
          return;
        }
        var nodeState = data.nodeState;
        console.log('handleChange: ', nodeState);
        if (node && nodeState) {
          baseState.setNodeState(node, nodeState);
        } else {
          console.debug('handleChange: Unable to setNodeState for ', data.cssSelector);
        }
      }
    }
    //------------------- Event Listener -----------------------/
    function monitorKeyPress(event) {
      console.log('monitorKeyPress', event);
      // handles all printable characters
      //keydown
      //    Fires when the user depresses a key. It repeats while the user keeps the key depressed.
      //keypress
      //    Fires when an actual character is being inserted in, for instance, a text input. It repeats while the user keeps the key depressed. Not supported by Safari iPhone.
      //keyup
      //    Fires when the user releases a key, after the default action of that key has been performed
      //console.debug("KeyEvent caught - TYPE: " + event.type + " KEYCODE: " + event.keyCode);
      //console.debug("Check if is result of simulated key down...");
      if (synchEvent.isSimulated(event)) {
        //console.debug("...TRUE -> SIMULATED EVENT");
        return true;  //do not stop event propagation
      }
      if (!processEventNow(event)) {
        return;
      }
      // must be before early exits
      var keyboardEvent, msg = {};
      var selector;
      var node = synchEvent.getNodeFromEvent(event);
      if (event.charCode) {
        keyboardEvent = _collectKeyEvent(event);
        if (keyboardEvent.isProtected) {
          typing.show(node, config.userName, config.userId, true);
          if (config.isAgent) {
            event.preventDefault();
            return false;
          }
        }
        selector = synchQuery.getNodeSelectorFromEvent(event);
        var synKey = keyboardEvent.synKey;
        console.info('keypress: ', synKey);
        var ls = synKey.toLowerCase();
        var isCopyPaste = (event.ctrlKey || event.metaKey) && (ls == 'v' || ls == 'c' || ls == 'x' || ls == 'a');
        if (isCopyPaste) {
          // fixme
          // this.monitorNodeChanges[selector.element] = true;
          // setTimeout(lang.hitch(this, this.monitorChange, event), 100);
          return true;
        }
        msg = {
          cssSelector: selector,
          senderId: config.userId,
          keyboardEvent: keyboardEvent,
          userName: config.userName
        };
        if (synchDom.isTypeable(node)) {
          var LD_cobrowse_sync_input_field_isEnabled = false;
          try {
            LD_cobrowse_sync_input_field_isEnabled = launchDarkly.isFeatureFlagEnabled('cobrowse-input-text-overflow-fix');
          } catch (e) {
            console.log('cobrowse keyboard.js - monitorKeyPress() - Failure to enable launchDarkly flag cobrowse-input-text-overflow-fix', e);
          }
          //if an input field will have maxlength then get that else it will be null.
          var maxL = node.getAttribute('maxlength');
          if (LD_cobrowse_sync_input_field_isEnabled && maxL != null && maxL < baseState.getNodeState(node).v.length + 1) {
            return;
          }
          msg.nodeState = baseState.getNodeState(node);
          msg.targetNodeHadWindowFocus = _nodeHasWindowFocus(node);
          try {
            msg.selectRange = Syn.getSelection(node);
          } catch (e) {
            console.error('Error calling Syn.getSelection', {
              error: e,
              message: msg,
              node: node
            });
          }
        }
        localEvents.emit(type, msg);
      } else {
        if (event.which == 13) {
          console.info('unprintable character in keypress: ENTER');
          //ENTER Key (printable in textarea,
          // results in form submit when hit on input text)
          keyboardEvent = _collectKeyEvent(event);
          selector = synchQuery.getNodeSelector(node);
          msg = {
            cssSelector: selector,
            senderId: config.userId,
            keyboardEvent: keyboardEvent,
            userName: config.userName,
            targetNodeHadWindowFocus: _nodeHasWindowFocus(node)
          };
          localEvents.emit(type, msg);
        } else {
          console.info('unprintable character in keypress');
        }
      }
    }
    function monitorKeyDown(event) {
      // handles all non-printable characters
      //keydown
      //    Fires when the user depresses a key. It repeats while the user keeps the key depressed.
      //keypress
      //    Fires when an actual character is being inserted in, for instance, a text input. It repeats while the user keeps the key depressed. Not supported by Safari iPhone.
      //keyup
      //    Fires when the user releases a key, after the default action of that key has been performed
      //console.debug("KeyEvent caught - TYPE: " + event.type + " KEYCODE: " + event.keyCode);
      //console.debug("Check if is result of simulated key down...");
      if (synchEvent.isSimulated(event)) {
        //console.debug("...TRUE -> SIMULATED EVENT");
        return true;  //do not stop event propagation
      }
      if (!processEventNow(event)) {
        return;
      }
      var node = event.target || event.srcElement, activeDocument = node.ownerDocument;
      // FIXED: Under certain circumstances the event.target has no ownerDocument
      //        in IE8 on my cosmos / vertragsdetails
      if (activeDocument && activeDocument.designMode && /on/gi.test(activeDocument.designMode)) {
        // handled via events/editable.js
        return true;  //do not stop event propagation
      }
      if (_isUnprintableChar(event)) {
        var nodeName = node.nodeName;
        if (nodeName) {
          // nodeName maybe undefined in IE10 on window
          nodeName = nodeName.toLowerCase();
        }
        var selector = synchQuery.getNodeSelector(node);
        var keyCode = event.keyCode;
        console.info('keydown: ', event.keyCode);
        var keyboardEvent = _collectKeyEvent(event);
        var msg = {
          cssSelector: selector,
          senderId: config.userId,
          keyboardEvent: keyboardEvent,
          userName: config.userName
        };
        console.log('monitorKeyDown() msg', msg);
        //BAD FIX for ctrl, alt, shift
        if (keyCode == 16 || keyCode == 17 || keyCode == 18 || keyCode == 91 || keyCode == 92 || keyCode == 93) {
          return true;
        }
        if (synchDom.isTypeable(node)) {
          msg.nodeState = baseState.getNodeState(node);
          msg.targetNodeHadWindowFocus = _nodeHasWindowFocus(node);
          try {
            msg.selectRange = Syn.getSelection(node);
          } catch (e) {
          }
        }
        localEvents.emit(type, msg);
      }
    }
    function monitorKeyUp(event) {
      console.log('monitorKeyUp ', event);  // var node = event.target || event.srcElement;
                                            // var activeDocument = node.ownerDocument;
                                            //                if (activeDocument) {
                                            //                    if (event.which === 18 /* altKey */) {
                                            //                        torch.off(activeDocument);
                                            //                    }
                                            //                }
    }
    //------------------- Utility functions -----------------------//
    function processEventNow(event) {
      var closestDirectListener = synchQuery.closestEventMonitor(event.target, event.type);
      if (closestDirectListener) {
        return closestDirectListener == event.currentTarget;
      } else {
        // This event is only fired once on the document object.
        return true;
      }
    }
    var attachKeyEventListeners = function (node) {
      _addEvent(node, 'keydown', monitorKeyDown);
      _addEvent(node, 'keypress', monitorKeyPress);
    };
    function registerNodeListeners(rootNode) {
      baseArray.forEach(keyNodes, function (selector) {
        query(selector, rootNode).forEach(function (node) {
          if (!node[strings.PROP_KEY_MONITORED]) {
            attachKeyEventListeners(node);
            node[strings.PROP_KEY_MONITORED] = true;
          }
        });
      });
    }
    function removeNodeListeners(rootNode) {
      baseArray.forEach(keyNodes, function (selector) {
        query(selector, rootNode).forEach(function (node) {
          if (node[strings.PROP_KEY_MONITORED]) {
            delete node[strings.PROP_KEY_MONITORED];
          }
        });
      });
    }
    function _addEvent(node, eventType, listener, dontFix) {
      var useCapture = true;
      if (has('dom-addeventlistener')) {
        if (eventType == 'click') {
          node.addEventListener(eventType, listener, useCapture);
          listeners.push({
            remove: function () {
              node.removeEventListener(eventType, listener, useCapture);
            }
          });
        } else {
          listeners.push(on(node, eventType, listener));
        }
      } else {
        // IE<9 uses DOM Level 0 event handlers like node.onclick
        // which can be overriden other event 0 handler on
        // the target page.
        //WARN: on._fixEvent is only present in ie8 when has("dom-addeventlistener")= false
        var fixedListener = function (evt) {
          if (!dontFix) {
            evt = on._fixEvent(evt, node);
          }
          return listener.call(this, evt);
        };
        node.attachEvent('on' + eventType, fixedListener);
      }
    }
    function _isUnprintableChar(event) {
      var k = typeof event.which == 'number' ? event.which : event.keyCode;
      var unprintable = (k != 13 || has('ie') >= 9 && !has('quirks')) && k != 32 && k != 173 && (k != 27 || !has('ie')) && (k < 48 || k > 90) && (k < 96 || k > 111) && (k < 186 || k > 192) && (k < 219 || k > 222) && k != 229;
      return unprintable;
    }
    function _nodeHasWindowFocus(node) {
      var ownerDocumentOfNode = node.ownerDocument;
      if (ownerDocumentOfNode) {
        var activeElement = ownerDocumentOfNode.activeElement;
        if (isFirefoxBrowser && activeElement) {
          // Use activeElement for Firefox because of bug: https://bugzilla.mozilla.org/show_bug.cgi?id=85686
          return activeElement.contains(node);
        } else if (ownerDocumentOfNode.getSelection) {
          var selection = ownerDocumentOfNode.getSelection();
          if (selection) {
            if (selection.rangeCount && selection.getRangeAt) {
              var focussedContainer = selection.getRangeAt(0).endContainer;
              if (focussedContainer && focussedContainer.contains) {
                return focussedContainer.contains(node);
              }
            }
          } else if (selection.rangeCount === 0) {
            return false;
          }
        }
      }
      return true;
    }
    function _collectKeyEvent(event) {
      var keyboardEvent = {
        type: event.type,
        canBubble: !!event.canBubble,
        //cancelable: !(!(event.cancelable)),
        clientX: event.clientX,
        clientY: event.clientY,
        ctrlKey: !!event.ctrlKey,
        altKey: !!event.altKey,
        shiftKey: !!event.shiftKey,
        metaKey: !!event.metaKey,
        keyCode: event.keyCode || event.which,
        which: event.which || event.keyCode,
        charCode: event.charCode
      };
      try {
        if (event.charCode) {
          // charCode == 0 when the TAB key is pressed.
          keyboardEvent.synKey = String.fromCharCode(event.charCode);
        }
      } catch (e) {
      }
      var element = synchEvent.getNodeFromEvent(event);
      if (synchQuery.isProtected(element)) {
        console.debug('Safety first. Password keyCodes are not published.');
        var overrides = { isProtected: true };
        if (!config.sendProtected) {
          overrides = lang.mixin(overrides, {
            charCode: 'x',
            keyCode: 88,
            which: 88,
            synKey: 'x'
          });
        }
        keyboardEvent = lang.mixin(keyboardEvent, overrides);
      }
      return keyboardEvent;
    }
    // EXPORTS
    /////////////////
    return {
      type: type,
      local: localEvents,
      remote: remoteEvents,
      configure: function (_config) {
        profile = profile || _config.profile;
        Syn = Syn || _config.Syn;
      },
      tearDown: function () {
        stopListening();
      },
      startListening: startListening,
      startReplicating: startReplicating
    };
  }(dojo__base_lang, dojo__base_array, dojo_query, dojo_Evented, dojo_on, dojo_has, synchronite__base_query, synchronite__base_event, synchronite_micro_dom, synchronite__base_state, synchronite_ui_typing, synchronite_constants_strings, transpiled_node_modules_ua_parser, synchronite_call_launchDarkly);
  dojo_text_synchronite_config_participantProfilesjson = '{\n    "presenter": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true,\n            "resize": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true,\n            "resize": false,\n            "annotations": true\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button",\n            "pause-button",\n            "invite-button",\n            "upload-file"\n        ]\n    },\n    "agent-lp": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "end-button",\n            "pause-button"\n        ]\n    },\n    "master-dom": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true,\n            "dom": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true,\n            "dom": false\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "end-button",\n            "pause-button",\n            "invite-button",\n            "user-dropdown"\n        ]\n    },\n    "presenter-no-chat": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 150,\n        "endWhenAlone": true,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button",\n            "pause-button",\n            "invite-button"\n        ]\n    },\n    "interviewer": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true\n        },\n        "startActive": false,\n        "autostart": true,\n        "mouseMoveIntervall": 150,\n        "hideMouseTimeout": 2000,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "pause-button",\n            "end-button",\n            "invite-button"\n        ]\n    },\n    "supportagent": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": false,\n            "mouseMove": true,\n            "key": false,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true\n        },\n        "startActive": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button",\n            "invite-button"\n        ],\n        "blockEvents": true\n    },\n    "p-interactive": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": false,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": false,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true,\n            "dom": true,\n            "resize": true\n        },\n        "startActive": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button"\n        ],\n        "blockEvents": false\n    },\n    "p-view": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": false,\n            "mouseMove": true,\n            "key": false,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": false,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": false,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true,\n            "dom": true,\n            "resize": true\n        },\n        "startActive": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button"\n        ],\n        "blockEvents": true\n    },\n    "p-follow": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": false,\n            "mouseMove": true,\n            "key": false,\n            "scroll": false\n        },\n        "handle": {\n            "highlight": true,\n            "create": false,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": false,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true,\n            "dom": true,\n            "resize": true\n        },\n        "startActive": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "url-form",\n            "forward-button",\n            "back-button",\n            "user-dropdown",\n            "users-dropdown",\n            "end-button"\n        ],\n        "blockEvents": true\n    },\n    "view": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": false,\n            "mouseMove": true,\n            "key": false,\n            "scroll": true\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true\n        },\n        "startActive": true,\n        "mouseMoveIntervall": 150,\n        "showElements": [\n            "end-button",\n            "users-dropdown"\n        ],\n        "blockEvents": true\n    },\n    "customer": {\n        "monitor": {\n            "highlight": true,\n            "mouseClick": true,\n            "mouseMove": true,\n            "key": true,\n            "scroll": true,\n            "resize": false\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true,\n            "resize": false,\n            "annotations": true\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 250,\n        "showElements": [\n            "end-button",\n            "users-dropdown"\n        ]\n    },\n    "follow": {\n        "monitor": {\n            "highlight": false,\n            "mouseClick": false,\n            "mouseMove": false,\n            "key": false,\n            "scroll": false\n        },\n        "handle": {\n            "highlight": true,\n            "create": true,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": false,\n            "session": true,\n            "service": true\n        },\n        "startActive": false,\n        "mouseMoveIntervall": 9999,\n        "hideMouseTimeout": 2000,\n        "showElements": [\n            "users-dropdown"\n        ],\n        "addBlockCover": true,\n        "blockEvents": true\n    },\n    "solo": {\n        "monitor": {\n            "highlight": false,\n            "mouseClick": false,\n            "mouseMove": false,\n            "key": false,\n            "scroll": false\n        },\n        "handle": {\n            "highlight": true,\n            "create": false,\n            "change": true,\n            "scroll": true,\n            "mouseMove": true,\n            "mouseClick": true,\n            "key": true,\n            "focus": true,\n            "chat": true,\n            "session": true,\n            "service": true\n        },\n        "startActive": true,\n        "autostart": true,\n        "mouseMoveIntervall": 9999,\n        "hideMouseTimeout": 2000,\n        "showElements": [\n            "end-button",\n            "users-dropdown"\n        ],\n        "addBlockCover": false,\n        "blockEvents": false\n    }\n}\n';
  synchronite_config_profiles = function (participantProfiles) {
    var profiles = JSON.parse(participantProfiles);
    return { config: profiles };
  }(dojo_text_synchronite_config_participantProfilesjson);
  synchronite_proxyless_requestDomRetry = function (utils, datachannel) {
    var domReceived = false, retries = 0, maxRetries = 7;
    function startRetry() {
      setTimeout(function () {
        if ((!domReceived || utils.isPageEmpty()) && retries <= maxRetries) {
          datachannel.send('requestState', '');
          retries++;
          console.log('request state after no Dom has been received for 3s');
          startRetry();
        }
      }, 3000);
    }
    function stopRetry() {
      domReceived = true;
    }
    function hasReceivedDom() {
      return domReceived;
    }
    return {
      startRetry: startRetry,
      stopRetry: stopRetry,
      hasReceivedDom: hasReceivedDom
    };
  }(synchronite_proxyless_utils, synchronite_proxyless_datachannel);
  synchronite_proxyless_dom_replicator = function (utils, common, baseArray, synchQuery, lang) {
    var treeMirrors = {};
    var cobrowseWindow;
    var config;
    var eventHandles = [];
    var domMirrors = {};
    var ignoreCreateElementClasses = /(ignoreDOM|lp_desktop|LPMcontainer|lp_mobile|lp_main_ltr|lp_tablet|lp_android|lp_cobrowse_mask_element)/i;
    var ignoreSetAttributeClasses = /(ignoreDOM|sn_ps_hover|lp_desktop|LPMcontainer|lp_mobile|lp_main_ltr|lp_tablet|lp_android|lp_cobrowse_mask_element)/i;
    /* idempotent */
    var startReplicating = function (_config) {
      console.info('STARTREPLICATING');
      config = _config;
      var remoteEvents = config.remoteEvents;
      cobrowseWindow = config.window;
      delete config.window;
      baseArray.forEach(eventHandles, function (handle) {
        handle.remove();
      });
      eventHandles = [
        remoteEvents.on(common.DOM_FRAME_INITIALIZE, handleFrameInitialize),
        remoteEvents.on(common.DOM_SHADOW_INITIALIZE, handleShadowInitialize),
        remoteEvents.on(common.DOM_CHANGE, handleChange)
      ];
    };
    var handleFrameInitialize = function (event) {
      console.log('handleFrameInitialize ' + JSON.stringify(event));
      var mirrorRoot;
      var frameSelector = event.target;
      var win;
      var mirror;
      var configCopy = JSON.parse(JSON.stringify(config));
      var delegateConfig = lang.mixin(configCopy, event.loc);
      if (frameSelector === null) {
        // => main parent frame
        win = synchQuery.queryFrame(frameSelector, false);  // returns displayContent frame if frameSelector is null
      } else {
        // => iframe inside parent frame
        win = synchQuery.queryFrame(frameSelector, true);
      }
      if (typeof win === 'undefined') {
        console.warn('Unable to find frame: ' + frameSelector + '. Ignore initialize');
        return;
      }
      mirrorRoot = win.document;
      // Lesson learned: Always create a new TreeMirror for "initialize" calls, because deserializeNodes function
      //                uses IDs to distinguish between nodes and these might be the same although docs are different.
      if (win === cobrowseWindow) {
        // new root document is loaded so kill all references to old treemirrors
        console.info('NEW ROOT MIRROR. CLEARING EXISTING MIRRORS: ', win.location.href);
        treeMirrors = {};
        domMirrors = {};
        synchroniteConfig.currentURL = event.loc.href;
      }
      var mirrorId = common.frameSelectorToId(frameSelector);
      mirror = treeMirrors[mirrorId] = new TreeMirror(mirrorRoot, createReplicatingDelegates(delegateConfig));
      while (mirrorRoot.firstChild) {
        mirrorRoot.removeChild(mirrorRoot.firstChild);
      }
      mirror.initialize.apply(mirror, event.args);
      if (win === cobrowseWindow) {
        // some browsers scroll to the bottom once we insert the DOM
        win.scrollTo(0, 0);
      }
    };
    var handleShadowInitialize = function (event) {
      console.log('handleShadowInitialize ' + JSON.stringify(event));
      var mirrorRoot;
      var mirror;
      var configCopy = JSON.parse(JSON.stringify(config));
      var delegateConfig = lang.mixin(configCopy, event.loc);
      mirrorRoot = synchQuery.queryElement(event.target);
      var shadowRoot = mirrorRoot.attachShadow({ mode: 'open' });
      mirror = domMirrors[common.getShadowId(event.target)] = new TreeMirror(shadowRoot, createReplicatingDelegates(delegateConfig));
      mirror.initialize.apply(mirror, event.args);
    };
    var getTreeMirror = function (frameSelector) {
      var mirrorId = common.frameSelectorToId(frameSelector);
      return treeMirrors[mirrorId];
    };
    var handleChange = function (event) {
      console.log('handleChange ' + JSON.stringify(event));
      if (event.shadowDom && domMirrors[common.getShadowId(event.shadowDom)]) {
        domMirrors[common.getShadowId(event.shadowDom)].applyChanged.apply(domMirrors[common.getShadowId(event.shadowDom)], event.args);
      } else {
        var frameSelector = event.frame;
        var mirror = getTreeMirror(frameSelector);
        if (!mirror) {
          console.warn('TreeMirror for \'' + frameSelector + '\' has not been initialized. Ignoring dom change event.');
          return;
        }
        mirror.applyChanged.apply(mirror, event.args);
      }
    };
    var createReplicatingDelegates = function (config) {
      return {
        href: config.href,
        createElement: function (tagName, nodeData, inSVG) {
          var node;
          if (nodeData.attributes.class && ignoreCreateElementClasses.test(nodeData.attributes.class)) {
            return true;
          } else if (/^script$/i.test(tagName)) {
            node = document.createElement('NOSCRIPT');
            node.style.display = 'none';
            return node;
          } else if (nodeData.isSVG || inSVG) {
            // converting svg to lower case fixes
            // treeMirror_test->mirrorDelegatesCreateElementNamespace in IE 11
            tagName = tagName && tagName.toLowerCase();
            var svgNS = 'http://www.w3.org/2000/svg';
            node = document.createElementNS(svgNS, tagName);
            return node;
          } else if (/^embed$/i.test(tagName)) {
            return true;
          } else if (nodeData.ignored) {
            return true;
          }
        },
        setAttribute: function (node, name, value, attributes, inSVG) {
          if (attributes && attributes.class && ignoreSetAttributeClasses.test(attributes.class)) {
            return true;
          } else if (node.nodeType === 1 && /^src$/i.test(name) && /^img$/i.test(node.tagName)) {
            //rewrite image urls
            value = config.rewriteSrc ? utils.rewriteImgUrl(value, config.href) : value;
            node.setAttribute(name, value);
            return node;
          } else if (node.nodeType === 1 && /^srcset$/i.test(name) && /^(img|source)$/i.test(node.tagName)) {
            // rewrite srcset attributes. Note that there might be multiple URLs in a srcst attribute (see test cases)
            // If we have trouble with splitting the urls we could implement the full parsing:
            // https://html.spec.whatwg.org/multipage/images.html#parsing-a-srcset-attribute
            value = value.split(/,\s/).map(function (url) {
              url = url.trim();
              if (url.indexOf(' ') !== -1) {
                var rewrittenURL = utils.rewriteImgUrl(url.substring(0, url.indexOf(' ')), config.href);
                return rewrittenURL + url.substring(url.indexOf(' '), url.length);
              } else {
                return utils.rewriteImgUrl(url.trim(), config.href);
              }
            });
            node.setAttribute(name, value.join(', '));
            return node;
          } else if (node.nodeType === 1 && /data-auto-download/i.test(name)) {
            //don't set auto download attributes
            return true;
          } else if (node.nodeType === 1 && /^http-equiv/i.test(name) && /refresh/i.test(value)) {
            //don't set meta refresh header
            return true;
          } else if (node.nodeType === 1 && /^http-equiv/i.test(name) && /X-Frame-Options/i.test(value)) {
            //don't set X-Frame-Options header
            return true;
          } else if (node.nodeType === 1 && /.*AllowScriptAccess.*/i.test(name)) {
            //don't set AllowScriptAccess
            node.setAttribute(name, 'never');
            return node;
          } else if (node.nodeType === 1 && /.*AllowNetworking.*/i.test(name)) {
            //don't set AllowNetworking
            node.setAttribute(name, 'none');
            return node;
          } else if (node.nodeType === 1 && /^href$/i.test(name) && /^link$/i.test(node.tagName) && attributes && /stylesheet/i.test(attributes.rel)) {
            //proxify url of stylesheet (possible fonts)
            value = config.rewriteCss ? utils.rewriteCssSource(value, config.href) : value;
            node.setAttribute(name, value);
            return node;
          } else if (node.nodeType === 1 && /^integrity$/i.test(name) && /^link$/i.test(node.tagName)) {
            // don't set integrity attribute
            return true;
          } else if (node.nodeType === 1 && /^href$/i.test(name) && /^link$/i.test(node.tagName) && /preload|preconnect|prefetch/i.test(attributes.rel)) {
            // don't set href of preload, prefetch or preconnect links
            return true;
          } else if (node.nodeType === 1 && /^style$/i.test(name)) {
            //parse content of style attributes
            value = config.rewriteCss ? utils.parseCss(value, config.href) : value;
            node.setAttribute(name, value);
            return node;
          } else if (/^\s*on[a-z]+/i.test(name)  /* filter all on* attributes */ || /textInput/i.test(name)) {
            //don't set script attributes on elements, see http://www.w3schools.com/tags/ref_eventattributes.asp
            // and http://help.dottoro.com/ljfvvdnm.php
            return true;
          } else if ((inSVG || name === 'fill' || name === 'clip-path') && /url/i.test(value)) {
            //set absolute urls in svg links
            node.setAttribute(name, utils.rewriteSvgLink(value, config.href));
            return node;
          } else if (node.nodeType === 1 && /\s*javascript:.*/i.test(value)) {
            //don't set attributes that include javascript
            return true;
          } else if (node.nodeType === 1 && /^action$/i.test(name)) {
            //don't set action attributes
            return true;
          } else if (node.nodeType === 1 && /^data$/i.test(name) && /^object$/i.test(node.tagName)) {
            //don't set data attributes on object nodes
            return true;
          } else if (node.nodeType === 1 && /^href$/i.test(name) && /^base$/i.test(node.tagName) && !/javascript/i.test(value)) {
            if (!utils.isHttps(value, config.href)) {
              node.setAttribute(name, value.replace('http', 'https'));
              return node;
            }
          } else if (node.nodeType === 1 && /^src$/i.test(name) && /^(frame|iframe)$/i.test(node.tagName)) {
            //don't set src in iframe elements
            return true;
          } else {
            return false;
          }
        },
        createTextNode: function (text, inStyle) {
          if (config.rewriteCss && inStyle) {
            text = this.getSanitizedCssTextNodeVal(text);
          }
          return document.createTextNode(text);
        },
        getSanitizedCssTextNodeVal: function (text) {
          return utils.parseCss(text, config.href);
        }
      };
    };
    var domReplicator = {
      startReplicating: startReplicating,
      setState: handleFrameInitialize,
      getTreeMirror: getTreeMirror,
      // expose for scrollableNodes
      _createDelegates: createReplicatingDelegates  // exposed only for testing
    };
    return domReplicator;
  }(synchronite_proxyless_utils, synchronite_proxyless_dom_common, dojo__base_array, synchronite__base_query, dojo__base_lang);
  synchronite_proxyless_unifiedWindowState_replicator = function (Evented, query, baseArray, common, constants) {
    var remoteEvents = new Evented();
    var eventHandles = [];
    var defaultBodyWidth;
    function startReplicating() {
      baseArray.forEach(eventHandles, function (handle) {
        handle.remove();
      });
      var doc = document.getElementById(constants.cobrowsingFrameName).contentDocument;
      var body = doc.body || doc.getElementsByTagName('body')[0];
      if (typeof body === 'undefined') {
        return;
      }
      defaultBodyWidth = body.style.width;
      eventHandles.push(remoteEvents.on(common.MAXIMIZED, function () {
        console.log('maximized event received');
        setTimeout(function () {
          if (body && body.style) {
            body.style.width = defaultBodyWidth;
          }
        }, 1000);
      }));
      eventHandles.push(remoteEvents.on(common.MINIMIZED, function () {
        console.log('minimized event received');
      }));
    }
    return {
      remote: remoteEvents,
      startReplicating: startReplicating
    };
  }(dojo_Evented, dojo_query, dojo__base_array, synchronite_proxyless_unifiedWindowState_common, synchronite_constants_constants);
  synchronite_simulate_synthetic = function (dojoHas, synchDom) {
    //    //PATCHED ADDED FOCUS TEST
    //    dojoHas.add("focusHandler-triggered-only-when-doc-focussed", function(global, doc, element) {
    //        // FF only executes the focus handler when focus() is called AND the current document is
    //        // focussed (document.hasFocus())
    //        // Also filed as jQuery Bug: http://bugs.jquery.com/ticket/13363
    //        var focusHandlerTriggered = false;
    //
    //        var iframe = doc.createElement("iframe");
    //        var body = doc.body;
    //        body.appendChild(iframe);
    //
    //        var iframeWin = iframe.contentWindow;
    //        var iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
    //
    //        iframeDoc.write("<!doctype html><head></head><body><input type='text'></input></body></html>")
    //
    //        var inputField = iframeDoc.getElementsByTagName("input")[0];
    //        inputField.addEventListener("focus", function(){
    //            focusHandlerTriggered = true;
    //            console.info("focusHandler triggered!")
    //        });
    //
    //        document.documentElement.focus();
    //        console.error("inputField.focus() -> hashFocus: "+ iframeDoc.hasFocus());
    //        inputField.focus();
    //        return !focusHandlerTriggered;
    //    });
    // console.error("FOCUS TEST: " +  dojoHas("focusHandler-triggered-only-when-doc-focussed"));
    // PATCHED START: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
    dojoHas.add('pointerEvents', function (win) {
      return win.PointerEvent && win.navigator.pointerEnabled;
    });
    dojoHas.add('msPointerEvents', function (win) {
      return win.MSPointerEvent && win.navigator.msPointerEnabled;
    });
    // PATCHED END: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
    var extend = function (d, s) {
        var p;
        for (p in s) {
          d[p] = s[p];
        }
        return d;
      },
      // only uses browser detection for key events
      browser = {
        msie: !!(window.attachEvent && !window.opera),
        opera: !!window.opera,
        webkit: navigator.userAgent.indexOf('AppleWebKit/') > -1,
        safari: navigator.userAgent.indexOf('AppleWebKit/') > -1 && navigator.userAgent.indexOf('Chrome/') === -1,
        gecko: navigator.userAgent.indexOf('Gecko') > -1,
        mobilesafari: !!navigator.userAgent.match(/Apple.*Mobile.*Safari/),
        rhino: navigator.userAgent.match(/Rhino/) && true
      }, createEventObject = function (type, options, element) {
        var event = element.ownerDocument.createEventObject();
        return extend(event, options);
      }, data = {}, id = 1, expando = '_synthetic' + new Date().getTime(), bind, unbind, key = /keypress|keyup|keydown/, page = /load|unload|abort|error|select|change|submit|reset|focus|blur|resize|scroll/,
      //this is maintained so we can click on html and blur the active element
      activeElement,
      /**
               * @class Syn
               * @download funcunit/dist/syn.js
               * @test funcunit/synthetic/qunit.html
               * Syn is used to simulate user actions.  It creates synthetic events and
               * performs their default behaviors.
               *
               * <h2>Basic Use</h2>
               * The following clicks an input element with <code>id='description'</code>
               * and then types <code>'Hello World'</code>.
               *
               @codestart
               Syn.click({},'description')
               .type("Hello World")
               @codeend
               * <h2>User Actions and Events</h2>
               * <p>Syn is typically used to simulate user actions as opposed to triggering events. Typing characters
               * is an example of a user action.  The keypress that represents an <code>'a'</code>
               * character being typed is an example of an event.
               * </p>
               * <p>
               *   While triggering events is supported, it's much more useful to simulate actual user behavior.  The
               *   following actions are supported by Syn:
               * </p>
               * <ul>
               *   <li><code>[Syn.prototype.click click]</code> - a mousedown, focus, mouseup, and click.</li>
               *   <li><code>[Syn.prototype.dblclick dblclick]</code> - two <code>click!</code> events followed by a <code>dblclick</code>.</li>
               *   <li><code>[Syn.prototype.key key]</code> - types a single character (keydown, keypress, keyup).</li>
               *   <li><code>[Syn.prototype.type type]</code> - types multiple characters into an element.</li>
               *   <li><code>[Syn.prototype.move move]</code> - moves the mouse from one position to another (triggering mouseover / mouseouts).</li>
               *   <li><code>[Syn.prototype.drag drag]</code> - a mousedown, followed by mousemoves, and a mouseup.</li>
               * </ul>
               * All actions run asynchronously.
               * Click on the links above for more
               * information on how to use the specific action.
               * <h2>Asynchronous Callbacks</h2>
               * Actions don't complete immediately. This is almost
               * entirely because <code>focus()</code>
               * doesn't run immediately in IE.
               * If you provide a callback function to Syn, it will
               * be called after the action is completed.
               * <br/>The following checks that "Hello World" was entered correctly:
               @codestart
               Syn.click({},'description')
               .type("Hello World", function(){
      
                   ok("Hello World" == document.getElementById('description').value)
                   })
               @codeend
               <h2>Asynchronous Chaining</h2>
               <p>You might have noticed the [Syn.prototype.then then] method.  It provides chaining
               so you can do a sequence of events with a single (final) callback.
               </p><p>
               If an element isn't provided to then, it uses the previous Syn's element.
               </p>
               The following does a lot of stuff before checking the result:
               @codestart
               Syn.type('ice water','title')
               .type('ice and water','description')
               .click({},'create')
               .drag({to: 'favorites'},'newRecipe',
               function(){
                   ok($('#newRecipe').parents('#favorites').length);
                   })
               @codeend
      
               <h2>jQuery Helper</h2>
               If jQuery is present, Syn adds a triggerSyn helper you can use like:
               @codestart
               $("#description").triggerSyn("type","Hello World");
               @codeend
               * <h2>Key Event Recording</h2>
               * <p>Every browser has very different rules for dispatching key events.
               * As there is no way to feature detect how a browser handles key events,
               * synthetic uses a description of how the browser behaves generated
               * by a recording application.  </p>
               * <p>
               * If you want to support a browser not currently supported, you can
               * record that browser's key event description and add it to
               * <code>Syn.key.browsers</code> by it's navigator agent.
               * </p>
               @codestart
               Syn.key.browsers["Envjs\ Resig/20070309 PilotFish/1.2.0.10\1.6"] = {
                   'prevent':
                   {"keyup":[],"keydown":["char","keypress"],"keypress":["char"]},
                   'character':
                   { ... }
                   }
               @codeend
               * <h2>Limitations</h2>
               * Syn fully supports IE 6+, FF 3+, Chrome, Safari, Opera 10+.
               * With FF 1+, drag / move events are only partially supported. They will
               * not trigger mouseover / mouseout events.<br/>
               * Safari crashes when a mousedown is triggered on a select.  Syn will not
               * create this event.
               * <h2>Contributing to Syn</h2>
               * Have we missed something? We happily accept patches.  The following are
               * important objects and properties of Syn:
               * <ul>
               *    <li><code>Syn.create</code> - contains methods to setup, convert options, and create an event of a specific type.</li>
               *  <li><code>Syn.defaults</code> - default behavior by event type (except for keys).</li>
               *  <li><code>Syn.key.defaults</code> - default behavior by key.</li>
               *  <li><code>Syn.keycodes</code> - supported keys you can type.</li>
               * </ul>
               * <h2>Roll Your Own Functional Test Framework</h2>
               * <p>Syn is really the foundation of JavaScriptMVC's functional testing framework - [FuncUnit].
               *   But, we've purposely made Syn work without any dependencies in the hopes that other frameworks or
               *   testing solutions can use it as well.
               * </p>
               * @constructor
               * Creates a synthetic event on the element.
               * @param {Object} type
               * @param {Object} options
               * @param {Object} element
               * @param {Object} callback
               * @return Syn
               */
      Syn = function (type, options, element, callback) {
        return new Syn.init(type, options, element, callback);
      };
    bind = function (el, ev, f) {
      return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
    };
    unbind = function (el, ev, f) {
      return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
    };
    // PATCHED (INSERTED)
    var safelyFocusElement = function (el) {
      var focusTriggered, blurTriggered, wasFocused, win = Syn.helpers.getWindow(el), doc = win.document;
      var focusTriggeredHandler = function (event) {
        var tgt = event.target || event.srcElement;
        var act = tgt.ownerDocument.activeElement;
        console.debug('SYN: FOCUSHANDLER TRIGGERED ON ' + tgt.nodeName + '[id=' + tgt.id + '][name=' + tgt.name + '], activeElement = ' + act.nodeName + '[id=' + act.id + '][name=' + act.name + ']');
        focusTriggered = true;
      };
      var blurTriggeredHandler = function (event) {
        var tgt = event.target || event.srcElement;
        var act = tgt.ownerDocument.activeElement;
        console.debug('SYN: BLURHANDLER TRIGGERED ON ' + tgt.nodeName + '[id=' + tgt.id + '][name=' + tgt.name + '], activeElement = ' + act.nodeName + '[id=' + act.id + '][name=' + act.name + ']');
        blurTriggered = true;
      };
      var verifyFocus = function (focusEl) {
        var _setActiveElement = function (focusEl) {
          // Required for IE11
          console.debug('SYN: SETTING win.document.activeElement = ' + focusEl.tagName);
          var win = Syn.helpers.getWindow(focusEl);
          win.document.activeElement = focusEl;
        };
        if (!synchDom.canAccessNode(focusEl)) {
          return;
        }
        unbind(focusEl, 'focus', focusTriggeredHandler);
        // Check if setting focus was successful.
        if (focusTriggered || wasFocused) {
          // activeElement is supported by:
          // IE6+, FF3+, Safari 4+, Opera 9+, Chrome 9+. (FF2, Saf3 are not supported this property)
          if (wasFocused) {
            console.debug('SYN: FOCUS WAS ALREADY SET :)');
          } else {
            console.debug('SYN: FOCUS SET :)');
          }  // _setActiveElement(focusEl);
        } else {
          console.debug('SYN: FOCUS NOT SET. SIMULATING VIA \'trigger\'');
          if (focusEl && Syn.isFocusable(focusEl)) {
            var options = {
              _autoPrevent: true,
              _dispatch: true
            };
            Syn.trigger('focus', options, focusEl);
          }  /*else
                              if (win.$ && win.$(focusEl) && win.$(focusEl).triggerHandler) {
                              // Use jQuery when present
                              console.debug("SYN: trigger('focus')");
                              //win.$(focusEl).triggerHandler("focus");
                              var focusEvent = win.$.Event("focus");
                              focusEvent.target = focusEl;
             
                              // last param true => only trigger handlers do not execute default behaviour
                              win.$.event.trigger(focusEvent, [focusEvent], focusEl, true);
                              } else {
                              // Use dom level 0 otherwise
                              console.debug("SYN: FOCUS NOT SET. SIMULATING VIA DOM LEVEL 0 'onfocus/onblur'");
                              var domFocusHandler = focusEl.onfocus;
                              if (domFocusHandler && domFocusHandler.call) {
                              console.debug("SYN: 'onfocus'");
                              var focusEvt = Syn.helpers.createBasicStandardEvent("focus", {
                              target: focusEl,
                              srcElement: focusEl
                              },
                              doc);
                              domFocusHandler.call(focusEl, focusEvt);
                              } else {
                              console.debug("SYN: No 'onfocus'");
                              }
                              } */
        }
      };
      var verifyBlur = function (blurEl) {
        if (!blurEl || !synchDom.canAccessNode(blurEl)) {
          return;
        }
        unbind(blurEl, 'blur', blurTriggeredHandler);
        // Check if setting focus was successful.
        if (blurTriggered) {
          console.debug('SYN: BLUR WAS TRIGGERED :)');
        } else {
          // var win = Syn.helpers.getWindow(blurEl);
          //if (win.$ && win.$(blurEl) && win.$(blurEl).triggerHandler) {
          // Use jQuery when present
          console.debug('SYN: BLUR NOT TRIGGERED. SIMULATING VIA \'trigger\'');
          if (blurEl && Syn.isFocusable(blurEl)) {
            console.debug('SYN: trigger(\'blur\')');
            // DOM-events triggered using jQuery.trigger wont work with event
            // listeners registered using native addEventListener method.
            // see: http://jnotes.jonasfischer.net/2012/09/jquery-trigger-vs-document-dispatchevent/
            //
            // The other way is working fine: DOM-events triggered using native
            // createEvent/dispatchEvent methods work with event listeners registered
            // using jQuery.bind.
            // calls jQuery.event.trigger( type, data, this )
            // win.$(blurEl).trigger("blur"); //Handler
            //var blurEvent = win.$.Event("blur");
            //blurEvent.target = blurEl;
            //dispatch: function(event, element, type, autoPrevent) {
            var options = {
              _autoPrevent: true,
              _dispatch: true
            };
            Syn.trigger('blur', options, blurEl);  /*
                                                    * jQuery.event.trigger takes the following params
                                                    *    event, data, elem, onlyHandlers
                                                    *    onlyHandlers = true ==> don't run the default action
                                                    *
                                                    * for jquery 1.7 we need to set onlyHandlers==false otherwise our
                                                    * synthetic "change" handler is not invoked
                                                    *
                                                    */
                                                   //  win.$.event.trigger(blurEvent, [blurEvent], blurEl, true);
          }  /*} else {
             // Use dom level 0 otherwise
             console.debug("SYN: BLUR NOT TRIGGERED. SIMULATING VIA DOM LEVEL 0 'onblur'");
             var domBlurHandler = blurEl.onblur;
             if (blurEl && Syn.isFocusable(blurEl)) {
             if (domBlurHandler && domBlurHandler.call) {
             console.debug("SYN: 'onblur'");
             var blurEvt = Syn.helpers.createBasicStandardEvent("blur", {
             target: blurEl,
             srcElement: blurEl
             },
             doc);
             domBlurHandler.call(blurEl, blurEvt);
             } else {
             console.debug("SYN: No 'onblur'");
             }
             }
             }*/
        }
      };
      var lastActiveEl;
      if (activeElement && synchDom.canAccessNode(activeElement)) {
        // Note: We need to check if the activeElement is still accessible as
        //       it might originate from a previous page load. Not checking
        //       causes an error for IE8 and IE11.
        lastActiveEl = activeElement;
      } else {
        lastActiveEl = doc.activeElement;
        console.debug('synthetic: Using document.activeElement for focus setting. canAccessNode => ' + synchDom.canAccessNode(lastActiveEl));
      }
      wasFocused = activeElement && activeElement == el;
      if (lastActiveEl) {
        console.debug('lastActiveEl: ' + lastActiveEl.tagName);
      } else {
        console.debug('lastActiveEl: NONE');
      }
      bind(el, 'focus', focusTriggeredHandler);
      if (lastActiveEl) {
        bind(lastActiveEl, 'blur', blurTriggeredHandler);
      }
      // Statement: node.focus() yields different results in browsers when window is not focussed
      //    FF 23     - Triggers Focus Handler: NO, Triggers Blur Handler: NO
      //    IE 10     - Triggers Focus Handler: YES, Triggers Blur Handler: NO
      //    Chrome 29 - Triggers Focus Handler: YES, Triggers Blur Handler: YES
      if (el.nodeName.toLowerCase() !== 'html') {
        // focussing html will scroll in FF
        // in IE 11 focus() will only take effect after setTimeout.
        el.focus();
      }
      setTimeout(function () {
        verifyBlur(lastActiveEl);
        verifyFocus(el);
      }, 1);
    };
    /**
     * @Static
     */
    extend(Syn, {
      /**
       * Creates a new synthetic event instance
       * @hide
       * @param {Object} type
       * @param {Object} options
       * @param {Object} element
       * @param {Object} callback
       */
      init: function (type, options, element, callback) {
        var args = Syn.args(options, element, callback), self = this;
        this.queue = [];
        this.element = args.element;
        //run event
        if (typeof this[type] === 'function') {
          this[type](args.options, args.element, function (defaults, el) {
            args.callback && args.callback.apply(self, arguments);
            self.done.apply(self, arguments);
          });
        } else {
          this.result = Syn.trigger(type, args.options, args.element);
          args.callback && args.callback.call(this, args.element, this.result);
        }
      },
      jquery: function (el, fast) {
        if (window.FuncUnit && window.FuncUnit.jQuery) {
          return window.FuncUnit.jQuery;
        }
        if (el) {
          return Syn.helpers.getWindow(el).jQuery || window.jQuery;
        } else {
          return window.jQuery;
        }
      },
      /**
       * Returns an object with the args for a Syn.
       * @hide
       * @return {Object}
       */
      args: function () {
        var res = {}, i = 0;
        for (; i < arguments.length; i++) {
          if (typeof arguments[i] === 'function' && arguments[i] && !arguments[i].nodeName) {
            //PATCHED: embed node was falsely recognized as  function
            res.callback = arguments[i];
          } else if (arguments[i] && arguments[i].jquery) {
            res.element = arguments[i][0];
          } else if (arguments[i] && arguments[i].nodeName) {
            res.element = arguments[i];
          } else if (res.options && typeof arguments[i] === 'string') {
            //we can get by id
            res.element = document.getElementById(arguments[i]);
          } else if (arguments[i]) {
            res.options = arguments[i];
          }
        }
        return res;
      },
      click: function (options, element, callback) {
        console.debug('SYN: CLICK!');
        Syn('click!', options, element, callback);
      },
      /**
       * @attribute defaults
       * Default actions for events.  Each default function is called with this as its
       * element.  It should return true if a timeout
       * should happen after it.  If it returns an element, a timeout will happen
       * and the next event will happen on that element.
       */
      defaults: {
        focus: function () {
          if (!Syn.support.focusChanges) {
            var element = this, nodeName = element.nodeName.toLowerCase();
            Syn.data(element, 'syntheticvalue', element.value);
            //TODO, this should be textarea too
            //and this might be for only text style inputs ... hmmmmm ....
            if (nodeName === 'input' || nodeName === 'textarea') {
              console.info('Syn.defaults.focus: Binding blur/change listener to ' + nodeName);
              bind(element, 'blur', function () {
                // Next two lines PACTHED, to account for blur without focus when
                // synchronite is tested on one pc with two browsers.
                var syntheticvalue = Syn.data(element, 'syntheticvalue');
                console.info('Syn.defaults.focus: Triggered blur/change listener (focusvalue=' + syntheticvalue + ', blurvalue=' + element.value + ')');
                var blurHappenedWithoutFocus = typeof syntheticvalue === 'undefined';
                if (!blurHappenedWithoutFocus && syntheticvalue != element.value) {
                  Syn.trigger('change', {}, element);
                }
                unbind(element, 'blur', arguments.callee);
              });
            }
          }
        },
        submit: function () {
          Syn.onParents(this, function (el) {
            if (el.nodeName.toLowerCase() === 'form') {
              el.submit();
              return false;
            }
          });
        }
      },
      changeOnBlur: function (element, prop, value) {
        bind(element, 'blur', function () {
          if (value !== element[prop]) {
            Syn.trigger('change', {}, element);
          }
          unbind(element, 'blur', arguments.callee);
        });
      },
      /**
       * Returns the closest element of a particular type.
       * @hide
       * @param {Object} el
       * @param {Object} type
       */
      closest: function (el, type) {
        while (el && el.nodeName.toLowerCase() !== type.toLowerCase()) {
          el = el.parentNode;
        }
        return el;
      },
      /**
       * adds jQuery like data (adds an expando) and data exists FOREVER :)
       * @hide
       * @param {Object} el
       * @param {Object} key
       * @param {Object} value
       */
      data: function (el, key, value) {
        var d;
        if (!el[expando]) {
          el[expando] = id++;
        }
        if (!data[el[expando]]) {
          data[el[expando]] = {};
        }
        d = data[el[expando]];
        if (typeof value != 'undefined') {
          // PATCHED: FIXES BUG WHERE Booleab "FALSE" value cannot be set.
          data[el[expando]][key] = value;
        } else {
          return data[el[expando]][key];
        }
      },
      /**
       * Calls a function on the element and all parents of the element until the function returns
       * false.
       * @hide
       * @param {Object} el
       * @param {Object} func
       */
      onParents: function (el, func) {
        var res;
        while (el && res !== false) {
          res = func(el);
          el = el.parentNode;
        }
        return el;
      },
      //regex to match focusable elements
      focusable: /^(a|area|frame|iframe|label|input|select|textarea|button|html|object)$/i,
      /**
       * Returns if an element is focusable
       * @hide
       * @param {Object} elem
       */
      isFocusable: function (elem) {
        var attributeNode;
        return (this.focusable.test(elem.nodeName) || (attributeNode = elem.getAttributeNode && elem.getAttributeNode('tabIndex')) && attributeNode.specified) && Syn.isVisible(elem);
      },
      /**
       * Returns if an element is visible or not
       * @hide
       * @param {Object} elem
       */
      isVisible: function (elem) {
        return elem.offsetWidth && elem.offsetHeight || elem.clientWidth && elem.clientHeight;
      },
      /**
       * Gets the tabIndex as a number or null
       * @hide
       * @param {Object} elem
       */
      tabIndex: function (elem) {
        var attributeNode = elem.getAttributeNode('tabIndex');
        return attributeNode && attributeNode.specified && (parseInt(elem.getAttribute('tabIndex'), 10) || 0);
      },
      bind: bind,
      unbind: unbind,
      browser: browser,
      //some generic helpers
      helpers: {
        createEventObject: createEventObject,
        createBasicStandardEvent: function (type, defaults, doc) {
          var event;
          try {
            event = doc.createEvent('Events');
          } catch (e2) {
            event = doc.createEvent('UIEvents');
          } finally {
            event.initEvent(type, true, true);
            extend(event, defaults);
          }
          return event;
        },
        inArray: function (item, array) {
          var i = 0;
          for (; i < array.length; i++) {
            if (array[i] === item) {
              return i;
            }
          }
          return -1;
        },
        getWindow: function (element) {
          return element.ownerDocument.defaultView || element.ownerDocument.parentWindow;
        },
        extend: extend,
        scrollOffset: function (win, set) {
          var doc = win.document.documentElement, body = win.document.body;
          if (set) {
            // FIXME! AVOID BACKSCROLLING.
            window.scrollTo(set.left, set.top);
          } else {
            return {
              left: (doc && doc.scrollLeft || body && body.scrollLeft || 0) + (doc.clientLeft || 0),
              top: (doc && doc.scrollTop || body && body.scrollTop || 0) + (doc.clientTop || 0)
            };
          }
        },
        scrollDimensions: function (win) {
          var doc = win.document.documentElement, body = win.document.body, docWidth = doc.clientWidth, docHeight = doc.clientHeight, compat = win.document.compatMode === 'CSS1Compat';
          return {
            height: compat && docHeight || body.clientHeight || docHeight,
            width: compat && docWidth || body.clientWidth || docWidth
          };
        },
        addOffset: function (options, el) {
          var jq = Syn.jquery(el), off;
          if (typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq) {
            el = jq(el);
            off = el.offset();
            options.pageX = off.left + el.width() / 2;
            options.pageY = off.top + el.height() / 2;
          }
        }
      },
      // place for key data
      key: {
        ctrlKey: null,
        altKey: null,
        shiftKey: null,
        metaKey: null
      },
      //triggers an event on an element, returns true if default events should be run
      /**
       * Dispatches an event and returns true if default events should be run.
       * @hide
       * @param {Object} event
       * @param {Object} element
       * @param {Object} type
       * @param {Object} autoPrevent
       */
      dispatch: function (event, element, type, autoPrevent) {
        // dispatchEvent doesn't always work in IE (mostly in a popup)
        if (element.dispatchEvent && event) {
          var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
          //automatically prevents the default behavior for this event
          //this is to protect agianst nasty browser freezing bug in safari
          if (autoPrevent) {
            bind(element, type, function (ev) {
              //console.info("Syn.dispatch: preventDefault();");
              ev.preventDefault();
              unbind(this, type, arguments.callee);
            });
          }
          event.preventDefault = function () {
            prevents++;
            if (++prevents > 0) {
              preventDefault.apply(this, []);
            }
          };
          element.dispatchEvent(event);
          return prevents <= 0;
        } else {
          try {
            window.event = event;
          } catch (e) {
          }
          //source element makes sure element is still in the document
          return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
        }
      },
      /**
       * @attribute
       * @hide
       * An object of eventType -> function that create that event.
       */
      create: {
        //-------- PAGE EVENTS ---------------------
        page: {
          event: function (type, options, element) {
            var doc = Syn.helpers.getWindow(element).document || document, event;
            if (doc.createEvent) {
              event = doc.createEvent('Events');
              event.initEvent(type, true, true);
              return event;
            } else {
              try {
                event = createEventObject(type, options, element);
              } catch (e) {
              }
              return event;
            }
          }
        },
        // unique events
        focus: {
          event: function (type, options, element) {
            //PATCHED!!
            // FIXED: doc should be used instead of "document" reference which points to the
            //        wrong document
            // var doc = Syn.helpers.getWindow(element).document;
            Syn.onParents(element, function (el) {
              if (Syn.isFocusable(el)) {
                // LESSONS LEARNED:
                // (i)  Do not blur the body element if there is no activeElement,
                //      because it will move IE8 browser window to the background.
                // (ii) The HTML element isn't focusable in IE, but it is
                //      in FF.
                if (synchroniteConfig.mousedownChangesFocus && (synchroniteConfig.cobrowseEngine === 'proxybased' || !synchroniteConfig.isAgent && synchroniteConfig.cobrowseEngine === 'proxyless')) {
                  //PATCHED
                  console.debug('SYN: ' + el.nodeName + '.FOCUS()');
                  safelyFocusElement(el);
                  activeElement = el;  //                                else if (activeElement && !/body/i.test(activeElement.nodeName)) { // PATCHED DO NOT MOVE IE8 TO BACKGROUND = DO NOT BLUR BODY
                                       //                                    // TODO: The HTML element isn't focasable in IE, but it is
                                       //                                    // in FF.  We should detect this and do a true focus instead
                                       //                                    // of just a blur
                                       //
                                       //                                    ///////////////////////
                                       //                                    // PATCH 4
                                       //                                    //////////////////////
                                       //                                    /* if ( doc !== window.document ) {
                                       //                                     return false;
                                       //                                     } else */
                                       //                                        activeElement.blur();
                                       //                                        activeElement = null;
                                       //
                                       //                                }
                }
                return false;  //aborts iteration over parents
              }
            });
            return true;
          }
        }
      },
      /**
       * @attribute support
       *
       * Feature detected properties of a browser's event system.
       * Support has the following properties:
       *
       *   - `backspaceWorks` - typing a backspace removes a character
       *   - `clickChanges` - clicking on an option element creates a change event.
       *   - `clickSubmits` - clicking on a form button submits the form.
       *   - `focusChanges` - focus/blur creates a change event.
       *   - `keypressOnAnchorClicks` - Keying enter on an anchor triggers a click.
       *   - `keypressSubmits` - enter key submits
       *   - `keyCharacters` - typing a character shows up
       *   - `keysOnNotFocused` - enters keys when not focused.
       *   - `linkHrefJS` - An achor's href JavaScript is run.
       *   - `mouseDownUpClicks` - A mousedown followed by mouseup creates a click event.
       *   - `mouseupSubmits` - a mouseup on a form button submits the form.
       *   - `radioClickChanges` - clicking a radio button changes the radio.
       *   - `tabKeyTabs` - A tab key changes tabs.
       *   - `textareaCarriage` - a new line in a textarea creates a carriage return.
       *
       *
       */
      support: {
        clickChanges: false,
        clickSubmits: false,
        keypressSubmits: false,
        mouseupSubmits: false,
        radioClickChanges: false,
        focusChanges: false,
        linkHrefJS: false,
        keyCharacters: false,
        backspaceWorks: false,
        mouseDownUpClicks: false,
        tabKeyTabs: false,
        keypressOnAnchorClicks: false,
        optionClickBubbles: false,
        ready: 0
      },
      /**
       * Creates a synthetic event and dispatches it on the element.
       * This will run any default actions for the element.
       * Typically you want to use Syn, but if you want the return value, use this.
       * @param {String} type
       * @param {Object} options
       * @param {HTMLElement} element
       * @return {Boolean} true if default events were run, false if otherwise.
       */
      trigger: function (type, options, element) {
        options || (options = {});
        var create = Syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatchEl = element;
        //any setup code?
        Syn.support.ready === 2 && setup && setup(type, options, element);
        autoPrevent = options._autoPrevent;
        //get kind
        delete options._autoPrevent;
        if (createType.event) {
          ret = createType.event(type, options, element);
        } else {
          //convert options
          options = createKind.options ? createKind.options(type, options, element) : options;
          if (!Syn.support.changeBubbles && /option/i.test(element.nodeName)) {
            dispatchEl = element.parentNode;  //jQuery expects clicks on select
          }
          //create the event
          event = createKind.event(type, options, dispatchEl);
          //send the event
          ret = Syn.dispatch(event, dispatchEl, type, autoPrevent);
        }
        //run default behavior
        ret && Syn.support.ready === 2 && Syn.defaults[type] && Syn.defaults[type].call(element, options, autoPrevent);
        return ret;
      },
      eventSupported: function (eventName) {
        var el = document.createElement('div');
        eventName = 'on' + eventName;
        var isSupported = eventName in el;
        if (!isSupported) {
          el.setAttribute(eventName, 'return;');
          isSupported = typeof el[eventName] === 'function';
        }
        el = null;
        return isSupported;
      }
    });
    /**
     * @Prototype
     */
    extend(Syn.init.prototype, {
      /**
       * @function then
       * <p>
       * Then is used to chain a sequence of actions to be run one after the other.
       * This is useful when many asynchronous actions need to be performed before some
       * final check needs to be made.
       * </p>
       * <p>The following clicks and types into the <code>id='age'</code> element and then checks that only numeric characters can be entered.</p>
       * <h3>Example</h3>
       * @codestart
       * Syn('click',{},'age')
       *   .then('type','I am 12',function(){
       *   equals($('#age').val(),"12")
       * })
       * @codeend
       * If the element argument is undefined, then the last element is used.
       *
       * @param {String} type The type of event or action to create: "_click", "_dblclick", "_drag", "_type".
       * @param {Object} options Optiosn to pass to the event.
       * @param {String|HTMLElement} [element] A element's id or an element.  If undefined, defaults to the previous element.
       * @param {Function} [callback] A function to callback after the action has run, but before any future chained actions are run.
       */
      then: function (type, options, element, callback) {
        if (Syn.autoDelay) {
          this.delay();
        }
        var args = Syn.args(options, element, callback), self = this;
        //if stack is empty run right away
        //otherwise ... unshift it
        this.queue.unshift(function (el, prevented) {
          if (typeof this[type] === 'function') {
            this.element = args.element || el;
            this[type](args.options, this.element, function (defaults, el) {
              args.callback && args.callback.apply(self, arguments);
              self.done.apply(self, arguments);
            });
          } else {
            this.result = Syn.trigger(type, args.options, args.element);
            args.callback && args.callback.call(this, args.element, this.result);
            return this;
          }
        });
        return this;
      },
      /**
       * Delays the next command a set timeout.
       * @param {Number} [timeout]
       * @param {Function} [callback]
       */
      delay: function (timeout, callback) {
        if (typeof timeout === 'function') {
          callback = timeout;
          timeout = null;
        }
        timeout = timeout || 600;
        var self = this;
        this.queue.unshift(function () {
          setTimeout(function () {
            callback && callback.apply(self, []);
            self.done.apply(self, arguments);
          }, timeout);
        });
        return this;
      },
      done: function (defaults, el) {
        el && (this.element = el);
        if (this.queue.length) {
          this.queue.pop().call(this, this.element, defaults);
        }
      },
      /**
       * @function click
       * Clicks an element by triggering a mousedown,
       * mouseup,
       * and a click event.
       * <h3>Example</h3>
       * @codestart
       * Syn.click({},'create',function(){
       *   //check something
       * })
       * @codeend
       * You can also provide the coordinates of the click.
       * If jQuery is present, it will set clientX and clientY
       * for you.  Here's how to set it yourself:
       * @codestart
       * Syn.click(
       *     {clientX: 20, clientY: 100},
       *     'create',
       *     function(){
       *       //check something
       *     })
       * @codeend
       * You can also provide pageX and pageY and Syn will convert it for you.
       * @param {Object} options
       * @param {HTMLElement} element
       * @param {Function} callback
       */
      '_click': function (options, element, callback, force) {
        Syn.helpers.addOffset(options, element);
        console.debug('SYN TRIGGER: _click');
        // PATCHED: TO ACHIEVE CONSISTENT BEHAVIOR ACROSS ALL BROWSERS
        // CHROME open select boxes on mousedown.
        if (!/option|select/i.test(element.nodeName)) {
          console.debug('SYN TRIGGER: _click -> mousedown');
          try {
            Syn.trigger('mousedown', options, element);
            // PATCHED START: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
            if (dojoHas('pointerEvents') || dojoHas('msPointerEvents')) {
              var pointerDown = dojoHas('pointerEvents') ? 'pointerdown' : 'mspointerdown';
              console.debug('SYN TRIGGER: _click -> ' + pointerDown);
              Syn.trigger(pointerDown, options, element);
            }  // PATCHED END: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
          } catch (e) {
            console.log('Syn.trigger(\'mousedown) failed. ' + e);
          }
        }
        //timeout is b/c IE is stupid and won't call focus handlers
        setTimeout(function () {
          console.debug('SYN TRIGGER: _click -> mouseup');
          Syn.trigger('mouseup', options, element);
          // PATCHED START: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
          if (dojoHas('pointerEvents') || dojoHas('msPointerEvents')) {
            var pointerUp = dojoHas('pointerEvents') ? 'pointerup' : 'mspointerup';
            console.debug('SYN TRIGGER: _click -> ' + pointerUp);
            Syn.trigger(pointerUp, options, element);
          }
          // PATCHED END: Added to support cosmosdirekt.de kendo selectables that listen to pointerdown events
          if (!Syn.support.mouseDownUpClicks || force) {
            console.debug('SYN TRIGGER: _click -> click');
            Syn.trigger('click', options, element);
            callback(true);
          } else {
            console.debug('SYN TRIGGER: (click) mouseDownUpClicks=true');
            //we still have to run the default (presumably)
            Syn.create.click.setup('click', options, element);
            Syn.defaults.click.call(element);
            //must give time for callback
            setTimeout(function () {
              callback(true);
            }, 1);
          }
        }, 1);
      },
      /**
       * Right clicks in browsers that support it (everyone but opera).
       * @param {Object} options
       * @param {Object} element
       * @param {Object} callback
       */
      '_rightClick': function (options, element, callback) {
        Syn.helpers.addOffset(options, element);
        var mouseopts = extend(extend({}, Syn.mouse.browser.right.mouseup), options);
        Syn.trigger('mousedown', mouseopts, element);
        //timeout is b/c IE is stupid and won't call focus handlers
        setTimeout(function () {
          console.debug('SYN: MOUSEUP');
          Syn.trigger('mouseup', mouseopts, element);
          if (Syn.mouse.browser.right.contextmenu) {
            Syn.trigger('contextmenu', extend(extend({}, Syn.mouse.browser.right.contextmenu), options), element);
          }
          callback(true);
        }, 1);
      },
      /**
       * @function dblclick
       * Dblclicks an element.  This runs two [Syn.prototype.click click] events followed by
       * a dblclick on the element.
       * <h3>Example</h3>
       * @codestart
       * Syn.dblclick({},'open')
       * @codeend
       * @param {Object} options
       * @param {HTMLElement} element
       * @param {Function} callback
       */
      '_dblclick': function (options, element, callback) {
        Syn.helpers.addOffset(options, element);
        var self = this;
        this._click(options, element, function () {
          setTimeout(function () {
            self._click(options, element, function () {
              Syn.trigger('dblclick', options, element);
              callback(true);
            }, true);
          }, 2);
        });
      }
    });
    var actions = [
        'click',
        'dblclick',
        'move',
        'drag',
        'key',
        'type',
        'rightClick'
      ], makeAction = function (name) {
        Syn[name] = function (options, element, callback) {
          return Syn('_' + name, options, element, callback);
        };
        Syn.init.prototype[name] = function (options, element, callback) {
          return this.then('_' + name, options, element, callback);
        };
      }, i = 0;
    for (; i < actions.length; i++) {
      makeAction(actions[i]);
    }
    //    /**
    //		 * Used for creating and dispatching synthetic events.
    //		 * @codestart
    //		 * new MVC.Syn('click').send(MVC.$E('id'))
    //		 * @codeend
    //		 * @constructor Sets up a synthetic event.
    //		 * @param {String} type type of event, ex: 'click'
    //		 * @param {optional:Object} options
    //		 */
    //    if ( (window.FuncUnit && window.FuncUnit.jQuery) || window.jQuery ) {
    //        ((window.FuncUnit && window.FuncUnit.jQuery) || window.jQuery).fn.triggerSyn = function( type, options, callback ) {
    //            if(!this[0]){
    //                throw "Can't "+type.substring(1)+" because no element matching '"+this.selector+"' was found"
    //            }
    //            Syn(type, options, this[0], callback);
    //            return this;
    //        };
    //    }
    //    /////////////////
    //    // PATCH 4
    //    /////////////////
    //
    //
    //    Syn.focus =  {
    //        event: function( type, options, element ) {
    //            Syn.onParents(element, function( el ) {
    //                if ( Syn.isFocusable(el) ) {
    //                    if (synchroniteConfig.mousedownChangesFocus) {
    //                        if ( el.nodeName.toLowerCase() !== 'html' ) {
    //                            el.focus();
    //                            activeElement = el;
    //                        }
    //                    }
    //                    else if ( activeElement ) {
    //                        // TODO: The HTML element isn't focasable in IE, but it is
    //                        // in FF.  We should detect this and do a true focus instead
    //                        // of just a blur
    //                        var doc = Syn.helpers.getWindow(element).document;
    //
    //
    //                        ///////////////////////
    //                        // PATCH 4
    //                        //////////////////////
    //                        /* if ( doc !== window.document ) {
    //                                    return false;
    //                                } else */
    //                        if ( doc.activeElement ) {
    //                            doc.activeElement.blur();
    //                            activeElement = null;
    //                        } else {
    //                            activeElement.blur();
    //                            activeElement = null;
    //                        }
    //
    //
    //                    }
    //                    return false;
    //                }
    //            });
    //            return true;
    //        }
    //    };
    /////////////////
    // PATCH 5
    /////////////////
    Syn.trigger = function (type, options, element) {
      options || (options = {});
      var create = Syn.create, setup = create[type] && create[type].setup, kind = key.test(type) ? 'key' : page.test(type) ? 'page' : 'mouse', createType = create[type] || {}, createKind = create[kind], event, ret, autoPrevent, dispatch, dispatchEl = element;
      // PATCHED: inserted dispatch
      //any setup code?
      Syn.support.ready === 2 && setup && setup(type, options, element);
      autoPrevent = options._autoPrevent;
      dispatch = options._dispatch;
      // PATCHED
      //get kind
      delete options._autoPrevent;
      delete options._dispatch;
      //PATCHED
      if (createType.event && !dispatch) {
        //PATCHED
        ret = createType.event(type, options, element);
      } else {
        //convert options
        options = createKind.options ? createKind.options(type, options, element) : options;
        if (!Syn.support.changeBubbles && /option/i.test(element.nodeName)) {
          //FIXED: parentNode maybe optgroup tag not select
          dispatchEl = Syn.closest(element, 'select');  //jQuery expects clicks on select
                                                        //END FIX
        }
        //create the event
        event = createKind.event(type, options, dispatchEl);
        //send the event
        ret = Syn.dispatch(event, dispatchEl, type, autoPrevent);
      }
      //run default behavior
      ret && Syn.support.ready === 2 && Syn.defaults[type] && Syn.defaults[type].call(element, options, autoPrevent);
      //FIXED: Save return value
      if (event) {
        event.returnValue = ret;  //console.debug("RTURNED: " + ret);
      }
      return ret;
    };
    //window.Syn = Syn;
    return Syn;
  }(dojo_has, synchronite_micro_dom);
  synchronite_simulate_mouse = function (Syn, synchDom) {
    //handles mosue events
    var h = Syn.helpers, getWin = h.getWindow;
    Syn.mouse = {};
    h.extend(Syn.defaults, {
      mousedown: function (options) {
        console.debug('SYN: MOUSEDOWN');
        // We now handle this via monitorFocus()
        if (synchroniteConfig.mousedownChangesFocus && (synchroniteConfig.cobrowseEngine === 'proxybased' || !synchroniteConfig.isAgent && synchroniteConfig.cobrowseEngine === 'proxyless')) {
          try {
            Syn.trigger('focus', {}, this);  //PATCHED
          } catch (e) {
            console.warn('Syn.trigger(\'focus\') caused an error' + e);
          }
        }
      },
      click: function () {
        // prevents the access denied issue in IE if the click causes the element to be destroyed
        var element = this;
        if (!synchDom.canAccessNode(element)) {
          return;
        }
        //get old values
        var href, radioChanged = Syn.data(element, 'radioChanged'), scope = getWin(element), nodeName = element.nodeName.toLowerCase();
        //this code was for restoring the href attribute to prevent popup opening
        //if ((href = Syn.data(element, "href"))) {
        //	element.setAttribute('href', href)
        //}
        //run href javascript
        var JS_REGEX = /^\s*javascript:/;
        if (!Syn.support.linkHrefJS && JS_REGEX.test(element.href)) {
          //eval js
          var code = element.href.replace(JS_REGEX, '');
          //try{
          if (code != '//' && code.indexOf('void(0)') == -1) {
            if (window.selenium) {
              eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
            } else {
              eval('with(scope){' + code + '}');
            }
          }
        }
        //submit a form
        if (!Syn.support.clickSubmits && (nodeName == 'input' && element.type == 'submit') || nodeName == 'button') {
          var form = Syn.closest(element, 'form');
          if (form) {
            Syn.trigger('submit', {}, form);
          }
        }
        //follow a link, probably needs to check if in an a.
        if (nodeName == 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
          scope.location.href = element.href;
        }
        //change a checkbox
        if (nodeName == 'input' && element.type == 'checkbox') {
          //if(!Syn.support.clickChecks && !Syn.support.changeChecks){
          //	element.checked = !element.checked;
          //}
          if (!Syn.support.clickChanges) {
            Syn.trigger('change', {}, element);
          }
        }
        //change a radio button
        if (nodeName == 'input' && element.type == 'radio') {
          // need to uncheck others if not checked
          if (radioChanged && !Syn.support.radioClickChanges) {
            Syn.trigger('change', {}, element);
          }
        }
        // change options
        if (nodeName == 'option') {
          var selectNode = Syn.closest(element, 'select');
          //PATCHED!
          if (Syn.data(selectNode, 'createChange')) {
            Syn.trigger('change', {}, selectNode);
            //does not bubble //PATCHED
            Syn.data(selectNode, 'createChange', false);
          }
        }
      }
    });
    //add create and setup behavior for mosue events
    h.extend(Syn.create, {
      mouse: {
        options: function (type, options, element) {
          var doc = document.documentElement, body = document.body, center = [
              options.pageX || 0,
              options.pageY || 0
            ],
            //browser might not be loaded yet (doing support code)
            left = Syn.mouse.browser && Syn.mouse.browser.left[type], right = Syn.mouse.browser && Syn.mouse.browser.right[type];
          return h.extend({
            bubbles: true,
            cancelable: true,
            view: window,
            detail: 1,
            screenX: 1,
            screenY: 1,
            clientX: options.clientX || center[0] - (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc.clientLeft || 0),
            clientY: options.clientY || center[1] - (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc.clientTop || 0),
            ctrlKey: !!Syn.key.ctrlKey,
            altKey: !!Syn.key.altKey,
            shiftKey: !!Syn.key.shiftKey,
            metaKey: !!Syn.key.metaKey,
            button: left && left.button != null ? left.button : right && right.button || (type == 'contextmenu' ? 2 : 0),
            relatedTarget: document.documentElement
          }, options);
        },
        event: function (type, defaults, element) {
          //Everyone Else
          var doc = getWin(element).document || document;
          if (doc.createEvent) {
            var event;
            try {
              if (typeof MouseEvent === 'function') {
                event = new MouseEvent(type, defaults);
              } else {
                event = doc.createEvent('MouseEvents');
                event.initMouseEvent(type, defaults.bubbles, defaults.cancelable, defaults.view, defaults.detail, defaults.screenX, defaults.screenY, defaults.clientX, defaults.clientY, defaults.ctrlKey, defaults.altKey, defaults.shiftKey, defaults.metaKey, defaults.button, defaults.relatedTarget);
              }
            } catch (e) {
              event = h.createBasicStandardEvent(type, defaults, doc);
            }
            event.synthetic = true;
            return event;
          } else {
            var event;
            try {
              event = h.createEventObject(type, defaults, element);
            } catch (e) {
            }
            return event;
          }
        }
      },
      click: {
        setup: function (type, options, element) {
          var nodeName = element.nodeName.toLowerCase(), type;
          //we need to manually 'check' in browser that can't check
          //so checked has the right value
          if (!Syn.support.clickChecks && !Syn.support.changeChecks && nodeName === 'input') {
            type = element.type.toLowerCase();
            //pretty sure lowercase isn't needed
            if (type === 'checkbox') {
              element.checked = !element.checked;
            }
            if (type === 'radio') {
              //do the checks manually
              if (!element.checked) {
                //do nothing, no change
                try {
                  Syn.data(element, 'radioChanged', true);
                } catch (e) {
                }
                element.checked = true;
              }
            }
          }
          if (nodeName == 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
            //save href
            Syn.data(element, 'href', element.href);  //remove b/c safari/opera will open a new tab instead of changing the page
                                                      // this has been removed because newer versions don't have this problem
                                                      //element.setAttribute('href', 'javascript://')
                                                      //however this breaks scripts using the href
                                                      //we need to listen to this and prevent the default behavior
                                                      //and run the default behavior ourselves. Boo!
          }
          //if select or option, save old value and mark to change
          if (/option/i.test(element.nodeName)) {
            //PATCHED to respect selectNode
            var selectNode = Syn.closest(element, 'select');
            var child = selectNode.firstChild, i = -1;
            while (child) {
              if (child.nodeType == 1) {
                i++;
                if (child == element)
                  break;
              }
              child = child.nextSibling;
            }
            if (i !== selectNode.selectedIndex) {
              //shouldn't this wait on triggering
              //change?
              selectNode.selectedIndex = i;
              Syn.data(selectNode, 'createChange', true);
            }
          }
        }
      },
      mousedown: {
        setup: function (type, options, element) {
          var nn = element.nodeName.toLowerCase();
          //we have to auto prevent default to prevent freezing error in safari
          if (Syn.browser.safari && (nn == 'select' || nn == 'option')) {
            options._autoPrevent = true;
          }
        }
      }
    });
    //do support code
    (function () {
      if (!document.body) {
        setTimeout(arguments.callee, 1);
        return;
      }
      var oldSynth = window.__synthTest;
      Syn.support.linkHrefJS = true;
      var div = document.createElement('div'), checkbox, submit, form, input, select;
      div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<select><option></option></select>' + '</form>';
      document.documentElement.appendChild(div);
      form = div.firstChild;
      checkbox = form.childNodes[0];
      submit = form.childNodes[2];
      select = form.getElementsByTagName('select')[0];
      checkbox.checked = false;
      checkbox.onchange = function () {
        Syn.support.clickChanges = true;
      };
      Syn.trigger('click', {}, checkbox);
      Syn.support.clickChecks = checkbox.checked;
      checkbox.checked = false;
      Syn.trigger('change', {}, checkbox);
      Syn.support.changeChecks = checkbox.checked;
      form.onsubmit = function (ev) {
        if (ev.preventDefault)
          ev.preventDefault();
        Syn.support.clickSubmits = true;
        return false;
      };
      Syn.trigger('click', {}, submit);
      form.childNodes[1].onchange = function () {
        Syn.support.radioClickChanges = true;
      };
      Syn.trigger('click', {}, form.childNodes[1]);
      Syn.bind(div, 'click', function () {
        Syn.support.optionClickBubbles = true;
        Syn.unbind(div, 'click', arguments.callee);
      });
      Syn.trigger('click', {}, select.firstChild);
      Syn.support.changeBubbles = Syn.eventSupported('change');
      //test if mousedown followed by mouseup causes click (opera), make sure there are no clicks after this
      var clicksCount = 0;
      div.onclick = function () {
        Syn.support.mouseDownUpClicks = true;  //we should use this to check for opera potentially, but would
                                               //be difficult to remove element correctly
                                               //Syn.support.mouseDownUpRepeatClicks = (2 == (++clicksCount))
      };
      Syn.trigger('mousedown', {}, div);
      Syn.trigger('mouseup', {}, div);
      //setTimeout(function(){
      //	Syn.trigger("mousedown",{},div)
      //	Syn.trigger("mouseup",{},div)
      //},1)
      document.documentElement.removeChild(div);
      //check stuff
      // PATCH: FireFox 20 seems to dispatch events asynchronously, so we cannot replace __systhTest yet
      // or it will be unavailable and throw an error in FF.
      // window.__synthTest = oldSynth;
      Syn.support.ready++;
    }());
    return Syn;
  }(synchronite_simulate_synthetic, synchronite_micro_dom);
  synchronite_simulate_browsers = function (Syn) {
    Syn.key.browsers = {
      webkit: {
        'prevent': {
          'keyup': [],
          'keydown': [
            'char',
            'keypress'
          ],
          'keypress': ['char']
        },
        'character': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            'char',
            'char'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'specialChars': {
          'keydown': [
            0,
            'char'
          ],
          'keyup': [
            0,
            'char'
          ]
        },
        'navigation': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'special': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'tab': {
          'keydown': [
            0,
            'char'
          ],
          'keyup': [
            0,
            'char'
          ]
        },
        'pause-break': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'caps': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'escape': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'num-lock': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'scroll-lock': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'print': {
          'keyup': [
            0,
            'key'
          ]
        },
        'function': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        '\r': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            'char',
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        }
      },
      gecko: {
        'prevent': {
          'keyup': [],
          'keydown': ['char'],
          'keypress': ['char']
        },
        'character': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            'char',
            0
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'specialChars': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'navigation': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'special': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        '\t': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'pause-break': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'caps': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'escape': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'num-lock': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'scroll-lock': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        'print': {
          'keyup': [
            0,
            'key'
          ]
        },
        'function': {
          'keydown': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        },
        '\r': {
          'keydown': [
            0,
            'key'
          ],
          'keypress': [
            0,
            'key'
          ],
          'keyup': [
            0,
            'key'
          ]
        }
      },
      msie: {
        'prevent': {
          'keyup': [],
          'keydown': [
            'char',
            'keypress'
          ],
          'keypress': ['char']
        },
        'character': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'specialChars': {
          'keydown': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'char'
          ]
        },
        'navigation': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'special': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'tab': {
          'keydown': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'char'
          ]
        },
        'pause-break': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'caps': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'escape': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'num-lock': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'scroll-lock': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'print': {
          'keyup': [
            null,
            'key'
          ]
        },
        'function': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        '\r': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        }
      },
      opera: {
        'prevent': {
          'keyup': [],
          'keydown': [],
          'keypress': ['char']
        },
        'character': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'specialChars': {
          'keydown': [
            null,
            'char'
          ],
          'keypress': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'char'
          ]
        },
        'navigation': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ]
        },
        'special': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'tab': {
          'keydown': [
            null,
            'char'
          ],
          'keypress': [
            null,
            'char'
          ],
          'keyup': [
            null,
            'char'
          ]
        },
        'pause-break': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'caps': {
          'keydown': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'escape': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ]
        },
        'num-lock': {
          'keyup': [
            null,
            'key'
          ],
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ]
        },
        'scroll-lock': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        'print': {},
        'function': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        },
        '\r': {
          'keydown': [
            null,
            'key'
          ],
          'keypress': [
            null,
            'key'
          ],
          'keyup': [
            null,
            'key'
          ]
        }
      }
    };
    Syn.mouse.browsers = {
      webkit: {
        'right': {
          'mousedown': {
            'button': 2,
            'which': 3
          },
          'mouseup': {
            'button': 2,
            'which': 3
          },
          'contextmenu': {
            'button': 2,
            'which': 3
          }
        },
        'left': {
          'mousedown': {
            'button': 0,
            'which': 1
          },
          'mouseup': {
            'button': 0,
            'which': 1
          },
          'click': {
            'button': 0,
            'which': 1
          }
        }
      },
      opera: {
        'right': {
          'mousedown': {
            'button': 2,
            'which': 3
          },
          'mouseup': {
            'button': 2,
            'which': 3
          }
        },
        'left': {
          'mousedown': {
            'button': 0,
            'which': 1
          },
          'mouseup': {
            'button': 0,
            'which': 1
          },
          'click': {
            'button': 0,
            'which': 1
          }
        }
      },
      msie: {
        'right': {
          'mousedown': { 'button': 2 },
          'mouseup': { 'button': 2 },
          'contextmenu': { 'button': 0 }
        },
        'left': {
          'mousedown': { 'button': 1 },
          'mouseup': { 'button': 1 },
          'click': { 'button': 0 }
        }
      },
      chrome: {
        'right': {
          'mousedown': {
            'button': 2,
            'which': 3
          },
          'mouseup': {
            'button': 2,
            'which': 3
          },
          'contextmenu': {
            'button': 2,
            'which': 3
          }
        },
        'left': {
          'mousedown': {
            'button': 0,
            'which': 1
          },
          'mouseup': {
            'button': 0,
            'which': 1
          },
          'click': {
            'button': 0,
            'which': 1
          }
        }
      },
      gecko: {
        'left': {
          'mousedown': {
            'button': 0,
            'which': 1
          },
          'mouseup': {
            'button': 0,
            'which': 1
          },
          'click': {
            'button': 0,
            'which': 1
          }
        },
        'right': {
          'mousedown': {
            'button': 2,
            'which': 3
          },
          'mouseup': {
            'button': 2,
            'which': 3
          },
          'contextmenu': {
            'button': 2,
            'which': 3
          }
        }
      }
    };
    //set browser
    Syn.key.browser = function () {
      if (Syn.key.browsers[window.navigator.userAgent]) {
        return Syn.key.browsers[window.navigator.userAgent];
      }
      for (var browser in Syn.browser) {
        if (Syn.browser[browser] && Syn.key.browsers[browser]) {
          return Syn.key.browsers[browser];
        }
      }
      return Syn.key.browsers.gecko;
    }();
    Syn.mouse.browser = function () {
      if (Syn.mouse.browsers[window.navigator.userAgent]) {
        return Syn.mouse.browsers[window.navigator.userAgent];
      }
      for (var browser in Syn.browser) {
        if (Syn.browser[browser] && Syn.mouse.browsers[browser]) {
          return Syn.mouse.browsers[browser];
        }
      }
      return Syn.mouse.browsers.gecko;
    }();
    return Syn;
  }(synchronite_simulate_mouse);
  synchronite_simulate_key = function (Syn, baseDom) {
    var h = Syn.helpers, S = Syn,
      // gets the selection of an input or textarea
      getSelection = function (el) {
        // use selectionStart if we can
        if (baseDom.canAccessProperty(el, 'selectionStart') && el.selectionStart !== undefined) {
          // this is for opera, so we don't have to focus to type how we think we would
          // PATCHED: NOT NEEDED ANYMORE CAUSES INCORRECT RESULTS IN CHROME AND FIREFOX.
          //            if ( document.activeElement && document.activeElement != el && el.selectionStart == el.selectionEnd && el.selectionStart == 0 ) {
          //                return {
          //                    start: el.value.length,
          //                    end: el.value.length
          //                };
          //            }
          return {
            start: el.selectionStart,
            end: el.selectionEnd
          };
        } else {
          //check if we aren't focused
          try {
            //try 2 different methods that work differently (IE breaks depending on type)
            if (el.nodeName.toLowerCase() == 'input') {
              var real = h.getWindow(el).document.selection.createRange(), r = el.createTextRange();
              r.setEndPoint('EndToStart', real);
              var start = r.text.length;
              return {
                start: start,
                end: start + real.text.length
              };
            } else {
              var real = h.getWindow(el).document.selection.createRange(), r = real.duplicate(), r2 = real.duplicate(), r3 = real.duplicate();
              r2.collapse();
              r3.collapse(false);
              r2.moveStart('character', -1);
              r3.moveStart('character', -1);
              //select all of our element
              r.moveToElementText(el);
              //now move our endpoint to the end of our real range
              r.setEndPoint('EndToEnd', real);
              var start = r.text.length - real.text.length, end = r.text.length;
              if (start != 0 && r2.text == '') {
                start += 2;
              }
              if (end != 0 && r3.text == '') {
                end += 2;
              }
              //if we aren't at the start, but previous is empty, we are at start of newline
              return {
                start: start,
                end: end
              };
            }
          } catch (e) {
            console.error('Error getting selection', e);
            return {
              start: el.value.length,
              end: el.value.length
            };
          }
        }
      },
      // gets all focusable elements
      getFocusable = function (el) {
        var document = h.getWindow(el).document, res = [];
        var els = document.getElementsByTagName('*'), len = els.length;
        for (var i = 0; i < len; i++) {
          Syn.isFocusable(els[i]) && els[i] != document.documentElement && res.push(els[i]);
        }
        return res;
      };
    /**
     * @add Syn static
     */
    h.extend(Syn, {
      /**
       * @attribute
       * A list of the keys and their keycodes codes you can type.
       * You can add type keys with
       * @codestart
       * Syn('key','delete','title');
       *
       * //or
       *
       * Syn('type','One Two Three[left][left][delete]','title')
       * @codeend
       *
       * The following are a list of keys you can type:
       * @codestart text
       * \b        - backspace
       * \t        - tab
       * \r        - enter
       * ' '       - space
       * a-Z 0-9   - normal characters
       * /!@#$*,.? - All other typeable characters
       * page-up   - scrolls up
       * page-down - scrolls down
       * end       - scrolls to bottom
       * home      - scrolls to top
       * insert    - changes how keys are entered
       * delete    - deletes the next character
       * left      - moves cursor left
       * right     - moves cursor right
       * up        - moves the cursor up
       * down      - moves the cursor down
       * f1-12     - function buttons
       * shift, ctrl, alt - special keys
       * pause-break      - the pause button
       * scroll-lock      - locks scrolling
       * caps      - makes caps
       * escape    - escape button
       * num-lock  - allows numbers on keypad
       * print     - screen capture
       * @codeend
       */
      keycodes: {
        //backspace
        '\b': 8,
        //tab
        '\t': 9,
        //enter
        '\r': 13,
        //special
        'shift': 16,
        'ctrl': 17,
        'alt': 18,
        //weird
        'pause-break': 19,
        'caps': 20,
        'escape': 27,
        'num-lock': 144,
        'scroll-lock': 145,
        'print': 44,
        //navigation
        'page-up': 33,
        'page-down': 34,
        'end': 35,
        'home': 36,
        'left': 37,
        'up': 38,
        'right': 39,
        'down': 40,
        'insert': 45,
        'delete': 46,
        //normal characters
        ' ': 32,
        '0': 48,
        '1': 49,
        '2': 50,
        '3': 51,
        '4': 52,
        '5': 53,
        '6': 54,
        '7': 55,
        '8': 56,
        '9': 57,
        'a': 65,
        'b': 66,
        'c': 67,
        'd': 68,
        'e': 69,
        'f': 70,
        'g': 71,
        'h': 72,
        'i': 73,
        'j': 74,
        'k': 75,
        'l': 76,
        'm': 77,
        'n': 78,
        'o': 79,
        'p': 80,
        'q': 81,
        'r': 82,
        's': 83,
        't': 84,
        'u': 85,
        'v': 86,
        'w': 87,
        'x': 88,
        'y': 89,
        'z': 90,
        //PATCH INSERTED CAPITAL LETTERS
        'A': 65,
        'B': 66,
        'C': 67,
        'D': 68,
        'E': 69,
        'F': 70,
        'G': 71,
        'H': 72,
        'I': 73,
        'J': 74,
        'K': 75,
        'L': 76,
        'M': 77,
        'N': 78,
        'O': 79,
        'P': 80,
        'Q': 81,
        'R': 82,
        'S': 83,
        'T': 84,
        'U': 85,
        'V': 86,
        'W': 87,
        'X': 88,
        'Y': 89,
        'Z': 90,
        //normal-characters, numpad
        'num0': 96,
        'num1': 97,
        'num2': 98,
        'num3': 99,
        'num4': 100,
        'num5': 101,
        'num6': 102,
        'num7': 103,
        'num8': 104,
        'num9': 105,
        '*': 106,
        '+': 107,
        '-': 109,
        '.': 110,
        //normal-characters, others
        '/': 111,
        ';': 186,
        '=': 187,
        ',': 188,
        '-': 189,
        '.': 190,
        '/': 191,
        '`': 192,
        '[': 219,
        '\\': 220,
        ']': 221,
        '\'': 222,
        //ignore these, you shouldn't use them
        'left window key': 91,
        'right window key': 92,
        'select key': 93,
        'f1': 112,
        'f2': 113,
        'f3': 114,
        'f4': 115,
        'f5': 116,
        'f6': 117,
        'f7': 118,
        'f8': 119,
        'f9': 120,
        'f10': 121,
        'f11': 122,
        'f12': 123
      },
      // what we can type in
      typeable: /input|textarea/i,
      // selects text on an element
      selectText: function (el, start, end) {
        if (el.setSelectionRange) {
          if (!end) {
            if (synchroniteConfig.mousedownChangesFocus && (synchroniteConfig.cobrowseEngine === 'proxybased' || !synchroniteConfig.isAgent && synchroniteConfig.cobrowseEngine === 'proxyless')) {
              el.focus();
            }
            try {
              //PATCHED try catch
              el.setSelectionRange(start, start);
            } catch (e) {
              console.warn('Cannot call setSelectionRange on element ' + el.type);
            }
          } else {
            el.selectionStart = start;
            el.selectionEnd = end;
          }
        } else if (el.createTextRange) {
          //el.focus();
          var r = el.createTextRange();
          r.moveStart('character', start);
          end = end || start;
          r.moveEnd('character', end - el.value.length);
          r.select();
        }
      },
      getText: function (el) {
        //first check if the el has anything selected ..
        if (Syn.typeable.test(el.nodeName)) {
          var sel = getSelection(el);
          return el.value.substring(sel.start, sel.end);
        }
        //otherwise get from page
        var win = Syn.helpers.getWindow(el);
        if (win.getSelection) {
          return win.getSelection().toString();
        } else if (win.document.getSelection) {
          return win.document.getSelection().toString();
        } else {
          return win.document.selection.createRange().text;
        }
      },
      getSelection: getSelection
    });
    h.extend(Syn.key, {
      // retrieves a description of what events for this character should look like
      data: function (key) {
        //check if it is described directly
        if (S.key.browser[key]) {
          return S.key.browser[key];
        }
        for (var kind in S.key.kinds) {
          if (h.inArray(key, S.key.kinds[kind]) > -1) {
            return S.key.browser[kind];
          }
        }
        return S.key.browser.character;
      },
      //returns the special key if special
      isSpecial: function (keyCode) {
        var specials = S.key.kinds.special;
        for (var i = 0; i < specials.length; i++) {
          if (Syn.keycodes[specials[i]] == keyCode) {
            return specials[i];
          }
        }
      },
      /**
       * @hide
       * gets the options for a key and event type ...
       * @param {Object} key
       * @param {Object} event
       */
      options: function (key, event) {
        var keyData = Syn.key.data(key);
        if (!keyData[event]) {
          //we shouldn't be creating this event
          return null;
        }
        var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
        if (keyCode == 'key') {
          result.keyCode = Syn.keycodes[key];
          // PATCH
          if (!result.keyCode) {
            result.keyCode = key.charCodeAt(0);
          }
        } else if (keyCode == 'char') {
          result.keyCode = key.charCodeAt(0);
        } else {
          result.keyCode = keyCode;
        }
        if (charCode == 'char') {
          result.charCode = key.charCodeAt(0);
        } else if (charCode !== null) {
          result.charCode = charCode;
        }
        // all current browsers have which property to normalize keyCode/charCode
        if (result.keyCode) {
          result.which = result.keyCode;
        } else {
          result.which = result.charCode;
        }
        return result;
      },
      //types of event keys
      kinds: {
        special: [
          'shift',
          'ctrl',
          'alt',
          'caps'
        ],
        specialChars: ['\b'],
        navigation: [
          'page-up',
          'page-down',
          'end',
          'home',
          'left',
          'up',
          'right',
          'down',
          'insert',
          'delete'
        ],
        'function': [
          'f1',
          'f2',
          'f3',
          'f4',
          'f5',
          'f6',
          'f7',
          'f8',
          'f9',
          'f10',
          'f11',
          'f12'
        ]
      },
      //returns the default function
      // some keys have default functions
      // some 'kinds' of keys have default functions
      getDefault: function (key) {
        //check if it is described directly
        if (Syn.key.defaults[key]) {
          return Syn.key.defaults[key];
        }
        for (var kind in Syn.key.kinds) {
          if (h.inArray(key, Syn.key.kinds[kind]) > -1 && Syn.key.defaults[kind]) {
            return Syn.key.defaults[kind];
          }
        }
        return Syn.key.defaults.character;
      },
      // default behavior when typing
      defaults: {
        'character': function (options, scope, key, force, sel) {
          if (/num\d+/.test(key)) {
            key = key.match(/\d+/)[0];
          }
          if (force || !S.support.keyCharacters && Syn.typeable.test(this.nodeName)) {
            var current = this.value, before = current.substr(0, sel.start), after = current.substr(sel.end), character = key;
            this.value = before + character + after;
            //handle IE inserting \r\n
            var charLength = character == '\n' && S.support.textareaCarriage ? 2 : character.length;
            Syn.selectText(this, before.length + charLength);
          }
        },
        'c': function (options, scope, key, force, sel) {
          if (Syn.key.ctrlKey) {
            Syn.key.clipboard = Syn.getText(this);
          } else {
            Syn.key.defaults.character.apply(this, arguments);
          }
        },
        'v': function (options, scope, key, force, sel) {
          if (Syn.key.ctrlKey) {
            Syn.key.defaults.character.call(this, options, scope, Syn.key.clipboard, true, sel);
          } else {
            Syn.key.defaults.character.apply(this, arguments);
          }
        },
        'a': function (options, scope, key, force, sel) {
          if (Syn.key.ctrlKey) {
            Syn.selectText(this, 0, this.value.length);
          } else {
            Syn.key.defaults.character.apply(this, arguments);
          }
        },
        'home': function () {
          Syn.onParents(this, function (el) {
            if (el.scrollHeight != el.clientHeight) {
              el.scrollTop = 0;
              return false;
            }
          });
        },
        'end': function () {
          Syn.onParents(this, function (el) {
            if (el.scrollHeight != el.clientHeight) {
              el.scrollTop = el.scrollHeight;
              return false;
            }
          });
        },
        'page-down': function () {
          //find the first parent we can scroll
          Syn.onParents(this, function (el) {
            if (el.scrollHeight != el.clientHeight) {
              var ch = el.clientHeight;
              el.scrollTop += ch;
              return false;
            }
          });
        },
        'page-up': function () {
          Syn.onParents(this, function (el) {
            if (el.scrollHeight != el.clientHeight) {
              var ch = el.clientHeight;
              el.scrollTop -= ch;
              return false;
            }
          });
        },
        '\b': function (options, scope, key, force, sel) {
          //this assumes we are deleting from the end
          if (!S.support.backspaceWorks && Syn.typeable.test(this.nodeName)) {
            var current = this.value, before = current.substr(0, sel.start), after = current.substr(sel.end);
            if (sel.start == sel.end && sel.start > 0) {
              //remove a character
              this.value = before.substring(0, before.length - 1) + after;
              Syn.selectText(this, sel.start - 1);
            } else {
              this.value = before + after;
              Syn.selectText(this, sel.start);
            }  //set back the selection
          }
        },
        'delete': function (options, scope, key, force, sel) {
          if (!S.support.backspaceWorks && Syn.typeable.test(this.nodeName)) {
            var current = this.value, before = current.substr(0, sel.start), after = current.substr(sel.end);
            if (sel.start == sel.end && sel.start <= this.value.length - 1) {
              this.value = before + after.substring(1);
            } else {
              this.value = before + after;
            }
            Syn.selectText(this, sel.start);
          }
        },
        '\r': function (options, scope, key, force, sel) {
          var nodeName = this.nodeName.toLowerCase();
          // submit a form
          if (!S.support.keypressSubmits && nodeName == 'input') {
            var form = Syn.closest(this, 'form');
            if (form) {
              Syn.trigger('submit', {}, form);
            }
          }
          //newline in textarea
          if (!S.support.keyCharacters && nodeName == 'textarea') {
            Syn.key.defaults.character.call(this, options, scope, '\n', undefined, sel);
          }
          // 'click' hyperlinks
          if (!S.support.keypressOnAnchorClicks && nodeName == 'a') {
            Syn.trigger('click', {}, this);
          }
        },
        //
        // Gets all focusable elements.  If the element (this)
        // doesn't have a tabindex, finds the next element after.
        // If the element (this) has a tabindex finds the element
        // with the next higher tabindex OR the element with the same
        // tabindex after it in the document.
        // @return the next element
        //
        '\t': function (options, scope) {
          // focusable elements
          var focusEls = getFocusable(this),
            // the current element's tabindex
            tabIndex = Syn.tabIndex(this),
            // will be set to our guess for the next element
            current = null,
            // the next index we care about
            currentIndex = 1000000000,
            // set to true once we found 'this' element
            found = false, i = 0, el,
            //the tabindex of the tabable element we are looking at
            elIndex, firstNotIndexed, prev;
          orders = [];
          for (; i < focusEls.length; i++) {
            orders.push([
              focusEls[i],
              i
            ]);
          }
          var sort = function (order1, order2) {
            var el1 = order1[0], el2 = order2[0], tab1 = Syn.tabIndex(el1) || 0, tab2 = Syn.tabIndex(el2) || 0;
            if (tab1 == tab2) {
              return order1[1] - order2[1];
            } else {
              if (tab1 === 0) {
                return 1;
              } else if (tab2 === 0) {
                return -1;
              } else {
                return tab1 - tab2;
              }
            }
          };
          orders.sort(sort);
          //now find current
          for (i = 0; i < orders.length; i++) {
            el = orders[i][0];
            if (this == el) {
              if (!Syn.key.shiftKey) {
                current = i + 1 < orders.length ? orders[i + 1][0] : null;
                // PATCHED: Do not move past last tabIndex Element
                if (!current) {
                  current = orders[0][0];
                }
              } else {
                current = orders[i - 1][0];
                if (!current) {
                  current = orders[focusEls.length - 1][0];
                }
              }
            }
          }
          //restart if we didn't find anything
          if (!current) {
            current = firstNotIndexed;
          }
          if (synchroniteConfig.mousedownChangesFocus && (synchroniteConfig.cobrowseEngine === 'proxybased' || !synchroniteConfig.isAgent && synchroniteConfig.cobrowseEngine === 'proxyless')) {
            current && Syn.trigger('focus', {}, current);  //PATCHED: current.focus();
          }
          return current;
        },
        'left': function (options, scope, key, force, sel) {
          if (Syn.typeable.test(this.nodeName)) {
            if (Syn.key.shiftKey) {
              Syn.selectText(this, sel.start == 0 ? 0 : sel.start - 1, sel.end);
            } else {
              Syn.selectText(this, sel.start == 0 ? 0 : sel.start - 1);
            }
          }
        },
        'right': function (options, scope, key, force, sel) {
          if (Syn.typeable.test(this.nodeName)) {
            if (Syn.key.shiftKey) {
              Syn.selectText(this, sel.start, sel.end + 1 > this.value.length ? this.value.length : sel.end + 1);
            } else {
              Syn.selectText(this, sel.end + 1 > this.value.length ? this.value.length : sel.end + 1);
            }
          }
        },
        'up': function () {
          if (/select/i.test(this.nodeName)) {
            this.selectedIndex = this.selectedIndex ? this.selectedIndex - 1 : 0;  //set this to change on blur?
          }
        },
        'down': function () {
          if (/select/i.test(this.nodeName)) {
            Syn.changeOnBlur(this, 'selectedIndex', this.selectedIndex);
            this.selectedIndex = this.selectedIndex + 1;  //set this to change on blur?
          }
        },
        'shift': function () {
          return null;
        }
      }
    });
    h.extend(Syn.create, {
      keydown: {
        setup: function (type, options, element) {
          if (h.inArray(options, Syn.key.kinds.special) != -1) {
            Syn.key[options + 'Key'] = element;
          }
        }
      },
      keypress: {
        setup: function (type, options, element) {
          // if this browsers supports writing keys on events
          // but doesn't write them if the element isn't focused
          // focus on the element (ignored if already focused)
          if (S.support.keyCharacters && !S.support.keysOnNotFocused) {
            if (synchroniteConfig.mousedownChangesFocus && (synchroniteConfig.cobrowseEngine === 'proxybased' || !synchroniteConfig.isAgent && synchroniteConfig.cobrowseEngine === 'proxyless')) {
              element.focus();
            }
          }
        }
      },
      keyup: {
        setup: function (type, options, element) {
          if (h.inArray(options, Syn.key.kinds.special) != -1) {
            Syn.key[options + 'Key'] = null;
          }
        }
      },
      key: {
        // return the options for a key event
        options: function (type, options, element) {
          //check if options is character or has character
          options = typeof options != 'object' ? { character: options } : options;
          //don't change the orignial
          options = h.extend({}, options);
          if (options.character) {
            h.extend(options, S.key.options(options.character, type));
            delete options.character;
          }
          options = h.extend({
            ctrlKey: !!Syn.key.ctrlKey,
            altKey: !!Syn.key.altKey,
            shiftKey: !!Syn.key.shiftKey,
            metaKey: !!Syn.key.metaKey,
            screenX: 1,
            //PATCH: set screenX, screenY so synthetic events can be detected.
            screenY: 1
          }, options);
          return options;
        },
        // creates a key event
        event: function (type, options, element) {
          //Everyone Else
          var doc = h.getWindow(element).document || document;
          if (doc.createEvent) {
            var event;
            try {
              event = doc.createEvent('KeyEvents');
              event.initKeyEvent(type, true, true, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.keyCode, options.charCode);
            } catch (e) {
              event = h.createBasicStandardEvent(type, options, doc);
            }
            event.synthetic = true;
            return event;
          } else {
            var event;
            try {
              event = h.createEventObject.apply(this, arguments);
              h.extend(event, options);
            } catch (e) {
            }
            return event;
          }
        }
      }
    });
    var convert = {
      'enter': '\r',
      'backspace': '\b',
      'tab': '\t',
      'space': ' '
    };
    /**
     * @add Syn prototype
     */
    h.extend(Syn.init.prototype, {
      /**
       * @function key
       * Types a single key.  The key should be
       * a string that matches a
       * [Syn.static.keycodes].
       *
       * The following sends a carridge return
       * to the 'name' element.
       * @codestart
       * Syn.key('\r','name')
       * @codeend
       * For each character, a keydown, keypress, and keyup is triggered if
       * appropriate.
       * @param {String} options
       * @param {HTMLElement} [element]
       * @param {Function} [callback]
       * @return {HTMLElement} the element currently focused.
       */
      _key: function (options, element, callback) {
        if (!element) {
          return;
        }
        //first check if it is a special up
        if (/-up$/.test(options) && h.inArray(options.replace('-up', ''), Syn.key.kinds.special) != -1) {
          Syn.trigger('keyup', options.replace('-up', ''), element);
          callback(true, element);
          return;
        }
        // keep reference to current activeElement
        // PATCH: INSERTED TRY CATCH
        var activeElement = null;
        try {
          activeElement = h.getWindow(element).document.activeElement;
        } catch (e) {
        }
        var caret = Syn.typeable.test(element.nodeName) && getSelection(element), key = convert[options] || options,
          // should we run default events
          runDefaults = Syn.trigger('keydown', key, element),
          // a function that gets the default behavior for a key
          getDefault = Syn.key.getDefault,
          // how this browser handles preventing default events
          prevent = Syn.key.browser.prevent,
          // the result of the default event
          defaultResult, keypressOptions = Syn.key.options(key, 'keypress');
        if (runDefaults) {
          //if the browser doesn't create keypresses for this key, run default
          if (!keypressOptions) {
            defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
          } else {
            //do keypress
            try {
              //PATCH: TRY CATCH
              // check if activeElement changed b/c someone called focus in keydown
              if (activeElement !== h.getWindow(element).document.activeElement) {
                element = h.getWindow(element).document.activeElement;
              }
            } catch (e) {
            }
            runDefaults = Syn.trigger('keypress', keypressOptions, element);
            if (runDefaults) {
              defaultResult = getDefault(key).call(element, keypressOptions, h.getWindow(element), key, undefined, caret);
            }
          }
        } else {
          //canceled ... possibly don't run keypress
          if (keypressOptions && h.inArray('keypress', prevent.keydown) == -1) {
            // check if activeElement changed b/c someone called focus in keydown
            if (activeElement !== h.getWindow(element).document.activeElement) {
              element = h.getWindow(element).document.activeElement;
            }
            Syn.trigger('keypress', keypressOptions, element);
          }
        }
        if (defaultResult && defaultResult.nodeName) {
          element = defaultResult;
        }
        if (defaultResult !== null) {
          setTimeout(function () {
            Syn.trigger('keyup', Syn.key.options(key, 'keyup'), element);
            callback(runDefaults, element);
          }, 1);
        } else {
          callback(runDefaults, element);
        }
        //do mouseup
        return element;  // is there a keypress? .. if not , run default
                         // yes -> did we prevent it?, if not run ...
      },
      /**
       * @function type
       * Types sequence of [Syn.key key actions].  Each
       * character is typed, one at a type.
       * Multi-character keys like 'left' should be
       * enclosed in square brackents.
       *
       * The following types 'JavaScript MVC' then deletes the space.
       * @codestart
       * Syn.type('JavaScript MVC[left][left][left]\b','name')
       * @codeend
       *
       * Type is able to handle (and move with) tabs (\t).
       * The following simulates tabing and entering values in a form and
       * eventually submitting the form.
       * @codestart
       * Syn.type("Justin\tMeyer\t27\tjustinbmeyer@gmail.com\r")
       * @codeend
       * @param {String} options the text to type
       * @param {HTMLElement} [element] an element or an id of an element
       * @param {Function} [callback] a function to callback
       */
      _type: function (options, element, callback) {
        //break it up into parts ...
        //go through each type and run
        var parts = options.match(/(\[[^\]]+\])|([^\[])/g), self = this, runNextPart = function (runDefaults, el) {
            var part = parts.shift();
            if (!part) {
              callback(runDefaults, el);
              return;
            }
            el = el || element;
            if (part.length > 1) {
              part = part.substr(1, part.length - 2);
            }
            self._key(part, el, runNextPart);
          };
        runNextPart();
      }
    });
    //do support code
    (function () {
      if (!document.body) {
        setTimeout(arguments.callee, 1);
        return;
      }
      var div = document.createElement('div'), checkbox, submit, form, input, submitted = false, anchor, textarea, inputter;
      div.innerHTML = '<form id=\'outer\'>' + '<input name=\'checkbox\' type=\'checkbox\'/>' + '<input name=\'radio\' type=\'radio\' />' + '<input type=\'submit\' name=\'submitter\'/>' + '<input type=\'input\' name=\'inputter\'/>' + '<input name=\'one\'>' + '<input name=\'two\'/>' + '<a href=\'#abc\'></a>' + '<textarea>1\n2</textarea>' + '</form>';
      document.documentElement.appendChild(div);
      form = div.firstChild;
      checkbox = form.childNodes[0];
      submit = form.childNodes[2];
      anchor = form.getElementsByTagName('a')[0];
      textarea = form.getElementsByTagName('textarea')[0];
      inputter = form.childNodes[3];
      function stopPropagation(evt) {
        if (evt.stopPropagation) {
          evt.stopPropagation();
        } else {
          evt.cancelBubble = true;
        }
      }
      inputter.onkeypress = stopPropagation;
      anchor.onkeypress = stopPropagation;
      form.onsubmit = function (ev) {
        if (ev.preventDefault)
          ev.preventDefault();
        S.support.keypressSubmits = true;
        ev.returnValue = false;
        return false;
      };
      // Firefox 4 won't write key events if the element isn't focused
      inputter.focus();
      Syn.trigger('keypress', '\r', inputter);
      Syn.trigger('keypress', 'a', inputter);
      S.support.keyCharacters = inputter.value == 'a';
      inputter.value = 'a';
      Syn.trigger('keypress', '\b', inputter);
      S.support.backspaceWorks = inputter.value == '';
      inputter.onchange = function () {
        S.support.focusChanges = true;
      };
      inputter.focus();
      Syn.trigger('keypress', 'a', inputter);
      form.childNodes[5].focus();
      // this will throw a change event
      Syn.trigger('keypress', 'b', inputter);
      S.support.keysOnNotFocused = inputter.value == 'ab';
      //test keypress \r on anchor submits
      S.bind(anchor, 'click', function (ev) {
        if (ev.preventDefault)
          ev.preventDefault();
        S.support.keypressOnAnchorClicks = true;
        ev.returnValue = false;
        return false;
      });
      Syn.trigger('keypress', '\r', anchor);
      S.support.textareaCarriage = textarea.value.length == 4;
      document.documentElement.removeChild(div);
      S.support.ready++;
    }());
    return Syn;
  }(synchronite_simulate_browsers, synchronite_micro_dom);
  dojo_NodeList_traverse = function (dquery, lang, array) {
    // module:
    //		dojo/NodeList-traverse
    /*=====
    return function(){
    	// summary:
    	//		Adds chainable methods to dojo/query() / NodeList instances for traversing the DOM
    };
    =====*/
    var NodeList = dquery.NodeList;
    lang.extend(NodeList, {
      _buildArrayFromCallback: function (callback) {
        // summary:
        //		builds a new array of possibly differing size based on the input list.
        //		Since the returned array is likely of different size than the input array,
        //		the array's map function cannot be used.
        var ary = [];
        for (var i = 0; i < this.length; i++) {
          var items = callback.call(this[i], this[i], ary);
          if (items) {
            ary = ary.concat(items);
          }
        }
        return ary;  //Array
      },
      _getUniqueAsNodeList: function (nodes) {
        // summary:
        //		given a list of nodes, make sure only unique
        //		elements are returned as our NodeList object.
        //		Does not call _stash().
        var ary = [];
        //Using for loop for better speed.
        for (var i = 0, node; node = nodes[i]; i++) {
          //Should be a faster way to do this. dojo/query has a private
          //_zip function that may be inspirational, but there are pathways
          //in query that force nozip?
          if (node.nodeType == 1 && array.indexOf(ary, node) == -1) {
            ary.push(node);
          }
        }
        return this._wrap(ary, null, this._NodeListCtor);  // dojo/NodeList
      },
      _getUniqueNodeListWithParent: function (nodes, query) {
        // summary:
        //		gets unique element nodes, filters them further
        //		with an optional query and then calls _stash to track parent NodeList.
        var ary = this._getUniqueAsNodeList(nodes);
        ary = query ? dquery._filterResult(ary, query) : ary;
        return ary._stash(this);  // dojo/NodeList
      },
      _getRelatedUniqueNodes: function (query, callback) {
        // summary:
        //		cycles over all the nodes and calls a callback
        //		to collect nodes for a possible inclusion in a result.
        //		The callback will get two args: callback(node, ary),
        //		where ary is the array being used to collect the nodes.
        return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  // dojo/NodeList
      },
      children: function (query) {
        // summary:
        //		Returns all immediate child elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the child elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all immediate child elements for the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".container").children();
        //	|	});
        //		returns the four divs that are children of the container div.
        //		Running this code:
        //	|	dojo.query(".container").children(".red");
        //		returns the two divs that have the class "red".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          return lang._toArray(node.childNodes);
        });  // dojo/NodeList
      },
      closest: function (query, root) {
        // summary:
        //		Returns closest parent that matches query, including current node in this
        //		dojo/NodeList if it matches the query.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // root:
        //		If specified, query is relative to "root" rather than document body.
        // returns:
        //		the closest parent that matches the query, including the current
        //		node in this dojo/NodeList if it matches the query.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        //	|		<div class="red">Red One</div>
        //	|		Some Text
        //	|		<div class="blue">Blue One</div>
        //	|		<div class="red">Red Two</div>
        //	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".red").closest(".container");
        //	|	});
        //		returns the div with class "container".
        return this._getRelatedUniqueNodes(null, function (node, ary) {
          do {
            if (dquery._filterResult([node], query, root).length) {
              return node;
            }
          } while (node != root && (node = node.parentNode) && node.nodeType == 1);
          return null;  //To make rhino strict checking happy.
        });  // dojo/NodeList
      },
      parent: function (query) {
        // summary:
        //		Returns immediate parent elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the parent elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		immediate parent elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first"><span class="text">Blue One</span></div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue"><span class="text">Blue Two</span></div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".text").parent();
        //	|	});
        //		returns the two divs with class "blue".
        //		Running this code:
        //	|		query(".text").parent(".first");
        //		returns the one div with class "blue" and "first".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          return node.parentNode;
        });  // dojo/NodeList
      },
      parents: function (query) {
        // summary:
        //		Returns all parent elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the child elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all parent elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first"><span class="text">Blue One</span></div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue"><span class="text">Blue Two</span></div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".text").parents();
        //	|	});
        //		returns the two divs with class "blue", the div with class "container",
        // 	|	the body element and the html element.
        //		Running this code:
        //	|		query(".text").parents(".container");
        //		returns the one div with class "container".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          while (node.parentNode) {
            node = node.parentNode;
            pary.push(node);
          }
          return pary;
        });  // dojo/NodeList
      },
      siblings: function (query) {
        // summary:
        //		Returns all sibling elements for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").siblings();
        //	|	});
        //		returns the two divs with class "red" and the other div
        // 	|	with class "blue" that does not have "first".
        //		Running this code:
        //	|		query(".first").siblings(".red");
        //		returns the two div with class "red".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var nodes = node.parentNode && node.parentNode.childNodes;
          for (var i = 0; i < nodes.length; i++) {
            if (nodes[i] != node) {
              pary.push(nodes[i]);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      next: function (query) {
        // summary:
        //		Returns the next element for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the next elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		the next element for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").next();
        //	|	});
        //		returns the div with class "red" and has innerHTML of "Red Two".
        //		Running this code:
        //	|	dojo.query(".last").next(".red");
        //		does not return any elements.
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var next = node.nextSibling;
          while (next && next.nodeType != 1) {
            next = next.nextSibling;
          }
          return next;
        });  // dojo/NodeList
      },
      nextAll: function (query) {
        // summary:
        //		Returns all sibling elements that come after the nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements that come after the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red next">Red Two</div>
        // 	|		<div class="blue next">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").nextAll();
        //	|	});
        //		returns the two divs with class of "next".
        //		Running this code:
        //	|		query(".first").nextAll(".red");
        //		returns the one div with class "red" and innerHTML "Red Two".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var next = node;
          while (next = next.nextSibling) {
            if (next.nodeType == 1) {
              pary.push(next);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      prev: function (query) {
        // summary:
        //		Returns the previous element for nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the previous elements.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		the previous element for nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".first").prev();
        //	|	});
        //		returns the div with class "red" and has innerHTML of "Red One".
        //		Running this code:
        //	|		query(".first").prev(".blue");
        //		does not return any elements.
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var prev = node.previousSibling;
          while (prev && prev.nodeType != 1) {
            prev = prev.previousSibling;
          }
          return prev;
        });  // dojo/NodeList
      },
      prevAll: function (query) {
        // summary:
        //		Returns all sibling elements that come before the nodes in this dojo/NodeList.
        //		Optionally takes a query to filter the sibling elements.
        // description:
        //		The returned nodes will be in reverse DOM order -- the first node in the list will
        //		be the node closest to the original node/NodeList.
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // query:
        //		a CSS selector.
        // returns:
        //		all sibling elements that come before the nodes in this dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red prev">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue prev">Blue One</div>
        // 	|		<div class="red second">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".second").prevAll();
        //	|	});
        //		returns the two divs with class of "prev".
        //		Running this code:
        //	|		query(".first").prevAll(".red");
        //		returns the one div with class "red prev" and innerHTML "Red One".
        return this._getRelatedUniqueNodes(query, function (node, ary) {
          var pary = [];
          var prev = node;
          while (prev = prev.previousSibling) {
            if (prev.nodeType == 1) {
              pary.push(prev);
            }
          }
          return pary;
        });  // dojo/NodeList
      },
      andSelf: function () {
        // summary:
        //		Adds the nodes from the previous dojo/NodeList to the current dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red prev">Red One</div>
        // 	|		Some Text
        // 	|		<div class="blue prev">Blue One</div>
        // 	|		<div class="red second">Red Two</div>
        // 	|		<div class="blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".second").prevAll().andSelf();
        //	|	});
        //		returns the two divs with class of "prev", as well as the div with class "second".
        return this.concat(this._parent);  // dojo/NodeList
      },
      //Alternate methods for the :first/:last/:even/:odd pseudos.
      first: function () {
        // summary:
        //		Returns the first node in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the first node in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".blue").first();
        //	|	});
        //		returns the div with class "blue" and "first".
        return this._wrap(this[0] && [this[0]] || [], this);  // dojo/NodeList
      },
      last: function () {
        // summary:
        //		Returns the last node in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the last node in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="red">Red One</div>
        // 	|		<div class="blue first">Blue One</div>
        // 	|		<div class="red">Red Two</div>
        // 	|		<div class="blue last">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|	query(".blue").last();
        //	|	});
        //		returns the last div with class "blue",
        return this._wrap(this.length ? [this[this.length - 1]] : [], this);  // dojo/NodeList
      },
      even: function () {
        // summary:
        //		Returns the even nodes in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the even nodes in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="interior red">Red One</div>
        // 	|		<div class="interior blue">Blue One</div>
        // 	|		<div class="interior red">Red Two</div>
        // 	|		<div class="interior blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".interior").even();
        //	|	});
        //		returns the two divs with class "blue"
        return this.filter(function (item, i) {
          return i % 2 != 0;
        });  // dojo/NodeList
      },
      odd: function () {
        // summary:
        //		Returns the odd nodes in this dojo/NodeList as a dojo/NodeList.
        // description:
        //		.end() can be used on the returned dojo/NodeList to get back to the
        //		original dojo/NodeList.
        // returns:
        //		the odd nodes in this dojo/NodeList
        // example:
        //		assume a DOM created by this markup:
        //	|	<div class="container">
        // 	|		<div class="interior red">Red One</div>
        // 	|		<div class="interior blue">Blue One</div>
        // 	|		<div class="interior red">Red Two</div>
        // 	|		<div class="interior blue">Blue Two</div>
        //	|	</div>
        //		Running this code:
        //	|	require(["dojo/query", "dojo/NodeList-traverse"
        //	|	], function(query){
        //	|		query(".interior").odd();
        //	|	});
        //		returns the two divs with class "red"
        return this.filter(function (item, i) {
          return i % 2 == 0;
        });  // dojo/NodeList
      }
    });
    return NodeList;
  }(dojo_query, dojo__base_lang, dojo__base_array);
  synchronite_simulate_drag_drag = function (Syn, NodeList) {
    // check if elementFromPageExists
    (function () {
      // document body has to exists for this test
      if (!document.body) {
        setTimeout(arguments.callee, 1);
        return;
      }
      var div = document.createElement('div');
      document.body.appendChild(div);
      Syn.helpers.extend(div.style, {
        width: '100px',
        height: '10000px',
        backgroundColor: 'white',
        //PATCHED TO BE MORE DECENT (BLUE)
        position: 'absolute',
        top: '10px',
        left: '0px',
        zIndex: 2147483647  //PATCHED: Max possible
      });
      document.body.scrollTop = 11;
      if (document.documentElement) {
        //PATCHED
        document.documentElement.scrollTop = 11;
      }
      // http://www.quirksmode.org/blog/archives/2010/06/more_ie9_goodne.html
      // can be either relative to viewport or to browser window
      if (!document.elementFromPoint) {
        return;
      }
      var el = document.elementFromPoint(3, 1);
      if (el == div) {
        Syn.support.elementFromClient = true;
      } else {
        Syn.support.elementFromPage = true;
      }
      document.body.removeChild(div);
      document.body.scrollTop = 0;
      if (document.documentElement) {
        document.documentElement.scrollTop = 0;
      }
    }());
    //gets an element from a point
    var elementFromPoint = function (point, element) {
        var clientX = point.clientX, clientY = point.clientY, win = Syn.helpers.getWindow(element), el;
        if (Syn.support.elementFromPage) {
          var off = Syn.helpers.scrollOffset(win);
          clientX = clientX + off.left;
          //convert to pageX
          clientY = clientY + off.top;  //convert to pageY
        }
        el = win.document.elementFromPoint ? win.document.elementFromPoint(clientX, clientY) : element;
        if (el === win.document.documentElement && (point.clientY < 0 || point.clientX < 0)) {
          return element;
        } else {
          return el;
        }
      },
      //creates an event at a certain point
      createEventAtPoint = function (event, point, element) {
        var el = elementFromPoint(point, element);
        Syn.trigger(event, point, el || element);
        return el;
      },
      // creates a mousemove event, but first triggering mouseout / mouseover if appropriate
      mouseMove = function (point, element, last) {
        var el = elementFromPoint(point, element);
        if (last != el && el && last) {
          var options = Syn.helpers.extend({}, point);
          options.relatedTarget = el;
          Syn.trigger('mouseout', options, last);
          options.relatedTarget = last;
          Syn.trigger('mouseover', options, el);
          //PATCH add pseudo classes
          try {
            var lastList = new NodeList(last).parents();
            lastList.push(last);
            lastList.removeClass('sn_ps_hover');
            var currentList = new NodeList(el).parents();
            currentList.push(el);
            currentList.addClass('sn_ps_hover');
          } catch (e) {
            console.warn('Error setting pseudo styles: ', e);
          }
        }
        // FF and Chrome automatically create pageX and pageY properties based on submitted
        // clientX and clientY values.
        // IE89 do NOT do this: http://yuilibrary.com/projects/yui3/ticket/2531581
        Syn.trigger('mousemove', point, el || element);
        return el;
      },
      // start and end are in clientX, clientY
      startMove = function (start, end, duration, element, callback) {
        var startTime = new Date(), distX = end.clientX - start.clientX, distY = end.clientY - start.clientY, win = Syn.helpers.getWindow(element), current = elementFromPoint(start, element), cursor, calls = 0;
        if (synchroniteConfig.isDebug) {
          // PATCH
          cursor = win.document.createElement('div');
        }
        move = function () {
          //get what fraction we are at
          var now = new Date(), scrollOffset = Syn.helpers.scrollOffset(win), fraction = (calls === 0 ? 0 : now - startTime) / duration, options = {
              clientX: distX * fraction + start.clientX,
              clientY: distY * fraction + start.clientY
            };
          calls++;
          if (fraction < 1) {
            if (synchroniteConfig.isDebug) {
              Syn.helpers.extend(cursor.style, {
                left: options.clientX + scrollOffset.left + 2 + 'px',
                top: options.clientY + scrollOffset.top + 2 + 'px'
              });
            }
            current = mouseMove(options, element, current);
            setTimeout(arguments.callee, 15);
          } else {
            current = mouseMove(end, element, current);
            if (synchroniteConfig.isDebug) {
              win.document.body.removeChild(cursor);
            }
            callback();
          }
        };
        // PATCH
        if (synchroniteConfig.isDebug) {
          Syn.helpers.extend(cursor.style, {
            height: '5px',
            width: '5px',
            backgroundColor: 'red',
            position: 'absolute',
            zIndex: 19999,
            fontSize: '1px'
          });
          win.document.body.appendChild(cursor);
        }
        move();
      }, startDrag = function (start, end, duration, element, callback) {
        createEventAtPoint('mousedown', start, element);
        startMove(start, end, duration, element, function () {
          createEventAtPoint('mouseup', end, element);
          callback();
        });
      }, center = function (el) {
        var j = Syn.jquery()(el), o = j.offset();
        return {
          pageX: o.left + j.outerWidth() / 2,
          pageY: o.top + j.outerHeight() / 2
        };
      }, convertOption = function (option, win, from) {
        var page = /(\d+)[x ](\d+)/, client = /(\d+)X(\d+)/, relative = /([+-]\d+)[xX ]([+-]\d+)/;
        //check relative "+22x-44"
        if (typeof option == 'string' && relative.test(option) && from) {
          var cent = center(from), parts = option.match(relative);
          option = {
            pageX: cent.pageX + parseInt(parts[1], 10),
            pageY: cent.pageY + parseInt(parts[2], 10)
          };
        }
        if (typeof option == 'string' && page.test(option)) {
          var parts = option.match(page);
          option = {
            pageX: parseInt(parts[1], 10),
            pageY: parseInt(parts[2], 10)
          };
        }
        if (typeof option == 'string' && client.test(option)) {
          var parts = option.match(client);
          option = {
            clientX: parseInt(parts[1], 10),
            clientY: parseInt(parts[2], 10)
          };
        }
        if (typeof option == 'string') {
          option = Syn.jquery()(option, win.document)[0];
        }
        if (option.nodeName) {
          option = center(option);
        }
        if (option.pageX) {
          var off = Syn.helpers.scrollOffset(win);
          option = {
            clientX: option.pageX - off.left,
            clientY: option.pageY - off.top
          };
        }
        return option;
      },
      // if the client chords are not going to be visible ... scroll the page so they will be ...
      adjust = function (from, to, win) {
        if (from.clientY < 0) {
          var off = Syn.helpers.scrollOffset(win);
          var dimensions = Syn.helpers.scrollDimensions(win), top = off.top + from.clientY - 100, diff = top - off.top;
          // first, lets see if we can scroll 100 px
          if (top > 0) {
          } else {
            top = 0;
            diff = -off.top;
          }
          from.clientY = from.clientY - diff;
          to.clientY = to.clientY - diff;
          Syn.helpers.scrollOffset(win, {
            top: top,
            left: off.left
          });  //throw "out of bounds!"
        }
      };
    /**
     * @add Syn prototype
     */
    Syn.helpers.extend(Syn.init.prototype, {
      /**
               * @function move
               * Moves the cursor from one point to another.
               *
               * ### Quick Example
               *
               * The following moves the cursor from (0,0) in
               * the window to (100,100) in 1 second.
               *
               *     Syn.move(
               *          {
               *            from: {clientX: 0, clientY: 0},
               *            to: {clientX: 100, clientY: 100},
               *            duration: 1000
               *          },
               *          document.document)
               *
               * ## Options
               *
               * There are many ways to configure the endpoints of the move.
               *
               * ### PageX and PageY
               *
               * If you pass pageX or pageY, these will get converted
               * to client coordinates.
               *
               *     Syn.move(
               *          {
               *            from: {pageX: 0, pageY: 0},
               *            to: {pageX: 100, pageY: 100}
               *          },
               *          document.document)
               *
               * ### String Coordinates
               *
               * You can set the pageX and pageY as strings like:
               *
               *     Syn.move(
               *          {
               *            from: "0x0",
               *            to: "100x100"
               *          },
               *          document.document)
               *
               * ### Element Coordinates
               *
               * If jQuery is present, you can pass an element as the from or to option
               * and the coordinate will be set as the center of the element.
      
               *     Syn.move(
               *          {
               *            from: $(".recipe")[0],
               *            to: $("#trash")[0]
               *          },
               *          document.document)
               *
               * ### Query Strings
               *
               * If jQuery is present, you can pass a query string as the from or to option.
               *
               * Syn.move(
               *      {
               *        from: ".recipe",
               *        to: "#trash"
               *      },
               *      document.document)
               *
               * ### No From
               *
               * If you don't provide a from, the element argument passed to Syn is used.
               *
               *     Syn.move(
               *          { to: "#trash" },
               *          'myrecipe')
               *
               * ### Relative
               *
               * You can move the drag relative to the center of the from element.
               *
               *     Syn.move("+20 +30", "myrecipe");
               *
               * @param {Object} options options to configure the drag
               * @param {HTMLElement} from the element to move
               * @param {Function} callback a callback that happens after the drag motion has completed
               */
      _move: function (options, from, callback) {
        //need to convert if elements
        var win = Syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
        options.adjust !== false && adjust(fro, to, win);
        startMove(fro, to, options.duration || 500, from, callback);
      },
      /**
       * @function drag
       * Creates a mousedown and drags from one point to another.
       * Check out [Syn.prototype.move move] for API details.
       *
       * @param {Object} options
       * @param {Object} from
       * @param {Object} callback
       */
      _drag: function (options, from, callback) {
        //need to convert if elements
        var win = Syn.helpers.getWindow(from), fro = convertOption(options.from || from, win, from), to = convertOption(options.to || options, win, from);
        options.adjust !== false && adjust(fro, to, win);
        startDrag(fro, to, options.duration || 500, from, callback);
      }
    });
    return Syn;
  }(synchronite_simulate_key, dojo_NodeList_traverse);
  synchronite_simulate = function (Syn, synchQuery, synchDom, dojoLang, dom, domGeom, mouse, goog) {
    /****************
     * PATCH MOUSE.JS
     *****************/
    ////////////
    //PATCH 1
    ////////////
    Syn.defaults.click = function () {
      // prevents the access denied issue in IE if the click causes the element to be destroyed
      var element = this;
      if (!synchDom.canAccessNode(element)) {
        return;
      }
      //get old values
      var radioChanged = Syn.data(element, 'radioChanged'), nodeName = element.nodeName.toLowerCase();
      //FIXED: scope will be renamed by shrinksafe so use short name.
      window.SCOPE_PROTECTED_FROM_CC = Syn.helpers.getWindow(element);
      //this code was for restoring the href attribute to prevent popup opening
      //if ((href = Syn.data(element, "href"))) {
      // element.setAttribute('href', href)
      //}
      //run href javascript
      if (!Syn.support.linkHrefJS && /^\s*javascript:/.test(element.href)) {
        //eval js
        //FIXED: There may be a space after the colon.
        var code = unescape(element.href).replace(/^\s*javascript:\s*/, '');
        //try{
        if (code != '//' && code.indexOf('void(0)') == -1) {
          if (window.selenium) {
            //noinspection JSHint
            eval('with(selenium.browserbot.getCurrentWindow()){' + code + '}');
          } else {
            //FIXED: scope will be renamed by shrinksafe so use short name.
            if (window.SCOPE_PROTECTED_FROM_CC) {
              //FIXED: scope s must be used or it will be removed by closure compiler
              //noinspection JSHint
              eval('with(SCOPE_PROTECTED_FROM_CC){' + code + '}');  // PATCHED
            } else {
              //noinspection JSHint
              eval(code);
            }
          }
        }
      }
      //submit a form
      // FIXED: In Chrome this leads to the button event handler
      //        being executed twice.
      // Reason was wrong logic in if statement
      // old: if (!(Syn.support.clickSubmits) && (nodeName == "input" && element.type == "submit") || nodeName == 'button') {
      if (!Syn.support.clickSubmits && (nodeName == 'input' && element.type == 'submit' || nodeName == 'button')) {
        var form = Syn.closest(element, 'form');
        if (form) {
          // FIXED: This submitting the form omits send the value of the button
          //        as a parameter: Syn.trigger("submit", {}, form);
          mouse.disableClickMonitoring();
          element.click();
          mouse.enableClickMonitoring();
        }
      }
      //follow a link, probably needs to check if in an a.
      try {
        if (!Syn.support.linkHrefJS && nodeName == 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
          //FIXED: scope may be redefined by target attribute
          var scope = synchQuery.getTargetWindow(element);
          if (scope) {
            scope.location.href = element.href;
          } else {
            //Happens when javascript unloads the window, before href is triggered
            console.warn('Window already unloaded when trying to trigger href');
          }
        }
      } catch (e) {
        console.warn('Should only happen in IE. Element is already destroyed.');
      }
      //change a checkbox
      if (nodeName == 'input' && element.type == 'checkbox') {
        //                if(!Syn.support.clickChecks && !Syn.support.changeChecks){
        //                    element.checked = !element.checked;
        //                }
        if (!Syn.support.clickChanges) {
          Syn.trigger('change', {}, element);
        }
      }
      //change a radio button
      if (nodeName == 'input' && element.type == 'radio') {
        // need to uncheck others if not checked
        //                if(!Syn.support.clickChecks && !Syn.support.changeChecks){
        //                    //do the checks manually
        //                    if(!element.checked){ //do nothing, no change
        //                        element.checked = true;
        //                    }
        //                }
        if (radioChanged && !Syn.support.radioClickChanges) {
          Syn.trigger('change', {}, element);
        }
      }
      // change options
      if (nodeName == 'option') {
        //FIXED: parentNode maybe optgroup tag not select
        var selectNode = Syn.closest(element, 'select');
        //PATCHED!
        if (Syn.data(selectNode, 'createChange')) {
          Syn.trigger('change', {}, selectNode);
          //does not bubble //PATCHED
          Syn.data(selectNode, 'createChange', false);
        }
      }
    };
    ////////////
    //PATCH 2
    ////////////
    Syn.create.click.setup = dojoLang.hitch(Syn.create.click, function (type, options, element) {
      var nodeName = element.nodeName.toLowerCase();
      //we need to manually 'check' in browser that can't check
      //so checked has the right value
      if (!Syn.support.clickChecks && !Syn.support.changeChecks && nodeName === 'input') {
        type = element.type.toLowerCase();
        //pretty sure lowercase isn't needed
        if (type === 'checkbox') {
          element.checked = !element.checked;
        }
        if (type === 'radio') {
          //do the checks manually
          if (!element.checked) {
            //do nothing, no change
            try {
              Syn.data(element, 'radioChanged', true);
            } catch (e) {
            }
            element.checked = true;
          }
        }
      }
      if (nodeName == 'a' && element.href && !/^\s*javascript:/.test(element.href)) {
        //save href
        Syn.data(element, 'href', element.href);  //remove b/c safari/opera will open a new tab instead of changing the page
                                                  // this has been removed because newer versions don't have this problem
                                                  //FIXED: Onclick event handlers might use href to open content in a lightbox.
                                                  //element.setAttribute('href', 'javascript://')
                                                  //however this breaks scripts using the href
                                                  //we need to listen to this and prevent the default behavior
                                                  //and run the default behavior ourselves. Boo!
      }
      //if select or option, save old value and mark to change
      if (/option/i.test(element.nodeName)) {
        //PATCHED
        //FIXED: parentNode maybe optgroup tag not select
        var selectNode = element.parentNode, i = -1;
        while (selectNode.nodeName.toLowerCase() != 'select') {
          selectNode = selectNode.parentNode;
        }
        //END FIX
        // Get the index of the option to select
        //var child = element.parentNode.firstChild,
        if (element.index || element.index === 0) {
          i = element.index;
        } else {
          var opts = selectNode.options;
          for (var j = 0; j < opts.length; j++) {
            if (opts[j].nodeType == 1) {
              if (opts[j].value == element.value) {
                break;
              }
              j++;
            }
          }
        }
        //if (i !== selectNode.selectedIndex) {
        if (selectNode.multiple && (options.ctrlKey || options.metaKey)) {
          element.selected = typeof options.selected != 'undefined' ? options.selected : true;
        } else if (i !== selectNode.selectedIndex) {
          //shouldn't this wait on triggering
          //change?
          selectNode.selectedIndex = i;
        }
        console.info('createChange=TRUE');
        Syn.data(selectNode, 'createChange', true);
      }
    });
    /********************
     * PATCH SYNTHETIC.JS
     *********************/
    ///////////////////////
    // PATCH 3
    //////////////////////
    function _synchroniteDispatch(event, element, type, autoPrevent) {
      //console.info("Syn.dispatch(" + event + ", "+  element.nodeName + ", " + type);
      var bind = function (el, ev, f) {
          return el.addEventListener ? el.addEventListener(ev, f, false) : el.attachEvent('on' + ev, f);
        }, unbind = function (el, ev, f) {
          return el.addEventListener ? el.removeEventListener(ev, f, false) : el.detachEvent('on' + ev, f);
        };
      // dispatchEvent doesn't always work in IE (mostly in a popup)
      if (element.dispatchEvent && event) {
        var preventDefault = event.preventDefault, prevents = autoPrevent ? -1 : 0;
        //automatically prevents the default behavior for this event
        //this is to protect agianst nasty browser freezing bug in safari
        if (autoPrevent) {
          bind(element, type, function (ev) {
            // console.info("Syn.dispatch: event.peventDefault();");
            ev.preventDefault();
            //noinspection JSHint
            unbind(this, type, arguments.callee);
          });
        }
        event.preventDefault = function () {
          prevents++;
          if (++prevents > 0) {
            preventDefault.apply(this, []);
          }
        };
        //FIXED: need to take returnValue of dispatch into account
        // ==> return false; => prevent default
        //MDC: The return value is false if at least one of the event
        //     handlers which handled this event called preventDefault.
        //     Otherwise it returns true.
        // https://developer.mozilla.org/en/DOM/element.dispatchEvent
        try {
          //var returnValue = element.dispatchEvent(event);
          element.dispatchEvent(event);  //console.debug("dispatchEvent return value: " + returnValue);
        } catch (e) {
          console.warn('Error dispatching event: ' + event.type);
        }
        // Returns a boolean indicating whether or not
        // event.preventDefault() was called on the event.
        //event.defaultPrevented
        var isDefaultPrevented = event.defaultPrevented || event.returnValue === false || event.getPreventDefault && event.getPreventDefault() ? true : false;
        //console.debug("defaultPrevented: " + isDefaultPrevented);
        return prevents <= 0 && !isDefaultPrevented;
      } else {
        try {
          window.event = event;
        } catch (e) {
        }
        // PATCH START: Element might be in iframe
        try {
          var activeWin = Syn.helpers.getWindow(element);
          activeWin.event = event;
        } catch (e) {
        }
        //source element makes sure element is still in the document
        return element.sourceIndex <= 0 || element.fireEvent && element.fireEvent('on' + type, event);
      }
    }
    // Trick to keep the name of the function, after google closure compiler has
    // obfuscated it.
    //var exportedSynchroniteDispatch = goog.keepFunctionName("synchroniteDispatch", _synchroniteDispatch);
    Syn.dispatch = dojoLang.hitch(Syn, _synchroniteDispatch);
    //    center = function( el ) {
    //        var j = Syn.jquery()(el),
    //        o = j.offset();
    //        return {
    //            pageX: o.left + (j.outerWidth() / 2),
    //            pageY: o.top + (j.outerHeight() / 2)
    //        }
    //    }
    //            addOffset: function( options, el ) {
    //                var jq = Syn.jquery(el),
    //                off;
    //                if ( typeof options === 'object' && options.clientX === undefined && options.clientY === undefined && options.pageX === undefined && options.pageY === undefined && jq ) {
    //                    el = jq(el);
    //                    off = el.offset();
    //                    options.pageX = off.left + el.width() / 2;
    //                    options.pageY = off.top + el.height() / 2;
    //                }
    //            }
    ////////////////////////////
    // PATCH 4
    ////////////////////////////
    Syn.jquery = dojoLang.hitch(Syn, function () {
      return function (el) {
        if (el) {
          var pos = domGeom.position(el);
          var contentBox = domGeom.getContentBox(el);
          return {
            offset: function () {
              return {
                left: pos.x,
                top: pos.y
              };
            },
            outerHeight: function () {
              return pos.h;
            },
            outerWidth: function () {
              return pos.w;
            },
            width: function () {
              return contentBox.w;
            },
            height: function () {
              return contentBox.h;
            }
          };
        }
      };
    });
    ///////////////////////
    // PATCH 5
    //////////////////////
    Syn.create.key.options = dojoLang.hitch(Syn.create.key, function (type, options, element) {
      console.debug('Syn.create.key.options - ' + element);
      //check if options is character or has character
      options = typeof options != 'object' ? { character: options } : options;
      //don't change the orignial
      options = Syn.helpers.extend({}, options);
      if (options.character) {
        Syn.helpers.extend(options, Syn.key.options(options.character, type));
        delete options.character;
      }
      options = Syn.helpers.extend({
        ctrlKey: !!Syn.key.ctrlKey,
        altKey: !!Syn.key.altKey,
        shiftKey: !!Syn.key.shiftKey,
        metaKey: !!Syn.key.metaKey,
        screenX: 1,
        //PATCH: set screenX, screenY so synthetic events can be detected.
        screenY: 1
      }, options);
      return options;
    });
    /////////////////////
    // PATCH 6
    ///////////////////
    Syn.key.options = dojoLang.hitch(Syn.key, function (key, event) {
      var keyData = Syn.key.data(key);
      if (!keyData[event]) {
        //we shouldn't be creating this event
        return null;
      }
      var charCode = keyData[event][0], keyCode = keyData[event][1], result = {};
      if (keyCode == 'key') {
        result.keyCode = Syn.keycodes[key];
        // PATCH
        if (!result.keyCode) {
          result.keyCode = key.charCodeAt(0);
        }
      } else if (keyCode == 'char') {
        result.keyCode = key.charCodeAt(0);
      } else {
        result.keyCode = keyCode;
      }
      if (charCode == 'char') {
        result.charCode = key.charCodeAt(0);
      } else if (charCode !== null) {
        result.charCode = charCode;
      }
      // all current browsers have which property to normalize keyCode/charCode
      if (result.keyCode) {
        result.which = result.keyCode;
      } else {
        result.which = result.charCode;
      }
      return result;
    });
    return Syn;
  }(synchronite_simulate_drag_drag, synchronite__base_query, synchronite_micro_dom, dojo__base_lang, dojo_dom, dojo_dom_geometry, synchronite_events_mouse, synchronite__base_goog);
  synchronite_proxyless_eventreplicator = function (utils, constants, datachannel, requestDomRetry, domReplicator, domCommon, uwcommon, uwReplicator, ui, participantNotification, query, has, domGeom, synchQuery, synchUrl, Evented, baseArray, scroll, mouse, focus, keyboard, resize, profiles, Syn) {
    var remoteEvents = new Evented(), config = synchroniteConfig;
    var processNodes = function (msg) {
      var movedOrAdded = msg.args && msg.args[1];
      if (movedOrAdded && movedOrAdded.length) {
        var mirror = domReplicator.getTreeMirror(msg.frame);
        if (typeof mirror === 'undefined') {
          return;
        }
        setTimeout(function () {
          var requestStateRequired = false;
          baseArray.forEach(movedOrAdded, function (data) {
            if (/div|ul|tbody/i.test(data.tagName)) {
              var node = mirror.idMap[data.id];
              if (node) {
                var nodeDoc = node.ownerDocument, nodeWindow = nodeDoc.defaultView || nodeDoc.parentWindow;
                utils.listenToScrollableNodes(nodeWindow);  // SLAVE: re-attach scroll listeners for scrollable divs
              }
            } else if (!requestStateRequired && /input/i.test(data.tagName)) {
              requestStateRequired = true;
            } else if (/iframe/i.test(data.tagName)) {
              ui.updateBlockedContentWarning();
            }
          });
          if (requestStateRequired) {
            utils.requestState(datachannel, true);
          }
        }, 1);
      }
    };
    var EventReplicator = {
      remoteEvents: remoteEvents,
      domChangeHandler: {
        type: constants.EVENT.DOM,
        handleMessage: function (msg) {
          remoteEvents.emit(msg.type, msg);
          //reattach listeners
          if (msg.type === domCommon.DOM_FRAME_INITIALIZE) {
            var frame = synchQuery.queryFrame(msg.target);
            scroll.startListening(frame);
            focus.listenToScroll(frame);
            mouse.startListening(frame.document);
            keyboard.startListening(frame.document);
            requestDomRetry.stopRetry();
            ui.removeNoDomErrorTimeout();
            ui.hideLoadingOverlay();
            utils.protectFields(frame.document);
            focus.hideOverlay();
            setTimeout(function () {
              ui.updateBlockedContentWarning();
            }, 1);
          }
          if (msg.type === domCommon.DOM_CHANGE) {
            processNodes(msg);
          }
        }
      },
      textContentHandler: {
        type: constants.EVENT.TEXTCONTENT,
        handleMessage: function (msg) {
          var element = synchQuery.queryElement(msg.target);
          setTimeout(function () {
            if (element && typeof element.textContent !== 'undefined') {
              element.textContent = msg.value;
            }
          }, 50);
        }
      },
      fullStateHandler: {
        type: constants.EVENT.STATE,
        handleMessage: function (msg) {
          console.log('handle full state');
          msg.forEach(function (element) {
            var singleMessage = { data: element };
            datachannel.handleMessage(singleMessage);
          });
        }
      },
      mouseClickHandler: {
        type: constants.EVENT.MOUSE,
        handleMessage: function (msg) {
          if (!config.isSlave && msg.cssSelector.windowName === constants.cobrowsingFrameName) {
            msg.cssSelector.windowName = null;
            msg.cssSelector.frame = null;
          }
          mouse.remote.emit(mouse.type.CLICK, msg);
          if (!config.isSlave) {
            // A click might update some form fields so we need to synchronize the state again
            // it's difficult to know when to send the state of input fields since the update of the fields
            // can be asynchronous. We call the first synchronize after 100ms and a second one after 1s.
            setTimeout(function () {
              utils.sendState(datachannel);
              utils.sendState(datachannel);  // intentionally called twice to send state a second time after 1 s
            }, 101);
          }
        }
      },
      uwHandler: {
        //state of unified window
        type: constants.EVENT.UWSTATE,
        handleMessage: function (msg) {
          uwReplicator.remote.emit(msg);
        }
      },
      resizeHandler: {
        type: constants.EVENT.RESIZE,
        handleMessage: function (msg) {
          resize.remote.emit(resize.type, msg);
        }
      },
      selectHandler: {
        type: constants.EVENT.SELECT,
        handleMessage: function (msg) {
          if (config.isSlave && msg.cssSelector && msg.cssSelector.windowName === 'presenterWindow') {
            msg.cssSelector.windowName = 'dislayContent';
          }
          mouse.remote.emit(mouse.type.SELECT, msg);
        }
      },
      restrictedPageHandler: {
        type: constants.EVENT.RESTRICTEDPAGE,
        handleMessage: function () {
          console.log('Visitor on restricted page. Show info message');
          ui.showRestrictedPageMessage();
          ui.removeNoDomErrorTimeout();
          resize.resetMobileOverlay();
          requestDomRetry.stopRetry();
          //handlers
          mouse.tearDown(false);
          scroll.tearDown();
          keyboard.tearDown();
          resize.setDefaultSize();
        }
      },
      elementvalueHandlerMaster: {
        type: constants.EVENT.ELEMENTVALUE,
        handleMessage: function (msg) {
          if (!msg.target) {
            console.warn('Received message with null target ' + JSON.stringify(msg));
            return;
          }
          if (msg.target.windowName === constants.cobrowsingFrameName) {
            msg.target.windowName = null;
            msg.target.frame = null;
          }
          var element = synchQuery.queryElement(msg.target);
          if (!element.getAttribute('data-protected')) {
            element.value = msg.value;
            utils.sendState(datachannel);
          }
        }
      },
      keyboardHandler: {
        type: constants.EVENT.KEYBOARD,
        handleMessage: function (msg) {
          if (config.isSlave && msg.cssSelector.windowName === 'presenterWindow') {
            msg.cssSelector.windowName = 'dislayContent';
          }
          keyboard.remote.emit(keyboard.type, msg);
        }
      },
      scrollHandler: {
        type: constants.EVENT.SCROLL,
        handleMessage: function (msg) {
          scroll.remote.emit('scroll', msg);
        }
      },
      isLoadingHandler: {
        type: constants.EVENT.LOADING,
        handleMessage: function (msg) {
          if (msg.begin === true) {
            ui.showLoadingOverlay();
          } else {
            ui.hideLoadingOverlay();
          }
        }
      },
      elementvalueHandler: {
        type: constants.EVENT.ELEMENTVALUE,
        handleMessage: function (msg) {
          if (config.isSlave && msg && msg.target.windowName === 'presenterWindow') {
            msg.target.frameName = 'displayContent';
          }
          var element = synchQuery.queryElement(msg.target);
          if (element) {
            /* IE9 throws exception when calling document.activeElement, so we exclude it here */
            if (has('ie') !== 9 && element.type === 'text' && element === element.ownerDocument.activeElement) {
              return;
            }
            element.value = msg.value;
            element.checked = msg.checked;
          }
        }
      },
      canvasHandler: {
        type: constants.EVENT.CANVAS,
        handleMessage: function (msg) {
          msg.target.frameName = constants.cobrowsingFrameName;
          var ctx = synchQuery.queryElement(msg.target).getContext('2d');
          var img = new Image();
          img.onload = function () {
            ctx.drawImage(img, 0, 0);
          };
          img.src = msg.value;
        }
      },
      mouseMoveHandler: {
        type: constants.EVENT.MOUSEMOVE,
        handleMessage: function (msg) {
          if (config.isSlave && msg.cssSelector.windowName === 'presenterWindow') {
            msg.cssSelector.windowName = 'dislayContent';
          } else if (!config.isSlave) {
            if (msg.cssSelector.windowName === constants.cobrowsingFrameName) {
              msg.cssSelector.windowName = null;
              msg.cssSelector.frame = null;
            }
          }
          mouse.remote.emit(mouse.type.MOVE, msg);
        }
      },
      focusHandler: {
        type: constants.EVENT.FOCUS,
        handleMessage: function (msg) {
          focus.remote.emit(focus.type, msg);
        }
      },
      customerSatisfactionHandler: {
        type: constants.EVENT.CSAT,
        handleMessage: function () {
          ui.showCSat();
        }
      },
      heartbeatHandler: {
        type: constants.EVENT.HEARTBEAT,
        handleMessage: function (msg) {
          participantNotification.handleHeartbeat(msg);
        }
      },
      startReplicatingSlave: function () {
        var cobrowseWindow = document.getElementById(constants.cobrowsingFrameName).contentWindow;
        domReplicator.startReplicating({
          remoteEvents: remoteEvents,
          window: cobrowseWindow,
          rewriteCss: true,
          rewriteSrc: true
        });
        var activeProfile = profiles.config[config.defaultSupportProfile];
        scroll.configure({ profile: activeProfile });
        scroll.startReplicating();
        mouse.configure({
          profile: activeProfile,
          Syn: Syn,
          store: participantNotification
        });
        mouse.startReplicating();
        keyboard.configure({
          profile: activeProfile,
          Syn: Syn
        });
        keyboard.startReplicating();
        uwReplicator.startReplicating();
        resize.configure({ profile: activeProfile });
        resize.startReplicating();
        focus.configure({
          store: participantNotification,
          userId: datachannel.getUserId()
        });
        focus.startReplicating();  //annotations.startReplicating();
      },
      startReplicatingMaster: function () {
        var activeProfile = profiles.config.presenter;
        scroll.configure({ profile: activeProfile });
        scroll.startReplicating();
        mouse.configure({
          profile: activeProfile,
          Syn: Syn,
          store: participantNotification
        });
        mouse.startReplicating();
        keyboard.configure({
          profile: activeProfile,
          Syn: Syn
        });
        keyboard.startReplicating();  //annotations.startReplicating();
      }
    };
    return EventReplicator;
  }(synchronite_proxyless_utils, synchronite_constants_constants, synchronite_proxyless_datachannel, synchronite_proxyless_requestDomRetry, synchronite_proxyless_dom_replicator, synchronite_proxyless_dom_common, synchronite_proxyless_unifiedWindowState_common, synchronite_proxyless_unifiedWindowState_replicator, synchronite_proxyless_ui, synchronite_proxyless_participantNotification, dojo_query, dojo_has, dojo_dom_geometry, synchronite__base_query, synchronite__base_url, dojo_Evented, dojo__base_array, synchronite_events_scroll, synchronite_events_mouse, synchronite_events_focus, synchronite_events_keyboard, synchronite_events_resize, synchronite_config_profiles, synchronite_simulate);
  dojo_topic = function (Evented) {
    // module:
    //		dojo/topic
    var hub = new Evented();
    return {
      // summary:
      //		Pubsub hub.
      // example:
      //		| 	topic.subscribe("some/topic", function(event){
      //		|	... do something with event
      //		|	});
      //		|	topic.publish("some/topic", {name:"some event", ...});
      publish: function (topic, event) {
        // summary:
        //		Publishes a message to a topic on the pub/sub hub. All arguments after
        //		the first will be passed to the subscribers, so any number of arguments
        //		can be provided (not just event).
        // topic: String
        //		The name of the topic to publish to
        // event: Object
        //		An event to distribute to the topic listeners
        return hub.emit.apply(hub, arguments);
      },
      subscribe: function (topic, listener) {
        // summary:
        //		Subscribes to a topic on the pub/sub hub
        // topic: String
        //		The topic to subscribe to
        // listener: Function
        //		A function to call when a message is published to the given topic
        return hub.on.apply(hub, arguments);
      }
    };
  }(dojo_Evented);
  dojo_keys = function (dojo, has) {
    // module:
    //		dojo/keys
    return dojo.keys = {
      // summary:
      //		Definitions for common key values.  Client code should test keyCode against these named constants,
      //		as the actual codes can vary by browser.
      BACKSPACE: 8,
      TAB: 9,
      CLEAR: 12,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      META: has('webkit') ? 91 : 224,
      // the apple key on macs
      PAUSE: 19,
      CAPS_LOCK: 20,
      ESCAPE: 27,
      SPACE: 32,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      LEFT_ARROW: 37,
      UP_ARROW: 38,
      RIGHT_ARROW: 39,
      DOWN_ARROW: 40,
      INSERT: 45,
      DELETE: 46,
      HELP: 47,
      LEFT_WINDOW: 91,
      RIGHT_WINDOW: 92,
      SELECT: 93,
      NUMPAD_0: 96,
      NUMPAD_1: 97,
      NUMPAD_2: 98,
      NUMPAD_3: 99,
      NUMPAD_4: 100,
      NUMPAD_5: 101,
      NUMPAD_6: 102,
      NUMPAD_7: 103,
      NUMPAD_8: 104,
      NUMPAD_9: 105,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_PLUS: 107,
      NUMPAD_ENTER: 108,
      NUMPAD_MINUS: 109,
      NUMPAD_PERIOD: 110,
      NUMPAD_DIVIDE: 111,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123,
      F13: 124,
      F14: 125,
      F15: 126,
      NUM_LOCK: 144,
      SCROLL_LOCK: 145,
      UP_DPAD: 175,
      DOWN_DPAD: 176,
      LEFT_DPAD: 177,
      RIGHT_DPAD: 178,
      // virtual key mapping
      copyKey: has('mac') && !has('air') ? has('safari') ? 91 : 224 : 17
    };
  }(dojo__base_kernel, dojo_sniff);
  dojo__base_connect = function (dojo, on, hub, aspect, eventModule, mouse, has, lang) {
    // module:
    //		dojo/_base/connect
    has.add('events-keypress-typed', function () {
      // keypresses should only occur a printable character is hit
      var testKeyEvent = { charCode: 0 };
      try {
        testKeyEvent = document.createEvent('KeyboardEvent');
        (testKeyEvent.initKeyboardEvent || testKeyEvent.initKeyEvent).call(testKeyEvent, 'keypress', true, true, null, false, false, false, false, 9, 3);
      } catch (e) {
      }
      return testKeyEvent.charCode == 0 && !has('opera');
    });
    function connect_(obj, event, context, method, dontFix) {
      method = lang.hitch(context, method);
      if (!obj || !(obj.addEventListener || obj.attachEvent)) {
        // it is a not a DOM node and we are using the dojo.connect style of treating a
        // method like an event, must go right to aspect
        return aspect.after(obj || dojo.global, event, method, true);
      }
      if (typeof event == 'string' && event.substring(0, 2) == 'on') {
        event = event.substring(2);
      }
      if (!obj) {
        obj = dojo.global;
      }
      if (!dontFix) {
        switch (event) {
        // dojo.connect has special handling for these event types
        case 'keypress':
          event = keypress;
          break;
        case 'mouseenter':
          event = mouse.enter;
          break;
        case 'mouseleave':
          event = mouse.leave;
          break;
        }
      }
      return on(obj, event, method, dontFix);
    }
    var _punctMap = {
      106: 42,
      111: 47,
      186: 59,
      187: 43,
      188: 44,
      189: 45,
      190: 46,
      191: 47,
      192: 96,
      219: 91,
      220: 92,
      221: 93,
      222: 39,
      229: 113
    };
    var evtCopyKey = has('mac') ? 'metaKey' : 'ctrlKey';
    var _synthesizeEvent = function (evt, props) {
      var faux = lang.mixin({}, evt, props);
      setKeyChar(faux);
      // FIXME: would prefer to use lang.hitch: lang.hitch(evt, evt.preventDefault);
      // but it throws an error when preventDefault is invoked on Safari
      // does Event.preventDefault not support "apply" on Safari?
      faux.preventDefault = function () {
        evt.preventDefault();
      };
      faux.stopPropagation = function () {
        evt.stopPropagation();
      };
      return faux;
    };
    function setKeyChar(evt) {
      evt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';
      evt.charOrCode = evt.keyChar || evt.keyCode;
    }
    var keypress;
    if (has('events-keypress-typed')) {
      // this emulates Firefox's keypress behavior where every keydown can correspond to a keypress
      var _trySetKeyCode = function (e, code) {
        try {
          // squelch errors when keyCode is read-only
          // (e.g. if keyCode is ctrl or shift)
          return e.keyCode = code;
        } catch (e) {
          return 0;
        }
      };
      keypress = function (object, listener) {
        var keydownSignal = on(object, 'keydown', function (evt) {
          // munge key/charCode
          var k = evt.keyCode;
          // These are Windows Virtual Key Codes
          // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/WinUI/WindowsUserInterface/UserInput/VirtualKeyCodes.asp
          var unprintable = k != 13 && k != 32 && (k != 27 || !has('ie')) && (k < 48 || k > 90) && (k < 96 || k > 111) && (k < 186 || k > 192) && (k < 219 || k > 222) && k != 229;
          // synthesize keypress for most unprintables and CTRL-keys
          if (unprintable || evt.ctrlKey) {
            var c = unprintable ? 0 : k;
            if (evt.ctrlKey) {
              if (k == 3 || k == 13) {
                return listener.call(evt.currentTarget, evt);  // IE will post CTRL-BREAK, CTRL-ENTER as keypress natively
              } else if (c > 95 && c < 106) {
                c -= 48;  // map CTRL-[numpad 0-9] to ASCII
              } else if (!evt.shiftKey && (c >= 65 && c <= 90)) {
                c += 32;  // map CTRL-[A-Z] to lowercase
              } else {
                c = _punctMap[c] || c;  // map other problematic CTRL combinations to ASCII
              }
            }
            // simulate a keypress event
            var faux = _synthesizeEvent(evt, {
              type: 'keypress',
              faux: true,
              charCode: c
            });
            listener.call(evt.currentTarget, faux);
            if (has('ie')) {
              _trySetKeyCode(evt, faux.keyCode);
            }
          }
        });
        var keypressSignal = on(object, 'keypress', function (evt) {
          var c = evt.charCode;
          c = c >= 32 ? c : 0;
          evt = _synthesizeEvent(evt, {
            charCode: c,
            faux: true
          });
          return listener.call(this, evt);
        });
        return {
          remove: function () {
            keydownSignal.remove();
            keypressSignal.remove();
          }
        };
      };
    } else {
      if (has('opera')) {
        keypress = function (object, listener) {
          return on(object, 'keypress', function (evt) {
            var c = evt.which;
            if (c == 3) {
              c = 99;  // Mozilla maps CTRL-BREAK to CTRL-c
            }
            // can't trap some keys at all, like INSERT and DELETE
            // there is no differentiating info between DELETE and ".", or INSERT and "-"
            c = c < 32 && !evt.shiftKey ? 0 : c;
            if (evt.ctrlKey && !evt.shiftKey && c >= 65 && c <= 90) {
              // lowercase CTRL-[A-Z] keys
              c += 32;
            }
            return listener.call(this, _synthesizeEvent(evt, { charCode: c }));
          });
        };
      } else {
        keypress = function (object, listener) {
          return on(object, 'keypress', function (evt) {
            setKeyChar(evt);
            return listener.call(this, evt);
          });
        };
      }
    }
    var connect = {
      // summary:
      //		This module defines the dojo.connect API.
      //		This modules also provides keyboard event handling helpers.
      //		This module exports an extension event for emulating Firefox's keypress handling.
      //		However, this extension event exists primarily for backwards compatibility and
      //		is not recommended. WebKit and IE uses an alternate keypress handling (only
      //		firing for printable characters, to distinguish from keydown events), and most
      //		consider the WebKit/IE behavior more desirable.
      _keypress: keypress,
      connect: function (obj, event, context, method, dontFix) {
        // summary:
        //		`dojo.connect` is a deprecated event handling and delegation method in
        //		Dojo. It allows one function to "listen in" on the execution of
        //		any other, triggering the second whenever the first is called. Many
        //		listeners may be attached to a function, and source functions may
        //		be either regular function calls or DOM events.
        //
        // description:
        //		Connects listeners to actions, so that after event fires, a
        //		listener is called with the same arguments passed to the original
        //		function.
        //
        //		Since `dojo.connect` allows the source of events to be either a
        //		"regular" JavaScript function or a DOM event, it provides a uniform
        //		interface for listening to all the types of events that an
        //		application is likely to deal with though a single, unified
        //		interface. DOM programmers may want to think of it as
        //		"addEventListener for everything and anything".
        //
        //		When setting up a connection, the `event` parameter must be a
        //		string that is the name of the method/event to be listened for. If
        //		`obj` is null, `kernel.global` is assumed, meaning that connections
        //		to global methods are supported but also that you may inadvertently
        //		connect to a global by passing an incorrect object name or invalid
        //		reference.
        //
        //		`dojo.connect` generally is forgiving. If you pass the name of a
        //		function or method that does not yet exist on `obj`, connect will
        //		not fail, but will instead set up a stub method. Similarly, null
        //		arguments may simply be omitted such that fewer than 4 arguments
        //		may be required to set up a connection See the examples for details.
        //
        //		The return value is a handle that is needed to
        //		remove this connection with `dojo.disconnect`.
        //
        // obj: Object?
        //		The source object for the event function.
        //		Defaults to `kernel.global` if null.
        //		If obj is a DOM node, the connection is delegated
        //		to the DOM event manager (unless dontFix is true).
        //
        // event: String
        //		String name of the event function in obj.
        //		I.e. identifies a property `obj[event]`.
        //
        // context: Object|null
        //		The object that method will receive as "this".
        //
        //		If context is null and method is a function, then method
        //		inherits the context of event.
        //
        //		If method is a string then context must be the source
        //		object object for method (context[method]). If context is null,
        //		kernel.global is used.
        //
        // method: String|Function
        //		A function reference, or name of a function in context.
        //		The function identified by method fires after event does.
        //		method receives the same arguments as the event.
        //		See context argument comments for information on method's scope.
        //
        // dontFix: Boolean?
        //		If obj is a DOM node, set dontFix to true to prevent delegation
        //		of this connection to the DOM event manager.
        //
        // example:
        //		When obj.onchange(), do ui.update():
        //	|	dojo.connect(obj, "onchange", ui, "update");
        //	|	dojo.connect(obj, "onchange", ui, ui.update); // same
        //
        // example:
        //		Using return value for disconnect:
        //	|	var link = dojo.connect(obj, "onchange", ui, "update");
        //	|	...
        //	|	dojo.disconnect(link);
        //
        // example:
        //		When onglobalevent executes, watcher.handler is invoked:
        //	|	dojo.connect(null, "onglobalevent", watcher, "handler");
        //
        // example:
        //		When ob.onCustomEvent executes, customEventHandler is invoked:
        //	|	dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
        //	|	dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same
        //
        // example:
        //		When ob.onCustomEvent executes, customEventHandler is invoked
        //		with the same scope (this):
        //	|	dojo.connect(ob, "onCustomEvent", null, customEventHandler);
        //	|	dojo.connect(ob, "onCustomEvent", customEventHandler); // same
        //
        // example:
        //		When globalEvent executes, globalHandler is invoked
        //		with the same scope (this):
        //	|	dojo.connect(null, "globalEvent", null, globalHandler);
        //	|	dojo.connect("globalEvent", globalHandler); // same
        // normalize arguments
        var a = arguments, args = [], i = 0;
        // if a[0] is a String, obj was omitted
        args.push(typeof a[0] == 'string' ? null : a[i++], a[i++]);
        // if the arg-after-next is a String or Function, context was NOT omitted
        var a1 = a[i + 1];
        args.push(typeof a1 == 'string' || typeof a1 == 'function' ? a[i++] : null, a[i++]);
        // absorb any additional arguments
        for (var l = a.length; i < l; i++) {
          args.push(a[i]);
        }
        return connect_.apply(this, args);
      },
      disconnect: function (handle) {
        // summary:
        //		Remove a link created by dojo.connect.
        // description:
        //		Removes the connection between event and the method referenced by handle.
        // handle: Handle
        //		the return value of the dojo.connect call that created the connection.
        if (handle) {
          handle.remove();
        }
      },
      subscribe: function (topic, context, method) {
        // summary:
        //		Attach a listener to a named topic. The listener function is invoked whenever the
        //		named topic is published (see: dojo.publish).
        //		Returns a handle which is needed to unsubscribe this listener.
        // topic: String
        //		The topic to which to subscribe.
        // context: Object?
        //		Scope in which method will be invoked, or null for default scope.
        // method: String|Function
        //		The name of a function in context, or a function reference. This is the function that
        //		is invoked when topic is published.
        // example:
        //	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); });
        //	|	dojo.publish("alerts", [ "read this", "hello world" ]);
        return hub.subscribe(topic, lang.hitch(context, method));
      },
      publish: function (topic, args) {
        // summary:
        //		Invoke all listener method subscribed to topic.
        // topic: String
        //		The name of the topic to publish.
        // args: Array?
        //		An array of arguments. The arguments will be applied
        //		to each topic subscriber (as first class parameters, via apply).
        // example:
        //	|	dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
        //	|	dojo.publish("alerts", [ "read this", "hello world" ]);
        return hub.publish.apply(hub, [topic].concat(args));
      },
      connectPublisher: function (topic, obj, event) {
        // summary:
        //		Ensure that every time obj.event() is called, a message is published
        //		on the topic. Returns a handle which can be passed to
        //		dojo.disconnect() to disable subsequent automatic publication on
        //		the topic.
        // topic: String
        //		The name of the topic to publish.
        // obj: Object?
        //		The source object for the event function. Defaults to kernel.global
        //		if null.
        // event: String
        //		The name of the event function in obj.
        //		I.e. identifies a property obj[event].
        // example:
        //	|	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");
        var pf = function () {
          connect.publish(topic, arguments);
        };
        return event ? connect.connect(obj, event, pf) : connect.connect(obj, pf);  //Handle
      },
      isCopyKey: function (e) {
        // summary:
        //		Checks an event for the copy key (meta on Mac, and ctrl anywhere else)
        // e: Event
        //		Event object to examine
        return e[evtCopyKey];  // Boolean
      }
    };
    connect.unsubscribe = connect.disconnect;
    /*=====
     connect.unsubscribe = function(handle){
    	 // summary:
    	 //		Remove a topic listener.
    	 // handle: Handle
    	 //		The handle returned from a call to subscribe.
    	 // example:
    	 //	|	var alerter = dojo.subscribe("alerts", null, function(caption, message){ alert(caption + "\n" + message); };
    	 //	|	...
    	 //	|	dojo.unsubscribe(alerter);
     };
     =====*/
    has('extend-dojo') && lang.mixin(dojo, connect);
    return connect;
  }(dojo__base_kernel, dojo_on, dojo_topic, dojo_aspect, dojo__base_event, dojo_mouse, dojo__base_sniff, dojo__base_lang);
  dojo_dom_prop = function (exports, dojo, has, lang, dom, style, ctr, conn) {
    // module:
    //		dojo/dom-prop
    // summary:
    //		This module defines the core dojo DOM properties API.
    // TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
    // =============================
    // Element properties Functions
    // =============================
    // helper to connect events
    var _evtHdlrMap = {}, _ctr = 0, _attrId = dojo._scopeName + 'attrid';
    has.add('dom-textContent', function (global, doc, element) {
      return 'textContent' in element;
    });
    exports.names = {
      // properties renamed to avoid clashes with reserved words
      'class': 'className',
      'for': 'htmlFor',
      // properties written as camelCase
      tabindex: 'tabIndex',
      readonly: 'readOnly',
      colspan: 'colSpan',
      frameborder: 'frameBorder',
      rowspan: 'rowSpan',
      textcontent: 'textContent',
      valuetype: 'valueType'
    };
    function getText(node) {
      // summary:
      //		recursion method for get('textContent') to use. Gets text value for a node.
      // description:
      //		Juse uses nodedValue so things like <br/> tags do not end up in
      //		the text as any sort of line return.
      var text = '', ch = node.childNodes;
      for (var i = 0, n; n = ch[i]; i++) {
        //Skip comments.
        if (n.nodeType != 8) {
          if (n.nodeType == 1) {
            text += getText(n);
          } else {
            text += n.nodeValue;
          }
        }
      }
      return text;
    }
    exports.get = function getProp(node, name) {
      // summary:
      //		Gets a property on an HTML element.
      // description:
      //		Handles normalized getting of properties on DOM nodes.
      //
      // node: DOMNode|String
      //		id or reference to the element to get the property on
      // name: String
      //		the name of the property to get.
      // returns:
      //		the value of the requested property or its default value
      //
      // example:
      //	|	// get the current value of the "foo" property on a node
      //	|	require(["dojo/dom-prop", "dojo/dom"], function(domProp, dom){
      //	|		domProp.get(dom.byId("nodeId"), "foo");
      //	|		// or we can just pass the id:
      //	|		domProp.get("nodeId", "foo");
      //	|	});
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = exports.names[lc] || name;
      if (propName == 'textContent' && !has('dom-textContent')) {
        return getText(node);
      }
      return node[propName];  // Anything
    };
    exports.set = function setProp(node, name, value) {
      // summary:
      //		Sets a property on an HTML element.
      // description:
      //		Handles normalized setting of properties on DOM nodes.
      //
      //		When passing functions as values, note that they will not be
      //		directly assigned to slots on the node, but rather the default
      //		behavior will be removed and the new behavior will be added
      //		using `dojo.connect()`, meaning that event handler properties
      //		will be normalized and that some caveats with regards to
      //		non-standard behaviors for onsubmit apply. Namely that you
      //		should cancel form submission using `dojo.stopEvent()` on the
      //		passed event object instead of returning a boolean value from
      //		the handler itself.
      // node: DOMNode|String
      //		id or reference to the element to set the property on
      // name: String|Object
      //		the name of the property to set, or a hash object to set
      //		multiple properties at once.
      // value: String?
      //		The value to set for the property
      // returns:
      //		the DOM node
      //
      // example:
      //	|	// use prop() to set the tab index
      //	|	require(["dojo/dom-prop"], function(domProp){
      //	|		domProp.set("nodeId", "tabIndex", 3);
      //	|	});
      //
      // example:
      //	Set multiple values at once, including event handlers:
      //	|	require(["dojo/dom-prop"], function(domProp){
      //	|		domProp.set("formId", {
      //	|			"foo": "bar",
      //	|			"tabIndex": -1,
      //	|			"method": "POST",
      //	|		});
      //	|	});
      node = dom.byId(node);
      var l = arguments.length;
      if (l == 2 && typeof name != 'string') {
        // inline'd type check
        // the object form of setter: the 2nd argument is a dictionary
        for (var x in name) {
          exports.set(node, x, name[x]);
        }
        return node;  // DomNode
      }
      var lc = name.toLowerCase(), propName = exports.names[lc] || name;
      if (propName == 'style' && typeof value != 'string') {
        // inline'd type check
        // special case: setting a style
        style.set(node, value);
        return node;  // DomNode
      }
      if (propName == 'innerHTML') {
        // special case: assigning HTML
        // the hash lists elements with read-only innerHTML on IE
        if (has('ie') && node.tagName.toLowerCase() in {
            col: 1,
            colgroup: 1,
            table: 1,
            tbody: 1,
            tfoot: 1,
            thead: 1,
            tr: 1,
            title: 1
          }) {
          ctr.empty(node);
          node.appendChild(ctr.toDom(value, node.ownerDocument));
        } else {
          node[propName] = value;
        }
        return node;  // DomNode
      }
      if (propName == 'textContent' && !has('dom-textContent')) {
        ctr.empty(node);
        node.appendChild(node.ownerDocument.createTextNode(value));
        return node;
      }
      if (lang.isFunction(value)) {
        // special case: assigning an event handler
        // clobber if we can
        var attrId = node[_attrId];
        if (!attrId) {
          attrId = _ctr++;
          node[_attrId] = attrId;
        }
        if (!_evtHdlrMap[attrId]) {
          _evtHdlrMap[attrId] = {};
        }
        var h = _evtHdlrMap[attrId][propName];
        if (h) {
          //h.remove();
          conn.disconnect(h);
        } else {
          try {
            delete node[propName];
          } catch (e) {
          }
        }
        // ensure that event objects are normalized, etc.
        if (value) {
          //_evtHdlrMap[attrId][propName] = on(node, propName, value);
          _evtHdlrMap[attrId][propName] = conn.connect(node, propName, value);
        } else {
          node[propName] = null;
        }
        return node;  // DomNode
      }
      node[propName] = value;
      return node;  // DomNode
    };
    return exports;
  }(dojo_dom_prop, dojo__base_kernel, dojo_sniff, dojo__base_lang, dojo_dom, dojo_dom_style, dojo_dom_construct, dojo__base_connect);
  dojo_dom_attr = function (exports, has, lang, dom, style, prop) {
    // module:
    //		dojo/dom-attr
    // summary:
    //		This module defines the core dojo DOM attributes API.
    // TODOC: summary not showing up in output see https://github.com/csnover/js-doc-parse/issues/42
    // =============================
    // Element attribute Functions
    // =============================
    // This module will be obsolete soon. Use dojo/prop instead.
    // dojo/dom-attr.get() should conform to http://www.w3.org/TR/DOM-Level-2-Core/
    // attribute-related functions (to be obsolete soon)
    var forcePropNames = {
        innerHTML: 1,
        textContent: 1,
        className: 1,
        htmlFor: has('ie'),
        value: 1
      }, attrNames = {
        // original attribute names
        classname: 'class',
        htmlfor: 'for',
        // for IE
        tabindex: 'tabIndex',
        readonly: 'readOnly'
      };
    function _hasAttr(node, name) {
      var attr = node.getAttributeNode && node.getAttributeNode(name);
      return !!attr && attr.specified;  // Boolean
    }
    // There is a difference in the presence of certain properties and their default values
    // between browsers. For example, on IE "disabled" is present on all elements,
    // but it is value is "false"; "tabIndex" of <div> returns 0 by default on IE, yet other browsers
    // can return -1.
    exports.has = function hasAttr(node, name) {
      // summary:
      //		Returns true if the requested attribute is specified on the
      //		given element, and false otherwise.
      // node: DOMNode|String
      //		id or reference to the element to check
      // name: String
      //		the name of the attribute
      // returns: Boolean
      //		true if the requested attribute is specified on the
      //		given element, and false otherwise
      var lc = name.toLowerCase();
      return forcePropNames[prop.names[lc] || name] || _hasAttr(dom.byId(node), attrNames[lc] || name);  // Boolean
    };
    exports.get = function getAttr(node, name) {
      // summary:
      //		Gets an attribute on an HTML element.
      // description:
      //		Handles normalized getting of attributes on DOM Nodes.
      // node: DOMNode|String
      //		id or reference to the element to get the attribute on
      // name: String
      //		the name of the attribute to get.
      // returns:
      //		the value of the requested attribute or null if that attribute does not have a specified or
      //		default value;
      //
      // example:
      //	|	// get the current value of the "foo" attribute on a node
      //	|	require(["dojo/dom-attr", "dojo/dom"], function(domAttr, dom){
      //	|		domAttr.get(dom.byId("nodeId"), "foo");
      //	|		// or we can just pass the id:
      //	|		domAttr.get("nodeId", "foo");
      //	|	});	
      //	|	
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName], value = node[propName];
      // should we access this attribute via a property or via getAttribute()?
      if (forceProp && typeof value != 'undefined') {
        // node's property
        return value;  // Anything
      }
      if (propName == 'textContent') {
        return prop.get(node, propName);
      }
      if (propName != 'href' && (typeof value == 'boolean' || lang.isFunction(value))) {
        // node's property
        return value;  // Anything
      }
      // node's attribute
      // we need _hasAttr() here to guard against IE returning a default value
      var attrName = attrNames[lc] || name;
      return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;  // Anything
    };
    exports.set = function setAttr(node, name, value) {
      // summary:
      //		Sets an attribute on an HTML element.
      // description:
      //		Handles normalized setting of attributes on DOM Nodes.
      //
      //		When passing functions as values, note that they will not be
      //		directly assigned to slots on the node, but rather the default
      //		behavior will be removed and the new behavior will be added
      //		using `dojo.connect()`, meaning that event handler properties
      //		will be normalized and that some caveats with regards to
      //		non-standard behaviors for onsubmit apply. Namely that you
      //		should cancel form submission using `dojo.stopEvent()` on the
      //		passed event object instead of returning a boolean value from
      //		the handler itself.
      // node: DOMNode|String
      //		id or reference to the element to set the attribute on
      // name: String|Object
      //		the name of the attribute to set, or a hash of key-value pairs to set.
      // value: String?
      //		the value to set for the attribute, if the name is a string.
      // returns:
      //		the DOM node
      //
      // example:
      //	|	// use attr() to set the tab index
      //	|	require(["dojo/dom-attr"], function(domAttr){
      //	|		domAttr.set("nodeId", "tabIndex", 3);
      //	|	});
      //
      // example:
      //	Set multiple values at once, including event handlers:
      //	|	require(["dojo/dom-attr"],
      //	|	function(domAttr){
      //	|		domAttr.set("formId", {
      //	|			"foo": "bar",
      //	|			"tabIndex": -1,
      //	|			"method": "POST"
      //	|		}
      //	|	});
      node = dom.byId(node);
      if (arguments.length == 2) {
        // inline'd type check
        // the object form of setter: the 2nd argument is a dictionary
        for (var x in name) {
          exports.set(node, x, name[x]);
        }
        return node;  // DomNode
      }
      var lc = name.toLowerCase(), propName = prop.names[lc] || name, forceProp = forcePropNames[propName];
      if (propName == 'style' && typeof value != 'string') {
        // inline'd type check
        // special case: setting a style
        style.set(node, value);
        return node;  // DomNode
      }
      if (forceProp || typeof value == 'boolean' || lang.isFunction(value)) {
        return prop.set(node, name, value);
      }
      // node's attribute
      node.setAttribute(attrNames[lc] || name, value);
      return node;  // DomNode
    };
    exports.remove = function removeAttr(node, name) {
      // summary:
      //		Removes an attribute from an HTML element.
      // node: DOMNode|String
      //		id or reference to the element to remove the attribute from
      // name: String
      //		the name of the attribute to remove
      dom.byId(node).removeAttribute(attrNames[name.toLowerCase()] || name);
    };
    exports.getNodeProp = function getNodeProp(node, name) {
      // summary:
      //		Returns an effective value of a property or an attribute.
      // node: DOMNode|String
      //		id or reference to the element to remove the attribute from
      // name: String
      //		the name of the attribute
      // returns:
      //		the value of the attribute
      node = dom.byId(node);
      var lc = name.toLowerCase(), propName = prop.names[lc] || name;
      if (propName in node && propName != 'href') {
        // node's property
        return node[propName];  // Anything
      }
      // node's attribute
      var attrName = attrNames[lc] || name;
      return _hasAttr(node, attrName) ? node.getAttribute(attrName) : null;  // Anything
    };
    return exports;
  }(dojo_dom_attr, dojo_sniff, dojo__base_lang, dojo_dom, dojo_dom_style, dojo_dom_prop);
  dojo_dom_construct = function (exports, dojo, has, win, dom, attr) {
    // module:
    //		dojo/dom-construct
    // summary:
    //		This module defines the core dojo DOM construction API.
    // TODOC: summary not showing up in output, see https://github.com/csnover/js-doc-parse/issues/42
    // support stuff for toDom()
    var tagWrap = {
        option: ['select'],
        tbody: ['table'],
        thead: ['table'],
        tfoot: ['table'],
        tr: [
          'table',
          'tbody'
        ],
        td: [
          'table',
          'tbody',
          'tr'
        ],
        th: [
          'table',
          'thead',
          'tr'
        ],
        legend: ['fieldset'],
        caption: ['table'],
        colgroup: ['table'],
        col: [
          'table',
          'colgroup'
        ],
        li: ['ul']
      }, reTag = /<\s*([\w\:]+)/, masterNode = {}, masterNum = 0, masterName = '__' + dojo._scopeName + 'ToCobrowseDomId';
    //PATCHED
    // generate start/end tag strings to use
    // for the injection for each special tag wrap case.
    for (var param in tagWrap) {
      if (tagWrap.hasOwnProperty(param)) {
        var tw = tagWrap[param];
        tw.pre = param == 'option' ? '<select multiple="multiple">' : '<' + tw.join('><') + '>';
        tw.post = '</' + tw.reverse().join('></') + '>';  // the last line is destructive: it reverses the array,
                                                          // but we don't care at this point
      }
    }
    var html5domfix;
    if (has('ie') <= 8) {
      html5domfix = function (doc) {
        doc.__dojo_html5_tested = 'yes';
        var div = create('div', {
          innerHTML: '<nav>a</nav>',
          style: { visibility: 'hidden' }
        }, doc.body);
        if (div.childNodes.length !== 1) {
          ('abbr article aside audio canvas details figcaption figure footer header ' + 'hgroup mark meter nav output progress section summary time video').replace(/\b\w+\b/g, function (n) {
            doc.createElement(n);
          });
        }
        destroy(div);
      };
    }
    function _insertBefore(node, ref) {
      var parent = ref.parentNode;
      if (parent) {
        parent.insertBefore(node, ref);
      }
    }
    function _insertAfter(node, ref) {
      // summary:
      //		Try to insert node after ref
      var parent = ref.parentNode;
      if (parent) {
        if (parent.lastChild == ref) {
          parent.appendChild(node);
        } else {
          parent.insertBefore(node, ref.nextSibling);
        }
      }
    }
    exports.toDom = function toDom(frag, doc) {
      // summary:
      //		instantiates an HTML fragment returning the corresponding DOM.
      // frag: String
      //		the HTML fragment
      // doc: DocumentNode?
      //		optional document to use when creating DOM nodes, defaults to
      //		dojo/_base/window.doc if not specified.
      // returns:
      //		Document fragment, unless it's a single node in which case it returns the node itself
      // example:
      //		Create a table row:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var tr = domConstruct.toDom("<tr><td>First!</td></tr>");
      //	|	});
      doc = doc || win.doc;
      var masterId = doc[masterName];
      if (!masterId) {
        doc[masterName] = masterId = ++masterNum + '';
        masterNode[masterId] = doc.createElement('div');
      }
      if (has('ie') <= 8) {
        if (!doc.__dojo_html5_tested && doc.body) {
          html5domfix(doc);
        }
      }
      // make sure the frag is a string.
      frag += '';
      // find the starting tag, and get node wrapper
      var match = frag.match(reTag), tag = match ? match[1].toLowerCase() : '', master = masterNode[masterId], wrap, i, fc, df;
      if (match && tagWrap[tag]) {
        wrap = tagWrap[tag];
        master.innerHTML = wrap.pre + frag + wrap.post;
        for (i = wrap.length; i; --i) {
          master = master.firstChild;
        }
      } else {
        master.innerHTML = frag;
      }
      // one node shortcut => return the node itself
      if (master.childNodes.length == 1) {
        return master.removeChild(master.firstChild);  // DOMNode
      }
      // return multiple nodes as a document fragment
      df = doc.createDocumentFragment();
      while (fc = master.firstChild) {
        // intentional assignment
        df.appendChild(fc);
      }
      return df;  // DocumentFragment
    };
    exports.place = function place(node, refNode, position) {
      // summary:
      //		Attempt to insert node into the DOM, choosing from various positioning options.
      //		Returns the first argument resolved to a DOM node.
      // node: DOMNode|DocumentFragment|String
      //		id or node reference, or HTML fragment starting with "<" to place relative to refNode
      // refNode: DOMNode|String
      //		id or node reference to use as basis for placement
      // position: String|Number?
      //		string noting the position of node relative to refNode or a
      //		number indicating the location in the childNodes collection of refNode.
      //		Accepted string values are:
      //
      //		- before
      //		- after
      //		- replace
      //		- only
      //		- first
      //		- last
      //
      //		"first" and "last" indicate positions as children of refNode, "replace" replaces refNode,
      //		"only" replaces all children.  position defaults to "last" if not specified
      // returns: DOMNode
      //		Returned values is the first argument resolved to a DOM node.
      //
      //		.place() is also a method of `dojo/NodeList`, allowing `dojo/query` node lookups.
      // example:
      //		Place a node by string id as the last child of another node by string id:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("someNode", "anotherNode");
      //	|	});
      // example:
      //		Place a node by string id before another node by string id
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("someNode", "anotherNode", "before");
      //	|	});
      // example:
      //		Create a Node, and place it in the body element (last child):
      //	|	require(["dojo/dom-construct", "dojo/_base/window"
      //	|	], function(domConstruct, win){
      //	|		domConstruct.place("<div></div>", win.body());
      //	|	});
      // example:
      //		Put a new LI as the first child of a list by id:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.place("<li></li>", "someUl", "first");
      //	|	});
      refNode = dom.byId(refNode);
      if (typeof node == 'string') {
        // inline'd type check
        node = /^\s*</.test(node) ? exports.toDom(node, refNode.ownerDocument) : dom.byId(node);
      }
      if (typeof position == 'number') {
        // inline'd type check
        var cn = refNode.childNodes;
        if (!cn.length || cn.length <= position) {
          refNode.appendChild(node);
        } else {
          _insertBefore(node, cn[position < 0 ? 0 : position]);
        }
      } else {
        switch (position) {
        case 'before':
          _insertBefore(node, refNode);
          break;
        case 'after':
          _insertAfter(node, refNode);
          break;
        case 'replace':
          refNode.parentNode.replaceChild(node, refNode);
          break;
        case 'only':
          exports.empty(refNode);
          refNode.appendChild(node);
          break;
        case 'first':
          if (refNode.firstChild) {
            _insertBefore(node, refNode.firstChild);
            break;
          }
        // else fallthrough...
        default:
          // aka: last
          refNode.appendChild(node);
        }
      }
      return node;  // DomNode
    };
    var create = exports.create = function create(tag, attrs, refNode, pos) {
      // summary:
      //		Create an element, allowing for optional attribute decoration
      //		and placement.
      // description:
      //		A DOM Element creation function. A shorthand method for creating a node or
      //		a fragment, and allowing for a convenient optional attribute setting step,
      //		as well as an optional DOM placement reference.
      //
      //		Attributes are set by passing the optional object through `dojo/dom-attr.set`.
      //		See `dojo/dom-attr.set` for noted caveats and nuances, and API if applicable.
      //
      //		Placement is done via `dojo/dom-construct.place`, assuming the new node to be
      //		the action node, passing along the optional reference node and position.
      // tag: DOMNode|String
      //		A string of the element to create (eg: "div", "a", "p", "li", "script", "br"),
      //		or an existing DOM node to process.
      // attrs: Object
      //		An object-hash of attributes to set on the newly created node.
      //		Can be null, if you don't want to set any attributes/styles.
      //		See: `dojo/dom-attr.set` for a description of available attributes.
      // refNode: DOMNode|String?
      //		Optional reference node. Used by `dojo/dom-construct.place` to place the newly created
      //		node somewhere in the dom relative to refNode. Can be a DomNode reference
      //		or String ID of a node.
      // pos: String?
      //		Optional positional reference. Defaults to "last" by way of `dojo/domConstruct.place`,
      //		though can be set to "first","after","before","last", "replace" or "only"
      //		to further control the placement of the new node relative to the refNode.
      //		'refNode' is required if a 'pos' is specified.
      // example:
      //		Create a DIV:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var n = domConstruct.create("div");
      //	|	});
      //
      // example:
      //		Create a DIV with content:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		var n = domConstruct.create("div", { innerHTML:"<p>hi</p>" });
      //	|	});
      //
      // example:
      //		Place a new DIV in the BODY, with no attributes set
      //	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
      //	|		var n = domConstruct.create("div", null, win.body());
      //	|	});
      //
      // example:
      //		Create an UL, and populate it with LI's. Place the list as the first-child of a
      //		node with id="someId":
      //	|	require(["dojo/dom-construct", "dojo/_base/array"],
      //	|	function(domConstruct, arrayUtil){
      //	|		var ul = domConstruct.create("ul", null, "someId", "first");
      //	|		var items = ["one", "two", "three", "four"];
      //	|		arrayUtil.forEach(items, function(data){
      //	|			domConstruct.create("li", { innerHTML: data }, ul);
      //	|		});
      //	|	});
      //
      // example:
      //		Create an anchor, with an href. Place in BODY:
      //	|	require(["dojo/dom-construct", "dojo/_base/window"], function(domConstruct, win){
      //	|		domConstruct.create("a", { href:"foo.html", title:"Goto FOO!" }, win.body());
      //	|	});
      var doc = win.doc;
      if (refNode) {
        refNode = dom.byId(refNode);
        doc = refNode.ownerDocument;
      }
      if (typeof tag == 'string') {
        // inline'd type check
        tag = doc.createElement(tag);
      }
      if (attrs) {
        attr.set(tag, attrs);
      }
      if (refNode) {
        exports.place(tag, refNode, pos);
      }
      return tag;  // DomNode
    };
    function _empty(node) {
      // TODO: remove this if() block in 2.0 when we no longer have to worry about IE memory leaks,
      // and then uncomment the emptyGrandchildren() test case from html.html.
      // Note that besides fixing #16957, using removeChild() is actually faster than setting node.innerHTML,
      // see http://jsperf.com/clear-dom-node.
      if ('innerHTML' in node) {
        try {
          // fast path
          node.innerHTML = '';
          return;
        } catch (e) {
        }
      }
      // SVG/strict elements don't support innerHTML
      for (var c; c = node.lastChild;) {
        // intentional assignment
        node.removeChild(c);
      }
    }
    exports.empty = function empty(node) {
      // summary:
      //		safely removes all children of the node.
      // node: DOMNode|String
      //		a reference to a DOM node or an id.
      // example:
      //		Destroy node's children byId:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.empty("someId");
      //	|	});
      _empty(dom.byId(node));
    };
    function _destroy(node, parent) {
      // in IE quirks, node.canHaveChildren can be false but firstChild can be non-null (OBJECT/APPLET)
      if (node.firstChild) {
        _empty(node);
      }
      if (parent) {
        // removeNode(false) doesn't leak in IE 6+, but removeChild() and removeNode(true) are known to leak under IE 8- while 9+ is TBD.
        // In IE quirks mode, PARAM nodes as children of OBJECT/APPLET nodes have a removeNode method that does nothing and
        // the parent node has canHaveChildren=false even though removeChild correctly removes the PARAM children.
        // In IE, SVG/strict nodes don't have a removeNode method nor a canHaveChildren boolean.
        has('ie') && parent.canHaveChildren && 'removeNode' in node ? node.removeNode(false) : parent.removeChild(node);
      }
    }
    var destroy = exports.destroy = function destroy(node) {
      // summary:
      //		Removes a node from its parent, clobbering it and all of its
      //		children.
      //
      // description:
      //		Removes a node from its parent, clobbering it and all of its
      //		children. Function only works with DomNodes, and returns nothing.
      //
      // node: DOMNode|String
      //		A String ID or DomNode reference of the element to be destroyed
      //
      // example:
      //		Destroy a node byId:
      //	|	require(["dojo/dom-construct"], function(domConstruct){
      //	|		domConstruct.destroy("someId");
      //	|	});
      node = dom.byId(node);
      if (!node) {
        return;
      }
      _destroy(node, node.parentNode);
    };
    return exports;
  }(dojo_dom_construct, dojo__base_kernel, dojo_sniff, dojo__base_window, dojo_dom, dojo_dom_attr);
  dojo_text_synchronite_proxyless_templates_csathtml = '<div id="cobrowse-csat-container" class="ignoreDOM">\n\t<div id="cobrowse-csat-header">\n\t\t<div id="cobrowse-csat-header-title">Thank you</div>\n\t\t<a id="cobrowse-csat-close-button" role="button" href="#">&times</a>\n\t</div>\n\n\t<div id="cobrowse-csat-title">\n\t\t${csatMessage}\n\t</div>\n\n\t<div id="cobrowse-stars" data-stars="1">\n\t\t<svg height="37.5" width="34.5" class="cobrowse-star" data-noclick="true" data-rating="1">\n\t\t\t<polygon points="14.85, 1.65, 4.95, 32.67, 29.7, 12.87, 0, 12.87, 24.75, 32.67" style="fill-rule:nonzero;"/>\n\t\t</svg>\n\t\t<svg height="37.5" width="34.5" class="cobrowse-star" data-noclick="true" data-rating="2">\n\t\t\t<polygon points="14.85, 1.65, 4.95, 32.67, 29.7, 12.87, 0, 12.87, 24.75, 32.67" style="fill-rule:nonzero;"/>\n\t\t</svg>\n\t\t<svg height="37.5" width="34.5" class="cobrowse-star" data-noclick="true" data-rating="3">\n\t\t\t<polygon points="14.85, 1.65, 4.95, 32.67, 29.7, 12.87, 0, 12.87, 24.75, 32.67" style="fill-rule:nonzero;"/>\n\t\t</svg>\n\t\t<svg height="37.5" width="34.5" class="cobrowse-star" data-noclick="true" data-rating="4">\n\t\t\t<polygon points="14.85, 1.65, 4.95, 32.67, 29.7, 12.87, 0, 12.87, 24.75, 32.67" style="fill-rule:nonzero;"/>\n\t\t</svg>\n\t\t<svg height="37.5" width="34.5" class="cobrowse-star" data-noclick="true" data-rating="5">\n\t\t\t<polygon points="14.85, 1.65, 4.95, 32.67, 29.7, 12.87, 0, 12.87, 24.75, 32.67" style="fill-rule:nonzero;"/>\n\t\t</svg>\n\t</div>\n\n\t<div id="cobrowse-csat-disclaimer">\n\t\t${csatDisclaimer}\n\t</div>\n\n\t<div id="cobrowse-csat-response"></div>\n\n</div>\n';
  synchronite_proxyless_csat = function (dom, construct, query, dojoString, fx, i18next, datachannel, csatTemplate) {
    var responseTimeout = 100000;
    // 1:40 minutes. Must be less than ticket expiry!
    var animationTimeout = 4000;
    var config = synchroniteConfig;
    var csatContainerId = 'cobrowse-csat-container';
    var synchroniteWidgetsContainer = 'synchronite-widgets';
    csatTemplate = dojoString.trim(csatTemplate);
    function _toDom(html) {
      html = dojoString.trim(html);
      var div = document.createElement('div');
      div.innerHTML = html;
      return div.firstChild;
    }
    function _getBodyOrRoot() {
      var body = query('body');
      return body.length === 0 ? document.documentElement : body[0];
    }
    /**
     * Return the synchronite-widgets container element or if it does not exist
     * create it.
     * @private
     */
    function _getSynchroniteContainer() {
      var div = document.createElement('div');
      div.setAttribute('id', synchroniteWidgetsContainer);
      var container = query('#' + synchroniteWidgetsContainer);
      return container.length === 0 ? _getBodyOrRoot().appendChild(div) : dom.byId(synchroniteWidgetsContainer);
    }
    /**
     * Remove CSAT window node from the DOM.
     * @private
     */
    function _cleanup() {
      var container = dom.byId(csatContainerId);
      if (container) {
        container.parentNode.removeChild(container);
      }
    }
    /**
     * Hide the CSAT survey window with an animation and cleanup the
     * window node from the DOM.
     * @private
     */
    function _hideWindow() {
      fx.animateProperty({
        node: 'cobrowse-csat-container',
        properties: { bottom: -1000 },
        onEnd: function (element) {
          element.style.display = 'none';
          _cleanup();
        }
      }).play();
    }
    /**
     * Remove the content inside of the CSAT window (titles, stars,
     * disclaimers etc..).
     * @private
     */
    function _cleanWindowContent() {
      construct.destroy('cobrowse-csat-title');
      construct.destroy('cobrowse-stars');
      construct.destroy('cobrowse-csat-disclaimer');
    }
    /**
     * Insert the feedback response in the CSAT window.
     * @private
     */
    function _showFeedback(response) {
      if (response.success === true) {
        _cleanWindowContent();
        dom.byId('cobrowse-csat-response').innerHTML = i18next.t('csatAnswerFeedback', { ns: ['session'] });
        setTimeout(_hideWindow, animationTimeout);
      }
    }
    /**
     * Pop up the CSAT window and listen for the click events (close and rating)
     * @private
     */
    function _startSurvey() {
      var synchContainer = _getSynchroniteContainer();
      synchContainer.appendChild(_toDom(i18next.replace(csatTemplate, config)));
      query('#cobrowse-csat-close-button').on('click', _hideWindow);
      query('.cobrowse-star').on('click', function (event) {
        var rating = event.currentTarget.getAttribute('data-rating');
        this.parentNode.dataset.stars = rating;
        datachannel.sendCustomerSatisfaction(rating).then(_showFeedback);
      });
    }
    return {
      triggerSurvey: function () {
        _startSurvey();
        setTimeout(_hideWindow, responseTimeout);
      }
    };
  }(dojo_dom, dojo_dom_construct, dojo_query, dojo_string, dojo__base_fx, i18next_loader, synchronite_proxyless_datachannel, dojo_text_synchronite_proxyless_templates_csathtml);
  synchronite_proxyless_app = function (datachannel, utils, storage, ui, constants, memberStateEvents, memberState, connectionEvents, connectionState, i18next, lang, baseArray, request, query, dojoCookie, has, Deferred, strings, domListener, domCommon, uwCommon, uwListener, scroll, synchQuery, trackingEvents, trackingLoader, mouse, resize, focus, keyboard, profiles, participantNotification, eventreplicator, requestDomRetry, csat) {
    var blackboxWin, config = window.synchroniteConfig;
    var registeredListeners = [];
    var endSessionAfterVisitorLeftTimeoutRef = null;
    var SYNCHRONITE_ENDSESSIONURL_COOKIE_NAME = 's.ewa';
    var sessionEndAlreadyTracked, lastlpTagNewPageUrl, isSendingDom = false;
    var params, firstStart = false, validateTicketRetries = 0;
    function registerHandlersForMaster() {
      datachannel.addHandler(eventreplicator.mouseMoveHandler);
      datachannel.addHandler(eventreplicator.mouseClickHandler);
      datachannel.addHandler(eventreplicator.selectHandler);
      datachannel.addHandler(eventreplicator.keyboardHandler);
      datachannel.addHandler(eventreplicator.scrollHandler);
      datachannel.addHandler(eventreplicator.elementvalueHandlerMaster);
      datachannel.addHandler(eventreplicator.customerSatisfactionHandler);
      datachannel.addHandler(eventreplicator.heartbeatHandler);
      eventreplicator.startReplicatingMaster();
    }
    function registerHandlersForSlave() {
      datachannel.addHandler(eventreplicator.domChangeHandler);
      datachannel.addHandler(eventreplicator.mouseMoveHandler);
      datachannel.addHandler(eventreplicator.mouseClickHandler);
      datachannel.addHandler(eventreplicator.selectHandler);
      datachannel.addHandler(eventreplicator.scrollHandler);
      datachannel.addHandler(eventreplicator.elementvalueHandler);
      datachannel.addHandler(eventreplicator.canvasHandler);
      datachannel.addHandler(eventreplicator.keyboardHandler);
      datachannel.addHandler(eventreplicator.fullStateHandler);
      datachannel.addHandler(eventreplicator.textContentHandler);
      datachannel.addHandler(eventreplicator.uwHandler);
      datachannel.addHandler(eventreplicator.resizeHandler);
      datachannel.addHandler(eventreplicator.heartbeatHandler);
      datachannel.addHandler(eventreplicator.restrictedPageHandler);
      datachannel.addHandler(eventreplicator.focusHandler);
      datachannel.addHandler(eventreplicator.isLoadingHandler);
      eventreplicator.startReplicatingSlave();
    }
    function sendInitialState(currentUrl) {
      if (utils.isBlacklistedUrl(currentUrl || window.location.href)) {
        console.log('Visitor is on a blacklisted page');
        mouse.tearDown(false);
        scroll.tearDown();
        keyboard.tearDown();
        domListener.stopListening();
        focus.stopListening();
        datachannel.send(constants.EVENT.RESTRICTEDPAGE, '');
        ui.showRestrictedPageMessage(true);
      } else {
        if (isSendingDom) {
          console.log('Already sending DOM tree', isSendingDom);
          return;
        }
        console.log('Start listening and send state', isSendingDom);
        isSendingDom = true;
        domListener.startListening(window);
        ui.hideRestrictedPageMessage(true);
      }
    }
    function updateBaseTag(force) {
      // set base tag so it will be pushed to slave
      var win = window, doc = win.document;
      var baseUrl = win.location.origin + win.location.pathname + win.location.search;
      if (query('base').length === 0) {
        var baseNode = doc.createElement('base'), headNode = doc.getElementsByTagName('head')[0];
        baseNode.setAttribute('href', baseUrl);
        headNode.insertBefore(baseNode, headNode.firstChild);
      } else {
        if (force) {
          query('base')[0].setAttribute('href', baseUrl);
        }
      }
    }
    function validateTicketRequest(tenantId, ticketId) {
      var requestUrl = config.serverUrl + strings.AJAX_PATH;
      return request.post(requestUrl, {
        preventCache: true,
        handleAs: 'json',
        timeout: 4000,
        data: {
          action: 'validateTicket',
          tI: tenantId,
          ticketId: ticketId
        }
      });
    }
    function clearSessionCookies() {
      try {
        storage.removeValue(constants.sendStateKey);
        storage.removeValue(constants.ticketIdKey);
        storage.removeValue(constants.sessionIdKey);
        storage.removeValue(constants.usernameKey);
        storage.removeValue(constants.cometReloadKey);
        storage.removeValue(constants.userIdKey);
        storage.removeValue(constants.startTimestampKey);
        storage.deleteCookie('s.at');
      } catch (e) {
        console.error('Error clearing session cookies');
        console.error(e.message);
      }
    }
    function getSessionEndUrl() {
      if (dojoCookie(SYNCHRONITE_ENDSESSIONURL_COOKIE_NAME)) {
        // Return to url saved in cookie, when there are fewer than 2
        // members in a session. This is used by qr-connect.
        return dojoCookie(SYNCHRONITE_ENDSESSIONURL_COOKIE_NAME);  // FIXED: Do not delete cookie, because othwerise we can't remember its value
                                                                   // on page changes. Instead the value is deleted in /agents or /console.
                                                                   //                    dojoCookie(SYNCHRONITE_ENDSESSIONURL_COOKIE_NAME, null, {
                                                                   //                        expires: -1,
                                                                   //                        path: "/"
                                                                   //                    });
      }
    }
    /**
     * Indicates to scripts running on the page that a CoBrowse session is currently active by setting the
     * 'isCobrowsingActive' flag on both the window and lpTag. Proxy-based CoBrowse uses the same flags.
     * Also adds a page variable to for reporting purposes.
     * @param win
     * @param active
     */
    function indicateCobrowseActive(win, active) {
      console.log('app.js indicateCobrowseActive', active);
      if (win) {
        var coreReporting, legacyReporting, lpTag = win.lpTag;
        win.isCobrowsingActive = active;
        if (lpTag) {
          lpTag.isCobrowsingActive = active;
        }
        if (window.proxyless) {
          window.proxyless.isCobrowsingActive = active;
        }
        // On the last co-browsed page where the session is ended, the reporting will first trigger active=true
        // and then override it with active=false.
        if (active && config && config.livepersonHandover) {
          coreReporting = lpTag.vars;
          if (coreReporting) {
            coreReporting.push([{
                scope: 'page',
                name: 'CobrowsingActive',
                value: !!active + ''
              }]);
            try {
              coreReporting.send();  // Send waiting variables immediately
            } catch (e) {
            }
          }
          if (!coreReporting) {
            legacyReporting = win.lpMTagConfig && win.lpMTagConfig.pageVar;
            if (legacyReporting) {
              legacyReporting.push('CobrowsingActive=' + !!active);
              if (win.lpSendData) {
                win.lpSendData();
              }
            }
          }
        }
      }
    }
    /**
     * @param sessionEndedInfo Example: { endedBy: { userId: 126193, isAgent: false } } }
     */
    function endSession(sessionEndedInfo) {
      storage.removeValueInLocalStorage(constants.cobrowseActive);
      if (config.isSlave) {
        // isAgent
        var lastBrowsedUrl = config.currentURL, agentEndUrl = getSessionEndUrl() || lastBrowsedUrl, gotoUrl, exitOperation = config.agentExitOperation;
        if (blackboxWin) {
          var message = {
            type: 'sessionEnded',
            info: sessionEndedInfo
          };
          blackboxWin.postMessage(message, window.location.origin);
          return;
        }
        if (exitOperation !== 'none') {
          if (exitOperation === 'closeWindow') {
            gotoUrl = lastBrowsedUrl;
            parent.window.close();  //not supported on firefox!
          } else if (exitOperation === 'useLastUrl') {
            gotoUrl = lastBrowsedUrl;
          } else if (exitOperation === 'useEndUrl') {
            gotoUrl = agentEndUrl;
          }
          if (gotoUrl) {
            // Fixes navigation to undefined for accounts that have wrong exitOperation setting.
            setTimeout(function () {
              parent.window.location.replace(gotoUrl);
            }, 500);
          }
        }
      } else {
        // execute tracking scripts for session end
        if (!sessionEndAlreadyTracked) {
          sessionEndAlreadyTracked = true;
          var info = lang.mixin({
            visitorId: 'Visitor_Id_anonymous',
            ticketId: config.ticketId
          }, sessionEndedInfo);
          storage.getValue(constants.startTimestampKey, function (sessionStartTS) {
            if (sessionStartTS) {
              var now = new Date().getTime();
              var durationMillis = now - parseInt(sessionStartTS, 10);
              info.duration = parseInt(durationMillis / 1000, 10);
              var visitorApi = lang.getObject(config.namespace || 'synchronite', false, window);
              if (visitorApi) {
                visitorApi.emit('sessionEnd', info);  // will publish it to tracking as well
              } else {
                trackingEvents.emit('sessionEnd', info);
              }
            }
          });
          if (config.enableCsat === true) {
            csat.triggerSurvey();
          }
        }
        clearSessionCookies();
        ui.cleanup();
        mouse.tearDown(true);
        scroll.tearDown();
        keyboard.tearDown();
        domListener.stopListening();
        focus.stopListening();
        //annotations.tearDown();
        config.proxylessInit = false;
        indicateCobrowseActive(window, false);
        //remove listeners
        for (var h = 0; h < registeredListeners.length; h++) {
          registeredListeners[h].remove();
        }
      }
    }
    function processNodes(msg, mirror) {
      var movedOrAdded = msg.args && msg.args[1];
      if (movedOrAdded && movedOrAdded.length) {
        window.setTimeout(function () {
          // avoid long-running script error
          baseArray.forEach(movedOrAdded, function (data) {
            if (data.parentNode && mirror) {
              var parentNode = mirror.knownNodes.nodes[data.parentNode.id];
              if (parentNode) {
                if (/div|ul|tbody/i.test(data.tagName)) {
                  try {
                    var nodeDoc = parentNode.ownerDocument, nodeWindow = nodeDoc.defaultView || nodeDoc.parentWindow;
                    // SLAVE: re-attach scroll listeners for scrollable divs
                    scroll.listenToScrollableNodes(nodeWindow, parentNode);
                  } catch (e) {
                    console.warn('error attaching scroll listeners');
                    console.warn(e);
                  }
                }
                utils.protectFields(parentNode);
              }
            }
          });
        }, 1);
      }
    }
    function showMemberLeftNotification() {
      if (config.isSlave) {
        ui.showError(i18next.t('visitorLeftError', { ns: ['session'] }));
        ui.showError(i18next.t('visitorLeftError', { ns: ['session'] }));
        endSessionAfterVisitorLeftTimeoutRef = window.setTimeout(function () {
          datachannel.endSession();
        }, 5000);
      } else {
        if (participantNotification.getNumberOfParticipants() === 1) {
          ui.showNotification(i18next.t('agentLeftError', { ns: ['session'] }));
        }
      }
    }
    function registerListeners() {
      registeredListeners.push(domListener.on(domCommon.DOM_CHANGE, function (event, mirror) {
        processNodes(event, mirror);
        // MASTER: re-attach scroll listeners for scrollable divs
        datachannel.send(constants.EVENT.DOM, event);
      }));
      registeredListeners.push(domListener.on(domCommon.DOM_INITIALIZE, function (event) {
        var win = synchQuery.queryFrame(event.target);
        if (event.type === domCommon.DOM_FRAME_INITIALIZE) {
          scroll.startListening(win);
          mouse.startListening(win.document);
          keyboard.startListening(win.document);
          uwListener.startListening();
          resize.configure({ profile: profiles.config.presenter });
          resize.startListening(window);
          focus.startListening({ userId: datachannel.getUserId() });
        }
        datachannel.send(constants.EVENT.DOM, event);
        datachannel.send(constants.EVENT.DUMMY, '', function () {
          isSendingDom = false;
          console.log('Sending DOM finished', isSendingDom);
        });
        if (event.type === domCommon.DOM_FRAME_INITIALIZE) {
          utils.protectFields(win.document);
          utils.sendState(datachannel, true);
        }
      }));
      registeredListeners.push(resize.local.on(resize.type, function (event) {
        datachannel.send(constants.EVENT.RESIZE, event);
      }));
      // Publish local scroll events
      registeredListeners.push(scroll.local.on(scroll.TYPE, function (event) {
        datachannel.send(constants.EVENT.SCROLL, event);
      }));
      // Publish MOUSE events
      registeredListeners.push(mouse.local.on(mouse.type.DOWN, function (event) {
        event.senderId = datachannel.getUserId();
        datachannel.send(constants.EVENT.MOUSE, event);
      }));
      registeredListeners.push(mouse.local.on(mouse.type.DRAG, function (event) {
        event.senderId = datachannel.getUserId();
        datachannel.send(constants.EVENT.MOUSE, event);
      }));
      registeredListeners.push(mouse.local.on(mouse.type.CLICK, function (event) {
        event.senderId = datachannel.getUserId();
        datachannel.send(constants.EVENT.MOUSE, event);
        if (!config.isSlave) {
          setTimeout(function () {
            utils.sendState(datachannel);
          }, 100);
        } else {
          var target = synchQuery.queryElement(event.cssSelector);
          // Synchronize the value of slider elements if we detect a click on it
          var nodeName = target.nodeName.toLowerCase();
          if (nodeName === 'input' && target.type === 'range') {
            datachannel.send(constants.EVENT.ELEMENTVALUE, {
              target: event.cssSelector,
              value: target.value
            });
          }
        }
      }));
      registeredListeners.push(mouse.local.on(mouse.type.SELECT, function (event) {
        event.senderId = datachannel.getUserId();
        datachannel.send(constants.EVENT.SELECT, event);
      }));
      registeredListeners.push(mouse.local.on(mouse.type.MOVE, function (event) {
        event.senderId = datachannel.getUserId();
        if (datachannel.isConnected()) {
          // Because this method is triggered by setTimeout, we might have already
          // disconnected. To avoid an error to be thrown, we check the connection state.
          datachannel.send(constants.EVENT.MOUSEMOVE, event);
        }
      }));
      registeredListeners.push(keyboard.local.on(keyboard.type, function (event) {
        event.senderId = datachannel.getUserId();
        if (event.keyboardEvent && event.keyboardEvent.which === 32) {
          // space bar
          if (!config.isSlave) {
            utils.sendState(datachannel);
          }
        }
        datachannel.send(constants.EVENT.KEYBOARD, event);
      }));
      registeredListeners.push(uwListener.on(uwCommon.NAMESPACE, function (data) {
        datachannel.send(constants.EVENT.UWSTATE, data);
      }));
      registeredListeners.push(focus.local.on(focus.type, function (data) {
        datachannel.send(constants.EVENT.FOCUS, data);
      }));
      registeredListeners.push(memberStateEvents.on(memberState.NAMESPACE, function (data) {
        if (data.state === memberState.LEFT && data.user.userId !== datachannel.getUserId()) {
          showMemberLeftNotification();
        } else if (data.state === memberState.INACTIVE) {
          if (config.isSlave) {
            ui.showLoadingOverlay();
          }
        } else if (data.state === memberState.ACTIVE) {
          if (config.isSlave) {
            ui.hideLoadingOverlay();
          }
        } else if (data.state === memberState.JOINED) {
          if (config.isSlave && Object.keys(data.currentUsers).length >= 2) {
            window.clearTimeout(endSessionAfterVisitorLeftTimeoutRef);
            setTimeout(function () {
              if (!requestDomRetry.hasReceivedDom()) {
                datachannel.send(constants.COMMAND.REQUESTSTATE, '');
                console.log('request state after second member joined');
              }
            }, 200);
          }
        }
      }));
      registeredListeners.push(connectionEvents.on(connectionState.NAMESPACE, function (data) {
        if (data === connectionState.HEALTHY) {
          ui.showNotification(i18next.t('connectionReestablished', { ns: ['session'] }), true);
          if (config.isAgent) {
            datachannel.send(constants.COMMAND.REQUESTSTATE, '');
          } else {
            sendInitialState();
          }
        } else if (data === connectionState.UNHEALTHY) {
          isSendingDom = false;
          ui.showNotification(i18next.t('connectionUnavailable', { ns: ['session'] }));
        }
      }));
    }
    //Remove getUpdatedLanguage function once site settings is updated with languages.
    function getUpdatedLanguage(lng) {
      //To test fallback language remove any language from object below.
      var lngObj = {
        'en': 'en-US',
        'da': 'da-DK',
        'de': 'de-DE',
        'es': 'es-ES',
        'fi': 'fi-FI',
        'fr': 'fr-FR',
        'it': 'it-IT',
        'ja': 'ja-JP',
        'ko': 'ko-KR',
        'pt': 'pt-PT',
        'tr': 'tr-TR',
        'zh': 'zh-CN',
        'zh-HK': 'zh-HK',
        'zh-TW': 'zh-TW'
      };
      var i18nLng = lngObj[lng];
      if (i18nLng === null || i18nLng === undefined) {
        i18nLng = 'en-US';
        console.log('Using fallback lng for i18 as : ' + lng + ' file not found');
      }
      return i18nLng;
    }
    function mergeCustomTranslations() {
      var customText = config.customText || {};
      for (var lng in customText) {
        if (customText.hasOwnProperty(lng)) {
          console.log('Overriding ' + lng + ' language files');
          for (var translationKey in customText[lng]) {
            if (customText[lng].hasOwnProperty(translationKey)) {
              var updatedLng = getUpdatedLanguage(lng);
              var updatedTranslationKey = 'session.' + translationKey;
              i18next.addResource(updatedLng, 'session', updatedTranslationKey, utils.escapeHtml(customText[lng][translationKey]));
            }
          }
        }
      }
    }
    function detectEngagementLanguage() {
      var win = window;
      if (win.lpTag && win.lpTag.events && win.lpTag.events.hasFired) {
        var events = win.lpTag.events.hasFired('lpUnifiedWindow', 'conversationInfo');
        // console.log("Events => ",events);
        if (events && events.length) {
          for (var i = 0; i < events.length; i++) {
            if (events[i].data && events[i].data.language) {
              return events[i].data.language;
            }
          }
          return null;
        }
        if (window.synchroniteConfig.locale) {
          return window.synchroniteConfig.locale;
        }
      }
    }
    function loadLanguageNamespaces(lng) {
      var deferred = new Deferred();
      var updatedLanguage = getUpdatedLanguage(lng) || i18next.language;
      console.log('CoBrowse - app.js -> loadLanguageNamespaces()', updatedLanguage);
      i18next.changeLanguage(updatedLanguage, function () {
        i18next.loadNamespaces(['session'], function () {
          deferred.resolve();
        });
      });
      return deferred;
    }
    function _setDocumentDomain() {
      //only do this if browser is not IE9
      if (has('ie') !== 9 && has('ie') !== 10) {
        var sd = window.location.hostname.split('.');
        document.domain = sd[sd.length - 2] + '.' + sd[sd.length - 1];
      }
    }
    function getUsername(parameter) {
      // eslint-disable-next-line max-len
      var regex = /^Vi$|^$|^$|^Vy$|^$|^Teie$|^You$|^Du$|^Sie$|^Usted$|^Vous$|^$|^$|^Js$|^U$|^Ty$|^$|^$|^$|^Sin$|^Tu$|^$|^$|^Voc$|^Siz$|^$/;
      if (parameter.username && !regex.test(params.username)) {
        // Ugly solution to find out if the visitor entered his name during prechat survey.
        // Just match against default username values in all languages
        return parameter.username;
      } else {
        return 'Visitor';
      }
    }
    function createPublicInterfaces() {
      window.proxyless = window.proxyless || {};
      // Function for ending the session. Used by cobrowse taglet to end the session once chat ended
      window.proxyless.endSession = function () {
        datachannel.endSession();
      };
      window.proxyless.newPage = function (url) {
        if (lastlpTagNewPageUrl !== url) {
          datachannel.joinSession(url);
          updateBaseTag(true);
          sendInitialState(url);
        }
        lastlpTagNewPageUrl = url;
        setTimeout(function () {
          utils.sendState(datachannel, true);
        }, 50);
      };
      window.proxyless.forceSync = function () {
        utils.sendState(datachannel, true);
      };
      if (config.isAgent) {
        window.proxyless.getState = function () {
          return {
            url: config.currentURL,
            memberCount: participantNotification.getNumberOfParticipants(),
            gotInitialState: participantNotification.gotInitialState()
          };
        };
      }
    }
    function initStorage() {
      var deferred = new Deferred();
      storage.init({
        site: config.tenantId,
        cobrowseBaseUrl: config.serverUrl
      });
      deferred.resolve();
      return deferred.promise;
    }
    function setServerUrls() {
      var deferred = new Deferred();
      var tenantHost = config.tenantHost || config.tenantId + '.' + config.proxyHost;
      config.proxyUrl = 'https://' + tenantHost;
      config.serverUrl = config.proxyUrl;
      lastlpTagNewPageUrl = window.location.href;
      deferred.resolve();
      return deferred.promise;
    }
    function getTicket() {
      var deferred = new Deferred();
      if (utils.getURLParameter('ticket') !== 'undefined') {
        deferred.resolve(utils.getURLParameter('ticket'));
        return deferred.promise;
      }
      storage.getValue(constants.ticketIdKey, function (ticket) {
        if (ticket) {
          deferred.resolve(ticket);
        } else {
          deferred.resolve(false);
        }
      });
      return deferred.promise;
    }
    function handleParams(ticketFromCache) {
      var deferred = new Deferred();
      var ticketId;
      var sendState;
      if (params) {
        if (params.master) {
          //only store ticket id on master, on slave it will always be in the URL
          storage.setValue(constants.ticketIdKey, params.ticket);
        }
        if (params.sid) {
          storage.setValue(constants.sessionIdKey, params.sid);
        }
        config.userName = getUsername(params);
        storage.setValue(constants.usernameKey, config.userName);
        ticketId = params.ticket;
        sendState = params.master || false;
        firstStart = true;
      } else {
        ticketId = ticketFromCache;
        storage.getValue(constants.usernameKey, function (userName) {
          if (userName) {
            config.userName = userName;
          } else {
            config.userName = 'Visitor';
          }
        });
      }
      config.ticketId = ticketId;
      if (ticketId) {
        deferred.resolve({
          firstStart: firstStart,
          ticketId: ticketId,
          sendState: sendState
        });
      }
      return deferred.promise;
    }
    function validateTicket(parameters) {
      var deferred = new Deferred();
      if (parameters.firstStart) {
        deferred.resolve({
          ticketId: parameters.ticketId,
          sendState: parameters.sendState
        });
      } else {
        /**
         * Due to issues around the beforeunload and pagehide callbacks not always firing properly at the end of the page lifecycle
         * and not removing the cobrowseActive value in LocalStorage, we have removed the check to see if there is an
         * active cobrowse session in another tab.
         *
         * TODO: Remove setting and getting the LocalStorage value for constants.cobrowseActive once confirmed to not
         * cause any issues. This check is no longer required.
         */
        // if (config.preventDuplicateSessions && storage.itemInLocalStorageExists(constants.cobrowseActive)) {
        //     deferred.reject("CoBrowse session already active in other tab");
        //     return;
        // }
        validateTicketRequest(config.tenantId, parameters.ticketId).then(function (result) {
          if (result.valid) {
            deferred.resolve({
              ticketId: parameters.ticketId,
              sendState: parameters.sendState
            });
          } else {
            clearSessionCookies();
            config.proxylessInit = false;
            indicateCobrowseActive(window, false);
            deferred.reject('Ticket is invalid or has expired.');
          }
        }, function () {
          validateTicketRetries++;
          if (validateTicketRetries > 3) {
            clearSessionCookies();
            deferred.reject('Failed to validate ticket');
          } else {
            validateTicket(parameters);
            console.log('Failed to validate ticket, retrying...');
          }
        });
      }
      return deferred.promise;
    }
    function initDatachannel(parameters) {
      console.debug('proxyless/app.js initDatachannel()');
      var deferred = new Deferred();
      var masterSlaveConfigDone = false;
      registeredListeners.push(datachannel.on('connected', function () {
        if (masterSlaveConfigDone) {
          return;
        }
        masterSlaveConfigDone = true;
        registerListeners();
        datachannel.registeredHandlers = [];
        createPublicInterfaces();
        deferred.resolve();
        window.proxylessConfig = null;
      }));
      registeredListeners.push(datachannel.on(constants.EVENT.ENDSESSION, function (info) {
        endSession(info);
      }));
      storage.getValue(constants.sendStateKey, function (sendStateVarFromCache) {
        if (utils.getURLParameter(constants.sendStateKey) === 'true' || sendStateVarFromCache || parameters.sendState) {
          storage.setValue({
            key: constants.sendStateKey,
            value: true
          }).then(function (data) {
            console.debug('proxyless/app.js initDatachannel() storage.getValue -> storage.setValue then()', data);
          }).isRejected(function (err) {
            initDatachannel(parameters);
            console.log('proxyless/app.js initDatachannel() storage.getValue -> storage.setValue isRejected()', err);
          });
          config.isSlave = false;
          storage.getValue(constants.sessionIdKey, function (sid) {
            datachannel.init(parameters.ticketId, sid);
          }, function (err) {
            console.debug('proxyless/app.js initDatachannel() storage.getValue -> storage.setValue error', err);
          });
        } else {
          console.debug('proxyless/app.js initDatachannel() if (utils.getURLParameter(constants... ELSE block');
          config.isSlave = true;
          datachannel.init(parameters.ticketId);
        }
      }, function (err) {
        console.debug('proxyless/app.js initDatachannel() initDatachannel', err);
      });
      ui.loadCSS(config.proxyUrl + '/css/proxyless.css');
      return deferred.promise;
    }
    function decideMasterSlave() {
      if (config.isSlave) {
        console.log('configure as slave');
        return configureSlave();
      } else {
        console.log('configure as master');
        return configureMaster();
      }
    }
    function configureSlave() {
      config.isAgent = true;
      _setDocumentDomain();
      ui.prepareDocument();
      requestDomRetry.startRetry();
      createUI(false).then(function () {
        ui.addNoDomErrorTimeout();
        registerHandlersForSlave();
        var masterIsLoadingHandler = {
          type: constants.EVENT.LOADING,
          handleMessage: function (msg) {
            if (msg.begin === true) {
              ui.showLoadingOverlay();
            } else {
              ui.hideLoadingOverlay();
            }
          }
        };
        datachannel.registeredHandlers.push(masterIsLoadingHandler);
      });
      addWebAgentInterface();
    }
    function configureMaster() {
      config.isAgent = false;
      // Initialize tracking API and set session start timeStamp
      trackingLoader.setupTracker(window, config.trackingAPI, trackingEvents);
      trackingEvents.emit('sessionStarted', {});
      createUI(true).then(function () {
        updateBaseTag();
        var sendStateHandler = {
          type: 'requestState',
          handleMessage: function (msg) {
            console.log('slave requests state ' + JSON.stringify(msg));
            if (msg && msg.noDom) {
              utils.sendState(datachannel, msg.force);
            } else {
              sendInitialState();  // this will also trigger utils.sendState() after the inital DOM is sent
            }
          }
        };
        datachannel.registeredHandlers.push(sendStateHandler);
        registerHandlersForMaster();
        if (!firstStart) {
          sendInitialState();
        }
        datachannel.send(constants.EVENT.LOADING, { begin: false });
        storage.getValue(constants.startTimestampKey, function (sessionStartTS) {
          if (!sessionStartTS) {
            var now = new Date().getTime();
            storage.setValue(constants.startTimestampKey, now);
          }
        });
        storage.setValueInLocalStorage(constants.cobrowseActive, true);
      });
    }
    function createUI(isMaster) {
      var deferred = new Deferred();
      loadLanguageNamespaces(detectEngagementLanguage()).then(function () {
        mergeCustomTranslations();
        isMaster ? ui.createMasterUI(firstStart) : ui.createSlaveUI();
        deferred.resolve();
      });
      return deferred.promise;
    }
    function addWebAgentInterface() {
      blackboxWin = findBlackboxFrame();
      if (blackboxWin) {
        registeredListeners.push(memberStateEvents.on(memberState.NAMESPACE, function (data) {
          if (data.state === memberState.JOINED && data.user.userId !== datachannel.userId) {
            blackboxWin.postMessage(memberState.JOINED, window.location.origin);
          } else if (data.state === memberState.LEFT && data.user.userId !== datachannel.userId) {
            blackboxWin.postMessage(memberState.LEFT, window.location.origin);
          }
        }));
      }
    }
    function findBlackboxFrame() {
      var blackboxFrames = [];
      for (var i = 0; i < top.frames.length; i++) {
        try {
          if (top.frames[i].location.href.indexOf('webagentframe') > 0) {
            blackboxFrames.push(top.frames[i]);
          }
        } catch (e) {
        }
      }
      if (blackboxFrames.length) {
        var tenantFrames = blackboxFrames.filter(function (frame) {
          return frame.location.href.indexOf(config.tenantId) > 0;
        });
        return tenantFrames.length ? tenantFrames[0] : blackboxFrames[0];
      }
      return null;
    }
    function onError(err) {
      console.error('Error during initialization', err);
      return new Deferred().reject(err);
    }
    return {
      initialize: function (parameters) {
        console.debug('proxyless/app.js initialize()');
        params = parameters;
        if (config.proxylessInit) {
          console.log('Proxyless App already initialized');
          return;
        } else {
          config.proxylessInit = true;
          indicateCobrowseActive(window, true);
        }
        setServerUrls().then(initStorage, onError).then(getTicket, onError).then(handleParams, onError).then(validateTicket, onError).then(initDatachannel, onError).then(decideMasterSlave, onError);
      },
      getUpdatedLanguage: getUpdatedLanguage
    };
  }(synchronite_proxyless_datachannel, synchronite_proxyless_utils, synchronite_proxyless_storage, synchronite_proxyless_ui, synchronite_constants_constants, synchronite_proxyless_memberStateEvents_events, synchronite_proxyless_memberStateEvents_common, synchronite_proxyless_connectionEvents_events, synchronite_proxyless_connectionEvents_common, i18next_loader, dojo__base_lang, dojo__base_array, dojo_request, dojo_query, dojo_cookie, dojo_has, dojo_Deferred, synchronite_constants_strings, synchronite_proxyless_dom_listener, synchronite_proxyless_dom_common, synchronite_proxyless_unifiedWindowState_common, synchronite_proxyless_unifiedWindowState_listener, synchronite_events_scroll, synchronite__base_query, synchronite__base_trackingEvents, synchronite_integration_tracking_loader, synchronite_events_mouse, synchronite_events_resize, synchronite_events_focus, synchronite_events_keyboard, synchronite_config_profiles, synchronite_proxyless_participantNotification, synchronite_proxyless_eventreplicator, synchronite_proxyless_requestDomRetry, synchronite_proxyless_csat);
  (function (domReady, app, launchDarkly) {
    domReady(function () {
      var ticket, master, username, sid, win = window, proxylessCfg = win && win.proxylessConfig;
      console.log('Loading proxyless app');
      if (win.location.protocol === 'file:') {
        // eslint-disable-next-line
        console.error('You cannot test CoBrowse through the file system due to browser permissions. You must run it over a web server.');
        return;
      }
      if (proxylessCfg) {
        ticket = proxylessCfg.ticket;
        master = proxylessCfg.master;
        if (proxylessCfg.username) {
          username = proxylessCfg.username;
        }
        if (proxylessCfg.sid) {
          sid = proxylessCfg.sid;
        }
        launchDarkly.init(synchroniteConfig.tenantId);
        app.initialize({
          ticket: ticket,
          master: master,
          username: username,
          sid: sid
        });
      } else {
        app.initialize();
      }
    });
  }(dojo_domReady, synchronite_proxyless_app, synchronite_call_launchDarkly));
  synchronite_proxyless_run = undefined;
  synchronite_proxyless_run_build = undefined;
}());
}());

///Users/wlai/Library/CloudStorage/GoogleDrive-wlai@liveperson.com/My Drive/Projects_code/cccu/js